
# 2018 - 8 - 18

##  线性基

线性无关。

基的概念。

寻找线性基。

求出的线性基需要和原集合的选线性组合完全一致。

求线性基方法如下：

对于我新加入的某个数，我对它进行二进制的扫描，从高到低位。如果当前位$i$已经有一个线性基$a[i]$，那么我们可以认为，当前数如果要表示，一定选取了那个基，所以我们剔除基的影响，也就是$s[i] \ xor \ a[i]$。最后所得的$a[i]$就是所有的线性基。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 1e5;
ll n, mx, t, ans, s[N], a[N];
int main() {
  scanf("%lld", &n);
  for (int i = 1; i <= n; ++i) 
    scanf("%lld", &s[i]);
  for (int i = 1; i <= n; ++i)
    for (int j = 51; j >= 0; --j)
      if(s[i] & (1ll << j)) {
        if(a[j] == 0) {
          a[j] = s[i];
          break;
        }
        s[i] ^= a[j];
      }
  for (int i = 51; i >= 0; --i) ans = max(ans, ans ^ a[i]);
  printf("%lld", ans);
}
```



### SCOI2016 幸运数字

给出一棵树，每个结点都有一个值$a[i]$，求$i \rightarrow j$路径上的异或最大值。

倍增上跑线性基。对于每个点$f[i][j]$，存一个$vector$，表示从$i$向上$2^j$的线性基有哪些...每次用$merge$进行暴力合并。最后查询的时候，找到$lca(i, j)$，然后对于$i \rightarrow lca(i, j)$，$j \rightarrow lca(i, j)$的线性基进行合并。复杂度$O(n\log^3{n})$。

### BZOJ2844

给出集合$S$，将集合$S$的所有子集取出来，对于每一个子集求出其异或和，排序，放到数组$a$中，给出数$k$，求$a$在$a$中第一次出现的下标是？

对于线性基的组合出来的集合$S_1$，我们把这个$S_1$分成两部分，第一部分是线性基，第二部分是由线性基组合出来的数字。假如$|S_1| = 2^n$，并且线性基有$m$个。对于查询的某一个数$j$，这个数一定可以由后面的$2^{n - m}$种组合再加上唯一的线性基的补全方案来组合。所以对于某一个数$j$，组合方案数和$j$是多少其实是无关的，所以只需要我们知道$j$在线性基的组合中排第几位。

重复一次，子问题就是求$j$是在线性基的所有子集的组合中的第几大。解决方式如下，对于$j$的每一位，假如说当前这一位$i$拥有一个$a[i] != 0$，那么我们可以称这一位是“流动”的。假如说不存在，那么一定选取了一个比它大的线性基。要理解这里还要明确“排序”的意义，假如说我选取了基$a_8$，那么对于第$8$位一定是选取了的。所以对于第$8$位的排序，一定是与流动的二进制位有关，这么看来，在集合$S_1$中的位置也只是由流动的二进制位决定的，对于数字$j$，我们抽离出所有的流动的二进制位，抽离的二进制位表示对应的$a$中的基的选取情况。因为选取更大的基，数字也就更大，所以二进制位的数值就是在$S_1$中的位置，最后套上$2^{n - m}$处理即可。

### T3

给出$n$个数，把这些数分成两部分，使得这两部分的异或和差最小。$n \leq $