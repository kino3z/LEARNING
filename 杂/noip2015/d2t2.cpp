#include <bits/stdc++.h>
#define ll long long
using namespace std;

/*
大概意思就是从$A$中取出$K$个子串，连起来和$B$相同吧。
$f[i][j][k]$表示取到了$A$的$i$位置，匹配完了$B$的前$j$个位置，已经取出了$k$个子串。$A$的$i$位置可以取、不取。如果$a[i] = b[j]$的话，取了就可以$++i, ++j$。不取的话就可以$++i$。如果$a[i] != b[j]$的话，$i$是不能取的。忽然发现，这样没法转移，因为无法确认这一次选或不选对子串数量的贡献，那我就加一个维度，$i - 1$选没选。$f[i][j][k][0/1]$表示到$A$的$i$位置，$B$的$j$位置，目前选取了$k$个子串，$i$位置选没选。转移略复杂，将就着看看吧。
假如说$a[i] == b[j]$，那么这一位有选择与不选择的权利。
$f[i][j][k][1]$，这一位选，那么就等于上一位选与不选的情况之和。上一位选了，又分上上位选没选。$f[i - 1][j - 1][k][1] + f[i - 1][j - 1][k - 1][1]$，上一位没选，但是这一位选了，所以会多出来一块，$f[i - 1][j - 1][k - 1][0]$。然后假如$a[i] != b[j]$，那么这一位就没有选择的权利了，只能不选，$f[i][j][k][0] +=$上一位选择，$f[i - 1][j][k][0] +f[i - 1][j][k][1]$。
其实这道题正向思考会简单一些的。
 */
const int N = 1005, MOD = 1e9 + 7;;
char a[N], b[N];
int n, m, K; ll f[2][205][205][2];
int main() {
  scanf("%d%d%d", &n, &m, &K);
  scanf("%s%s", a + 1, b + 1);
  int x = 0, y = 1;
  f[x][0][0][0] = f[y][0][0][0] = 1;
  for (int i = 1; i <= n; ++i, swap(x, y)) {
    for (int j = 1; j <= m; ++j)
      for (int k = 1; k <= K; ++k) 
        f[y][j][k][1] = f[y][j][k][0] = 0;
    for (int j = 1; j <= m; ++j)
      for (int k = 1; k <= K; ++k) {
        if (a[i] == b[j]) {
          (f[y][j][k][1] += (f[x][j - 1][k][1] + f[x][j - 1][k - 1][0] + f[x][j - 1][k - 1][1])) %= MOD;
          (f[y][j][k][0] += f[x][j][k][0] + f[x][j][k][1]) %= MOD;
        } else
          (f[y][j][k][0] += f[x][j][k][0] + f[x][j][k][1]) %= MOD;
      }
  }
  printf("%lld", (f[n & 1][m][K][1] + f[n & 1][m][K][0]) % MOD);
}