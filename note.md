# 2018 - 7 - 21日，图论建模初接触

## 首先扯清楚，查分约束到底是什么东西！
让我们扯清楚，差分约束系统到底怎么理解？
首先，图论中的三角形不等式，还没忘吧~
$dis[y] <= dis[x] + z;$
放到我们的差分约束系统里: 限制条件如下！$x_i - x_j <= c_k$
换一下，$x_i <= x_j + c_k$
然后，不就和查分约束一样了么！
然而，原图中我们是怎么连边的！
$x \rightarrow y (z)$
这可以保证所有的条件满足
这里，我排下版
$$
dis[y] <= dis[x] + z  \;
 x_i   <=  x_j   +c_k
 $$
$j \rightarrow i (k)$
问题又来了，什么时候用最长路呢
最长路满足以下条件
$dis[y] >= dis[x] + z;$
$x_i   >=  x_j   +c_k$
如果化出了这种式子，我们考虑跑最长路，因为这种式子对应最长路的三角形不等式
就拿SCOI2010的糖果举例子
b小朋友要比a小朋友拿的多
所以$b - a >= 1$
化为
$b >= a + 1$
对应$dis[y] >= dis[x] + z$
然后这道题一定是跑最长路（嗯！
再看HNOI2005的狡猾的商人
首先前缀和一发，$s[b] - s[a] = x$
啊啊啊不能用了
咋办呢
$s[b] - s[a] >= x$
$s[b] - s[a] <= x$
同时满足就行啦~
第一个是这样的
$s[b] >= x + s[a]$
三角形不等式第二种
$a$向$b$连$x$
$s[a] >= s[b] - x$
然后$b$向$a$连$-x$
如果有条件不满足
如果最长路，是图中出现正环
这么理解
正环是怎么情况呢~
$a >= b + x_1$
$b >= c + x_2$
$c >= a + x_3$
我们化简一下
$a + b + c >= a + b + c + x_1 + x_2 + x_3$
什么情况下有解？
$x_1 + x_2 + x_3 <= 0$
如果是最短路，那么图中出现负环无解
$a <= b + x_1$
$b <= c + x_2$
$c <= a + x_3$
可以化成这样
$a + b + c <= a + b + c + x_1 + x_2 + x_3$
如果是$x_1 + x_2 + x_3 >= 0$，有解，反之不等式不成立
然后看查分约束的最难题
$POI2012 Festival$
第一种限制
$x_i <= y_i$
咋办咋办
$y_i >= x_i + 0$
这种可以跑最长路
但是我不要
$x_i <= y_i + 0$
满足最短路三角形不等式
$y \rightarrow x (0)$
然后，建图完成~
我们来看如何进行操作？
第二种限制
$x_i + 1 = y_i$
回顾一下？
$x_i + 1 >= y_i$
$x_i + 1 <= y_i$
只用一种三角形不等式来解决
第一种，满足最短路三角形不等式
$y_i <= x_i + 1$
$x \rightarrow y (1)$
第二种，$y_i >= x_i + 1$
变成$x_i <= y_i - 1$
最短路三角形不等式
$y \rightarrow x (-1)$
然后就解决了...
这道题剩下的略...因为很难...
提一下吧
在建图后跑出$SCC$。
因为每个$SCC$内抬高降低
所以可以忽略$SCC$之间的影响
然后在$SCC$中跑$floyd$
找出最短路的最大值，里面每一个最大值都可以满足。
这里面每一个都可以满足。
所以把每个最短路的最大值里的$SCC$求和
然后就是$ans$

# 然后我们来看看神奇的二分图
通常，带有2的都是二分图的题（大雾
首先是判断二分图的问题，也就是二分图染色的问题
二分图染色，同一条边两端点的颜色不相同
然后咋建模呢？
同一条边可以作为限制条件。两边颜色不同，就是说可以分到不同集合里
NOIP2010关押罪犯，有一个分成两个监狱的条件，限制条件是可不可以分到一个监狱
ARC099E就是提供了限制条件，不过建补图比较特殊
然后是比较难的二分图最大匹配
二分图最大匹配的定义如下
任意两个点都没有公共边，就是一个边只能连接两个点
在二分图中，含边数最多的匹配是二分图的最大匹配
假如说，图如下
$s1 = \{1 \ 2 \ 3 \ 4 \}$
$s2 = \{5 \ 6 \ 7 \ 8 \}$
$1 \rightarrow 5$
$2 \rightarrow 5$
$2 \rightarrow 7$
$2 \rightarrow 8$
$3 \rightarrow 6$
$3 \rightarrow 8$
$4 \rightarrow 7$
如果改成找情侣的问题
$s1$是男，$s24是女
$1 \rightarrow 5$就代表$1 \rightarrow 5$有感情
如果一夫一妻制度的话
就会存在单身
我们的目的就是让单身的最少（嗯嗯嗯？？？
别人blog上看到一句
有个班，没搞基没百合，不能开后宫，让情侣最多。
匈牙利算法我不解释
dinic的方法是
建立超级源点$s$，建立超级汇点$t$
然后超级源点和所有的$s1$连$1$边，所有$s2$和$t$连1边
跑dinic。
为啥这么就是正确的？？？
因为每个点流量是平衡的，就是说跑完不能在某个点剩余。
算了算了，写起太累，就接上刚才那个比喻。
二分图的性质，单个集合里不能有连边。
所以不能开后宫合搞百合
$s \rightarrow nan (1)$，代表男生的出流量只能为1，限制，不能开后宫。
这样完美满足二分图的性质了！
然后需要最大匹配
这样，每个1边代表一对情侣
所以t的入流量代表情侣的个数，也就是最大流。
好了情侣用完可以烧了！！！

理解到了，我们来做题
$tyvj1035$ lyd上找的，棋盘覆盖
大意是$n$行$m$列的棋盘，在棋盘上放置$1 \times 2$的骨牌，所有骨牌都不重叠，某些位置禁止放骨牌，求放的最大值。
虽然这道题啊...可以用状压dp来解...最优自然不是这个~
我们把骨牌分成两部分，中心和附加的
首先，既然我们要放最多的骨牌，我们就把每个骨牌看成一个边。它覆盖的俩位置看成点。
我们考虑我们在某个位置放一个骨牌，假如说方向不定，那么四个周围的我只能放一个...然而确定一个骨牌的中心和附加位置后，这个附加位置所在地就不能再放骨牌了。
我们把每个位置和周围四个中可用的位置连边。然后在这其中跑二分图最大匹配。
问题来了，为啥这个图是二分图呢？
二分图的性质是能够分成两个不同的集合，且集合内没有连边。考虑我们刚才如何连边的？一个位置和四个可用位置。那么，这样！使得当前位置和周围四个位置颜色不一样。正好是一个奇偶交错的方格纸，和棋盘一样。没问题了，满足二分图，满足最大匹配，扔代码！
代码WA了。。。150行调不动...意会就好（逃

# 2018 - 7 - 23日 NOIP难度字符串拓展
嘛这里做一篇小笔记...
好吧
我承认我很笨
从去年到这个时候，才基本弄懂KMP（其实中间是咕咕咕了
`nxt[i]`表示以`a[i]`结尾，`a[1 -> i]`的后缀和`a[1 -> i]`的前缀的最大匹配，也就是$border$
举个栗子
`abaab`到5位置的最大匹配是`ab`，所以`nxt[5] = 2;`
`nxt`数组怎么求呢？是一个关系比较烧脑的递推式
首先，我们假设`nxt[i]`已经求好了，并且`x = nxt[i]`
那么，我们要求`nxt[i + 1]`的时候，需要考虑`a[x]`是否等于`a[i + 1]`
如果等于的话，那么`nxt[i + 1] = nxt[i] + 1`，因为多了一个字符后是匹配的
然而，不等于呢？我们就是需要找`a[i]`的一个后缀，让其和`a[i + 1]`连接起来的
找到的`a[i]`的后缀，一定是`a[i]`的$border$中的前缀的一个后缀。
这个后缀又一定是`a[i]`的$border$前缀的一个$border$的后缀...（绕死了
总之，就记住，我们要找$border$的一个$border$，使得其最长...
nxt数组求法如下
for (int i = 2, j = 0; i <= n; ++i)
{
	while(j && a[i] != a[j + 1]) j = nxt[j];
	if(a[i] == a[j + 1]) ++j;
	nxt[i] = j;
}
神奇的，我们看看下一个
为啥，$border$就是匹配失败后移动的距离啊...
for (int i = 0, j = 0; i < m; ++i)
{
	while(j && s1[i] != s2[j]) j = nxt[j];
	s1[i] == s2[j] ? ++j : j = j;
	if(j == n) printf("%d\n", i - n + 2);
}
首先，需要理解，KMP处理的是一个前缀，类似前缀和的东西
假如说，到了计算KMP前面的第k位，我们就已经知道了，前k个已经存在了，如果在k + 1失配了，我们可以直接把和前缀相同的后缀拉过来，继续进行匹配。

然后是manacher
马拉车
神奇和骚气
首先是加#
abaaba -> #a#b#a#a#b#a#
需要处理几个东西
p[i], max, i
关键代码如下~
int id, mx; id = mx = 0;
for (int i = 1; i < len2; ++i)
{
	if(mx > i) p[i] = mx(p[(id << 1) - i], mx - i);
	else p[i] = 1;
	for (; s[i + p[i]] == s[i - p[i]]; ++p[i]);
	if(p[i] + i > mx) mx = p[i] + i, id = i;
}
for (int i = 0; i < len2; ++i)
	ans = max(ans, p[i]);
具体解释网上多了去了~
我们看几道题： by ihopenot
骚起来！！！
给你一个字符串，它是由某个字符串不断自我连接形成的。 但是这个字符串是不确定的，现在只想知道它的最短长度是多少.
可以是不完全循环。
n<=1e6
结论是这样，非完全循环的，可以直接$n - nxt[n]$。
是这么思考的：
非严谨真名，仅供yy用
（请各位自行对着这些文字yy
首先，我们构建线段s，并且除去s的后缀$border$
然后，将s复制一份放在s的下面，用s的前缀$border$和上面的后缀$border$对齐。
以此类推，会发现，每个border之间的差，刚好可以构成整个字符串
如果，必须是完全循环呢
当然，可以用hash乱搞。
hash乱搞有技巧
二分要求区间必须连续且单调
所以二分是不可能二分的
我们考虑长度$n$的约数...
$border$的也差不多
存在的循环串一定是n - 某一个$border$
这样向下跳就行啦~枚举更小的$border$
能否刚好组成。
---
母亲节就要到了，小 H 准备送给她一个特殊的项链。这个项链可以看作一个用小写字
母组成的字符串，每个小写字母表示一种颜色。为了制作这个项链，小 H 购买了两个机器。第一个机器可以生成所有形式的回文串，第二个机器可以把两个回文串连接起来，而且第二个机器还有一个特殊的性质：假如一个字符串的后缀和一个字符串的前缀是完全相同的，那么可以将这个重复部分重叠。例如：aba和aca连接起来，可以生成串abaaca或 abaca。现在给出目标项链的样式，询问你需要使用第二个机器多少次才能生成这个特殊的项链。
n<=1e5
这道题是一个不错的综合题
这样考虑，我们先求出每个位置的manacher数组
然后在manacher数组上跑线段覆盖~
每个线段都是当前向周围覆盖的回文串区间~
解决啦~

Fish是一条生活在海里的鱼。有一天他很无聊，就到处去寻宝。他找到了位于海底深处的宫殿，但是一扇带有密码锁的大门却阻止了他的前进。通过翻阅古籍，Fish 得知了这个密码的相关信息：
1. 该密码的长度为N。
2. 密码仅含小写字母。
3. 以每一个字符为中心的最长回文串长度。
4. 以每两个相邻字符的间隙为中心的最长回文串长度。
很快Fish 发现可能有无数种满足条件的密码。经过分析，他觉得这些密码中字典序最小的一个最有可能是答案，你能帮他找到这个密码么？
n<=1e5

这道题也是一个不错的综合题
我们考虑回文串的性质：
对于某一个中心，周围的每一个都和别的相等
那么，我们建立并查集，每次进行左右的合并
最后，我们依次枚举，并且赋值，从小到大赋值。
总而言之，尽量赋值最小的...