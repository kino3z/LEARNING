title: 「51nod1476」括号序列的最小代价
author: kririae
date: 2018-08-22 11:34:57
tags:
---
# 「51nod1476」括号序列的最小代价

贪心即可。

<!--more-->

是一个很妙的贪心了。
这样考虑吧。对于最后的结果，一定是所有的$?$都归为了一个$($或者$)$。
还有一个问题，什么时候括号序列不匹配？我们视$($为$1$，$)$为-1。和往常的栈有所不同。满足条件的情况就是所有前缀和都$> 0$，且$s[n] = 0$。
对于所有的$)$，都需要一个$($来匹配。我们首先将$?$都视作$)$，遇到前缀和$< 0$的时候一定是加入了一个$)$，我们需要一个$($来将其匹配掉。将一个$)$变换成$($的代价是$a - b$。我们维护优先队列，取出最小的$)$将其变成$($，代价是$a - b$，然后当前的前缀和$+= 2$，因为将一个$-1$变成了$1$。
可是，这样为啥是正确的？
首先，当我们加入到完毕，使得完全匹配后，加入的$($、$)$的数量应该分别是恒量。所以我们全部加成$)$，括号匹配的数量是一定的，所以需要恒定量的$($使得括号完全匹配。如何使得这$($括号代价最小？也就是之前的贪心策略。
总结起来，其实还是一个定一贪心一的策略，这个策略在贪心中蛮常见。

千言万语汇成一句话：好题。

需要总结的，大概就是$-1$, $+1$消括号的方法，还有定一动一在这道题中的应用。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 50005;
char s[N]; 
int n, a, b, curr; ll ans;
priority_queue<int> pq;
int main() {
  scanf("%s", s + 1);
  n = strlen(s + 1);
  for (int i = 1; i <= n; ++i) {
    if (s[i] == '?') {
      scanf("%d%d", &a, &b);
      ans += b;
      --curr;
      pq.push(-(a - b));
    } else
      if(s[i] == '(') ++curr;
      else --curr;
    if (curr < 0) {
      if (pq.empty()) 
        return puts("-1"), 0;
      ans -= pq.top();
      pq.pop();
      curr += 2;
    }
  }
  if (curr > 0) 
    return puts("-1"), 0;
  printf("%d", ans);
}
```