Problem1000
2588
var a,b:Longint;
Begin
Readln(a,b);
Writeln(a+b);
End.
Problem1000
#include<iostream>
using namespace std;

int main()
{
    int a,b;
    cin>>a>>b;
    cout<<a+b<<endl;
    //system("pause");
    return 0;
}
Problem1001
#include<queue>
#include<cctype>
#include<cstdio>
#include<cstring>
using namespace std;

const int Maxm=2*3000000+19,Maxn=2*2000000+19;
struct note
{
	int ID,Dis;
	bool operator < (const note& A) const {return !(Dis<A.Dis);}
};
priority_queue<note> Q;
struct Edge {int u,v,Dis,nxt;} E[Maxm];
int Last[Maxn],vis[Maxn],Dis[Maxn];
int n,m,x,S,T,cnt=0,c;

void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void Add_Edge(int u,int v,int Dis) 
{
	E[cnt]=(Edge){u,v,Dis,Last[u]};
	Last[u]=cnt++;
	E[cnt]=(Edge){v,u,Dis,Last[v]};
	Last[v]=cnt++;
}
int Dijkstra_Heap()
{
	for (int i=1;i<=T;i++) Dis[i]=(1<<30)-1;
	Q.push((note){S,0});
	while (!Q.empty())
	{
		int x=Q.top().ID,D=Q.top().Dis;Q.pop();
		if (x==T) return Dis[T];
		if (vis[x]) continue;
		vis[x]=1;
		for (int i=Last[x];i!=-1;i=E[i].nxt)
		{
			int to=E[i].v;
			if (!vis[to]&&D+E[i].Dis<Dis[to])
			{
				Dis[to]=D+E[i].Dis;
				Q.push((note){to,Dis[to]});
			}
		}
	}
}

int main()
{
	memset(Last,255,sizeof(Last));
	scanf("%d%d",&n,&m);
	if (n==1)
	{
		int Ans=(1<<30)-1;
		for (int i=1;i<m;i++) Read(x),Ans=min(Ans,x);
		printf("%d\n",Ans);
		return 0;
	}
	if (m==1)
	{
		int Ans=(1<<30)-1;
		for (int i=1;i<n;i++) Read(x),Ans=min(Ans,x);
		printf("%d\n",Ans);
		return 0;
	}
	S=0;T=2*(n-1)*(m-1)+1;
	//横边 
	for (int i=1;i<m;i++) Read(x),Add_Edge(2*i,S,x);
	for (int i=0;i<n-2;i++)
		for (int j=1;j<m;j++) Read(x),Add_Edge(i*2*(m-1)+j*2-1,(i+1)*2*(m-1)+j*2,x);
	for (int i=m-1;i;i--) Read(x),Add_Edge(T-2*i,T,x);
	//竖边
	for (int i=0;i<n-1;i++)
	{
		Read(x);Add_Edge(i*2*(m-1)+1,T,x);
		for (int j=1;j<m-1;j++) 
		{
			Read(x);
			int tmp=i*2*(m-1)+j*2;
			Add_Edge(tmp,tmp+1,x);
		}
		Read(x);Add_Edge((i+1)*2*(m-1),S,x);
	}
	//斜边 
	for (int i=0;i<n-1;i++)
		for (int j=1;j<m;j++) Read(x),Add_Edge(i*2*(m-1)+j*2-1,i*2*(m-1)+j*2,x);
	printf("%d\n",Dijkstra_Heap());
	return 0;
}
Problem1001
#include<queue>
#include<cctype>
#include<cstdio>
#include<cstring>
using namespace std;

const int Maxm=2*3000000+19,Maxn=2000000+19;
struct note
{
	int ID,Dis;
	bool operator < (const note& A) const {return !(Dis<A.Dis);}
};
priority_queue<note> Q;
struct Edge {int v,Dis,nxt;} E[Maxm];
int Last[Maxn],vis[Maxn],Dis[Maxn];
int n,m,x,S,T,cnt=0,c;

void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void Add_Edge(int u,int v,int Dis) 
{
	E[cnt]=(Edge){v,Dis,Last[u]};
	Last[u]=cnt++;
	E[cnt]=(Edge){u,Dis,Last[v]};
	Last[v]=cnt++;
}
int Dijkstra_Heap()
{
	for (int i=1;i<=T;i++) Dis[i]=(1<<30)-1;
	Q.push((note){S,0});
	while (!Q.empty())
	{
		int x=Q.top().ID,D=Q.top().Dis;Q.pop();
		if (x==T) return Dis[T];
		if (vis[x]) continue;
		vis[x]=1;
		for (int i=Last[x];i!=-1;i=E[i].nxt)
		{
			int to=E[i].v;
			if (!vis[to]&&D+E[i].Dis<Dis[to])
			{
				Dis[to]=D+E[i].Dis;
				Q.push((note){to,Dis[to]});
			}
		}
	}
}

int main()
{
	memset(Last,255,sizeof(Last));
	scanf("%d%d",&n,&m);
	if (n==1)
	{
		int Ans=(1<<30)-1;
		for (int i=1;i<m;i++) Read(x),Ans=min(Ans,x);
		printf("%d\n",Ans);
		return 0;
	}
	if (m==1)
	{
		int Ans=(1<<30)-1;
		for (int i=1;i<n;i++) Read(x),Ans=min(Ans,x);
		printf("%d\n",Ans);
		return 0;
	}
	S=0;T=2*(n-1)*(m-1)+1;
	//横边 
	for (int i=1;i<m;i++) Read(x),Add_Edge(2*i,S,x);
	for (int i=0;i<n-2;i++)
		for (int j=1;j<m;j++) Read(x),Add_Edge(i*2*(m-1)+j*2-1,(i+1)*2*(m-1)+j*2,x);
	for (int i=m-1;i;i--) Read(x),Add_Edge(T-2*i,T,x);
	//竖边
	for (int i=0;i<n-1;i++)
	{
		Read(x);Add_Edge(i*2*(m-1)+1,T,x);
		for (int j=1;j<m-1;j++) 
		{
			Read(x);
			int tmp=i*2*(m-1)+j*2;
			Add_Edge(tmp,tmp+1,x);
		}
		Read(x);Add_Edge((i+1)*2*(m-1),S,x);
	}
	//斜边 
	for (int i=0;i<n-1;i++)
		for (int j=1;j<m;j++) Read(x),Add_Edge(i*2*(m-1)+j*2-1,i*2*(m-1)+j*2,x);
	printf("%d\n",Dijkstra_Heap());
	return 0;
}
Problem1001
#include<queue>
#include<cctype>
#include<cstdio>
#include<cstring>
using namespace std;

const int Maxm=2*3000000+19,Maxn=2000000+19;
struct note
{
	int ID,Dis;
	bool operator < (const note& A) const {return !(Dis<A.Dis);}
};
priority_queue<note> Q;
struct Edge {int v,Dis,nxt;} E[Maxm];
int Last[Maxn],vis[Maxn],Dis[Maxn];
int n,m,x,S,T,cnt=0,c;

inline void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
inline void Add_Edge(int u,int v,int Dis) 
{
	E[cnt]=(Edge){v,Dis,Last[u]};
	Last[u]=cnt++;
	E[cnt]=(Edge){u,Dis,Last[v]};
	Last[v]=cnt++;
}
inline int Dijkstra_Heap()
{
	memset(Dis,60,sizeof(Dis));
	Q.push((note){S,0});
	while (!Q.empty())
	{
		int x=Q.top().ID,D=Q.top().Dis;Q.pop();
		if (x==T) return Dis[T];
		if (vis[x]) continue;
		vis[x]=1;
		for (int i=Last[x];i!=-1;i=E[i].nxt)
		{
			int to=E[i].v;
			if (!vis[to]&&D+E[i].Dis<Dis[to])
			{
				Dis[to]=D+E[i].Dis;
				Q.push((note){to,Dis[to]});
			}
		}
	}
}

int main()
{
	memset(Last,255,sizeof(Last));
	scanf("%d%d",&n,&m);
	if (n==1)
	{
		int Ans=(1<<30)-1;
		for (int i=1;i<m;i++) Read(x),Ans=min(Ans,x);
		printf("%d\n",Ans);
		return 0;
	}
	if (m==1)
	{
		int Ans=(1<<30)-1;
		for (int i=1;i<n;i++) Read(x),Ans=min(Ans,x);
		printf("%d\n",Ans);
		return 0;
	}
	S=0;T=2*(n-1)*(m-1)+1;
	//横边 
	for (int i=1;i<m;i++) Read(x),Add_Edge(2*i,S,x);
	for (int i=0;i<n-2;i++)
		for (int j=1;j<m;j++) Read(x),Add_Edge(i*2*(m-1)+j*2-1,(i+1)*2*(m-1)+j*2,x);
	for (int i=m-1;i;i--) Read(x),Add_Edge(T-2*i,T,x);
	//竖边
	for (int i=0;i<n-1;i++)
	{
		Read(x);Add_Edge(i*2*(m-1)+1,T,x);
		for (int j=1;j<m-1;j++) 
		{
			Read(x);
			int tmp=i*2*(m-1)+j*2;
			Add_Edge(tmp,tmp+1,x);
		}
		Read(x);Add_Edge((i+1)*2*(m-1),S,x);
	}
	//斜边 
	for (int i=0;i<n-1;i++)
		for (int j=1;j<m;j++) Read(x),Add_Edge(i*2*(m-1)+j*2-1,i*2*(m-1)+j*2,x);
	printf("%d\n",Dijkstra_Heap());
	return 0;
}
Problem1002
#include<cstdio>
#include<cstring>
using namespace std;

const int Maxn=1000+19;
struct Num
{
	int len,s[Maxn];
	Num() {memset(s,0,sizeof(s));len=1;}
};

void Print(Num A)  //输出 
{
	for (int i=A.len-1;i>=0;i--) printf("%d",A.s[i]);
	printf("\n");
}
void Clean(Num &A,int L)  //进位 
{
	for (int i=0;i<L;i++) {A.s[i+1]+=A.s[i]/10;A.s[i]%=10;}
	A.len=L;
	while (A.len>1&&!A.s[A.len-1]) A.len--;
}
Num operator *(Num A,int B)  //高*单 
{
	for (int i=0;i<A.len;i++) A.s[i]*=B;
	Clean(A,A.len+2);
	return A;
}
Num operator *(Num A,Num B)  //高*高 
{
	Num C;
	for (int i=0;i<A.len;i++)
		for (int j=0;j<B.len;j++) C.s[i+j]+=A.s[i]*B.s[j];
	Clean(C,A.len+B.len+1);
	return C;
}
Num operator -(Num A,Num B)  //高-高
{
	for (int i=0;i<A.len;i++)
	{
		if (A.s[i]<B.s[i]) {A.s[i+1]--;A.s[i]+=10;}
		A.s[i]-=B.s[i];
	}
	Clean(A,A.len+1);
	return A;
} 
void eq(Num &C,Num A)  //赋值 
{
	C.len=A.len;
	for (int i=0;i<A.len;i++) C.s[i]=A.s[i];
}

int main()
{
	Num Ans,A,B;
	int n;
	scanf("%d",&n);
	if (n&1)
	{
		A.len=B.len=1;
		A.s[0]=1;B.s[0]=4;
		if (n==1) Print(A*A);else
			if (n==3) Print(B*B);else
			{
				for (int i=3;i<n;i+=2)
				{
					Num C;
					eq(C,B*3-A);
					eq(A,B);eq(B,C);
				}
				Print(B*B);
			}
	} else
		{
			A.len=B.len=1;
			A.s[0]=1;B.s[0]=3;
			if (n==2) Print((A*A)*5);else
				if (n==4) Print((B*B)*5);else
				{
					for (int i=4;i<n;i+=2)
					{
						Num C;
						eq(C,B*3-A);
						eq(A,B);eq(B,C);
					}
					Print((B*B)*5);
				}
		}
	//for(;;);
	return 0;
}
Problem1003
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;

const int oo=(1<<30)-1;
const int Maxn=20+19,Maxm=400+19,Date=100+19;
int n,m,Time,k,d,p,a,b,x,cnt=0,c;
int Last[Maxn],Dis[Maxn],vis[Maxn],can[Maxn];
int cost[Date][Date],F[Date];
struct Edge {int v,x,nxt;} E[Maxm<<2];
struct cant {int Dis,L,R;} C[Maxn<<1];
struct note 
{
	int ID,Dis;
	bool operator < (const note& A) const {return Dis>A.Dis;}
};
priority_queue<note> Q;

void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void Add_Edge(int u,int v,int x)
{
	E[cnt]=(Edge){v,x,Last[u]};
	Last[u]=cnt++;
}
int Dijkstra_Heap(int St,int Et)
{
	memset(Dis,64,sizeof(Dis));
	memset(vis,0,sizeof(vis));
	memset(can,1,sizeof(can));
	for (int i=0;i<d;i++) 
		if (C[i].R>=St&&C[i].L<=Et) can[C[i].Dis]=0;
	Q.push((note){1,0});
	while (!Q.empty())
	{
		int x=Q.top().ID,D=Q.top().Dis;Q.pop();
		if (x==n) return Dis[n];
		if (vis[x]||!can[x]) continue;
		vis[x]=1;
		for (int i=Last[x];i!=-1;i=E[i].nxt)
		{
			int y=E[i].v;
			if (!can[y]||vis[y]) continue;
			if (D+E[i].x<Dis[y])
			{
				Dis[y]=D+E[i].x;
				Q.push((note){y,Dis[y]});
			}
		}
	}
	return Dis[n];
}

int main()
{
	memset(Last,255,sizeof(Last));
	memset(F,64,sizeof(F));F[0]=0;
	scanf("%d%d%d%d",&Time,&n,&k,&m);
	for (int i=0;i<m;i++)
	{
		Read(a);Read(b);Read(x);
		Add_Edge(a,b,x);
		Add_Edge(b,a,x);
	}
	scanf("%d",&d);
	for (int i=0;i<d;i++) {Read(C[i].Dis);Read(C[i].L);Read(C[i].R);}
	for (int i=1;i<=Time;i++)
		for (int j=i;j<=Time;j++) cost[i][j]=Dijkstra_Heap(i,j);
	for (int i=1;i<=Time;i++)
		for (int j=i-1;j>=0;j--)
			if (F[j]<oo&&cost[j+1][i]<oo)
				F[i]=min(F[i],F[j]+cost[j+1][i]*(i-j)+(j?k:0));
			else break;
	printf("%d\n",F[Time]);
	return 0;
}
Problem1004
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;

const int Max=20+19;
int Sr,Sb,Sg,m,n,p;
int A[Max*3],vis[Max*3];
vector<int> T;

struct tmpint
{
	int s,ys;
	tmpint() {s=ys=0;}
	tmpint operator + (tmpint B)
	{
		tmpint Res;
		Res.ys=ys+B.ys;
		Res.s=(s+B.s+Res.ys/(m+1))%p;
		Res.ys%=m+1;
		return Res;
	}
} F[Max][Max][Max],Ans;

void Get_it(vector<int> &S)
{
	memset(vis,0,sizeof(vis));
	S.clear();
	for (int i=1;i<=n;i++)
		if (!vis[i])
		{
			int x=i,cnt=0;
			while (!vis[x]) {cnt++;vis[x]=1;x=A[x];}
			S.push_back(cnt);
		}
}

int main()
{
	scanf("%d%d%d%d%d",&Sr,&Sb,&Sg,&m,&p);
	n=Sr+Sb+Sg;
	for (int i=0;i<=m;i++)
	{
		if (i) 
			for (int j=1;j<=n;j++) scanf("%d",&A[j]);
		else 
			for (int j=1;j<=n;j++) A[j]=j;
		Get_it(T);
		for (int i=0;i<=Sr;i++)
			for (int j=0;j<=Sb;j++)
				for (int k=0;k<=Sg;k++) F[i][j][k]=tmpint();
		F[0][0][0].s=0;
		F[0][0][0].ys=1;
		for (int c=0;c<T.size();c++)
			for (int j=Sr;j>=0;j--)
				for (int k=Sb;k>=0;k--)
					for (int l=Sg;l>=0;l--)
					{
						
						if (j>=T[c]) F[j][k][l]=F[j][k][l]+F[j-T[c]][k][l];
						if (k>=T[c]) F[j][k][l]=F[j][k][l]+F[j][k-T[c]][l];
						if (l>=T[c]) F[j][k][l]=F[j][k][l]+F[j][k][l-T[c]];
					}
		Ans=Ans+F[Sr][Sb][Sg];
	}
	printf("%d\n",Ans.s);
	return 0;
}
Problem1005
#include<cstdio>
using namespace std;

const int Maxn=1000+19,Base=100000;
int n,cnt,tot;
int D[Maxn];

struct BigInt
{
	int Len,s[1200];
	void clear() {while (Len>1&&s[Len-1]==0) Len--;}
	void print()
	{
		for (int i=Len-1;i>=0;i--)
		{
			if (i!=Len-1&&s[i]<10000) putchar('0');
			if (i!=Len-1&&s[i]<1000) putchar('0');
			if (i!=Len-1&&s[i]<100) putchar('0');
			if (i!=Len-1&&s[i]<10) putchar('0');
			printf("%d",s[i]);
		}
		puts("");
	}
} Ans;

BigInt operator * (BigInt A,int B)
{
	for (int i=0;i<A.Len;i++) A.s[i]*=B;
	for (int i=0;i<A.Len+4;i++) A.s[i+1]+=A.s[i]/Base,A.s[i]%=Base;
	A.Len+=4;A.clear();
	return A;
}
BigInt operator / (BigInt A,int B)
{
	for (int i=A.Len-1;i;i--) A.s[i-1]+=(A.s[i]%B)*Base,A.s[i]/=B;
	A.s[0]/=B;A.clear();
	return A;
}

int main()
{
	scanf("%d",&n);
	Ans.Len=1;Ans.s[0]=1;
	for (int i=1;i<=n;i++) 
	{
		scanf("%d",&D[i]);
		if (D[i]!=-1) D[i]--,cnt+=D[i];else tot++;
	}
	for (int i=2;i<=n-2;i++) Ans=Ans*i;
	for (int i=2;i<=n-cnt-2;i++) Ans=Ans/i;
	for (int i=1;i<=n;i++) 
		for (int j=2;j<=D[i];j++) Ans=Ans/j;
	for (int i=1;i<=n-2-cnt;i++) Ans=Ans*tot;
	Ans.print();
}
Problem1007
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=50000+19;
struct Line
{
	int k,b,Dis;
	bool operator < (const Line& B) const {return k<B.k||k==B.k&&b>B.b;}
} S[Maxn],A[Maxn];
int n,top=0;

int cmp(Line A,Line B) {return A.Dis<B.Dis;}
double Cross(Line P,Line Q) {return double(Q.b-P.b)/double(P.k-Q.k);}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d%d",&A[i].k,&A[i].b),A[i].Dis=i+1;
	sort(A,A+n);
	for (int i=0;i<n;i++)
	{
		if (top&&A[i].k==S[top].k) continue;
		while (top>1&&Cross(A[i],S[top])<=Cross(S[top],S[top-1])) top--;
		S[++top]=A[i];
	}
	sort(S+1,S+top+1,cmp);
	for (int i=1;i<=top;i++) printf("%d ",S[i].Dis);
	printf("\n");
	return 0;
}
Problem1007
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=50000+19;
struct Line
{
	int k,b,Dis;
	bool operator < (const Line& B) const {return k<B.k||k==B.k&&b>B.b;}
} S[Maxn],A[Maxn];
int n,top=0,c,F;

int cmp(Line A,Line B) {return A.Dis<B.Dis;}
double Cross(Line P,Line Q) {return double(Q.b-P.b)/double(P.k-Q.k);}
void Read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') F=1;else F=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (F) x=-x;
}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) Read(A[i].k),Read(A[i].b),A[i].Dis=i+1;
	sort(A,A+n);
	for (int i=0;i<n;i++)
	{
		if (top&&A[i].k==S[top].k) continue;
		while (top>1&&Cross(A[i],S[top])<=Cross(S[top],S[top-1])) top--;
		S[++top]=A[i];
	}
	sort(S+1,S+top+1,cmp);
	for (int i=1;i<=top;i++) printf("%d ",S[i].Dis);
	printf("\n");
	return 0;
}
Problem1008
#include<cstdio>
using namespace std;

typedef long long LL;
const int Mod=100003;
LL power(LL a,LL b)
{
	LL res=1,tmp=a%Mod;
	for (;b;b>>=1) {if (b&1) res=tmp*res%Mod;tmp=tmp*tmp%Mod;}
	return res;
}

int main()
{
	LL n,m;
	scanf("%lld%lld",&m,&n);
	LL tmp1=power(m,n),tmp2=m*power(m-1,n-1);
	LL Ans=tmp1-tmp2;
	while (Ans<0) Ans+=Mod;
	printf("%lld\n",Ans%Mod);
	//for(;;);
	return 0;
}
Problem1009
#include<cstdio>
#include<cstring>
using namespace std;

const int Maxn=20+9;
struct Matrix
{
	int n,m,s[Maxn][Maxn];
	Matrix() {memset(s,0,sizeof(s));}
} F,A;
int Fail[Maxn],n,m,Mod,Ans;
char s[Maxn];

Matrix operator * (Matrix A,Matrix B)
{
	Matrix C;C.n=A.n,C.m=B.m;
	for (int i=0;i<A.n;i++)
		for (int j=0;j<B.m;j++)
			for (int k=0;k<A.m;k++) (C.s[i][j]+=(1LL*A.s[i][k]*B.s[k][j]%Mod))%=Mod;
	return C;
}
Matrix Pow(Matrix A,int b)
{
	Matrix res;res.n=res.m=m;
	for (int i=0;i<m;i++) res.s[i][i]=1;
	for (;b;b>>=1,A=A*A) if (b&1) res=res*A;
	return res;
}

int main()
{
	scanf("%d%d%d",&n,&m,&Mod);
	scanf("%s",s);
	Fail[0]=Fail[1]=0;
	for (int i=1;i<m;i++)
	{
		int j=Fail[i];
		while (j&&s[j]!=s[i]) j=Fail[j];
		Fail[i+1]=(s[j]==s[i]?j+1:0);
	}
	for (int i=0;i<m;i++)
		for (int k='0';k<='9';k++)
		{
			int j=i;
			while (j&&s[j]!=k) j=Fail[j];
			A.s[i][(s[j]==k)?j+1:0]++;
		}
	A.n=A.m=m;
	F.n=1,F.m=m,F.s[0][0]=1;
	F=F*Pow(A,n);
	for (int i=0;i<m;i++) (Ans+=F.s[0][i])%=Mod;
	printf("%d\n",Ans);
}
Problem1010
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=50000+19;
typedef long long LL;
LL F[Maxn],C[Maxn];
int n,Q[Maxn],f,w;LL L;

inline LL sqr(LL x) {return x*x;}
double get_y(int a) {return F[a]+sqr(C[a])+2*C[a]*L;}
double get_x(int a) {return 2*C[a];}
double Calc(int i,int j) {return (get_y(i)-get_y(j))/(get_x(i)-get_x(j));}

int main()
{
	scanf("%d%lld",&n,&L);L++;
	for (int i=1;i<=n;i++) scanf("%d",&C[i]),C[i]+=C[i-1]+1;
	F[0]=0;
	for (int i=1;i<=n;i++)
	{
		while (w<f&&Calc(Q[w],Q[w+1])<C[i]) w++;
		F[i]=F[Q[w]]+sqr(C[i]-C[Q[w]]-L);
		while (w<f&&Calc(Q[f-1],Q[f])>Calc(Q[f],i)) f--;
		Q[++f]=i;
	}
	printf("%lld\n",F[n]);
	return 0;
}
Problem1011
#include<cstdio>
#include<cmath>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1e5+19,T=500;
int M[N],g[N],n;
double A,f[N];

int main()
{
	scanf("%d%lf",&n,&A);
	For(i,1,n+1) scanf("%d",&M[i]),g[i]=floor(i*A);
	for (int i=2;i<=n&&i<=T;i++)
		For(j,1,g[i]+1) f[i]+=1.0*M[i]*M[j]/(i-j);
	for (int i=1;i+T<=n;i++)
	{
		f[i+T]=f[i]/M[i]*(i-g[i]/2)/(i+T-g[i]/2);
		For(j,g[i]+1,g[i+T]+1) f[i+T]+=1.0*M[j]/(i+T-j);
		f[i+T]*=M[i+T];
	}
	For(i,1,n+1) printf("%.6lf\n",f[i]);
}
Problem1012
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=200000+19;
int A[Maxn],Q[Maxn],n,x,D,Last=0,Qs=0,As=0;
char c[5];

int main()
{
	scanf("%d%d",&n,&D);
	for (int i=0;i<n;i++)
	{
		scanf("%s%d",c,&x);
		if (c[0]=='A')
		{
			A[As++]=x=(x+Last)%D;;
			while (Qs>0&&A[Q[Qs]]<x) Qs--;
			Q[++Qs]=As-1;
		} else
		{
			int pos=lower_bound(Q+1,Q+Qs+1,As-x)-Q;
			printf("%d\n",Last=A[Q[pos]]);
		}
	}
	return 0;
}
Problem1013
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;

typedef double Db;
Db A[11][12],B[11],x,y;
int n;

void Gauss()
{
	for (int i=1;i<=n;i++)
	{
		int r=i;
		for (int j=i+1;j<=n;j++) if (fabs(A[j][i])>fabs(A[r][i])) r=j;
		if (r!=i) for (int j=i;j<=n+1;j++) swap(A[r][j],A[i][j]);
		Db x=A[i][i];for (int j=i;j<=n+1;j++) A[i][j]/=x;
		for (int j=1;j<=n;j++)	
			if (j!=i)
			{
				Db x=A[j][i];
				for (int k=i;k<=n+1;k++) A[j][k]-=x*A[i][k];
			}
	}
}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%lf",&B[i]);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
		{
			scanf("%lf",&x);
			A[i][j]=-2.0*B[j]+2.0*x;
			A[i][n+1]+=-B[j]*B[j]+x*x;
		}
	Gauss();
	for (int i=1;i<n;i++) printf("%.3lf ",A[i][n+1]);
	printf("%.3lf\n",A[n][n+1]);
}
Problem1014
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19,B=10007;
typedef unsigned long long Ull;
Ull g[N];
char s[N],c[5];
int n,Ql,Qr,res,L,R,x;

struct node *null;
struct node
{
	node *L,*R,*Fa;
	int v,S;Ull h;

	void Update()
	{
		if (this!=null) h=(L->h*B+v)*g[R->S]+R->h,S=L->S+R->S+1;
	}
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N],*rt;

void Splay(node *x,node *Aim)
{
	while (x->Fa!=Aim)
	{
		node *y=x->Fa,*z=y->Fa;
		if (y->Fa!=Aim)
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();if (Aim==null) rt=x;
}
node *Build(int L,int R,node *Fa)
{
	if (L>R) return null;
	node *x=Nd+Mid;
	*x=(node){Build(L,Mid-1,x),Build(Mid+1,R,x),Fa,s[Mid],0,0};
	return x->Update(),x;
}
node *Findkth(int k)
{
	node *x=rt;
	for (;;)
	{
		if (k==x->L->S+1) return x;
		k<=x->L->S?x=x->L:(k-=x->L->S+1,x=x->R);
	}
}
void Insert(int p,char c)
{
	node *x=Nd+n+1;
	x->v=c;x->Fa=x->L=x->R=null;
	if (p==n) x->L=rt,rt->Fa=x,x->Update(),rt=x;else
	{
		Splay(Findkth(p+1),null);
		x->L=rt->L,x->R=rt;rt->Fa=x;
		if (p!=0) x->L->Fa=x;
		rt->L=null;rt->Update(),x->Update();rt=x;
	}
}
int Hash(int L,int R)
{
	if (L==1&&R==n) return rt->h;
	if (L==1) return Splay(Findkth(R+1),null),rt->L->h;
	if (R==n) return Splay(Findkth(L-1),null),rt->R->h;
	Splay(Findkth(L-1),null),Splay(Findkth(R+1),rt);
	return rt->R->L->h;
}

int main()
{
	null=Nd;
	null->L=null->R=null->Fa=null;
	g[0]=1;For(i,1,N) g[i]=g[i-1]*B;
	scanf("%s",s+1);n=strlen(s+1);
	rt=Build(1,n,null);
	for (int Q=IN();Q--;)
	{
		scanf("%s",s);
		if (s[0]=='Q')
		{
			Ql=IN(),Qr=IN(),L=1,R=n-max(Ql,Qr)+1,res=0;
			while (L<=R)
				if (Hash(Ql,Ql+Mid-1)==Hash(Qr,Qr+Mid-1)) res=Mid,L=Mid+1;else R=Mid-1;
			printf("%d\n",res);
		}
		if (s[0]=='R')
		{
			x=IN(),scanf("%s",c);
			Splay(Findkth(x),null);
			rt->v=c[0];rt->Update();
		}
		if (s[0]=='I')
		{
			x=IN(),scanf("%s",c);
			Insert(x,c[0]);n++;
		}
	}
}
Problem1015
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;

const int Maxn=400000+19,oo=(1<<25)-1;
int F[Maxn],A[Maxn],U[Maxn],Pr[Maxn];
int n,m,x,y,k,Ans=0,cnt=0;
vector<int> To[Maxn];

int Getf(int x) {return F[x]==x?x:F[x]=Getf(F[x]);}
void Union(int x,int y)
{
	int fx=Getf(x),fy=Getf(y);
	if (fx!=fy) {F[fx]=fy;Ans--;}
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=0;i<m;i++)
	{
		scanf("%d%d",&x,&y);
		To[x].push_back(y);To[y].push_back(x);
	}
	scanf("%d",&k);
	memset(U,60,sizeof(U));
	for (int i=0;i<k;i++) {scanf("%d",&A[i]);U[A[i]]=i;}
	Ans=n-k;
	for (int i=0;i<n;i++) F[i]=i;
	for (int i=0;i<n;i++) 
	{
		if (U[i]<oo) continue;
		for (int j=0;j<To[i].size();j++)
			if (U[To[i][j]]>oo) Union(i,To[i][j]);
	}
	for (int i=k-1;i>=0;i--)
	{
		Pr[cnt++]=Ans;Ans++;
		for (int j=0;j<To[A[i]].size();j++) 
			if (U[To[A[i]][j]]>U[A[i]]) Union(A[i],To[A[i]][j]);
	}
	Pr[cnt++]=Ans;
	for (int i=cnt-1;i>=0;i--) printf("%d\n",Pr[i]);
	return 0;
}
Problem1015
#include<cstdio>
#include<vector>
#include<cstring>
#include<cctype>
using namespace std;

const int Maxn=400000+19,oo=(1<<25)-1;
int F[Maxn],A[Maxn],U[Maxn],Pr[Maxn];
int n,m,x,y,k,Ans=0,cnt=0,c;
vector<int> To[Maxn];

void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
int Getf(int x) {return F[x]==x?x:F[x]=Getf(F[x]);}
void Union(int x,int y)
{
	int fx=Getf(x),fy=Getf(y);
	if (fx!=fy) {F[fx]=fy;Ans--;}
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=0;i<m;i++)
	{
		Read(x);Read(y);
		To[x].push_back(y);To[y].push_back(x);
	}
	scanf("%d",&k);
	memset(U,60,sizeof(U));
	for (int i=0;i<k;i++) {Read(A[i]);U[A[i]]=i;}
	Ans=n-k;
	for (int i=0;i<n;i++) F[i]=i;
	for (int i=0;i<n;i++) 
	{
		if (U[i]<oo) continue;
		for (int j=0;j<To[i].size();j++)
			if (U[To[i][j]]>oo) Union(i,To[i][j]);
	}
	for (int i=k-1;i>=0;i--)
	{
		Pr[cnt++]=Ans;Ans++;
		for (int j=0;j<To[A[i]].size();j++) 
			if (U[To[A[i]][j]]>U[A[i]]) Union(A[i],To[A[i]][j]);
	}
	Pr[cnt++]=Ans;
	for (int i=cnt-1;i>=0;i--) printf("%d\n",Pr[i]);
	return 0;
}
Problem1016
#include<cstdio>
#include<algorithm>
using namespace std;

const int Mod=31011;
struct Edge 
{
	int a,b,c;
	bool operator < (const Edge& B) const {return c<B.c;}
} E[1000+19];
struct node {int L,R,cnt;} A[1000+19];
int Fa[100+19];
int Ans=1,n,m,cnt,tot,tmp;

int Getf(int x) {return Fa[x]==x?x:Getf(Fa[x]);}
void DFS(int x,int i,int cur)
{
	if (i==A[x].R+1) {tmp+=(cur==A[x].cnt);return;}
	DFS(x,i+1,cur);
	int Fx=Getf(E[i].a),Fy=Getf(E[i].b);
	if (Fx!=Fy)
	{
		Fa[Fx]=Fy;DFS(x,i+1,cur+1);
		Fa[Fx]=Fx,Fa[Fy]=Fy;
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++) scanf("%d%d%d",&E[i].a,&E[i].b,&E[i].c);
	sort(E+1,E+m+1);
	for (int i=1;i<=n;i++) Fa[i]=i;
	for (int i=1;i<=m;i++)
	{
		if (E[i].c!=E[i-1].c) A[cnt].R=i-1,A[++cnt].L=i;
		int Fx=Getf(E[i].a),Fy=Getf(E[i].b);
		if (Fx!=Fy) Fa[Fx]=Fy,A[cnt].cnt++,tot++;
	}
	A[cnt].R=m;
	if (tot!=n-1) return puts("0"),0;
	for (int i=1;i<=n;i++) Fa[i]=i;
	for (int i=1;i<=cnt;i++)
	{
		tmp=0;DFS(i,A[i].L,0);Ans=Ans*tmp%Mod;
		for (int j=A[i].L;j<=A[i].R;j++)
		{
			int Fx=Getf(E[j].a),Fy=Getf(E[j].b);
			if (Fx!=Fy) Fa[Fx]=Fy;
		}
	}
	printf("%d\n",Ans);
}
Problem1018
//死于A和B打反 
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=100000+19;
struct node
{
	int L[2],R[2],c[6];
} S[N*4],A[N],v,Empty;
int C,Ql,Qr,Qx,r1,c1,r2,c2;
char s[6];

node operator + (node A,node B)
{
	node C;
	For(i,0,2) C.L[i]=A.L[i],C.R[i]=B.R[i];
	For(i,0,6) C.c[i]=0;
	C.c[1]=A.c[1],C.c[4]=B.c[4];
	if (A.R[0]) 
		C.c[0]|=A.c[0]&B.c[0],
		C.c[2]|=A.c[0]&B.c[2],
		C.c[3]|=A.c[3]&B.c[0],
		C.c[5]|=A.c[3]&B.c[2];
	if (A.R[1])
		C.c[0]|=A.c[2]&B.c[3],
		C.c[2]|=A.c[2]&B.c[5],
		C.c[3]|=A.c[5]&B.c[3],
		C.c[5]|=A.c[5]&B.c[5];
	if (A.R[0]&&A.R[1])
		C.c[1]|=A.c[0]&A.c[5]&B.c[1],
		C.c[4]|=B.c[0]&B.c[5]&A.c[4];
	return C;
}
void Build(int x,int L,int R)
{
	if (L==R) {S[x]=Empty;return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
void Update(int x,int L,int R)
{
	if (L==R) {S[x]=A[L];return;}
	Qx<=Mid?Update(Lsn,L,Mid):Update(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
node Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return S[x];
	if (Ql<=Mid&&Qr<=Mid) return Query(Lsn,L,Mid);
	if (Ql>Mid&&Qr>Mid) return Query(Rsn,Mid+1,R);
	return Query(Lsn,L,Mid)+Query(Rsn,Mid+1,R);
}

int main()
{
	read(C);
	Empty.c[0]=Empty.c[5]=1;
	Build(1,1,C);
	For(i,1,C+1) A[i]=Empty;
	while (scanf("%s",s)&&s[0]!='E')
	{
		read(r1),read(c1),read(r2),read(c2);
		if (c1>c2) swap(r1,r2),swap(c1,c2);		
		if (s[0]=='O'||s[0]=='C')
			if (r1==r2)
				A[c1].R[r1-1]=A[c2].L[r1-1]=(s[0]=='O'),
				Qx=c1,Update(1,1,C),Qx=c2,Update(1,1,C);
			else
				A[c1].c[1]=A[c1].c[2]=A[c1].c[3]=A[c1].c[4]=(s[0]=='O'),
				Qx=c1,Update(1,1,C);
		if (s[0]=='A')
		{
			node Q;bool Lu,Ld,Ru,Rd;
			Ql=1,Qr=c1,Q=Query(1,1,C),Lu=(r1==1||Q.c[4]),Ld=(r1==2||Q.c[4]);			
			Ql=c2,Qr=C,Q=Query(1,1,C),Ru=(r2==1||Q.c[1]),Rd=(r2==2||Q.c[1]);
			Ql=c1,Qr=c2,Q=Query(1,1,C);
			puts(Lu&&Ru&&Q.c[0]||Lu&&Rd&&Q.c[2]||Ld&&Ru&&Q.c[3]||Ld&&Rd&&Q.c[5]?"Y":"N");
		}
	}
}
Problem1022
#include<cstdio>

int T,n,x,a,b;

int main()
{
	for (scanf("%d",&T);T--;)
	{
		for (scanf("%d",&n),a=b=0;n--;) scanf("%d",&x),a^=x,b+=x>1;
		puts((a>0)^(b>0)?"Brother":"John");
	}
}
Problem1024
#include<cstdio>
#include<algorithm>
using namespace std;

int x,y,n;

double DFS(double x,double y,int n)
{
	if (n==1) return max(x,y)/min(x,y);
	double tmp=1<<30;
	for (int i=1;i<n;i++)
	{
		double Px=x/n*i,Py=y/n*i;
		tmp=min(tmp,max(DFS(Px,y,i),DFS(x-Px,y,n-i)));
		tmp=min(tmp,max(DFS(x,Py,i),DFS(x,y-Py,n-i)));
	}
	return tmp;
}

int main()
{
	scanf("%d%d%d",&x,&y,&n);
	printf("%.6lf\n",DFS(x,y,n));
	return 0;
}
Problem1025
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1000+19;
typedef long long LL;
int p[N],vis[N],n,cnt;
LL F[N][N],Ans;

int main()
{
	scanf("%d",&n);
	For(i,2,n+1)
	{
		if (!vis[i]) p[++cnt]=i;
		for (int j=1;j<=cnt&&p[j]*i<=n;j++)
		{
			vis[p[j]*i]=1;
			if (i%p[j]==0) break;
		}
	}
	F[0][0]=1;
	For(i,1,cnt+1)
		for (int j=0;j<=n;j++)
		{
			F[i][j]=F[i-1][j];
			for (int k=p[i];k<=j;k*=p[i]) F[i][j]+=F[i-1][j-k];
		}
	For(i,0,n+1) Ans+=F[cnt][i];
	printf("%lld\n",Ans);
}
Problem1026
#include<cstdio>
#include<algorithm>
using namespace std;

int f[11][10],num[11];
int a,b,t,Ans,Flag;

int calc(int x)
{
	if (x<0) return 0;
	t=(x==0);Ans=0;Flag=1;
	while (x) num[++t]=x%10,x/=10;
	for (int i=1;i<t;i++)
		for (int j=(i!=1);j<10;j++) Ans+=f[i][j];
	for (int i=t;i;i--)
	{
		for (int j=(i==t);j<num[i];j++)
			if (i==t||abs(j-num[i+1])>=2) Ans+=f[i][j];
		if (i!=t&&abs(num[i]-num[i+1])<2) break;
	}
	for (int i=1;i<t;i++) if (abs(num[i]-num[i+1])<2) {Flag=0;break;}
	return Ans+Flag;
}

int main()
{
	for (int i=0;i<10;i++) f[1][i]=1;
	for (int i=2;i<=10;i++)
		for (int j=0;j<10;j++)
			for (int k=0;k<10;k++) 
				if (abs(j-k)>=2) f[i][j]+=f[i-1][k];
	scanf("%d%d",&a,&b);
	printf("%d\n",calc(b)-calc(a-1));
}
Problem1027
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>

#define For(i) for (int i=1;i<=n;i++)
#define Rep(i) for (int i=1;i<=m;i++)
using namespace std;

const int N=500+19,oo=(1<<30)-1;
const double eps=1e-9;
struct Point
{
	double x,y;
	Point() {}
	Point(double x,double y):x(x),y(y){}
} A[N],B[N];
typedef Point Vector;
int n,m,Ans=oo,D[N][N];
double k;

Vector operator - (Point A,Point B) {return Vector(A.x-B.x,A.y-B.y);}
double Cross(Vector A,Vector B) {return A.x*B.y-A.y*B.x;}

int main()
{
	scanf("%d%d",&n,&m);
	For(i) scanf("%lf%lf%lf",&A[i].x,&A[i].y,&k);
	Rep(i) scanf("%lf%lf%lf",&B[i].x,&B[i].y,&k);
	int f=1;
	For(i) if (fabs(A[i].x-A[1].x)>eps||fabs(A[i].y-A[1].y)>eps) f=0;
	Rep(i) if (fabs(B[i].x-A[1].x)>eps||fabs(B[i].y-A[1].y)>eps) f=0;
	if (f) return puts("1"),0;
	For(i) For(j) D[i][j]=oo;
	For(i) for (int j=i+1;j<=n;j++)
	{
		int Cl=0,Cr=0;
		Rep(k)
			{double C=Cross(A[j]-A[i],B[k]-A[i]);Cl+=(C>eps),Cr+=(C<-eps);}
		if (!Cl&&!Cr)
		{
			int f=1;
			Rep(k)
				if (B[k].x<min(A[i].x,A[j].x)||B[k].x>max(A[i].x,A[j].x)||
					B[k].y<min(A[i].y,A[j].y)||B[k].y>max(A[i].y,A[j].y)) f=0;
			if (!f) D[i][j]=oo;else D[i][j]=D[j][i]=1;
		} else if (Cl&&Cr) D[i][j]=oo;else
			if (Cl) D[i][j]=1;else D[j][i]=1;
	}
	For(k) For(i) For(j) D[i][j]=min(D[i][j],D[i][k]+D[k][j]);
	For(i) Ans=min(Ans,D[i][i]);
	printf("%d\n",Ans==oo?-1:Ans);
}
Problem1029
#include<cstdio>
#include<queue>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=150000+19;
struct tmp
{
	int t1,t2;
	bool operator < (const tmp& B) const {return t2<B.t2;}
} A[Maxn];
int T1[Maxn],T2[Maxn],n,R,Ans=0,c;
priority_queue<int> Q;

void Read(int &x) 
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) Read(A[i].t1),Read(A[i].t2);
	sort(A,A+n);
	for (int i=0;i<n;i++)
	{
		if (R+A[i].t1<=A[i].t2) Ans++,R+=A[i].t1,Q.push(A[i].t1);
			else
		if (A[i].t1<Q.top()) R+=A[i].t1-Q.top(),Q.pop(),Q.push(A[i].t1);
	}
	printf("%d\n",Ans);
	return 0;
}
Problem1030
#include<cstdio>
#include<cstring>
using namespace std;

const int Mod=10007,Tot=100*60+19,L=100+19;
char s[L];
int F[L][Tot],t[Tot][26],d[Tot],Q[Tot],Fail[Tot];
int Pow,n,m,x,tot,f,w,Ans;

int main()
{
	scanf("%d%d",&n,&m);
	Pow=1;for (int i=1;i<=m;i++) (Pow*=26)%=Mod;
	while (n--)
	{
		scanf("%s",s);x=0;
		for (int i=0,_=strlen(s);i<_;i++)
			{int& u=t[x][s[i]-'A'];if (!u) u=++tot;x=u;}
		d[x]=1;
	}
	for (Q[w=0,f=1]=0;f>w;)
	{
		int x=Q[++w];d[x]|=d[Fail[x]];
		for (int i=0;i<26;i++)
		{
			int& u=t[x][i];
			if (u) {Q[++f]=u;if (x) Fail[u]=t[Fail[x]][i];}
				else u=t[Fail[x]][i];
		}
	}
	F[0][0]=1;
	for (int i=0;i<m;i++)
		for (int x=0;x<=tot;x++)
			if (F[i][x])
				for (int k=0;k<26;k++)
					if (!d[t[x][k]]) (F[i+1][t[x][k]]+=F[i][x])%=Mod;
	for (int i=0;i<=tot;i++) (Ans+=F[m][i])%=Mod;
	printf("%d\n",(Pow-Ans+Mod)%Mod);
}
Problem1031
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Rep(i,x,y) for (int i=x;i<=y;i++)
#define Dep(i,x,y) for (int i=x;i>=y;i--)
using namespace std;

const int N=200000+19;
int SA[N],rk[N*2],cnt[N],tmp[N],trk[N],p;
char s[N];
int n;

void Build_SA()
{
	Rep(i,1,n) p=s[i]>p?s[i]:p;
	Rep(i,1,n) cnt[s[i]]++;
	Rep(i,1,p) cnt[i]+=cnt[i-1];
	Dep(i,n,1) SA[cnt[s[i]]--]=i;
	rk[SA[1]]=p=1;
	Rep(i,2,n) rk[SA[i]]=(s[SA[i]]==s[SA[i-1]])?p:++p;
	for (int k=1;k<=n;k<<=1)
	{
		memset(cnt,0,sizeof(cnt));
		Rep(i,1,n) cnt[rk[i+k]]++;
		Rep(i,1,p) cnt[i]+=cnt[i-1];
		Dep(i,n,1) tmp[cnt[rk[i+k]]--]=i;
		memset(cnt,0,sizeof(cnt));
		Rep(i,1,n) cnt[rk[i]]++;
		Rep(i,1,p) cnt[i]+=cnt[i-1];
		Dep(i,n,1) SA[cnt[rk[tmp[i]]]--]=tmp[i];
		trk[SA[1]]=p=1;
		Rep(i,2,n) trk[SA[i]]=(rk[SA[i]]==rk[SA[i-1]]&&rk[SA[i]+k]==rk[SA[i-1]+k])?p:++p;
		Rep(i,1,n) rk[i]=trk[i];
	}
}

int main()
{
	scanf("%s",s+1);
	for (int i=1,_=strlen(s+1);i<=_;i++) s[i+_]=s[i];
	n=strlen(s+1);
	Build_SA();
	Rep(i,1,n) if (SA[i]<=n/2) putchar(s[SA[i]+n/2-1]);puts("");
}
Problem1034
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19;
int A[N],B[N],n;

int Query(int *A,int *B)
{
	int Al=1,Ar=n,Bl=1,Br=n,Ans=0;
	For(i,1,n+1)
		if (A[Al]>B[Bl]) Ans+=2,Al++,Bl++;else
		if (A[Ar]>B[Br]) Ans+=2,Ar--,Br--;else Ans+=(A[Al++]==B[Br--]);
	return Ans;
}

int main()
{
	n=IN();
	For(i,1,n+1) A[i]=IN();
	For(i,1,n+1) B[i]=IN();
	sort(A+1,A+n+1);sort(B+1,B+n+1);
	printf("%d %d\n",Query(A,B),2*n-Query(B,A));
}
Problem1036
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
using namespace std;

const int M=30000+19,oo=(1<<30)-1;
typedef int one[M],Log[M],Seg[M<<2];
struct Edge {int x,y,nxt;} E[M*2];
int n,Ecnt,cnt,t,v,Q,_sum,_max,qL,qR,x,y;
one SL,Last,Fa,size,Deep,rank,Bel;
Log top;
Seg Lsn,Rsn,Max,Sum;
char s[10];

int c,f;
inline void Read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') x=0,f=1;else x=c-'0',f=0;
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}

inline void Add_E(int x,int y)
{
	E[Ecnt]=(Edge){x,y,Last[x]};Last[x]=Ecnt++;
	E[Ecnt]=(Edge){y,x,Last[y]};Last[y]=Ecnt++;
}
inline void DFS(int x)
{
	int Max=0,Idx;
	size[x]=1;
	for (int i=Last[x];i^-1;i=E[i].nxt)
		if (E[i].y^Fa[x])
		{
			int y=E[i].y;Fa[y]=x;Deep[y]=Deep[x]+1;
			DFS(y);
			size[x]+=size[y];
			if (size[y]>Max) Max=size[y],Idx=y;
		}
	if (size[x]==1)
	{
		top[Bel[x]=++cnt]=x;
		rank[x]=1;
	}
	for (int i=Last[x];i^-1;i=E[i].nxt)
		if (E[i].y^Fa[x]&&E[i].y==Idx)
		{
			int y=E[i].y;
			top[Bel[x]=Bel[y]]=x;
			rank[x]=rank[y]+1;
		}
}
inline void Update(int &x,int L,int R)
{
	if (!x) x=++cnt;
	if (L==R) {Max[x]=Sum[x]=v;return;}
	int Mid=(L+R)>>1;
	if (t<=Mid) Update(Lsn[x],L,Mid);else Update(Rsn[x],Mid+1,R);
	Max[x]=max(Max[Lsn[x]],Max[Rsn[x]]);
	Sum[x]=Sum[Lsn[x]]+Sum[Rsn[x]];
}
inline void Count(int x,int L,int R)
{
	if (!x) return;
	if (qL<=L&&R<=qR) {_sum+=Sum[x];_max=max(_max,Max[x]);return;}
	int Mid=(L+R)>>1;
	if (qL<=Mid) Count(Lsn[x],L,Mid);
	if (qR>Mid) Count(Rsn[x],Mid+1,R);
}
inline void Query()
{
	int a=Bel[x],b=Bel[y];
	_sum=0;_max=-oo;
	while (a!=b)
	{
		if (Deep[top[a]]<Deep[top[b]]) swap(x,y),swap(a,b);
		qL=rank[x];qR=rank[top[a]];
		Count(a,1,qR);
		x=Fa[top[a]];a=Bel[x];
	}
	if (rank[x]>rank[y]) swap(x,y);
	qL=rank[x];qR=rank[y];
	Count(a,1,rank[top[a]]);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);
	for (int i=1;i<n;i++) Read(x),Read(y),Add_E(x,y);
	DFS(1);
	for (int i=1;i<=n;i++) Read(v),t=rank[i],Update(Bel[i],1,rank[top[Bel[i]]]);
	scanf("%d",&Q);
	while (Q--)
	{
		scanf("%s",s);
		if (s[0]=='C') Read(x),Read(v),t=rank[x],Update(Bel[x],1,rank[top[Bel[x]]]);
		if (s[0]=='Q') Read(x),Read(y),Query(),printf("%d\n",s[1]=='M'?_max:_sum);
	}
}
Problem1036
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int Maxn=30000+19,oo=(1<<30)-1;
typedef int one[Maxn];
one size,deep,son,ID,top,Fa,Last;
int Sum[Maxn*4],Max[Maxn*4];
int nxt[Maxn*2],to[Maxn*2];
int n,Q,x,y,t,v,cnt,tot,Ql,Qr;
char opt[10];

int f,c,buf[15],cc;
void read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}
void print(int x)
{
	if (x==0) {putchar('0');return;}
	if (x<0) putchar('-'),x=-x;
	cc=0;while (x) buf[cc++]=x%10,x/=10;
	while (--cc>=0) putchar(buf[cc]+'0');puts("");
}

void DFS_find(int x)
{
	size[x]=1;
	for (int i=Last[x];i!=-1;i=nxt[i]) 
		if (to[i]!=Fa[x]) 
		{
			Fa[to[i]]=x;deep[to[i]]=deep[x]+1;
			DFS_find(to[i]);
			size[x]+=size[to[i]];
			if (size[to[i]]>size[son[x]]) son[x]=to[i];
		}
}
void DFS_con(int x,int anc)
{
	ID[x]=++tot;top[x]=anc;
	if (son[x]) DFS_con(son[x],anc);
	for (int i=Last[x];i!=-1;i=nxt[i]) 
		if (to[i]!=Fa[x]&&to[i]!=son[x]) DFS_con(to[i],to[i]);
}

void Update(int x,int L,int R)
{
	if (L==R) {Sum[x]=Max[x]=v;return;};
	if (t<=Mid) Update(Lsn,L,Mid);else Update(Rsn,Mid+1,R);
	Sum[x]=Sum[Lsn]+Sum[Rsn];
	Max[x]=max(Max[Lsn],Max[Rsn]);
}
int Qsum(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return Sum[x];
	int Ans=0;
	if (Ql<=Mid) Ans+=Qsum(Lsn,L,Mid);
	if (Qr>Mid) Ans+=Qsum(Rsn,Mid+1,R);
	return Ans;
}
int Qmax(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return Max[x];
	int Ans=-oo;
	if (Ql<=Mid) Ans=max(Ans,Qmax(Lsn,L,Mid));
	if (Qr>Mid) Ans=max(Ans,Qmax(Rsn,Mid+1,R));
	return Ans;
}

int Query(int opt)
{
	int a=top[x],b=top[y],Ans=(opt?-oo:0);
	while (a!=b) 
	{
		if (deep[a]>deep[b]) swap(a,b),swap(x,y);
		Ql=ID[b],Qr=ID[y];
		if (opt) Ans=max(Ans,Qmax(1,1,n));else Ans+=Qsum(1,1,n);
		y=Fa[b];b=top[y];
	}
	Ql=min(ID[x],ID[y]),Qr=max(ID[x],ID[y]);
	if (opt) Ans=max(Ans,Qmax(1,1,n));else Ans+=Qsum(1,1,n);
	return Ans;
}

int main()
{
	read(n);
	memset(Last,-1,sizeof(Last));
	for (int i=1;i<n;i++) 
	{
		read(x),read(y);
		nxt[cnt]=Last[x];to[cnt]=y;Last[x]=cnt++;
		nxt[cnt]=Last[y];to[cnt]=x;Last[y]=cnt++;
	}
	DFS_find(1);
	DFS_con(1,1);
	for (int i=1;i<=n;i++) read(v),t=ID[i],Update(1,1,n);
	read(Q);
	while (Q--)
	{
		scanf("%s",opt);
		if (opt[0]=='C')
		{
			read(t),read(v);t=ID[t];
			Update(1,1,n);
		} else
		{
			read(x),read(y);
			print(Query(opt[1]=='M'));
		}
	}
}
Problem1036
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;
 
const int Maxn=30000+19,oo=(1<<30)-1;
typedef int one[Maxn];
one size,deep,son,ID,top,Fa,Last;
int Sum[Maxn*4],Max[Maxn*4];
int nxt[Maxn*2],to[Maxn*2];
int n,Q,x,y,t,v,cnt,tot,Ql,Qr;
char opt[10];
 
int f,c;
void read(int &x)
{
    while (!isdigit(c=getchar())&&c!='-');
    if (c=='-') f=1,x=0;else f=0,x=c-'0';
    while (isdigit(c=getchar())) x=x*10+c-'0';
    if (f) x=-x;
}
 
void DFS_find(int x)
{
    size[x]=1;
    for (int i=Last[x];i!=-1;i=nxt[i]) 
        if (to[i]!=Fa[x]) 
        {
            Fa[to[i]]=x;deep[to[i]]=deep[x]+1;
            DFS_find(to[i]);
            size[x]+=size[to[i]];
            if (size[to[i]]>size[son[x]]) son[x]=to[i];
        }
}
void DFS_con(int x,int anc)
{
    ID[x]=++tot;top[x]=anc;
    if (son[x]) DFS_con(son[x],anc);
    for (int i=Last[x];i!=-1;i=nxt[i]) 
        if (to[i]!=Fa[x]&&to[i]!=son[x]) DFS_con(to[i],to[i]);
}
 
void Update(int x,int L,int R)
{
    if (L==R) {Sum[x]=Max[x]=v;return;};
    if (t<=Mid) Update(Lsn,L,Mid);else Update(Rsn,Mid+1,R);
    Sum[x]=Sum[Lsn]+Sum[Rsn];
    Max[x]=max(Max[Lsn],Max[Rsn]);
}
int Qsum(int x,int L,int R)
{
    if (Ql<=L&&R<=Qr) return Sum[x];
    int Ans=0;
    if (Ql<=Mid) Ans+=Qsum(Lsn,L,Mid);
    if (Qr>Mid) Ans+=Qsum(Rsn,Mid+1,R);
    return Ans;
}
int Qmax(int x,int L,int R)
{
    if (Ql<=L&&R<=Qr) return Max[x];
    int Ans=-oo;
    if (Ql<=Mid) Ans=max(Ans,Qmax(Lsn,L,Mid));
    if (Qr>Mid) Ans=max(Ans,Qmax(Rsn,Mid+1,R));
    return Ans;
}
 
int Query(int opt)
{
    int a=top[x],b=top[y],Ans=(opt?-oo:0);
    while (a!=b) 
    {
        if (deep[a]>deep[b]) swap(a,b),swap(x,y);
        Ql=ID[b],Qr=ID[y];
        if (opt) Ans=max(Ans,Qmax(1,1,n));else Ans+=Qsum(1,1,n);
        y=Fa[b];b=top[y];
    }
    Ql=min(ID[x],ID[y]),Qr=max(ID[x],ID[y]);
    if (opt) Ans=max(Ans,Qmax(1,1,n));else Ans+=Qsum(1,1,n);
    return Ans;
}
 
int main()
{
    read(n);
    memset(Last,-1,sizeof(Last));
    for (int i=1;i<n;i++) 
    {
        read(x),read(y);
        nxt[cnt]=Last[x];to[cnt]=y;Last[x]=cnt++;
        nxt[cnt]=Last[y];to[cnt]=x;Last[y]=cnt++;
    }
    DFS_find(1);
    DFS_con(1,1);
    for (int i=1;i<=n;i++) read(v),t=ID[i],Update(1,1,n);
    read(Q);
    while (Q--)
    {
        scanf("%s",opt);
        if (opt[0]=='C')
        {
            read(t),read(v);t=ID[t];
            Update(1,1,n);
        } else
        {
            read(x),read(y);
            printf("%d\n",Query(opt[1]=='M'));
        }
    }
}
Problem1037
#include<cstdio>
#include<algorithm>
using namespace std;
 
const int Mod=12345678;
int n,m,k,Ans;
int F[300+19][150+19][21][21];
 
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    F[0][0][0][0]=1;
    for (int i=0;i<n+m;i++)
        for (int j=0;j<=n&&j<=i;j++)
            for (int a=0;a<=j&&a<=k;a++)
                for (int b=0;b<=i-j&&b<=k;b++)
                {
                    if (a+1<=k&&j+1<=n) (F[i+1][j+1][a+1][max(b-1,0)]+=F[i][j][a][b])%=Mod;
                    if (b+1<=k&&i-j+1<=m) (F[i+1][j][max(a-1,0)][b+1]+=F[i][j][a][b])%=Mod;
                }
    for (int i=0;i<=n;i++)
        for (int a=0;a<=k;a++)
            for (int b=0;b<=k;b++) (Ans+=F[n+m][i][a][b])%=Mod;
    printf("%d\n",Ans);
}
Problem1040
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000000+19;
typedef long long LL;
struct Edge {int y,nxt;} E[N*2];
int Last[N],A[N],vis[N];
int cnt,n,u,v,e;
LL f[N][2],Ans,Max;

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x,int fe)
{
	vis[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (i!=(fe^1))
			if (vis[E[i].y]) {u=x,v=E[i].y,e=i;} else DFS(E[i].y,i);
}
void DP(int x,int Fa)
{
	f[x][0]=0,f[x][1]=A[x];
	for (int i=Last[x];~i;i=E[i].nxt)
		if (i!=e&&i!=(e^1)&&E[i].y!=Fa)
		{
			DP(E[i].y,x);
			f[x][0]+=max(f[E[i].y][1],f[E[i].y][0]);
			f[x][1]+=f[E[i].y][0];
		}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN();
	For(i,1,n+1) A[i]=IN(),Link(i,IN());
	For(i,1,n+1)
		if (!vis[i])
		{
			DFS(i,-1),Max=0;
			DP(u,-1),Max=max(Max,f[u][0]);
			DP(v,-1),Max=max(Max,f[v][0]);
			Ans+=Max;
		}
	printf("%lld\n",Ans);
}
Problem1041
#include<cstdio>
#include<cmath>
#include<set>
using namespace std;

int r;
set<pair<int,int> > S;

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
void search(int d,int k)
{
	for (int m=1,_=sqrt(d/2);m<=_;m++)
	{
		int n=sqrt(d-m*m);
		if (n>m&&n*n+m*m==d&&gcd(n,m)==1) 
		{
			int a=n*n-m*m,b=2*m*n;
			S.insert(make_pair(min(a,b)*k,max(a,b)*k));
		}
	}
}

int main()
{
	scanf("%d",&r);
	for (int i=1,_=sqrt(r);i<=_;i++)
		if (r%i==0)
		{
			search(i,r/i);
			if (i*i!=r) search(r/i,i);
		}
	printf("%d\n",S.size()*8+4);
}
Problem1042
#include<cstdio>
#include<iostream>
using namespace std;

int C[5],D[5],tot,test;
long long F[100001],tmp,s;
int main()
{
	scanf("%d%d%d%d%d",&C[1],&C[2],&C[3],&C[4],&test);
	F[0]=1;
	for (int i=1;i<=4;i++)
		for (int j=C[i];j<=100000;j++) F[j]+=F[j-C[i]];
	while (test--)
	{
		for (int i=1;i<=4;i++) scanf("%d",&D[i]);
		scanf("%d",&s);
		long long ans=0;
		for (int i=0;i<(1<<4);i++)
		{
			tmp=tot=0;
			for (int j=0;j<4;j++)
				if (i&(1<<j)) 
				{
					tmp+=C[j+1]*(D[j+1]+1);
					if (tmp>s) break;
					tot++;
				}
			if (tmp>s) tmp=0;else tmp=F[s-tmp];
			if (tot&1) ans-=tmp;else ans+=tmp;
		}
	printf("%lld\n",ans);
	}
	return 0;
}
Problem1043
#include<cmath>
#include<cstdio>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mp make_pair
#define x first
#define y second
using namespace std;

typedef double Db;
typedef pair<Db,Db> Pdd;

const int N=1000+19;
const Db Pi=acos(-1.0);
Pdd P[N],Seg[N*2];
struct Cir
{
	Pdd O;Db r;
	void IN() {scanf("%lf%lf%lf",&r,&O.x,&O.y);}
} C[N];
int n,tot;
Db Ans;

Db Dis(Pdd A,Pdd B) {return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));}
void Work(Cir A,Cir B,Db D)
{
	Db a=atan2(B.O.y-A.O.y,B.O.x-A.O.x)+Pi;
	Db b=acos((A.r*A.r+D*D-B.r*B.r)/(2.0*A.r*D));
	Pdd S=Mp(a-b,a+b);
	if (S.x>=0&&S.y<=2*Pi) P[tot++]=S;else
		if (S.x<0)	P[tot++]=Mp(S.x+2*Pi,2*Pi),P[tot++]=Mp(0,S.y);
			else	P[tot++]=Mp(S.x,2*Pi),P[tot++]=Mp(0,S.y-2*Pi);
}
Db Calc()
{
	Db res=0,S=-1,T=-1;
	sort(P,P+tot);
	For(i,0,tot)
		if (P[i].x>T) res+=T-S,S=P[i].x,T=P[i].y;
			else T=max(T,P[i].y);
	res+=T-S;
	return 2*Pi-res;
}

int main()
{
	scanf("%d",&n);
	For(i,0,n) C[i].IN();
	For(i,0,n)
	{
		tot=0;int f=1;
		For(j,i+1,n)
		{
			Db D=Dis(C[i].O,C[j].O);
			if (C[j].r>C[i].r+D) {f=0;break;}
			if (C[i].r+C[j].r>D&&!(C[i].r>C[j].r+D)) Work(C[i],C[j],D);
		}
		if (f) Ans+=Calc()*C[i].r;
	}
	printf("%.3lf\n",Ans);
}
Problem1044
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=50000+19,M=1000+19,Mod=10007;
int n,m,c,tmp,L,R,now=0,pre=1,Ri=0,Le=0,Ans=0;
int Len[Maxn],F[2][Maxn],C[Maxn];

void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
int check(int x)
{
	int sum=0,tot=0;
	for (int i=0;i<n;i++)
	{
		if (sum+Len[i]>x) {sum=0;tot++;}
		sum+=Len[i];
		if (sum>x) return 0;
	}
	return tot<=m;
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=0;i<n;i++) {Read(Len[i]);Ri+=Len[i];}
	while (Le<Ri)
	{
		int Mid=(Le+Ri)>>1;
		if (check(Mid)) Ri=Mid;else Le=Mid+1;
	}
	for (int i=1;i<=n;i++) C[i]=C[i-1]+Len[i-1];
	for (int i=0;i<n;i++) 
		if (C[i+1]<=Ri) F[0][i]=1;else break;
	for (int i=1;i<=m;i++)
	{
		now^=1;pre^=1;tmp=L=0;
		for (int j=0;j<n;j++)
		{
			F[now][j]=tmp;
			tmp=(tmp+F[pre][j])%Mod;
			while (L<=j&&C[j+2]-C[L+1]>Ri) tmp=(tmp-F[pre][L]+Mod)%Mod,L++;
		}
		Ans=(Ans+F[now][n-1])%Mod;
	}
	printf("%d %d\n",Ri,Ans);
	return 0;
}
Problem1045
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=1000000+19;
typedef long long LL;
int n,A[Maxn];
LL Ans,S[Maxn],Cn,sum;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	read(n);
	for (int i=1;i<=n;i++) read(A[i]),sum+=A[i];sum/=n;
	for (int i=1;i<=n;i++) S[i]=S[i-1]-(A[i]-sum);
	sort(S+1,S+n+1);Cn=S[n/2+1];
	for (int i=1;i<=n;i++) Ans+=(Cn>S[i]?Cn-S[i]:S[i]-Cn);
	printf("%lld\n",Ans);
}
Problem1047
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=1000+19;
struct sqr {int Dis,num;} Q[2][Maxn*Maxn];
int n,m,k,f0,w0,f1,w1,Ans=(1<<30)-1,c;
int F[2][Maxn][Maxn],A[Maxn][Maxn];

void Check(int x) {Ans=Ans<x?Ans:x;}
void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for (int i=0;i<n;i++)
		for (int j=0;j<m;j++) Read(A[i][j]);
	for (int i=0;i<n;i++)
	{
		f0=f1=-1;w0=w1=0;
		for (int j=0;j<m;j++)
		{
			while (f0>=w0&&Q[0][w0].Dis+k<=j) w0++;
			while (f1>=w1&&Q[1][w1].Dis+k<=j) w1++;
			while (f0>=w0&&A[i][j]<Q[0][f0].num) f0--;
			while (f1>=w1&&A[i][j]>Q[1][f1].num) f1--;
			Q[0][++f0]=(sqr){j,A[i][j]};
			Q[1][++f1]=(sqr){j,A[i][j]};
			F[0][i][j]=Q[0][w0].num;
			F[1][i][j]=Q[1][w1].num;
		}
	}
	for (int i=k-1;i<m;i++)
	{
		f0=f1=-1;w0=w1=0;
		for (int j=0;j<n;j++)
		{
			while (f0>=w0&&Q[0][w0].Dis+k<=j) w0++;
			while (f1>=w1&&Q[1][w1].Dis+k<=j) w1++;
			while (f0>=w0&&F[0][j][i]<Q[0][f0].num) f0--;
			while (f1>=w1&&F[1][j][i]>Q[1][f1].num) f1--;
			Q[0][++f0]=(sqr){j,F[0][j][i]};
			Q[1][++f1]=(sqr){j,F[1][j][i]};
			if (j>=k-1) Check(Q[1][w1].num-Q[0][w0].num);
		}
	}
	printf("%d\n",Ans);
	return 0;
}
Problem1048
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

double f[11][11][11][11][11],s[11][11],ave;
int n,m,k;

double sqr(double x) {return 1.0*x*x;}
double DFS(int U,int L,int D,int R,int k)
{
	double& Ans=f[U][L][D][R][k];
	if (Ans>=0) return Ans;
	if (k==1) return Ans=sqr(s[D][R]-s[D][L-1]-s[U-1][R]+s[U-1][L-1]-ave);
	Ans=1e60;
	for (int i=U;i<D;i++)
		for (int j=1;j<k;j++) Ans=min(Ans,DFS(U,L,i,R,j)+DFS(i+1,L,D,R,k-j));
	for (int i=L;i<R;i++)
		for (int j=1;j<k;j++) Ans=min(Ans,DFS(U,L,D,i,j)+DFS(U,i+1,D,R,k-j));
	return Ans;
}

int main()
{
	memset(f,-1,sizeof(f));
	scanf("%d%d%d",&n,&m,&k);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			scanf("%lf",&s[i][j]),s[i][j]+=s[i][j-1]+s[i-1][j]-s[i-1][j-1];
	ave=s[n][m]/k;
	printf("%.2lf\n",sqrt(DFS(1,1,n,m,k)/k));
}
Problem1050
#include<cstdio>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=500+19,M=5000+19;
struct Edge
{
	int x,y,z;
	bool operator < (const Edge& B) const {return z<B.z;}
} E[M];
struct Sol
{
	int x,y;
	bool operator < (const Sol& B) const {return x*B.y<B.x*y;}
} Ans,tmp;
int Fa[N],n,m,x,y,z,t,S,T,Max;

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}

int main()
{
	Ans=(Sol){0,-1};
	scanf("%d%d",&n,&m);
	For(i,0,m) scanf("%d%d%d",&x,&y,&z),E[i]=(Edge){x,y,z};
	scanf("%d%d",&S,&T);
	sort(E,E+m);
	For(i,0,m)
	{
		For(j,1,n+1) Fa[j]=j;
		For(j,i,m)
		{
			int fx=Getf(E[j].x),fy=Getf(E[j].y);
			if (fx!=fy) Fa[fx]=fy,Max=E[j].z;
			if (Getf(S)==Getf(T)) break;
		}
		if (Getf(S)==Getf(T)) if ((tmp=(Sol){Max,E[i].z})<Ans) Ans=tmp;
	}
	if (Ans.y==-1) return puts("IMPOSSIBLE"),0;
	t=gcd(Ans.x,Ans.y);Ans.x/=t,Ans.y/=t;
	printf("%d",Ans.x);if (Ans.y!=1) printf("/%d\n",Ans.y);
}
Problem1051
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=10000+19,M=50000+19;
struct Edge {int y,nxt;} E[M];
int Last[N],cnt;
int DFN[N],Low[N],S[N],SCC[N],Size[N],Out[N];
int x,y,n,m,top,tot,Ans;

void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
void Tarjan(int x)
{
	DFN[x]=Low[x]=++cnt;
	S[++top]=x;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
	{
		int y=E[i].y;
		if (!DFN[y]) Tarjan(y),Low[x]=min(Low[x],Low[y]);
			else if (!SCC[y]) Low[x]=min(Low[x],DFN[y]);
	}
	if (Low[x]==DFN[x]) 
	{
		tot++;
		for (;;)
		{
			int z=S[top--];SCC[z]=tot;Size[tot]++;
			if (z==x) break;
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	memset(Last,-1,sizeof(Last));
	for (int i=0;i<m;i++) scanf("%d%d",&x,&y),Add_Edge(x,y);
	for (int i=1;i<=n;i++) if (!DFN[i]) Tarjan(i);
	for (int x=1;x<=n;x++)
		for (int i=Last[x];i!=-1;i=E[i].nxt) 
			if (SCC[x]!=SCC[E[i].y]) Out[SCC[x]]++;
	int Flag=1;
	for (int i=1;i<=tot;i++)
		if (Out[i]==0) 
			if (!Flag) {puts("0");return 0;} else Ans=Size[i],Flag=0;
	printf("%d\n",Ans);
}
Problem1052
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define Mid (L+R>>1)
using namespace std;

const int Maxn=20000+19,oo=1000000000+19;
int n,L,R,res,vis[Maxn],X[Maxn],Y[Maxn];

int c,f;
void read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}

inline void Cover(int x,int y,int L,int v)
{
	for (int i=1;i<=n;i++)
		if (X[i]>=x-L&&X[i]<=x+L&&Y[i]>=y-L&&Y[i]<=y+L) vis[i]+=v;
}
inline int DFS(int x,int L)
{
	int xb,xs,yb,ys;
	xb=yb=-oo;xs=ys=oo;
	for (int i=1;i<=n;i++) 
		if (!vis[i])
		{
			xb=max(xb,X[i]);yb=max(yb,Y[i]);
			xs=min(xs,X[i]);ys=min(ys,Y[i]);
		}
	if (x==3) return (xb-xs<=L&&yb-ys<=L);
	Cover(xs,ys,L,1);if (DFS(x+1,L)) return 1;Cover(xs,ys,L,-1);
	Cover(xs,yb,L,1);if (DFS(x+1,L)) return 1;Cover(xs,yb,L,-1);
	Cover(xb,ys,L,1);if (DFS(x+1,L)) return 1;Cover(xb,ys,L,-1);
	Cover(xb,yb,L,1);if (DFS(x+1,L)) return 1;Cover(xb,yb,L,-1);
	return 0;
}
inline int check(int x)
{
	for (int i=1;i<=n;i++) vis[i]=0;
	return DFS(1,x);
}

int main()
{
	read(n);
	for (int i=1;i<=n;i++) read(X[i]),read(Y[i]);
	L=0,R=oo;
	while (L<=R) if (check(Mid)) res=Mid,R=Mid-1;else L=Mid+1;
	printf("%d\n",res);	
}
Problem1053
#include<cstdio>
using namespace std;

int Ans=1,cnt=1,n;
int p[15]={0,2,3,5,7,11,13,17,19,23,29};

void DFS(int x,int now,int cur,int top)
{
	if (x==11) {if (cur>cnt||cur==cnt&&now<Ans) Ans=now,cnt=cur;return;}
	int t=1;
	for (int i=0;i<=top&&1LL*now*t<=n;i++,t*=p[x]) DFS(x+1,now*t,cur*(i+1),i);
}

int main()
{
	scanf("%d",&n);
	DFS(1,1,1,29);
	printf("%d\n",Ans);
}
Problem1054
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;

const int Maxn=(1<<16)+19;
struct state
{
	int s[4][4];
} Q[Maxn],tar;
int f,w,Dx[4]={1,0,-1,0},Dy[4]={0,1,0,-1};
int Dis[1<<16];
char s[5];

int num(state A) 
{
	int Ans=0;
	for (int i=0;i<4;i++)
		for (int j=0;j<4;j++) Ans=(Ans<<1)+A.s[i][j];
	return Ans;
}
int cmp(state A,state B) {return num(A)==num(B);}

int main()
{
	for (int i=0;i<4;i++)
	{
		scanf("%s",s);
		for (int j=0;j<4;j++) Q[1].s[i][j]=s[j]-'0';
	}
	for (int i=0;i<4;i++)
	{
		scanf("%s",s);
		for (int j=0;j<4;j++) tar.s[i][j]=s[j]-'0';
	}
	if (cmp(tar,Q[1])) {puts("0");return 0;}
	f=1;w=0;
	memset(Dis,60,sizeof(Dis));
	Dis[num(Q[1])]=0;
	while (w<f)
	{
		state x=Q[++w];int D=Dis[num(x)];
		for (int i=0;i<4;i++)
			for (int j=0;j<4;j++)
				if (x.s[i][j])
					for (int k=0;k<4;k++)
					{
						int dx=i+Dx[k],dy=j+Dy[k];
						if (dx>=0&&dx<4&&dy>=0&&dy<4&&!x.s[dx][dy]) 
						{
							x.s[dx][dy]=1;x.s[i][j]=0;
							if (D+1<Dis[num(x)]) Dis[num(x)]=D+1,Q[++f]=x;
							if (cmp(x,tar)) {printf("%d\n",D+1);return 0;}
							x.s[dx][dy]=0;x.s[i][j]=1;
						}
					}
	}
}
Problem1055
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int T=20,Len=200+19;
char s[4][T][2],S[Len],Ans[]="WING";
int f[Len][Len][4],cnt[4],Res[128],tmp;

int DP(int L,int R,int t)
{
	int &res=f[L][R][t];
	if (~res) return res;res=0;
	if (L==R) return res=(S[L]==Ans[t]);
	For(i,L,R) For(j,0,cnt[t])
		if (DP(L,i,Res[s[t][j][0]])&&DP(i+1,R,Res[s[t][j][1]])) return res=1;
	return res;
}

int main()
{
	Res['W']=0,Res['I']=1,Res['N']=2,Res['G']=3;
	memset(f,-1,sizeof(f));
	For(i,0,4) scanf("%d",&cnt[i]);
	For(i,0,4) For(j,0,cnt[i]) scanf("%s",s[i][j]);
	scanf("%s",S+1);
	For(i,0,4) if (DP(1,strlen(S+1),i)) putchar(Ans[i]),tmp=1;
	if (!tmp) puts("The name is wrong!");
}
Problem1056
#include<map>
#include<cstdio>
#include<string>
#include<cctype>
#include<sstream>
using namespace std;

const int Maxn=250000+19;
typedef int one[Maxn];
map<string,int> Map;
int T,sco,Dis,cnt,rk,PRE,c;
char ss[19];
string s,Map2[Maxn];

int rt;
one key,Lsn,Rsn,size,Fa;
struct Splay_tree
{
	
	inline void Update(int x) {size[x]=size[Lsn[x]]+size[Rsn[x]]+1;}
	inline void Zig(int x)
	{
		int y=Fa[x],z=Fa[y],t=Rsn[x];
		if (z) if (y==Lsn[z]) Lsn[z]=x;else Rsn[z]=x;
		Fa[x]=z;Rsn[x]=y;Fa[y]=x;Lsn[y]=t;
		if (t) Fa[t]=y;
		Update(y);
	}
	inline void Zag(int x)
	{
		int y=Fa[x],z=Fa[y],t=Lsn[x];
		if (z) if (y==Lsn[z]) Lsn[z]=x;else Rsn[z]=x;
		Fa[x]=z;Lsn[x]=y;Fa[y]=x;Rsn[y]=t;
		if (t) Fa[t]=y;
		Update(y);
	}
	inline void Splay(int x)
	{
		while (Fa[x])
		{
			int y=Fa[x],z=Fa[y];
			if (!z) 
				if (x==Lsn[y]) Zig(x);else Zag(x);
			else
				if (x==Lsn[y])
					if (y==Lsn[z]) Zig(y),Zig(x);else Zig(x),Zag(x);
				else
					if (y==Lsn[z]) Zag(x),Zig(x);else Zag(y),Zag(x);
		}
		Update(x);rt=x;
	}
	inline void Insert(int &t,int v,int F,int x)
	{
		if (!t) {t=x;Fa[t]=F;key[t]=v;size[t]=1;Lsn[t]=Rsn[t]=0;return;}
		size[t]++;
		Insert(v>key[t]?Lsn[t]:Rsn[t],v,t,x);
	}
	inline int Rank(int x) {Splay(x);return size[Lsn[x]]+1;}
	inline int Select(int k) 
	{
		int x=rt;
		while (1)
		{
			if (size[Lsn[x]]+1==k) return x;
			(size[Lsn[x]]+1<k)?(k-=size[Lsn[x]]+1,x=Rsn[x]):(x=Lsn[x]);
		}
	}
	inline int Join(int x,int y)
	{
		Fa[x]=Fa[y]=0;
		if (!x||!y) return x+y;
		while (Rsn[x]) x=Rsn[x];
		Splay(x);
		Fa[y]=x;Rsn[x]=y;
		return x;
	}
	inline void Delete(int x) {Splay(x);rt=Join(Lsn[x],Rsn[x]);}

} Splay;

inline void Mid_vis(int x)
{
	if (!x) return;PRE=x;
	if (rk&&Lsn[x]) Mid_vis(Lsn[x]);
	if (rk) {printf(" %s",Map2[x].c_str());rk--;}
	if (rk&&Rsn[x]) Mid_vis(Rsn[x]);
}

int main()
{
	scanf("%d",&T);
	while (T--)
	{
		while ((c=getchar())!='+'&&c!='?');
		if (c=='+')
		{
			scanf("%s%d",ss,&sco);s=string(ss);
			int &x=Map[s],_new=0;
			if (x==0) x=++cnt,_new=1,Map2[x]=s;else Splay.Delete(x);
			Splay.Insert(rt,sco,0,x),Splay.Splay(x);
		}
		if (c=='?')
		{
			scanf("%s",ss);s=string(ss);
			if (isdigit(ss[0]))
			{
				stringstream t;t<<s;t>>rk;
				Splay.Splay(Splay.Select(rk));rk=9;
				printf("%s",Map2[rt].c_str());
				Mid_vis(Rsn[rt]);puts("");
				if (PRE) Splay.Splay(PRE);
			} else 
			{
				int &x=Map[s],_new=0;
				printf("%d\n",Splay.Rank(x));
			}
		}
	}
}
Problem1057
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=2000+19;
typedef int two[Maxn][Maxn];
two A,L,R,U;
int n,m,c,Ans1,Ans2;

int sqr(int x) {return x*x;}
int Getchar() {while ((c=getchar())!='0'&&c!='1');return c-'0';}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) A[i][j]=Getchar();
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++) L[i][j]=(j==1||A[i][j]!=A[i][j-1])?L[i][j-1]+1:1;
		for (int j=m;j>=1;j--) R[i][j]=(j==m||A[i][j]!=A[i][j+1])?R[i][j+1]+1:1;
	}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) 
			if (i==1||A[i][j]!=A[i-1][j])
			{
				U[i][j]=U[i-1][j]+1;
				if (i>1)
					L[i][j]=min(L[i-1][j],L[i][j]),
					R[i][j]=min(R[i-1][j],R[i][j]);
			} else U[i][j]=1;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			Ans1=max(Ans1,sqr(min(L[i][j]+R[i][j]-1,U[i][j]))),
			Ans2=max(Ans2,(L[i][j]+R[i][j]-1)*U[i][j]);
	printf("%d\n%d\n",Ans1,Ans2);
}
Problem1058
#include<cstdio>
#include<algorithm>
#include<set>
using namespace std;

const int Maxn=500000+19;
multiset<int> Sa,Sb;
typedef multiset<int>::iterator Mit;
int A[Maxn],Last[Maxn],n,Q,x,y,Min=(1<<30)-1;
char s[20];

int main()
{
	scanf("%d%d",&n,&Q);
	for (int i=1;i<=n;i++) scanf("%d",&A[i]),Last[i]=A[i],Sa.insert(A[i]);
	for (int i=2;i<=n;i++) Sb.insert(abs(A[i]-A[i-1]));
	for (Mit i=Sa.begin(),j=++Sa.begin();j!=Sa.end();i++,j++) Min=min(Min,abs(*i-*j));
	while (Q--)
	{
		scanf("%s",s);
		if (s[0]=='I') 
		{
			scanf("%d%d",&x,&y);
			Mit it=Sa.insert(y);
			it--;Min=min(Min,abs(*it-y));it++;
			it++;Min=min(Min,abs(*it-y));it--;
			
			Sb.erase(Sb.find(abs(Last[x]-A[x+1])));
			Sb.insert(abs(Last[x]-y));
			Sb.insert(abs(y-A[x+1]));
			Last[x]=y;
		} else if (s[4]=='G') printf("%d\n",*Sb.begin());
			else printf("%d\n",Min);
	}
}
Problem1059
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=200+19;
int A[Maxn][Maxn],vis[Maxn],Link[Maxn];
int Q,n,cnt,Flag;

int Hungary(int x)
{
	for (int i=1;i<=n;i++)
		if (A[x][i]&&!vis[i]) 
		{
			vis[i]=1;
			if (!Link[i]||Hungary(Link[i])) {Link[i]=x;return 1;}
		}
	return 0;
}

int main()
{
	scanf("%d",&Q);
	while (Q--)
	{
		cnt=0;
		scanf("%d",&n);
		for (int i=1;i<=n;i++)
			for (int j=1;j<=n;j++) scanf("%d",&A[i][j]);
		Flag=0;
		memset(Link,0,sizeof(Link));
		for (int i=1;i<=n;i++)
		{
			memset(vis,0,sizeof(vis));
			if (!Hungary(i)) {Flag=1,puts("No");break;}
		}
		if (!Flag) puts("Yes");
	}
}
Problem1059
#include<cstdio>
#include<cstring>
#include<cctype>
using namespace std;

const int Maxn=200+19;
int A[Maxn][Maxn],vis[Maxn],Link[Maxn];
int Q,n,Flag,t;

int f,c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int Hungary(int x)
{
	for (int i=1;i<=n;i++)
		if (A[x][i]&&vis[i]!=t) 
		{
			vis[i]=t;
			if (!Link[i]||Hungary(Link[i])) {Link[i]=x;return 1;}
		}
	return 0;
}

int main()
{
	read(Q);
	while (Q--)
	{
		read(n);
		for (int i=1;i<=n;i++)
			for (int j=1;j<=n;j++) read(A[i][j]);
		for (int i=1;i<=n;i++) Link[i]=0;
		Flag=0;
		for (int i=1;i<=n;i++) {t++;if (!Hungary(i)) {Flag=1,puts("No");break;}}
		if (!Flag) puts("Yes");
	}
}
Problem1061
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	scanf("%d",&x);return x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000+19,oo=2147483647;
struct Edge {int y,f,c,nxt;} E[5000000];
int Last[N],Q[50*N],Dis[N],pre[N],vis[N];
int A[N],n,m,cnt,a,b,c,S,T,Ans;

void Add(int x,int y,int c,int f=oo)
{
	E[cnt]=(Edge){y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,-c,Last[y]};Last[y]=cnt++;
}
bool SPFA()
{
	For(i,1,T+1) Dis[i]=oo;Dis[S]=0;
	int f=1,w=0;Q[1]=S;pre[S]=-1;
	memset(pre,-1,sizeof(pre));
	while (f>w)
	{
		int x=Q[++w];vis[x]=0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[x]+E[i].c<Dis[E[i].y])
			{
				pre[E[i].y]=i;
				Dis[E[i].y]=Dis[x]+E[i].c;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
	}
	return Dis[T]<oo;
}
void Update()
{
	int Min=oo;
	for (int i=pre[T];~i;i=pre[E[i^1].y]) Min=min(Min,E[i].f);
	for (int i=pre[T];~i;i=pre[E[i^1].y]) E[i].f-=Min,E[i^1].f+=Min;
	Ans+=Min*Dis[T];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	S=0,T=n+2;
	For(i,1,n+1) A[i]=IN();
	For(i,1,m+1) a=IN(),b=IN(),c=IN(),Add(b+1,a,c);
	For(i,1,n+2)
	{
		int t=A[i]-A[i-1];
		t>0?Add(i,T,0,t):Add(S,i,0,-t);
		if (i<=n) Add(i,i+1,0);
	}
	while (SPFA()) Update();
	printf("%d\n",Ans);
}
Problem1064
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

const int N=100000+19,M=1000000+19;
struct Edge {int y,v,nxt;} E[M*2];
int Last[N],lev[N],vis[N],cnt;
int n,m,x,y,cir,tree,Ans1,Ans2,Max,Min;

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
void Add_Edge(int x,int y)
{
	E[cnt]=(Edge){y,1,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,-1,Last[y]};Last[y]=cnt++;
}
void Find_circle(int x)
{
	vis[x]=1;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (!vis[E[i].y]) lev[E[i].y]=lev[x]+E[i].v,Find_circle(E[i].y);
			else cir=gcd(cir,abs(lev[x]+E[i].v-lev[E[i].y]));
}
void Find_tree(int x)
{
	vis[x]=1;
	Max=max(Max,lev[x]);
	Min=min(Min,lev[x]);
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (!vis[E[i].y]) lev[E[i].y]=lev[x]+E[i].v,Find_tree(E[i].y);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++) scanf("%d%d",&x,&y),Add_Edge(x,y);
	for (int i=1;i<=n;i++) if (!vis[i]) Find_circle(i);
	if (cir)
	{
		Ans1=cir;
		for (Ans2=3;Ans2<=Ans1;Ans2++) if (Ans1%Ans2==0) break;
		if (Ans1%Ans2) Ans1=0;
	} else
	{
		memset(vis,0,sizeof(vis));
		memset(lev,0,sizeof(lev));
		for (int i=1;i<=n;i++) 
			if (!vis[i]) 
			{
				Max=Min=0;
				Find_tree(i);
				Ans1+=Max-Min+1;
			}
		Ans2=3;
	}
	Ans1<3?puts("-1 -1"):printf("%d %d\n",Ans1,Ans2);
}
Problem1066
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,j) for (int i=0;i<n;i++) for (int j=0;j<m;j++)
#define ID(x,y) ((x)*m+(y))
#define In(x,y) (ID(x,y))
#define Out(x,y) (ID(x,y)+(n*m))
using namespace std;

const int Maxn=20*20*2+19,M=Maxn*Maxn,oo=(1<<30)-1;
typedef int one[Maxn];
struct Edge {int y,f,nxt;} E[M];
one Last,Dis,Q;
int n,m,d,S,T,cnt,Ans,f,w,tot;
char s[29][29];

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

inline int BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=0;
	f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
inline int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (Dis[E[i].y]==Dis[x]+1&&E[i].f)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			E[i].f-=tmp,E[i^1].f+=tmp;
			Flow-=tmp;res+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d%d",&n,&m,&d);
	S=n*m*2;T=S+1;
	for (int i=0;i<n;i++) scanf("%s",s[i]);
	For(i,j) if (s[i][j]!='0')
	{
		Add_Edge(In(i,j),Out(i,j),s[i][j]-'0');
		For(k,l) if ((i!=k||j!=l)&&s[k][l]!='0'&&
			abs(i-k)*abs(i-k)+abs(j-l)*abs(j-l)<=d*d) Add_Edge(Out(i,j),In(k,l),oo);
	}
	for (int i=1;i<=d;i++)
		for (int j=0;j<m;j++)
		{
			if (s[i-1][j]!='0') Add_Edge(Out(i-1,j),T,oo);
			if (s[n-i][j]!='0') Add_Edge(Out(n-i,j),T,oo);
		}
	for (int i=0;i<n;i++)
		for (int j=1;j<=d;j++)
		{
			if (s[i][j-1]!='0') Add_Edge(Out(i,j-1),T,oo);
			if (s[i][m-j]!='0') Add_Edge(Out(i,m-j),T,oo);
		}
	for (int i=0;i<n;i++) scanf("%s",s[i]);
	For(i,j) if (s[i][j]=='L') Add_Edge(S,In(i,j),1),tot++;
	while (BFS()) Ans+=Dinic(S,oo);
	printf("%d\n",tot-Ans);
}
Problem1068
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=50+3;
int f[N][N][2];
char s[N];

bool Check(int L,int R)
{
	if ((L+R)%2==0) return 0;
	int P=(R-L+1)/2;
	For(i,L,L+P) if (s[i]!=s[i+P]) return 0;
	return 1;
}
int DP(int L,int R,int t)
{
	if (~f[L][R][t]) return f[L][R][t];
	int &res=f[L][R][t];res=R-L+1;
	For(i,L,R) res=min(res,DP(L,i,t)+(R-i));
	if (t) For(i,L,R) res=min(res,DP(L,i,t)+DP(i+1,R,t)+1);
	if (Check(L,R)) res=min(res,DP(L,L+R>>1,0)+1);
	return res;
}

int main()
{
	memset(f,-1,sizeof(f));
	scanf("%s",s+1);
	printf("%d\n",DP(1,strlen(s+1),1));
}
Problem1070
#include<cstdio>
#include<cstring>
using namespace std;

const int M=11,N=69,tot=M*N+N,oo=(1<<30)-1;
struct Edge {int x,y,f,c,nxt;} E[M*N*N*2];
int Last[tot],pre[tot],Dis[tot],vis[tot],cnt;
int n,m,x,y,c,t,s,Cost;
int Q[(M*N+N)*10],f,w;

void Add_Edge(int x,int y,int f,int c)
{
	E[cnt]=(Edge){x,y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){y,x,0,-c,Last[y]};Last[y]=cnt++;
}

int SPFA()
{
	f=1,w=0;
	memset(Dis,64,sizeof(Dis));
	Dis[s]=0;pre[s]=-1;Q[1]=s;
	while (f>w)
	{
		int x=Q[++w];
		vis[x]=0;
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[x]+E[i].c<Dis[E[i].y])
			{
				pre[E[i].y]=i;
				Dis[E[i].y]=Dis[x]+E[i].c;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
	}
	return Dis[t]<oo;
}
void Update()
{
	for (int i=pre[t];i!=-1;i=pre[E[i].x]) E[i].f--,E[i^1].f++;
	Cost+=Dis[t];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&m,&n);s=n+n*m+1;t=n+n*m+2;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++)
		{
			scanf("%d",&c);
			for (int k=1;k<=n;k++) Add_Edge(i,n+(j-1)*n+k,1,k*c);
		}
	}
	for (int i=1;i<=n;i++) Add_Edge(s,i,1,0);
	for (int i=n+1;i<=n+n*m;i++) Add_Edge(i,t,1,0);
	while (SPFA()) Update();
	printf("%.2lf\n",(1.0*Cost)/(1.0*n));
}
Problem1072
#include<cstdio>
#include<cstring>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

char s[19];
int F[1<<10][1000+19],Fac[11],cnt[10];
int Len,T,D,Ans;

int main()
{
	Fac[0]=1;For(i,1,10) Fac[i]=Fac[i-1]*i;
	scanf("%d",&T);
	while (T--)
	{
		scanf("%s%d",s,&D);Len=strlen(s);
		memset(F,0,sizeof(F));F[0][0]=1;
		For(i,0,10) cnt[i]=0;
		For(i,0,Len) cnt[s[i]-'0']++;
		For(i,0,1<<Len) For(j,0,D)
			if (F[i][j]) For(k,0,Len) if (!(i>>k&1)) F[i|1<<k][(j*10+s[k]-'0')%D]+=F[i][j];
		Ans=F[(1<<Len)-1][0];
		For(i,0,10) Ans/=Fac[cnt[i]];
		printf("%d\n",Ans);
	}
}
Problem1076
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x,f;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=16;
int m,n,x,A[N],B[N];
double f[100+19][1<<N],Ans;

int main()
{
	m=IN(),n=IN();
	For(i,0,n)
	{
		A[i]=IN();
		while (x=IN()) B[i]|=1<<x-1;
	}
	for (int i=m;i;i--)
		For(j,0,1<<n) For(k,0,n)
			if ((j&B[k])==B[k]) f[i][j]+=max(f[i+1][j],f[i+1][j|1<<k]+A[k])/n;
				else f[i][j]+=f[i+1][j]/n;
	printf("%.6lf\n",f[1][0]);
}
Problem1079
#include<cstdio>
#include<cstring>
using namespace std;

const int Mod=1000000007;
int c[6],f[16][16][16][16][16][6],n,x;

inline int DP(int a,int b,int c,int d,int e,int p)
{
	int& x=f[a][b][c][d][e][p];
	if (x!=-1) return x;
	if (a+b+c+d+e==0) return 1;
	int tmp=0;
	if (a) (tmp+=1LL*(a-(p==2))*DP(a-1,b,c,d,e,1)%Mod)%=Mod;
	if (b) (tmp+=1LL*(b-(p==3))*DP(a+1,b-1,c,d,e,2)%Mod)%=Mod;
	if (c) (tmp+=1LL*(c-(p==4))*DP(a,b+1,c-1,d,e,3)%Mod)%=Mod;
	if (d) (tmp+=1LL*(d-(p==5))*DP(a,b,c+1,d-1,e,4)%Mod)%=Mod;
	if (e) (tmp+=1LL*e*DP(a,b,c,d+1,e-1,5)%Mod)%=Mod;
	return x=tmp;
}

int main()
{
	memset(f,-1,sizeof(f));
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",&x),c[x]++;
	printf("%d\n",DP(c[1],c[2],c[3],c[4],c[5],0));
}
Problem1081
#include<cstdio>

int Pow[18],n,B;

void Prt(int x) {putchar(x<10?x+'0':x-10+'A');}

int main()
{
	scanf("%d%d",&n,&B);
	Pow[0]=1;for (int i=1;i<=n;i++) Pow[i]=Pow[i-1]*B;
	for (int i=0;i<Pow[n];i++,puts(""))
		for (int j=0;j<n;j++) Prt((i/Pow[j+1])&1?B-(i/Pow[j])%B-1:(i/Pow[j])%B);
}
Problem1082
#include<cstdio>
#include<algorithm>
using namespace std;

const int Mr=1023+19,Mb=50+19;
int n,R,Sboard,Srail[Mr],board[Mb],rail[Mr],Mtrash,OK=0;
int cmp(int a,int b) {return a>b;}

int DFSID(int r,int b,int trash)
{
	if (r<0) return 1;
	if (trash>Mtrash) return 0;
	for (int i=b;i<n;i++)
		if (board[i]>=rail[r])
		{
			board[i]-=rail[r];
			if (DFSID(r-1,
				(r&&rail[r]==rail[r-1])?i:0,
				trash+(board[i]<rail[0]?board[i]:0))) {board[i]+=rail[r];return 1;}
			board[i]+=rail[r];
		}
	return 0;
}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",&board[i]),Sboard+=board[i];
	scanf("%d",&R);
	for (int i=0;i<R;i++) scanf("%d",&rail[i]);
	sort(rail,rail+R);
	sort(board,board+n,cmp);
	Srail[0]=rail[0];
	for (int i=1;i<R;i++) Srail[i]=Srail[i-1]+rail[i];
	int Le=0,Ri=R-1;
	while (Le<=Ri)
	{
		int Mid=(Le+Ri)>>1;
		Mtrash=Sboard-Srail[Mid];
		if (DFSID(Mid,0,0)) {Le=Mid+1;OK=1;}else Ri=Mid-1;
	}
	printf("%d\n",OK?(Le+Ri)/2+1:0);
}
Problem1083
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;

struct Edge
{
	int A,B,C;
	bool operator < (const Edge& X) const {return C<X.C;}
};
vector<Edge> A;
int F[300+19];

int Getf(int x) {return x==F[x]?x:F[x]=Getf(F[x]);}

int main()
{
	int n,m,u,v,c,Ans;
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) F[i]=i;
	for (int i=0;i<m;i++)
	{
		scanf("%d%d%d",&u,&v,&c);
		A.push_back((Edge){u,v,c});
	}
	sort(A.begin(),A.end());
	for (int i=0;i<m;i++)
	{
		int fx=Getf(A[i].A),fy=Getf(A[i].B);
		if (fx!=fy)	F[fx]=fy,Ans=A[i].C;
	}
	printf("%d %d\n",n-1,Ans);
	//for(;;);
	return 0;
}
Problem1084
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=100+19;
int s[3][Maxn],f[Maxn][Maxn][11],g[Maxn][11];
int n,m,K;

int main()
{
	scanf("%d%d%d",&n,&m,&K);
	for (int i=1;i<=n;i++) 
		for (int j=1;j<=m;j++) scanf("%d",&s[j][i]);
	swap(n,m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) s[i][j]+=s[i][j-1];
	if (n==1)
	{
		for (int i=1;i<=m;i++)
			for (int k=1;k<=K;k++) 
			{
				g[i][k]=g[i-1][k];
				for (int j=0;j<i;j++) g[i][k]=max(g[i][k],g[j][k-1]+s[1][i]-s[1][j]);
			}
		printf("%d\n",g[m][K]);
	} else
	{
		for (int i=1;i<=m;i++)
			for (int j=1;j<=m;j++)
				for (int k=1;k<=K;k++)
				{
					f[i][j][k]=max(f[i-1][j][k],f[i][j-1][k]);
					for (int x=0;x<i;x++) f[i][j][k]=max(f[i][j][k],f[x][j][k-1]+s[1][i]-s[1][x]);
					for (int y=0;y<j;y++) f[i][j][k]=max(f[i][j][k],f[i][y][k-1]+s[2][j]-s[2][y]);
					if (i==j)
						for (int z=0;z<i;z++) 
							f[i][j][k]=max(f[i][j][k],f[z][z][k-1]+s[1][i]-s[1][z]+s[2][i]-s[2][z]);
				}
		printf("%d\n",f[m][m][K]);
	}
}
Problem1085
#include<cstdio>
#include<cstring>
using namespace std;

int tar=549855;
int t,Ans,flag,fx,fy;char s[5];
int Dx[8]={-2,-2,-1,-1,1,1,2,2};
int Dy[8]={1,-1,2,-2,2,-2,1,-1};

int check(int x,int y) {return y!=12?0:!(x^tar)||(x^tar)==4096;}
int h(int x,int y)
{
	int Ans=0;
	for (int i=0;i<25;i++) if (i!=12&&i!=y) Ans+=((tar>>i&1)!=(x>>i&1));
	return Ans;
}
int DFS(int top,int x,int y,int g)
{
	if (check(x,y)) return 1;
	if (g+h(x,y)>=top) return 0;
	for (int i=0;i<8;i++)
	{
		int cx=y/5+Dx[i],cy=y%5+Dy[i];
		if (cx<0||cx>4||cy<0||cy>4) continue;
		int nx=x,ny=y;
		nx&=(((1<<25)-1)^(1<<y));
		if (x>>(cx*5+cy)&1) nx|=1<<y;
		if (DFS(top,nx,cx*5+cy,g+1)) return 1;
	}
	return 0;
}

int main()
{
	scanf("%d",&t);
	while (t--)
	{
		fx=fy=0;
		for (int i=0;i<5;i++)
		{
			scanf("%s",s);
			for (int j=0;j<5;j++) s[j]=='*'?fy=i*5+j:fx|=(s[j]-'0')<<(i*5+j);
		}
		for (Ans=0;Ans<=15;Ans++) if (flag=DFS(Ans,fx,fy,0)) break;
		printf("%d\n",flag?Ans:-1);
	}
}
Problem1086
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=1000+19;

struct Edge{
	int y,nxt;
} E[N*2];
int Last[N],S[N],bel[N],rt[N];
int n,cnt,B,tot,num;

void Link(int x,int y){
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void dfs(int x,int fa){
	int tmp=tot;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if ((y=E[i].y)!=fa){
			dfs(y,x);
			while (tot-tmp>=B){
				rt[++num]=x;
				while (tot!=tmp) bel[S[tot--]]=num;
			}
		}
	S[++tot]=x;
}

int main(){
	memset(Last,-1,sizeof(Last));
	n=IN(),B=IN();
	For(i,1,n) Link(IN(),IN());
	dfs(1,-1);
	while (tot) bel[S[tot--]]=num;
	printf("%d\n",num);
	For(i,1,n+1) printf("%d ",bel[i]);puts("");
	For(i,1,num+1) printf("%d ",rt[i]);puts("");
}
Problem1087
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)

const int N=10;
long long F[N][N*N][1<<N],Ans;
int n,K,cnt[1<<N];

int main()
{
	scanf("%d%d",&n,&K);
	F[0][0][0]=1;
	For(i,0,1<<n) cnt[i]=cnt[i>>1]+(i&1);
	For(i,0,n) For(j,0,K+1) For(k,0,1<<n)
		if (F[i][j][k]) For(l,0,1<<n)
			if (j+cnt[l]<=K&&!((k|k<<1|k>>1)&l)&&!(l&l>>1)) F[i+1][j+cnt[l]][l]+=F[i][j][k];
	For(i,0,1<<n) Ans+=F[n][K][i];
	printf("%lld\n",Ans);
}
Problem1088
#include<cstdio>
using namespace std;

const int Maxn=10000+19;
int A[Maxn],B[Maxn];
int main()
{
	int n,ans=0;
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",&A[i]);
	for (int i=0;i<4;i++)
	{
		B[0]=i&1;B[1]=i>>1;
		if (B[0]+B[1]!=A[0]) continue;
		for (int j=2;j<n;j++) B[j]=A[j-1]-B[j-1]-B[j-2];
		bool flag=true;
		for (int j=0;j<n&&flag;j++) if (B[j]<0||B[j]>1) flag=false;
		if (B[n-1]+B[n-2]!=A[n-1]) flag=false;
		if (flag) ans++;
	}
	printf("%d\n",ans);
	//for(;;);
	return 0;
}
Problem1089
f=raw_input().split(" ")
n=int(f[0]);d=int(f[1]);
if (d==0):
    print 1;
else:
    def F(D):
        res=1;
        for i in xrange(1,D+1):
            f=1;
            for j in xrange(0,n):
                f*=res;
            res=f+1;
        return res;
    print F(d)-F(d-1);
Problem1090
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=100+19;
char s[N];
int f[N][N],D[N],n;

int main()
{
	scanf("%s",s),n=strlen(s);
	For(i,1,n+1) D[i]=D[i/10]+1;
	for (int i=n-1;~i;i--)
		for (int j=i;j<n;j++)
		{
			f[i][j]=j-i+1;
			for (int k=i;k<j;k++) f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
			for (int k=1;k<j-i+1;k++)
				if ((j-i+1)%k==0)
				{
					int fl=1;
					for (int l=i;l<=j;l++) if (s[l]!=s[i+(l-i)%k]) {fl=0;break;}
					if (fl) f[i][j]=min(f[i][j],f[i][i+k-1]+D[(j-i+1)/k]+2);
				}
		}
	printf("%d\n",f[0][n-1]);
}
Problem1093
#include<map>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define mp make_pair
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=100000+19,Mc=1000000+19;
typedef pair<int,int> Pii;
struct Edge {int y,nxt;} E[Mc];
typedef int one[N];
one Last,DFN,Low,SCC,S,Size;
int cnt,n,m,P,x,y,tot,top,num;
map<Pii,int> M;

void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
void Tarjan(int x)
{
	DFN[x]=Low[x]=++tot;
	S[++top]=x;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (!DFN[y=E[i].y]) Tarjan(y),Low[x]=min(Low[x],Low[y]);
			else if (!SCC[y]) Low[x]=min(Low[x],DFN[y]);
	if (Low[x]==DFN[x])
	{
		num++;int u;
		do u=S[top--],SCC[u]=num,Size[num]++; while (u!=x);
	}
}

struct Graph
{
	struct Edge {int y,nxt;} E[Mc];
	one Last,In,Q,Dis,Tot;int cnt,Ans,Max;
	Graph() {memset(Last,-1,sizeof(Last));}
	void Add_Edge(int x,int y)
	{
		if (M.count(mp(x,y))) return;
		In[y]++,M[mp(x,y)]=1;
		E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	}
	void Toposort()
	{
		int f=0,w=0;
		For(i,1,num+1) if (!In[i]) Q[++f]=i,Dis[i]=Size[i],Tot[i]=1;
		while (f>w)
		{
			int x=Q[++w];
			for (int i=Last[x],y;~i;i=E[i].nxt)
			{
				y=E[i].y;
				if (Dis[x]+Size[y]>Dis[y]) Dis[y]=Dis[x]+Size[y],Tot[y]=0;
				if (Dis[x]+Size[y]==Dis[y]) (Tot[y]+=Tot[x])%=P;
				if (--In[y]==0) Q[++f]=y;
			}
		}
		For(i,1,num+1) Max=max(Max,Dis[i]);
		For(i,1,num+1) if (Dis[i]==Max) (Ans+=Tot[i])%=P;
		printf("%d\n%d\n",Max,Ans);
	}
} G;

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN(),P=IN();
	For(i,1,m+1) x=IN(),y=IN(),Add_Edge(x,y);
	For(i,1,n+1) if (!DFN[i]) Tarjan(i);
	For(x,1,n+1) for (int i=Last[x],y;~i;i=E[i].nxt)
		if (SCC[x]!=SCC[y=E[i].y]) G.Add_Edge(SCC[x],SCC[y]);
	G.Toposort();
}
Problem1095
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=3e5+19,oo=(1<<30)-1,Len=12000000;
struct Edge {int y,nxt;} E[N*2];
int A[N],C[N],Last[N],Pos[N],n,cnt,tot,Q,num,x;
char s,Buf[Len],*B=Buf;

int IN()
{
	int c,x;
	while (!isdigit(c=*B++));x=c-'0';
	while (isdigit(c=*B++)) x=(x<<1)+(x<<3)+c-'0';return x;
}
int max(int a,int b,int c) {return max(max(a,b),c);}

//SegTree
struct node
{
	int a,b,Lp,Lm,Rp,Rm,Dis;
	void Init(int x)
	{
		Dis=-oo,a=!~x,b=!x;
		Lp=Lm=Rp=Rm=(x>0&&C[x]?0:-oo);
	}
};
node operator + (node A,node B)
{
	node C;
	if (A.b<B.a) C.a=A.a+B.a-A.b,C.b=B.b;
			else C.a=A.a,C.b=A.b-B.a+B.b;
	C.Dis=max(A.Dis,B.Dis);
	C.Dis=max(C.Dis,A.Rm+B.Lp,A.Rp+B.Lm);
	C.Lp=max(A.Lp,A.a-A.b+B.Lp,A.a+A.b+B.Lm);
	C.Lm=max(A.Lm,A.b-A.a+B.Lm);
	C.Rp=max(B.Rp,B.a+B.b+A.Rm,B.b-B.a+A.Rp);
	C.Rm=max(B.Rm,B.a-B.b+A.Rm);
	return C;
}

struct Seg
{
	#define Lsn (x<<1)
	#define Rsn (x<<1|1)
	#define Mid (L+R>>1)
	
	node S[N*4];int Qx;

	void Build(int x,int L,int R)
	{
		if (L==R) {S[x].Init(A[L]);return;}
		Build(Lsn,L,Mid);Build(Rsn,Mid+1,R);
		S[x]=S[Lsn]+S[Rsn];
	}
	void Update(int x,int L,int R)
	{
		if (L==R) {S[x].Init(A[L]);return;}
		Qx<=Mid?Update(Lsn,L,Mid):Update(Rsn,Mid+1,R);
		S[x]=S[Lsn]+S[Rsn];
	}
} S;

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x,int Fa)
{
	A[++tot]=0;
	A[++tot]=x,Pos[x]=tot;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa) DFS(E[i].y,x);
	A[++tot]=-1;
}

int main()
{
	fread(Buf,1,Len,stdin);
	memset(Last,-1,sizeof(Last));
	num=n=IN();
	For(i,1,n) Link(IN(),IN());
	DFS(1,-1);
	For(i,1,n+1) C[i]=1;
	S.Build(1,1,tot);
	for (Q=IN();Q--;)
	{
		while (!isalpha(s=*B++));
		if (s=='C')
		{
			if (C[x=IN()]^=1) num++;else num--;
			S.Qx=Pos[x],S.Update(1,1,tot);
		} else printf("%d\n",!num?-1:num==1?0:S.S[1].Dis);
	}
}
Problem1096
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=1000000+19;
typedef long long LL;
typedef int one[Maxn];
int n,L,R;
int Q[Maxn],x[Maxn],p[Maxn],C[Maxn];
LL A[Maxn],B[Maxn],F[Maxn];

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

double g(int a,int b) {return 1.0*((F[a]+B[a])-(F[b]+B[b]))/(A[a]-A[b]);}

int main()
{
	read(n);
	for (int i=1;i<=n;i++) read(x[i]),read(p[i]),read(C[i]);
	for (int i=1;i<=n;i++) A[i]=A[i-1]+p[i],B[i]=B[i-1]+1LL*x[i]*p[i];
	for (int i=1;i<=n;i++)
	{
		while (L<R&&g(Q[L+1],Q[L])<x[i]) L++;
		F[i]=F[Q[L]]+1LL*x[i]*(A[i]-A[Q[L]])-(B[i]-B[Q[L]])+C[i];
		while (L<R&&g(i,Q[R])<g(Q[R],Q[R-1])) R--;
		Q[++R]=i;
	}
	printf("%lld\n",F[n]);
}
Problem1098
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=100000+19,M=2000000+19;
struct Edge {int y,nxt;} E[M*2];
struct node {node *pre,*nxt;int ID;} A[N],*Q[N];
int Last[N],S[N],vis[N];
int n,m,x,y,cnt,tot,Time;

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}

void Del(node *x) {x->pre->nxt=x->nxt,x->nxt->pre=x->pre;}
void BFS(node *s)
{
	int f=1,w=0;Q[1]=s;
	while (f>w)
	{
		node *x=Q[++w];
		Time++;S[tot]++;
		for (int i=Last[x->ID];~i;i=E[i].nxt) vis[E[i].y]=Time;
		for (node *x=A->nxt;x!=A+n+1;x=x->nxt) if (vis[x->ID]!=Time) Del(x),Q[++f]=x;
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n),read(m);
	For(i,0,m) read(x),read(y),Link(x,y);
	For(i,1,n+1) A[i]=(node){A+i-1,A+i+1,i};
	A->nxt=A+1;(A+n+1)->pre=A+n;
	for (node *x=A->nxt;x!=A+n+1;x=A->nxt) Del(x),tot++,BFS(x);
	printf("%d\n",tot);
	sort(S+1,S+tot+1);
	For(i,1,tot+1) printf("%d ",S[i]);
}
Problem1099
#include<set>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

typedef long long LL;
typedef double Db;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=50000+19,Top=N*6,oo=2147483647;

typedef int one[N];
one A,B,ID,Al,Ar,Ax,L,R;
int n,cnt,c=1;
LL Ans[N],pre,tmp;

struct Tri
{
	int v[3];
	Tri() {}
	Tri(int a,int b,int c) {v[0]=a,v[1]=b,v[2]=c;}
} V[N][3];

struct SegTree
{
	multiset<int> key[N*4];
	int Min[N*4],Qx,Qv,Ql,Qr;
	SegTree() {For(i,0,N*4) Min[i]=oo;}
	void Ins(int x,int L,int R)
	{
		Min[x]=min(Min[x],Qv);
		if (L==R) {key[x].insert(Qv);return;}
		Qx<=Mid?Ins(Lsn,L,Mid):Ins(Rsn,Mid+1,R);
	}
	void Del(int x,int L,int R)
	{
		if (L==R)
		{
			key[x].erase(key[x].find(Qv));
			Min[x]=key[x].empty()?oo:*key[x].begin();
			return;
		}
		Qx<=Mid?Del(Lsn,L,Mid):Del(Rsn,Mid+1,R);
		Min[x]=min(Min[Lsn],Min[Rsn]);
	}
	int Query(int x,int L,int R)
	{
		if (Ql<=L&&R<=Qr) return Min[x];
		int res=oo;
		if (Ql<=Mid) res=min(res,Query(Lsn,L,Mid));
		if (Qr>Mid) res=min(res,Query(Rsn,Mid+1,R));
		return res;
	}
	void Ins(int x,int v) {Qx=x,Qv=v,Ins(1,1,*B);}
	void Del(int x,int v) {Qx=x,Qv=v,Del(1,1,*B);}
	int Query(int L,int R) {return Ql=L,Qr=R,Query(1,1,*B);}
} S[3][3];

struct QType
{
	int f,t,x,y;Tri T;
	QType() {}
	QType(int __f,int __t,int __x,int __y,Tri __T) {f=__f,t=__t,x=__x,y=__y,T=__T;}
	bool operator < (const QType &B) const {return x<B.x||x==B.x&&f>B.f;}
} Q[Top];

bool cmp(int a,int b) {return A[a]<A[b];}
int Find(int x) {return lower_bound(B+1,B+*B+1,x)-B;}
int __S(int x) {return abs(A[x]-A[x-1])+abs(A[x]-A[x+1]);}
void Upd(LL &x,LL y) {x=x<y?x:y;}

int main()
{
	n=IN();
	For(i,1,n+1) A[i]=B[i]=IN();
	sort(B+1,B+n+1),*B=unique(B+1,B+n+1)-B-1;
	For(i,1,n) pre+=abs(A[i]-A[i+1]);
	For(i,1,n+1) Ans[i]=pre;
	For(i,2,n)
	{
		L[i]=A[i-1],R[i]=A[i+1];
		if (L[i]>R[i]) swap(L[i],R[i]);
		Al[i]=Find(L[i]),Ax[i]=Find(A[i]),Ar[i]=Find(R[i]);
	}
	For(x,2,n)
	{
		For(i,0,3)
		{
			int tmp=-__S(x);
			if (i==0) tmp=tmp-2*A[x];
			if (i==2) tmp=tmp+2*A[x];
			V[x][0].v[i]=tmp+L[x]+R[x];
			V[x][1].v[i]=tmp-L[x]+R[x];
			V[x][2].v[i]=tmp-L[x]-R[x];
		}
		Q[++cnt]=QType(1,0,1,Ax[x],V[x][0]);
		Q[++cnt]=QType(0,0,Al[x],Ax[x],V[x][0]);
		Q[++cnt]=QType(1,1,Al[x],Ax[x],V[x][1]);
		Q[++cnt]=QType(0,1,Ar[x],Ax[x],V[x][1]);
		Q[++cnt]=QType(1,2,Ar[x],Ax[x],V[x][2]);
		ID[x]=x;
	}
	sort(Q+1,Q+cnt+1);
	sort(ID+2,ID+n,cmp);
	For(t,2,n)
	{
		int x=ID[t];
		for (;c<=cnt&&Q[c].x<=Ax[x];c++)
			For(i,0,3) if (Q[c].f==1)
				S[Q[c].t][i].Ins(Q[c].y,Q[c].T.v[i]);else
				S[Q[c].t][i].Del(Q[c].y,Q[c].T.v[i]);
		if (x-1!=1)
		{
			if (1<=Ax[x]&&Ax[x]<Al[x-1])		For(i,0,3) S[0][i].Del(Ax[x-1],V[x-1][0].v[i]);
			if (Al[x-1]<=Ax[x]&&Ax[x]<Ar[x-1])	For(i,0,3) S[1][i].Del(Ax[x-1],V[x-1][1].v[i]);
			if (Ar[x-1]<=Ax[x])					For(i,0,3) S[2][i].Del(Ax[x-1],V[x-1][2].v[i]);
		}
		if (x+1!=n)
		{
			if (1<=Ax[x]&&Ax[x]<Al[x+1])		For(i,0,3) S[0][i].Del(Ax[x+1],V[x+1][0].v[i]);
			if (Al[x+1]<=Ax[x]&&Ax[x]<Ar[x+1])	For(i,0,3) S[1][i].Del(Ax[x+1],V[x+1][1].v[i]);
			if (Ar[x+1]<=Ax[x])					For(i,0,3) S[2][i].Del(Ax[x+1],V[x+1][2].v[i]);
		}

		For(i,0,3)
		{
			LL tmp=pre-__S(x);
			if (i==0) tmp=tmp-2*A[x];
			if (i==2) tmp=tmp+2*A[x];
			Upd(Ans[x],tmp+L[x]+R[x]+S[i][0].Query(1,Al[x]));
			Upd(Ans[x],tmp-L[x]+R[x]+S[i][1].Query(Al[x],Ar[x]));
			Upd(Ans[x],tmp-L[x]-R[x]+S[i][2].Query(Ar[x],*B));
		}

		if (x-1!=1)
		{
			if (1<=Ax[x]&&Ax[x]<Al[x-1])		For(i,0,3) S[0][i].Ins(Ax[x-1],V[x-1][0].v[i]);
			if (Al[x-1]<=Ax[x]&&Ax[x]<Ar[x-1])	For(i,0,3) S[1][i].Ins(Ax[x-1],V[x-1][1].v[i]);
			if (Ar[x-1]<=Ax[x])					For(i,0,3) S[2][i].Ins(Ax[x-1],V[x-1][2].v[i]);
		}
		if (x+1!=n)
		{
			if (1<=Ax[x]&&Ax[x]<Al[x+1])		For(i,0,3) S[0][i].Ins(Ax[x+1],V[x+1][0].v[i]);
			if (Al[x+1]<=Ax[x]&&Ax[x]<Ar[x+1])	For(i,0,3) S[1][i].Ins(Ax[x+1],V[x+1][1].v[i]);
			if (Ar[x+1]<=Ax[x])					For(i,0,3) S[2][i].Ins(Ax[x+1],V[x+1][2].v[i]);
		}
	}

	For(i,2,n-1)
	{
		tmp=pre-abs(A[i]-A[i-1])-abs(A[i+1]-A[i+2])+abs(A[i]-A[i+2])+abs(A[i-1]-A[i+1]);
		Upd(Ans[i],tmp),Upd(Ans[i+1],tmp);
	}
	For(i,3,n)
	{
		tmp=pre-abs(A[1]-A[2])-__S(i);
		tmp+=abs(A[1]-A[i-1])+abs(A[1]-A[i+1])+abs(A[i]-A[2]);
		Upd(Ans[1],tmp),Upd(Ans[i],tmp);
	}
	For(i,2,n-1)
	{
		tmp=pre-abs(A[n-1]-A[n])-__S(i);
		tmp+=abs(A[n]-A[i-1])+abs(A[n]-A[i+1])+abs(A[n-1]-A[i]);
		Upd(Ans[n],tmp),Upd(Ans[i],tmp);
	}
	if (n>2)
	{
		tmp=pre-abs(A[2]-A[3])+abs(A[1]-A[3]);
		Upd(Ans[1],tmp),Upd(Ans[2],tmp);
		tmp=pre-abs(A[n-1]-A[n-2])+abs(A[n]-A[n-2]);
		Upd(Ans[n],tmp),Upd(Ans[n-1],tmp);
		tmp=pre-abs(A[1]-A[2])-abs(A[n-1]-A[n])+abs(A[1]-A[n-1])+abs(A[2]-A[n]);
		Upd(Ans[1],tmp),Upd(Ans[n],tmp);
	}

	For(i,1,n+1) printf("%lld\n",Ans[i]);
}
Problem1101
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int top=50000,Maxn=top+19;
int mu[Maxn],vis[Maxn],p[Maxn];
int T,a,b,d,cnt,Ans;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	mu[1]=1;
	for (int i=2;i<=top;i++)
	{
		if (!vis[i]) {p[cnt++]=i,mu[i]=-1;}
		for (int j=0;j<cnt&&p[j]*i<=top;j++)
		{
			vis[p[j]*i]=1;
			if (i%p[j]==0) {mu[p[j]*i]=0;break;}
				else mu[p[j]*i]=-mu[i];
		}
	}
	for (int i=2;i<=top;i++) mu[i]+=mu[i-1];
	read(T);
	while (T--)
	{
		read(a),read(b),read(d);a/=d,b/=d,Ans=0;
		for (int L=1,R;L<=a&&L<=b;L=R+1)
		{
			R=min(min(a,b),min(a/(a/L),b/(b/L)));
			Ans+=(mu[R]-mu[L-1])*(a/L)*(b/L);
		}
		printf("%d\n",Ans);
	}
}
Problem1102
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mp make_pair
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000+19;
typedef pair<int,int> Pii;
int A[N][N],vis[N][N],n,A1,A2,Big,Sml;
int Dx[8]={1,1,1,0,0,-1,-1,-1},Dy[8]={-1,0,1,-1,1,-1,0,1};
Pii Q[N*N];

void BFS(int Sx,int Sy)
{
	int v=A[Sx][Sy],f=1,w=0;
	Q[1]=Mp(Sx,Sy);vis[Sx][Sy]=1;
	while (f>w)
	{
		w++;
		For(i,0,8)
		{
			int x=Q[w].first+Dx[i],y=Q[w].second+Dy[i];
			if (x>=1&&x<=n&&y>=1&&y<=n)
				if (A[x][y]==v)
				{
					if (!vis[x][y]) Q[++f]=Mp(x,y),vis[x][y]=1;
				} else (A[x][y]<v)?Sml=1:Big=1;
		}
	}
}

int main()
{
	n=IN();
	For(i,1,n+1) For(j,1,n+1) A[i][j]=IN();
	For(i,1,n+1) For(j,1,n+1)
		if (!vis[i][j])
		{
			Big=Sml=0;
			BFS(i,j);
			if (!Big) A1++;
			if (!Sml) A2++;
		}
	printf("%d %d\n",A1,A2);
}
Problem1103
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=250000+19;
struct Edge {int y,nxt;} E[Maxn*2];
int In[Maxn],Out[Maxn],Last[Maxn],deep[Maxn],C[Maxn];
int t,n,m,x,y,cnt;
char s[3];

int Query(int x) {int Ans=0;while (x) Ans+=C[x],x-=x&-x;return Ans;}
int Add(int x,int v) {while (x<=n) C[x]+=v,x+=x&-x;}

void Add_Edge(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x,int Fa)
{
	In[x]=++t;
	for (int i=Last[x];i!=-1;i=E[i].nxt) 
		if (E[i].y!=Fa) deep[E[i].y]=deep[x]+1,DFS(E[i].y,x);
	Out[x]=t;
}

int main()
{
	scanf("%d",&n);
	memset(Last,-1,sizeof(Last));
	for (int i=1;i<n;i++) scanf("%d%d",&x,&y),Add_Edge(x,y);
	DFS(1,0);
	scanf("%d",&m);
	for (int Q=0;Q<n+m-1;Q++)
	{
		scanf("%s",s);
		if (s[0]=='W') scanf("%d",&x),printf("%d\n",deep[x]-Query(In[x]));
		if (s[0]=='A') 
		{
			scanf("%d%d",&x,&y);
			if (deep[x]>deep[y]) swap(x,y);
			Add(Out[y]+1,-1);Add(In[y],1);
		}
	}
}
Problem1103
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=250000+19;
struct Edge {int y,nxt;} E[Maxn*2];
int In[Maxn],Out[Maxn],Last[Maxn],deep[Maxn],C[Maxn];
int t,n,m,x,y,cnt;
char s[3];

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int Query(int x) {int Ans=0;while (x) Ans+=C[x],x-=x&-x;return Ans;}
int Add(int x,int v) {while (x<=n) C[x]+=v,x+=x&-x;}

void Add_Edge(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x,int Fa)
{
	In[x]=++t;
	for (int i=Last[x];i!=-1;i=E[i].nxt) 
		if (E[i].y!=Fa) deep[E[i].y]=deep[x]+1,DFS(E[i].y,x);
	Out[x]=t;
}

int main()
{
	read(n);
	memset(Last,-1,sizeof(Last));
	for (int i=1;i<n;i++) read(x),read(y),Add_Edge(x,y);
	DFS(1,0);
	read(m);
	for (int Q=0;Q<n+m-1;Q++)
	{
		scanf("%s",s);
		if (s[0]=='W') read(x),printf("%d\n",deep[x]-Query(In[x]));
		if (s[0]=='A') 
		{
			read(x),read(y);
			if (deep[x]>deep[y]) swap(x,y);
			Add(Out[y]+1,-1);Add(In[y],1);
		}
	}
}
Problem1106
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Opp(i) ((i)^P[A[i]])
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=50000+19;
int vis[N],S[N],n,x,Ans;

void Erase(int x)
{
	vis[x]=0;int i;
	for (i=*S;i;i--) if (S[i]==x) break;
	Ans+=(*S)-i;while (i<*S) S[i]=S[i+1],i++;(*S)--;
}

int main()
{
	n=IN();
	For(i,1,2*n+1)
		if (!vis[x=IN()]) vis[x]=1,S[++*S]=x;else Erase(x);
	printf("%d\n",Ans);
}
Problem1112
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19;
typedef long long LL;
int A[N],n,k;LL Ans=1LL<<60;

struct node *null;
struct node
{
	int key,S;LL Sum;
	node *L,*R,*Fa;

	void Update() {if (this!=null) S=L->S+R->S+1,Sum=L->Sum+R->Sum+key;}
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N],*rt,*cur=Nd;

void Splay(node *x,node *Aim)
{
	while (x->Fa!=Aim)
	{
		node *y=x->Fa,*z=y->Fa;
		if (y->Fa!=Aim)
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	if (Aim==null) rt=x;x->Update();
}

node *Find(node *x,int v) {return x->key==v?x:Find(v<x->key?x->L:x->R,v);}
node *Findkth(node *x,int k)
{
	if (k==x->L->S+1) return x;
	return k<x->L->S+1?Findkth(x->L,k):Findkth(x->R,k-x->L->S-1);
}
void Insert(node *&x,node *Fa,int v)
{
	if (x==null) {*(x=++cur)=(node){v,1,v,null,null,Fa};return;}
	Insert(v<x->key?x->L:x->R,x,v);
	x->Update();
}
void Delete(int v)
{
	node *x=Find(rt,v);
	Splay(x,null);
	if (x->L->S+1==1) rt=x->R,x->R->Fa=null;else
	{
		Splay(Findkth(x->L,x->L->S),x);
		rt=x->L,x->L->R=x->R,x->R->Fa=x->L,x->L->Fa=null,x->L->Update();
	}
}

int main()
{
	*(null=Nd)=(node){0,0,0,null,null,null};rt=null;
	n=IN(),k=IN();
	For(i,1,n+1) A[i]=IN();
	For(i,1,k+1) Insert(rt,null,A[i]);
	For(i,k,n+1)
	{
		Splay(Findkth(rt,k+1>>1),null);
		Ans=min(Ans,(1LL*rt->key*rt->L->S-rt->L->Sum)+(rt->R->Sum-1LL*rt->key*rt->R->S));
		if (i==n) break;
		Insert(rt,null,A[i+1]);Splay(cur,null);
		Delete(A[i-k+1]);
	}
	printf("%lld\n",Ans);
}
Problem1112
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19;
typedef long long LL;
int A[N],n,k;LL Ans=1LL<<60;

struct node *null;
struct node
{
	int key,S;LL Sum;
	node *L,*R,*Fa;

	void Update() {if (this!=null) S=L->S+R->S+1,Sum=L->Sum+R->Sum+key;}
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N],*rt,*cur=Nd;

void Splay(node *x,node *Aim)
{
	while (x->Fa!=Aim)
	{
		node *y=x->Fa,*z=y->Fa;
		if (y->Fa!=Aim)
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	if (Aim==null) rt=x;x->Update();
}

node *Find(node *x,int v) {return x->key==v?x:Find(v<x->key?x->L:x->R,v);}
node *Findkth(node *x,int k)
{
	if (k==x->L->S+1) return x;
	return k<x->L->S+1?Findkth(x->L,k):Findkth(x->R,k-x->L->S-1);
}
void Insert(node *&x,node *Fa,int v)
{
	if (x==null) {*(x=++cur)=(node){v,1,v,null,null,Fa};return;}
	Insert(v<x->key?x->L:x->R,x,v);
	x->Update();
}
void Delete(int v)
{
	node *x=Find(rt,v);
	Splay(x,null);
	if (x->L->S+1==1) rt=x->R,x->R->Fa=null;else
	{
		Splay(Findkth(x->L,x->L->S),x);
		rt=x->L,x->L->R=x->R,x->R->Fa=x->L,x->L->Fa=null,x->L->Update();
	}
}

int main()
{
	*(null=Nd)=(node){0,0,0,null,null,null};rt=null;
	n=IN(),k=IN();
	For(i,1,n+1) A[i]=IN();
	For(i,1,k+1) Insert(rt,null,A[i]),Splay(cur,null);
	For(i,k,n+1)
	{
		Splay(Findkth(rt,k+1>>1),null);
		Ans=min(Ans,(1LL*rt->key*rt->L->S-rt->L->Sum)+(rt->R->Sum-1LL*rt->key*rt->R->S));
		if (i==n) break;
		Insert(rt,null,A[i+1]);Splay(cur,null);
		Delete(A[i-k+1]);
	}
	printf("%lld\n",Ans);
}
Problem1113
#include<cstdio>
#include<cctype>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=250000+19;
int A[N],n,Ans,x,y;

int main()
{
	Ans=n=IN();
	For(i,1,n+1)
	{
		x=IN(),y=IN();
		while (*A&&A[*A]>=y)
		{
			if (A[*A]==y) Ans--;
			(*A)--;
		}
		A[++*A]=y;
	}
	printf("%d\n",Ans);
}
Problem1116
#include<cstdio>
#include<cctype>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1e5+19;
int Fa[N],v[N],n,m;

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}

int main()
{
	n=IN(),m=IN();
	For(i,1,n+1) Fa[i]=i;
	while (m--)
	{
		int fx=Getf(IN()),fy=Getf(IN());
		if (fx==fy) v[fx]=1;else Fa[fx]=fy,v[fy]|=v[fx];
	}
	For(i,1,n+1) if (!v[Getf(i)]) return puts("NIE"),0;
	puts("TAK");
}
Problem1129
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=300000+19,oo=(1<<30)-1;
int A[N],S[N],C[N],SS[N],p[20],k[20],a[20];
int n,Mod,tot,m,Ans,top,x;

int Pow(int a,int b,int Mod)
{
	if (b<0) return 0;
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%Mod) if (b&1) res=1LL*res*a%Mod;
	return res;
}
void ExEuclid(int a,int b,int &x,int &y)
{
	if (!b) {x=1,y=0;return;}
	ExEuclid(b,a%b,x,y);
	int tmp=x;x=y;y=tmp-a/b*y;
}

void Update(int x,int v) {for (int i=x;i<=top;i+=i&-i) C[i]+=v;}
int Query(int x) {int Ans=0;for (int i=x;i;i-=i&-i) Ans+=C[i];return Ans;}

int Inv(int a,int b)
{
	int x,y;
	ExEuclid(a,b,x,y);if (x<0) x+=b;
	return x;
}
int Calc(int p,int k)
{
	int q=0,res=1,Mod=Pow(p,k,oo),Ans=0;
	static int Qq[N],Res[N];
	memcpy(S,SS,sizeof(SS));

	Qq[0]=0,Res[0]=1;
	For(i,1,n+1)
	{
		Qq[i]=Qq[i-1],Res[i]=Res[i-1];
		x=i;while (x%p==0) Qq[i]++,x/=p;Res[i]=1LL*Res[i]*x%Mod;
	}

	For(i,1,n) {x=i;while (x%p==0) q++,x/=p;res=1LL*res*x%Mod;}
	For(i,1,top+1) q-=Qq[S[i]],res=1LL*res*Inv(Res[S[i]],Mod)%Mod;
	For(i,1,n+1) Update(A[i],1);
	For(i,1,n+1)
	{
		int x=Query(A[i]-1),qq=q;
		while (x&&x%p==0) qq++,x/=p;
		(Ans+=1LL*x*res%Mod*Pow(p,qq,Mod)%Mod)%=Mod;
		x=S[A[i]]--;while (x&&x%p==0) q++,x/=p;res=1LL*res*x%Mod;
		x=n-i;		while (x&&x%p==0) q--,x/=p;res=1LL*res*Inv(x,Mod)%Mod;
		Update(A[i],-1);
	}
	return (Ans+1)%Mod;
}

int main()
{
	read(n),read(Mod),m=Mod;
	For(i,1,n+1) read(A[i]),top=max(top,A[i]),S[A[i]]++;
	memcpy(SS,S,sizeof(S));

	for (int i=2;i*i<=m;i++)
		if (m%i==0) {p[tot]=i;while (m%i==0) k[tot]++,m/=i;tot++;}
	if (m>1) p[tot]=m,k[tot++]=1;

	For(i,0,tot) a[i]=Calc(p[i],k[i]);
	For(i,0,tot)
	{
		int Pi=Pow(p[i],k[i],oo),Ti=Mod/Pi,x,y;
		(Ans+=1LL*a[i]*Ti%Mod*Inv(Ti,Pi)%Mod)%=Mod;
	}
	printf("%d\n",Ans);
}
Problem1131
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000000+19;
struct Edge {int y,nxt;} E[N*2];
int Last[N],S[N],D[N],cnt,n,Ans;
long long F[N];

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}

void DFS_1(int x,int Fa)
{
	S[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa)
			D[E[i].y]=D[x]+1,DFS_1(E[i].y,x),S[x]+=S[E[i].y];
}
void DFS_2(int x,int Fa)
{
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa) F[E[i].y]=F[x]-S[E[i].y]+(n-S[E[i].y]),DFS_2(E[i].y,x);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN();
	For(i,1,n) Link(IN(),IN());
	DFS_1(1,-1);
	For(i,1,n+1) F[1]+=D[i];
	DFS_2(1,-1);
	For(i,1,n+1) if (!Ans||F[i]>F[Ans]) Ans=i;
	printf("%d\n",Ans);
}
Problem1143
#include<cstdio>
#include<bitset>
#include<cstring>
using namespace std;

const int Maxn=2*100+19;
struct Edge {int y,nxt;} E[Maxn*Maxn];
int Last[Maxn],Link[Maxn],vis[Maxn],cnt;
int n,m,x,y,t,Ans;
bitset<Maxn> A[Maxn];

void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
int Hungary(int x)
{
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (vis[E[i].y]!=t)
		{
			vis[E[i].y]=t;
			if (!Link[E[i].y]||Hungary(Link[E[i].y])) {Link[E[i].y]=x;return 1;}
		}
	return 0;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	for (int i=0;i<m;i++) scanf("%d%d",&x,&y),A[x][y]=1;
	for (int k=1;k<=n;k++)
		for (int i=1;i<=n;i++) if (A[i][k]==1) A[i]|=A[k];
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++) if (A[i][j]) Add_Edge(i,j+n);
	Ans=n;
	for (int i=1;i<=n;i++)
	{
		t++;
		if (Hungary(i)) Ans--;
	}
	printf("%d\n",Ans);
}
Problem1146
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define Mid (L+R>>1)
#define For(x) for (int i=x;i<=n;i+=i&-i)
#define Rep(x) for (int i=x;i;i-=i&-i)
using namespace std;

const int Maxn=80000+19,top=Maxn*100;
struct Event {int k,a,b;} D[Maxn];
struct Edge {int y,nxt;} E[Maxn*2];
typedef int one[Maxn];
one A,Last,Deep,In,Out,rt,Rt;
int Lsn[top],Rsn[top],Sum[top];
int B[Maxn*2],Fa[Maxn][18],At[4],Bt[4][21];
int n,m,Q,cnt,x,y,Time,t,tcnt;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
int Find(int x)
{
	int L=1,R=m,res;
	while (L<=R) if (B[Mid]>=x) res=Mid,R=Mid-1;else L=Mid+1;
	return res;
}

int Query(int t)
{
	int tmp=Sum[Lsn[At[t]]];
	for (int i=1;i<=Bt[t][0];i++) tmp+=Sum[Lsn[Bt[t][i]]];
	return tmp;
}
void Turn(int t,int f)
{
	At[t]=(!f?Lsn[At[t]]:Rsn[At[t]]);
	for (int i=1;i<=Bt[t][0];i++) Bt[t][i]=(!f?Lsn[Bt[t][i]]:Rsn[Bt[t][i]]);
}
void Init(int x,int t)
{
	At[t]=rt[x];Bt[t][0]=0;Rep(In[x]) Bt[t][++Bt[t][0]]=Rt[i];
}
void Update(int &x,int L,int R,int t,int v)
{
	if (!x) x=++tcnt;Sum[x]+=v;
	if (L==R) return;
	t<=Mid?Update(Lsn[x],L,Mid,t,v):Update(Rsn[x],Mid+1,R,t,v);
}
void Build(int &x,int y,int L,int R)
{
	Sum[x=++tcnt]=Sum[y]+1;
	if (L==R) return;
	Lsn[x]=Lsn[y],Rsn[x]=Rsn[y];
	t<=Mid?Build(Lsn[x],Lsn[y],L,Mid):Build(Rsn[x],Rsn[y],Mid+1,R);
}

void DFS(int x)
{
	In[x]=++Time;
	t=A[x],Build(rt[x],rt[Fa[x][0]],1,m);
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].y!=Fa[x][0]) Fa[E[i].y][0]=x,Deep[E[i].y]=Deep[x]+1,DFS(E[i].y);
	Out[x]=Time;
}
int LCA(int x,int y)
{
	if (Deep[x]>Deep[y]) swap(x,y);
	for (int k=Deep[y]-Deep[x],i=0;k;k>>=1,i++) if (k&1) y=Fa[y][i];
	if (x==y) return x;
	for (int i=17;i>=0;i--) if (Fa[x][i]!=Fa[y][i]) x=Fa[x][i],y=Fa[y][i];
	return Fa[x][0];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n),read(Q);
	for (int i=1;i<=n;i++) read(A[i]),B[++m]=A[i];
	for (int i=1;i<n;i++) read(x),read(y),Link(x,y);
	for (int i=0;i<Q;i++)
	{
		read(D[i].k),read(D[i].a),read(D[i].b);
		if (!D[i].k) B[++m]=D[i].b;
	}
	sort(B+1,B+m+1);m=unique(B+1,B+m+1)-B-1;
	for (int i=1;i<=n;i++) A[i]=Find(A[i]);
	for (int i=0;i<Q;i++) if (!D[i].k) D[i].b=Find(D[i].b);
	DFS(1);
	for (int x=1;x<=17;x++)
		for (int i=1;i<=n;i++) Fa[i][x]=Fa[Fa[i][x-1]][x-1];
	for (int q=0;q<Q;q++)
		if (D[q].k)
		{
			int a=D[q].a,b=D[q].b,c=LCA(a,b),d=Fa[c][0],k=D[q].k;
			
			Init(a,0),Init(b,1),Init(c,2),Init(d,3);
			int tmp=Sum[At[0]]+Sum[At[1]]-Sum[At[2]]-Sum[At[3]];
			for (int i=0;i<4;i++)
				for (int j=1;j<=Bt[i][0];j++) tmp+=(i<2?1:-1)*Sum[Bt[i][j]];
			if (tmp<k) {puts("invalid request!");continue;}
			
			int L=1,R=m;k=tmp-k+1;
			while (L!=R)
			{
				tmp=Query(0)+Query(1)-Query(2)-Query(3);
				for (int i=0;i<4;i++) Turn(i,tmp<k);
				if (tmp>=k) R=Mid;else L=Mid+1,k-=tmp;
			}
			printf("%d\n",B[L]);
		} else
		{
			int x=D[q].a;
			For(Out[x]+1) Update(Rt[i],1,m,A[x],1),Update(Rt[i],1,m,D[q].b,-1);
			For(In[x]) Update(Rt[i],1,m,A[x],-1),Update(Rt[i],1,m,D[q].b,1);
			A[x]=D[q].b;
		}
}
Problem1149
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x,f;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=100000+19;
int L[N],R[N],n,Ans,Max,Min=(1<<30)-1;

void DFS(int x,int Dep)
{
	if (x==-1) {Min=min(Min,Dep),Max=max(Max,Dep);return;}
	DFS(L[x],Dep+1),DFS(R[x],Dep+1);
}
int GetAns(int x,int Dep)
{
	if (x==-1) return Dep==Min?1:2;
	int l=GetAns(L[x],Dep+1),r=GetAns(R[x],Dep+1);
	if (l==3&&r==3) {puts("-1");exit(0);}
	if (l==3&&r==2||l==1&&r==2||l==1&&r==3) Ans++;
	return l|r;
}

int main()
{
	n=IN();
	For(i,1,n+1) L[i]=IN(),R[i]=IN();
	DFS(1,1);
	if (Max-Min>1) return puts("-1"),0;
	GetAns(1,1);
	printf("%d\n",Ans);
}
Problem1150
#include<set>
#include<cstdio>
#include<cctype>
#include<algorithm>
#define mp make_pair
using namespace std;

const int Maxn=100000+19;
typedef pair<int,int> Pii;
set<Pii> S;
int pre[Maxn],nxt[Maxn],A[Maxn];
int n,k,Ans;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	read(n);read(k);
	for (int i=1;i<=n;i++) read(A[i]);
	for (int i=1;i<n;i++) 
	{
		A[i]=A[i+1]-A[i];
		pre[i]=i-1;nxt[i]=i+1;
		S.insert(mp(A[i],i));
	}
	A[0]=A[n]=1<<30;
	S.insert(mp(A[0],0));
	S.insert(mp(A[n],n));
	for (int i=1;i<=k;i++)
	{
		set<Pii>::iterator it=S.begin();
		Ans+=(*it).first;int x=(*it).second;
		S.erase(*it);
		S.erase(mp(A[nxt[x]],nxt[x]));
		S.erase(mp(A[pre[x]],pre[x]));
		A[x]=A[pre[x]]+A[nxt[x]]-A[x];
		pre[x]=pre[pre[x]];nxt[x]=nxt[nxt[x]];
		pre[nxt[x]]=nxt[pre[x]]=x;
		S.insert(mp(A[x],x));
	}
	printf("%d\n",Ans);
}
Problem1152
// by ξ
// program sky  :)

#include <vector>
#include <stdio.h>
#include <algorithm>

#define Rin register int
#define oo (c=getchar())
#define For(i,l,r) for(int _r=r,i=l;i<=_r;++i)
#define rep(i,l,r) for(int _r=r,i=l;i<_r;++i)
#define dto(i,r,l) for(int _l=l,i=r;i>=_l;--i)
#define ALL(V) V.begin(),V.end()
#define pb push_back
#define x first
#define y second

using namespace std;

typedef double db;
typedef long long LL;
typedef pair<int ,int> PII;
typedef pair<db ,db> cpx;
typedef vector<int> VI;
typedef vector<PII> VII;

inline int IN(){
	char c;Rin x=0;
	for(;oo<48 && c^'-' || c>57;);bool f=c=='-';if(f)oo;
	for(;c>47 && c<58;oo)x=(x<<3)+(x<<1)+c-48;if(f)x=-x;return x;
}

inline void hello(){
	freopen("ha.in","r",stdin);
//	freopen("ha.out","w",stdout);
}

const int L=100010,mo=10000;

int n,pw[L],a[L],fail[L];

int main(){
// say hello
	//hello();
	n=IN();*pw=1;
	rep(i,1,L)pw[i]=pw[i-1]*n%mo;
	For(tc,1,IN()){
		int m=IN();
		For(i,1,m){
			a[i]=IN();
			if(i==1)continue;
			int j=fail[i-1];
			for(;j && a[j+1]^a[i];j=fail[j]);
			fail[i]=j+(a[j+1]==a[i]);
		}
		int ans=0;
		for(int j=m;j;j=fail[j])(ans+=pw[j])%=mo;
		printf("%04d\n",ans);
	}
// never say goodbye
}
Problem1152
// by ξ
// program sky  :)

#include <bits/stdc++.h>

using namespace std;

const int L=100010,mo=10000;

int n,m,pw[L],a[L],fail[L];

int main(){
	scanf("%d",&n);
	*pw=1;for(int i=1;i<L;++i)pw[i]=pw[i-1]*n%mo;
	int tc;for(scanf("%d",&tc);tc--;){
		scanf("%d",&m);
		for(int i=1;i<=m;++i){
			scanf("%d",a+i);
			if(i==1)continue;
			int j=fail[i-1];
			for(;j && a[j+1]^a[i];j=fail[j]);
			fail[i]=j+(a[j+1]==a[i]);
		}
		int ans=0;
		for(int j=m;j;j=fail[j])(ans+=pw[j])%=mo;
		printf("%04d\n",ans);
	}
}
Problem1152
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fi first
#define se second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=100000+19;
const int p=10000;

int pw[N],Fail[N],A[N];
int n,m,res;

void Main(){
	n=IN();
	For(i,1,n+1) A[i]=IN();
	Fail[1]=0;
	for (int i=2,j=0;i<=n;i++){
		while (j&&A[j+1]!=A[i]) j=Fail[j];
		if (A[j+1]==A[i]) j++;
		Fail[i]=j;
	}
	res=0;
	for (int i=n;i;i=Fail[i]) res=(res+pw[i])%p;
	printf("%04d\n",res);
}

int main(){
	m=IN();
	pw[0]=1;
	For(i,1,N) pw[i]=1ll*m*pw[i-1]%p;
	for (int T=IN();T--;) Main();
}
Problem1176
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int Q=10000+19,N=180000+19,W=2000000+19;
struct Event
{
	int opt,x,y,a,L,R,pos,ID;
	bool operator < (const Event& B) const {return x<B.x||x==B.x&&pos<B.pos;}
} E[N],tmp[N];
int S,w,opt,x,y,a,n,x1,y1,x2,y2,cnt,Time;
int Ans[Q],C[W],T[W];

void Update(int x,int v)
{
	for (int i=x;i<=w;i+=i&-i)
	{
		if (T[i]!=Time) T[i]=Time,C[i]=0;
		C[i]+=v;
	}
}
int Query(int x)
{
	int Ans=0;
	for (int i=x;i;i-=i&-i) Ans+=T[i]==Time?C[i]:0;
	return Ans;
}

void CDQ(int L,int R)
{
	if (L==R) return;
	Time++;
	For(i,L,R+1)
	{
		if (E[i].pos<=Mid&&E[i].opt==1) Update(E[i].y,E[i].a);
		if (E[i].pos>Mid&&E[i].opt==2) Ans[E[i].ID]+=E[i].a*(Query(E[i].R)-Query(E[i].L-1));
	}
	int Tl=L,Tr=Mid+1;
	For(i,L,R+1) if (E[i].pos<=Mid) tmp[Tl++]=E[i];else tmp[Tr++]=E[i];
	For(i,L,R+1) E[i]=tmp[i];
	CDQ(L,Mid);CDQ(Mid+1,R);
}

int main()
{
	read(S),read(w);
	while ((read(opt),opt)!=3)
		if (opt==1)
		{
			read(x),read(y),read(a);
			n++;E[n]=(Event){1,x,y,a,0,0,n,0};
		} else
		{
			read(x1),read(y1),read(x2),read(y2);
			cnt++,Ans[cnt]=S*(x2-x1+1)*(y2-y1+1);
			n++;E[n]=(Event){2,x1-1,0,-1,y1,y2,n,cnt};
			n++;E[n]=(Event){2,x2,0,1,y1,y2,n,cnt};
		}
	sort(E+1,E+n+1);
	CDQ(1,n);
	For(i,1,cnt+1) printf("%d\n",Ans[i]);
}
Problem1177
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<=y;i++)
#define Rep(i,x,y) for (int i=x;i>=y;i--)
using namespace std;

const int N=1500+19;
int s[N][N],A[N][N],B[N][N],C[N][N],D[N][N];
int n,m,k,Ans,x;

int Max(int a,int b,int c) {return max(max(a,b),c);}

int main()
{
	scanf("%d%d%d",&n,&m,&k);
	For(i,1,n) For(j,1,m) scanf("%d",&x),s[i][j]=s[i][j-1]+s[i-1][j]-s[i-1][j-1]+x;
	Rep(i,n,k) Rep(j,m,k) s[i][j]=s[i][j]-s[i][j-k]-s[i-k][j]+s[i-k][j-k];

	For(i,k,n) For(j,k,m) 			A[i][j]=Max(A[i-1][j],A[i][j-1],s[i][j]);
	For(i,k,n) Rep(j,m-k+1,1) 		B[i][j]=Max(B[i-1][j],B[i][j+1],s[i][j+k-1]);
	Rep(i,n-k+1,1) For(j,k,m) 		C[i][j]=Max(C[i+1][j],C[i][j-1],s[i+k-1][j]);
	Rep(i,n-k+1,1) Rep(j,m-k+1,1) 	D[i][j]=Max(D[i+1][j],D[i][j+1],s[i+k-1][j+k-1]);

	For(i,k,n-k) For(j,k,m-k)			Ans=max(Ans,A[i][j]+C[i+1][j]+D[1][j+1]);
	For(i,k,n-k) For(j,k+1,m-k+1)		Ans=max(Ans,B[i][j]+A[i][j-1]+D[i+1][1]);
	For(i,k+1,n-k+1) For(j,k,m-k)		Ans=max(Ans,C[i][j]+D[i][j+1]+A[i-1][m]);
	For(i,k+1,n-k+1) For(j,k+1,m-k+1)	Ans=max(Ans,D[i][j]+B[i-1][j]+A[n][j-1]);
	For(i,k+k,n-k) For(j,k,m)		Ans=max(Ans,s[i][j]+A[i-k][m]+D[i+1][1]);
	For(i,k,n) For(j,k+k,m-k)		Ans=max(Ans,s[i][j]+A[n][j-k]+D[1][j+1]);
	printf("%d\n",Ans);
}
Problem1179
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
using namespace std;
 
const int Maxn=500000+19;
struct Edge {int y,nxt;} E[Maxn*2],SE[Maxn*2];
typedef int one[Maxn];
one Last,Money,Bar,SM,SB,SL;
one DFN,Low,St,SCC,vis,F,Q;
int t,n,m,x,y,cnt,S,P,top,tot,Scnt,Ans,f,w;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
 
void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
void Add_SCC_Edge(int x,int y) {SE[Scnt]=(Edge){y,SL[x]};SL[x]=Scnt++;}
void Tarjan(int x)
{
    DFN[x]=Low[x]=++t;St[++top]=x;
    for (int i=Last[x];i!=-1;i=E[i].nxt)
    {
        int y=E[i].y;
        if (!DFN[y]) Tarjan(y),Low[x]=min(Low[x],Low[y]);
            else if (!SCC[y]) Low[x]=min(Low[x],DFN[y]);
    }
    if (DFN[x]==Low[x])
    {
        tot++;
        for (;;)
        {
            int y=St[top--];SCC[y]=tot;SM[tot]+=Money[y];SB[tot]|=Bar[y];
            if (x==y) break;
        }
    }
}
void SPFA(int S)    
{
    f=1;w=0;Q[1]=S;F[S]=SM[S];
    while (f>w)
    {
        int x=Q[++w];vis[x]=0;
        for (int i=SL[x];i!=-1;i=SE[i].nxt)
        {
            int y=SE[i].y;
            if (F[x]+SM[y]>F[y]) 
            {
                F[y]=F[x]+SM[y];
                if (!vis[y]) vis[y]=1,Q[++f]=y;
            }
        }
    }
}
 
int main()
{
    read(n),read(m);
    memset(Last,-1,sizeof(Last));
    memset(SL,-1,sizeof(SL));
    for (int i=0;i<m;i++) read(x),read(y),Add_Edge(x,y);
    for (int i=1;i<=n;i++) read(Money[i]);
    read(S),read(P);
    for (int i=1;i<=P;i++) read(x),Bar[x]=1;
	for (int i=1;i<=n;i++) if (!DFN[i]) Tarjan(i);
    for (int x=1;x<=n;x++)
        for (int i=Last[x];i!=-1;i=E[i].nxt)
        {
            int a=SCC[x],b=SCC[E[i].y];
            if (a!=b) Add_SCC_Edge(a,b);
        }
    SPFA(SCC[S]);
    for (int i=1;i<=tot;i++) if (SB[i]) Ans=max(Ans,F[i]);
    printf("%d\n",Ans);
}
Problem1180
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=30000+19;
struct node *null;
struct node
{
	node *L,*R,*Fa;
	int key,Sum,rev;

	bool Top() {return Fa==null||Fa->L!=this&&Fa->R!=this;}
	void Update() {Sum=L->Sum+R->Sum+key;}
	void Setrev() {rev^=1,swap(L,R);}
	void Down() {if (rev) L->Setrev(),R->Setrev(),rev=0;}

	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N];

void Splay(node *x)
{
	static node *S[N];
	node *tmp=x;int k=0;
	while (!tmp->Top()) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (!x->Top())
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top())
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}
node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa) Splay(x),x->R=y,x->Update();
	return y;
}
node *Root(node *x)
{
	Access(x),Splay(x);
	while (x->L!=null) x=x->L,x->Down();
	return x;
}
void Evert(node *x) {Access(x)->Setrev();}
void Link(node *x,node *y)
{
	if (Root(x)==Root(y)) {puts("no");return;}
	puts("yes"),Evert(x),Splay(x),x->Fa=y;
}

int A[N],n,Q,x,y;
char s[15];

int main()
{
	null=Nd;
	n=IN();
	For(i,1,n+1) A[i]=IN();
	For(i,0,n+1) Nd[i]=(node){null,null,null,A[i],A[i],0};
	Q=IN();
	while (Q--)
	{
		scanf("%s",s);
		if (s[0]=='b') Link(Nd+IN(),Nd+IN());
		if (s[0]=='p') x=IN(),y=IN(),Splay(Nd+x),(Nd+x)->key=y,(Nd+x)->Update();
		if (s[0]=='e')
		{
			x=IN(),y=IN();
			if (Root(Nd+x)!=Root(Nd+y)) puts("impossible");else
				Evert(Nd+x),printf("%d\n",Access(Nd+y)->Sum);
		}
	}
}
Problem1189
#include<cstdio>
#include<cstring>
#include<algorithm>
#define Rep(i,j) for (int i=1;i<=n;i++) for (int j=1;j<=m;j++)
using namespace std;

const int Maxn=20*20+19,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[Maxn*Maxn];
int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};
int A[22][22],ID[22][22];
int Dis[Maxn][Maxn],Last[Maxn],D[Maxn];
int n,m,tot,L,R,res,S,T,cnt,ptot;
int Q[Maxn][2],Qd[Maxn],f,w;
char s[22];

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,f,Last[y]};Last[y]=cnt++;
}
void BFS(int px,int py,int cur)
{
	f=1;w=0;Q[1][0]=px,Q[1][1]=py;
	Dis[cur][cur]=0;
	while (f>w)
	{
		w++;int x=Q[w][0],y=Q[w][1];
		for (int i=0;i<4;i++)
		{
			int nx=x+dx[i],ny=y+dy[i];
			if (nx<=1||nx>=n||ny<=1||ny>=m||A[nx][ny]=='X') continue;
			if (Dis[cur][ID[nx][ny]]==-1) 
			{
				Dis[cur][ID[nx][ny]]=Dis[cur][ID[x][y]]+1;
				f++;Q[f][0]=nx;Q[f][1]=ny;
			}
		}
	}
}
int Dinic_BFS()
{
	memset(D,-1,sizeof(D));
	D[S]=0;f=1;w=0;Qd[1]=S;
	while (f>w)
	{
		int x=Qd[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&D[E[i].y]==-1) D[E[i].y]=D[x]+1,Qd[++f]=E[i].y;
	}
	return D[T]!=-1;
}
int Dinic_DFS(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&D[E[i].y]==D[x]+1)
		{
			int tmp=Dinic_DFS(E[i].y,min(Flow,E[i].f));
			res+=tmp;Flow-=tmp;E[i].f-=tmp;E[i^1].f+=tmp;
		}
	if (!res) D[x]=-1;return res;
}
inline int check(int time)
{
	cnt=0;memset(Last,-1,sizeof(Last));
	for (int i=ptot+1;i<=tot-2;i++)
		for (int j=1;j<=ptot;j++) 
			if (Dis[i][j]!=-1&&Dis[i][j]<=time) Add_Edge(j,i,1);
	for (int i=ptot+1;i<=tot-2;i++) Add_Edge(i,T,time);
	for (int i=1;i<=ptot;i++) Add_Edge(S,i,1);
	int Flow=0;
	while (Dinic_BFS()) Flow+=Dinic_DFS(S,oo);
	return Flow==ptot;
}

int main()
{
	memset(Dis,-1,sizeof(Dis));
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	{
		scanf("%s",s);
		for (int j=1;j<=m;j++) A[i][j]=s[j-1];
	}
	Rep(i,j) if (A[i][j]=='.') ID[i][j]=++tot;ptot=tot;
	Rep(i,j) if (A[i][j]=='D') ID[i][j]=++tot,BFS(i,j,tot);
	S=++tot;T=++tot;
	Rep(i,j) if (A[i][j]=='.') 
	{
		int f=0;
		for (int k=1;k<=tot;k++) if (Dis[k][ID[i][j]]!=-1) {f=1;break;}
		if (!f) {puts("impossible");return 0;}
	}
	L=0;R=n*m*2;
	while (L<=R)
	{
		int Mid=(L+R)>>1;
		if (check(Mid)) res=Mid,R=Mid-1;else L=Mid+1;
	}
	printf("%d\n",res);
}
Problem1191
#include<cstdio>
#include<cstring>
using namespace std;

const int Maxn=1000+19;
int L[Maxn],Vis[Maxn],G[Maxn][2],n,m;

int Hungary(int v)
{
	for (int i=0;i<2;i++)
	{
		int nxt=G[v][i];
		if (!Vis[nxt]) 
		{
			Vis[nxt]=1;
			if (!L[nxt]||Hungary(L[nxt])) 
			{
				L[nxt]=v;return 1;
			}
		}
	}
	return 0;
}

int main()
{
	int ans=0;
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++) scanf("%d%d",&G[i][0],&G[i][1]);
	for (int i=1;i<=m;i++) 
	{
		memset(Vis,0,sizeof(Vis));
		if (Hungary(i)) ans++;else break;
	}
	printf("%d\n",ans);
	//for (;;);
	return 0;
}
Problem1192
#include<cstdio>
using namespace std;

int main()
{
	int log=0,n;
	scanf("%d",&n);
	for (;1<<log<n;log++);
	printf("%d\n",log);
	//for(;;);
	return 0;
}
Problem1193
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Eps=10;
int Dx[8]={2,2,1,1,-1,-1,-2,-2},Dy[8]={1,-1,2,-2,2,-2,1,-1};
int sx,sy,tx,ty,Ans,f,w;
int Dis[Eps*2+3][Eps*2+3],Q[Eps*Eps*4+19][2];

void BFS(int tx,int ty)
{
	f=1;w=0;Q[1][0]=Q[1][1]=Eps+1;
	while (f>w)
	{
		w++;int x=Q[w][0],y=Q[w][1];
		for (int i=0;i<8;i++)
		{
			int nx=x+Dx[i],ny=y+Dy[i];
			if (nx>=0&&nx<=Eps*2&&ny>=0&&ny<=Eps*2&&Dis[nx][ny]==-1) 
			{
				Dis[nx][ny]=Dis[x][y]+1;
				f++;Q[f][0]=nx,Q[f][1]=ny;
			}
		}
	}
}

int main()
{
	scanf("%d%d%d%d",&sx,&sy,&tx,&ty);
	memset(Dis,-1,sizeof(Dis));
	Dis[Eps+1][Eps+1]=0;
	while (abs(tx-sx+1)>Eps||abs(ty-sy+1)>Eps) 
	{
		if (sx>tx) swap(sx,tx);
		if (sy>ty) swap(sy,ty);
		Dis[Eps+1][Eps+1]++;
		if (tx-sx>ty-sy) sx+=2,sy++;else sx++,sy+=2;
	}
	BFS(tx-sx+1,ty-sy+1);
	printf("%d\n",Dis[tx-sx+Eps+1][ty-sy+Eps+1]);
}
Problem1196
#include<cstdio>
using namespace std;

const int Maxn=10000+19;
struct Edge {int x,y,c1,c2;} E[Maxn*2];
int n,m,k,L,R,res;
int Fa[Maxn];

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}
int check(int top)
{
	for (int i=1;i<=n;i++) Fa[i]=i;
	int cnt=0;
	for (int i=0;i<m;i++) 
		if (E[i].c1<=top) 
		{
			int Fx=Getf(E[i].x),Fy=Getf(E[i].y);
			if (Fx!=Fy) Fa[Fx]=Fy,cnt++;
		}
	if (cnt<k) return 0;
	for (int i=0;i<m;i++)
		if (E[i].c2<=top)
		{
			int Fx=Getf(E[i].x),Fy=Getf(E[i].y);
			if (Fx!=Fy) Fa[Fx]=Fy,cnt++;
		}
	return cnt==n-1;
}

int main()
{
	scanf("%d%d%d",&n,&k,&m);m--;
	for (int i=0;i<m;i++) scanf("%d%d%d%d",&E[i].x,&E[i].y,&E[i].c1,&E[i].c2);
	L=1,R=30000;
	while (L<=R)
	{
		int Mid=(L+R)>>1;
		if (check(Mid)) res=Mid,R=Mid-1;else L=Mid+1;
	}
	printf("%d\n",res);
}
Problem1202
#include<cstdio>
using namespace std;

int T,n,m,s,t,v;
int F[100+19],G[100+19];

int Getf(int x)
{
	if (F[x]==x) return x;
	int tmp=F[x];
	F[x]=Getf(F[x]);
	G[x]+=G[tmp];
	return F[x];
}

int main()
{
	scanf("%d",&T);
	while (T--)
	{
		int flag=1;
		scanf("%d%d",&n,&m);
		for (int i=0;i<=n;i++) {F[i]=i;G[i]=0;}
		for (int i=0;i<m;i++) 
		{
			scanf("%d%d%d",&s,&t,&v);s--;
			int fs=Getf(s),ft=Getf(t);
			if (fs!=ft)
			{
				F[fs]=ft;
				G[fs]=G[t]-G[s]-v;
			} else if (G[t]-G[s]!=v) flag=0;
		}
		printf("%s\n",flag?"true":"false");
	}
}
Problem1206
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000000+19;
struct node
{
	int x,t,T;
	bool operator < (const node& B) const {return t>B.t||t==B.t&&T>B.T;}
};priority_queue<node> Q;
int A[N],B[N],Add[N],vis[N],n,m,t,Ans;

int main()
{
	n=IN(),m=IN();
	For(i,1,m+1) A[i]=B[i]=IN();
	sort(B+1,B+m+1);t=unique(B+1,B+m+1)-B-1;
	For(i,1,m+1) A[i]=lower_bound(B+1,B+t+1,A[i])-B;
	For(i,1,m+1)
	{
		int x=A[i];
		if (vis[x]) Add[x]++,Ans++;else
		{
			if (Q.size()==n)
				while (1)
				{
					node P=Q.top();Q.pop();vis[P.x]=0;
					if (!Add[P.x]) break;
					P.t+=Add[P.x],Add[P.x]=0,Q.push(P);vis[P.x]=1;
				}
			Q.push((node){x,0,i}),vis[x]=1;
		}
	}
	printf("%d\n",Ans);
}
Problem1207
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=10000+19;
int t[Maxn],x[Maxn],y[Maxn],f[Maxn];
int main()
{
	int n,m,Ans=0;
	scanf("%d%d",&n,&m);
	for (int i=0;i<m;i++) scanf("%d%d%d",&t[i],&x[i],&y[i]),f[i]=1;
	for (int i=1;i<m;i++)
	{
		for (int j=0;j<i;j++)
			if (t[i]-t[j]>=abs(x[i]-x[j])+abs(y[i]-y[j]))
				f[i]=max(f[i],f[j]+1);
		Ans=max(Ans,f[i]);
	}
	printf("%d\n",Ans);
	//for (;;);
	return 0;
}
Problem1208
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

namespace SBT
{
	const int Maxn=80000+19;
	int key[Maxn],s[Maxn],Lsn[Maxn],Rsn[Maxn];
	int Size=0,Tree_Size=0,Root=0;
	void Left_Rotate(int &t) 
	{
		int k=Rsn[t];Rsn[t]=Lsn[k];Lsn[k]=t;
		s[k]=s[t];
		s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
		t=k;
	}
	void Right_Rotate(int &t) 
	{
		int k=Lsn[t];Lsn[t]=Rsn[k];Rsn[k]=t;
		s[k]=s[t];
		s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
		t=k;
	}
	void Maintain(int &t,int Flag) 
	{
		if (!Flag)
		{
			if (s[Lsn[Lsn[t]]]>s[Rsn[t]]) Right_Rotate(t);
				else 
			if (s[Rsn[Lsn[t]]]>s[Rsn[t]]) Left_Rotate(Lsn[t]),Right_Rotate(t);
				else return;
		} else
		{
			if (s[Rsn[Rsn[t]]]>s[Lsn[t]]) Left_Rotate(t);
				else
			if (s[Lsn[Rsn[t]]]>s[Lsn[t]]) Right_Rotate(Rsn[t]),Left_Rotate(t);
		}
	}
	void Insert(int &t,int v) 
	{
		if (!t) 
		{
			t=++Tree_Size;
			key[t]=v;s[t]=1;Lsn[t]=Rsn[t]=0;
		}
		else
		{
			s[t]++;
			Insert(v<=key[t]?Lsn[t]:Rsn[t],v);
			Maintain(t,v>key[t]);
		}
	}
	int Delete(int &t,int v) 
	{
		s[t]--;
		if (key[t]==v || v<key[t]&&!Lsn[t] || v>key[t]&&!Rsn[t])
		{
			int Del=key[t];
			if (!Lsn[t]||!Rsn[t]) t=Lsn[t]+Rsn[t];
				else key[t]=Delete(Lsn[t],key[t]+1);
			return Del;
		}
		if (v<key[t]) return Delete(Lsn[t],v);
			else return Delete(Rsn[t],v);
	}
	int Pred(int &t,int v) 
	{
		if (!t) return v;
		if (v<=key[t]) return Pred(Lsn[t],v);
			else {int tmp=Pred(Rsn[t],v);return tmp==v?key[t]:tmp;}
	}
	int Succ(int &t,int v) 
	{
		if (!t) return v;
		if (v>=key[t]) return Succ(Rsn[t],v);
			else {int tmp=Succ(Lsn[t],v);return tmp==v?key[t]:tmp;}
	}
}

int n,a,b,type,Ans=0,c;

void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++)
	{
		Read(a);Read(b);
		if (SBT::Size==0) type=a;
		if (type==a) SBT::Insert(SBT::Root,b),SBT::Size++;
		else
		{
			int Low=SBT::Pred(SBT::Root,b),High=SBT::Succ(SBT::Root,b);
			int tmp=(abs(Low-b)>abs(High-b)?High:Low);
			Ans=(Ans+abs(SBT::Delete(SBT::Root,tmp)-b))%1000000;
			SBT::Size--;
		}
	}
	printf("%d\n",Ans);
	return 0;
}
Problem1211
#include<cstdio>
using namespace std;

typedef long long LL;
const LL Mod=100000000000000003LL;

int n,d,tot;
LL Ans=1,Fac[150+19];

LL Mult(LL a,LL b)
{
	LL res=0;
	for (;b;b>>=1,(a<<=1)%=Mod) if (b&1) (res+=a)%=Mod;
	return res;
}
LL Pow(LL a,LL b)
{
	LL res=1;
	for (;b;b>>=1,a=Mult(a,a)) if (b&1) res=Mult(res,a);
	return res;
}

int main()
{
	scanf("%d",&n);
	if (n==1) {scanf("%d",&d);puts(d?"0":"1");return 0;}
	for(int i=2;i<=n-2;i++) Ans=Mult(Ans,i);
	Fac[0]=1;for (int i=1;i<=n;i++) Fac[i]=Mult(Fac[i-1],i);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&d);tot+=d-1;
		LL tmp=Pow(Fac[d-1],Mod-2);
		Ans=Mult(Ans,tmp);
	}
	if (tot!=n-2) {puts("0");return 0;}
	printf("%lld\n",Ans);
}
Problem1212
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

char s[1100000+19],t[21][12];
int Len[21],F[1100000+19],n,m,L,Ans;

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=0;i<n;i++) scanf("%s",t[i]),Len[i]=strlen(t[i]);
	while (m--)
	{
		scanf("%s",s+1);
		F[0]=1;L=strlen(s+1);Ans=0;
		for (int i=1;i<=L;i++)
		{
			F[i]=0;
			for (int j=0;j<n;j++)
				if (i>=Len[j]&&F[i-Len[j]])
				{
					int f=1;
					for (int k=1;k<=Len[j];k++) if (s[i-Len[j]+k]!=t[j][k-1]) {f=0;break;}
					if (f) {F[i]=1;break;}
				}
			if (F[i]) Ans=i;
		}
		printf("%d\n",Ans);
	}
}
Problem1213
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;

const int Base=10000,top=100000000;

string c;int n;
struct BigInt
{
	int Len,s[3000];
	BigInt() {Len=1;memset(s,0,sizeof(s));}
	bool operator <= (const BigInt& B) const 
	{
		if (Len!=B.Len) return Len<B.Len;
		for (int i=Len-1;i>=0;i--) if (s[i]!=B.s[i]) return s[i]<B.s[i];
		return 1;
	}
	void clear() {while (Len>1&&s[Len-1]==0) Len--;}
	void from_str(string c) 
	{
		int L=c.length();Len=L/4+(L%4!=0);
		for (int i=0;i<Len;i++)
			for (int j=max(L-(i+1)*4,0);j<L-i*4;j++) s[i]=s[i]*10+c[j]-'0';
	}
	void read() {cin>>c;from_str(c);}
	void print()
	{
		for (int i=Len-1;i>=0;i--)
		{
			if (i!=Len-1&&s[i]<1000) putchar('0');
			if (i!=Len-1&&s[i]<100) putchar('0');
			if (i!=Len-1&&s[i]<10) putchar('0');
			printf("%d",s[i]);
		}
		puts("");
	}
} A,L,R,res,Mid;

BigInt operator + (BigInt A,BigInt B)
{
	A.Len=max(A.Len,B.Len);
	for (int i=0;i<A.Len;i++) A.s[i]+=B.s[i];
	for (int i=0;i<A.Len;i++) A.s[i+1]+=A.s[i]/Base,A.s[i]%=Base;
	A.Len++;A.clear();return A;
}
BigInt operator * (BigInt A,BigInt B)
{
	BigInt C;C.Len=A.Len+B.Len;
	for (int i=0;i<A.Len;i++)
		for (int j=0;j<B.Len;j++) 
		{
			C.s[i+j]+=A.s[i]*B.s[j];
			if (C.s[i+j]>top) C.s[i+j+1]+=C.s[i+j]/Base,C.s[i+j]%=Base;
		}
	for (int i=0;i<C.Len;i++) C.s[i+1]+=C.s[i]/Base,C.s[i]%=Base;
	C.clear();return C;
}
BigInt Pow(BigInt a,int b)
{
	BigInt res;res.from_str("1");
	for (;b;b>>=1,a=a*a) 
	{
		if (b&1) res=res*a;
		if (b==1||!(res<=A)) return res;
	}
	return res;
}
BigInt Shr(BigInt A)
{
	for (int i=A.Len-1;i;i--) {A.s[i-1]+=(A.s[i]&1)*Base;A.s[i]>>=1;}
	A.s[0]>>=1;A.clear();return A;
}
void Inc(BigInt &A) 
{
	A.s[0]++;for (int i=0;i<A.Len;i++) A.s[i+1]+=A.s[i]/Base,A.s[i]%=Base;
	A.Len++;A.clear();
}
void Dec(BigInt &A)
{
	A.s[0]--;for (int i=0;i<A.Len;i++) if (A.s[i]<0) A.s[i]+=Base,A.s[i+1]--;
	A.clear();
}

int main()
{
	scanf("%d",&n);
	A.read();
	L.from_str("0");
	R.Len=(A.Len*4/n)/4+1;for (int i=0;i<R.Len;i++) R.s[i]=9999;
	while (L<=R)
	{
		Mid=Shr(L+R);
		if (Pow(Mid,n)<=A) res=Mid,L=Mid,Inc(L);else R=Mid,Dec(R);
	}
	res.print();
}
Problem1213
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int Maxl=20000,Base=10000;

struct Bigint{
	int len,s[Maxl];
	Bigint(){}
	Bigint(int v){
		len=1,s[0]=v;
	}
	bool operator <= (const Bigint &B) const{
		if (len!=B.len) return len<B.len;
		for (int i=len-1;~i;i--) if (s[i]!=B.s[i]) return s[i]<B.s[i];
		return 1;
	}
	void Clear(){
		while (len>1&&!s[len-1]) len--;
	}
	void div2(){
		for (int i=len-1;~i;i--){
			if (i) s[i-1]+=(s[i]&1)*Base;
			s[i]>>=1;
		}
		Clear();
	}
	void plus1(){
		s[0]++;s[len++]=0;
		For(i,0,len) if (s[i]==Base) s[i]-=Base,s[i+1]++;else break;
		Clear();
	}
	void minus1(){
		s[0]--;
		For(i,0,len) if (s[i]<0) s[i]+=Base,s[i+1]--;else break;
		Clear();
	}
	void IN(){
		static char c[Maxl+19];
		scanf("%s",c+1);
		int tmp=strlen(c+1);
		len=tmp/4+(tmp%4!=0);
		For(i,0,len)
			for (int j=max(tmp-i*4-4+1,1);j<=tmp-i*4;j++) s[i]=(s[i]*10+c[j]-'0');
		Clear();
	}
	void print(){
		printf("%d",s[len-1]);
		for (int i=len-2;~i;i--) printf("%04d",s[i]);
	}
} n,L,R,Mid,tmp,res;
int k,m;

Bigint operator + (const Bigint &A,const Bigint &B){
	tmp.len=max(A.len,B.len)+1;
	For(i,0,tmp.len) tmp.s[i]=0;
	For(i,0,A.len) tmp.s[i]+=A.s[i];
	For(i,0,B.len) tmp.s[i]+=B.s[i];
	For(i,0,tmp.len) tmp.s[i+1]+=tmp.s[i]/Base,tmp.s[i]%=Base;
	return tmp.Clear(),tmp;
}
Bigint operator * (const Bigint &A,const Bigint &B){
	tmp.len=A.len+B.len+2;
	For(i,0,tmp.len) tmp.s[i]=0;
	For(i,0,A.len) For(j,0,B.len){
		tmp.s[i+j]+=A.s[i]*B.s[j];
		if (tmp.s[i+j]>1e8){
			tmp.s[i+j+1]+=tmp.s[i+j]/Base;
			tmp.s[i+j]%=Base;
		}
	}
	For(i,0,tmp.len) tmp.s[i+1]+=tmp.s[i]/Base,tmp.s[i]%=Base;
	return tmp.Clear(),tmp;
}
bool cmpPow(Bigint A,int b){
	static Bigint res;
	res=1;
	for (;b;b>>=1,A=A*A){
		if (b&1){
			res=res*A;
			if (!(res<=n)) return 0;
		}
		if (!(A<=n)) return 0;
		if (b==1) return 1;
	}
	return 1;
}

int main(){
	m=IN();
	n.IN();
	res=0;
	L=1;
	R.len=(n.len*4/m)/4+1;
	For(i,0,R.len) R.s[i]=9999;
	while (L<=R){
		Mid=L+R;
		Mid.div2();
		if (cmpPow(Mid,m)){
			res=Mid;
			L=Mid;L.plus1();
		} else{
			R=Mid;R.minus1();
		}
	}
	res.print();
	puts("");
}
Problem1216
#include<cstdio>
#include<queue>
using namespace std;

const int oo=(1<<30)-1;
struct node 
{
	int s,t,ID,lev;
	bool operator < (const node& B) const {return lev<B.lev||lev==B.lev&&s>B.s;}
};
priority_queue<node> Q;
int s,t,ID,lev,time,Flag=1;

int main()
{
	time=1;
	while (Flag)
	{
		if (~scanf("%d%d%d%d",&ID,&s,&t,&lev));else Flag=0,s=oo/2;
		while (!Q.empty()&&Q.top().t-(s-time)<=0)
		{
			time+=Q.top().t;
			printf("%d %d\n",Q.top().ID,time),Q.pop();
		}
		if (!Q.empty())
		{
			node tmp=Q.top();Q.pop();
			Q.push((node){tmp.s,tmp.t-(s-time),tmp.ID,tmp.lev});
		}
		Q.push((node){s,t,ID,lev});time=s;
	}
}
Problem1216
#include<cstdio>
#include<queue>
#include<cctype>
using namespace std;

const int oo=(1<<30)-1;
struct node 
{
	int s,t,ID,lev;
	bool operator < (const node& B) const {return lev<B.lev||lev==B.lev&&s>B.s;}
};
priority_queue<node> Q;
int s,t,ID,lev,time,Flag=1;

int c;

void read(int &x)
{
	while ((c=getchar())!=EOF&&!isdigit(c));
	if (c==EOF) {x=-1;return;}
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	time=1;
	while (Flag)
	{
		if ((read(ID),read(s),read(t),read(lev),lev)!=-1);else Flag=0,s=oo/2;
		while (!Q.empty()&&Q.top().t-(s-time)<=0)
		{
			time+=Q.top().t;
			printf("%d %d\n",Q.top().ID,time),Q.pop();
		}
		if (!Q.empty())
		{
			node tmp=Q.top();Q.pop();
			Q.push((node){tmp.s,tmp.t-(s-time),tmp.ID,tmp.lev});
		}
		Q.push((node){s,t,ID,lev});time=s;
	}
}
Problem1217
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000+19,oo=(1<<30)-1;
struct Edge {int y,nxt;} E[N*2];
int Last[N],f[N][5],cnt,n;

void Add(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
void DFS(int x)
{
	f[x][0]=1,f[x][1]=oo,f[x][2]=oo;
	for (int i=Last[x];~i;i=E[i].nxt)
	{
		DFS(E[i].y);
		f[x][0]+=f[E[i].y][4];
		f[x][3]+=f[E[i].y][2];
		f[x][4]+=f[E[i].y][3];
	}
	for (int i=Last[x];~i;i=E[i].nxt)
	{
		f[x][1]=min(f[x][1],f[x][4]-f[E[i].y][3]+f[E[i].y][0]);
		f[x][2]=min(f[x][2],f[x][3]-f[E[i].y][2]+f[E[i].y][1]);
	}
	For(i,1,5) f[x][i]=min(f[x][i],f[x][i-1]);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN();
	For(i,2,n+1) Add(IN(),i);
	DFS(1),printf("%d\n",f[1][2]);
}
Problem1218
#include<cstdio>
#include<algorithm>
using namespace std;

const int oo=(1<<30)-1,Maxn=10000+19;
int X[Maxn],Y[Maxn],V[Maxn];
int C[6000];
int main()
{
	int n,r,Ans=-oo;
	scanf("%d%d",&n,&r);
	int Maxx=-oo,Minx=oo,Maxy=-oo,Miny=oo;
	for (int i=0;i<n;i++)
	{
		scanf("%d%d%d",&X[i],&Y[i],&V[i]);
		Maxx=max(Maxx,X[i]);Maxy=max(Maxy,Y[i]);
		Minx=min(Minx,X[i]);Miny=min(Miny,Y[i]);
	}
	Minx--;Miny--;Maxx++;Maxy++;
	for (int i=Miny;i<=Maxy;i++)
		for (int j=0;j<n;j++)
			if (Y[j]==i&&X[j]<r-1) C[i]+=V[j];
	for (int i=Minx;i<=Maxx;i++)
	{
		int s=0;
		for (int j=Miny;j<Miny+r;j++) s+=C[j];
		for (int j=Miny;j<=Maxy;j++)
		{
			Ans=max(Ans,s);
			s=s-C[j]+C[j+r];
		}
		for (int j=0;j<n;j++)
		{
			if (X[j]==i) C[Y[j]]-=V[j];
			if (X[j]==i+r) C[Y[j]]+=V[j];
		}
	}
	printf("%d\n",Ans);
	//for (;;);
	return 0;
}
Problem1221
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=2000+19,oo=(1<<30)-1;
struct Edge {int x,y,f,c,nxt;} E[N*3*2];
int Last[N],Q[N*10],vis[N],pre[N],Dis[N];
int n,a,b,f,fa,fb,x,cnt,S,T,Cost;

void Add_Edge(int x,int y,int f,int c)
{
	E[cnt]=(Edge){x,y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){y,x,0,-c,Last[y]};Last[y]=cnt++;
}

bool SPFA()
{
	int f=1,w=0;Q[1]=S;
	memset(Dis,64,sizeof(Dis));Dis[S]=0;vis[S]=1;pre[S]=-1;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[x]+E[i].c<Dis[E[i].y])
			{
				Dis[E[i].y]=Dis[x]+E[i].c;
				pre[E[i].y]=i;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
		vis[x]=0;
	}
	return Dis[T]<oo;
}
void Update()
{
	int Min=oo;
	for (int i=pre[T];~i;i=pre[E[i].x]) Min=min(Min,E[i].f);
	for (int i=pre[T];~i;i=pre[E[i].x]) E[i].f-=Min,E[i^1].f+=Min;
	Cost+=Min*Dis[T];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d%d%d%d%d",&n,&a,&b,&f,&fa,&fb);
	S=0,T=n+n+1;
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		Add_Edge(S,i,oo,f);
		Add_Edge(i,T,x,0);
		Add_Edge(S,i+n,x,0);
		if (i+1<=n) Add_Edge(i+n,i+1+n,oo,0);
		if (i+a+1<=n) Add_Edge(i+n,i+a+1,oo,fa);
		if (i+b+1<=n) Add_Edge(i+n,i+b+1,oo,fb);
	}
	while (SPFA()) Update();
	printf("%d\n",Cost);
}
Problem1222
#include<cstdio>
#include<algorithm>
using namespace std;

const int N=6000+19,oo=(1<<30)-1;
int F[N*5],n,a,b,c,S,x,Ans=oo;

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++)
	{
		scanf("%d%d%d",&a,&b,&c),S+=max(a,max(b,c));
		for (int j=S;j>=0;j--)
		{
			if (b) F[j]+=b;else F[j]=oo;
			if (a&&j>=a&&F[j-a]<F[j]) F[j]=F[j-a];
			if (c&&j>=c&&F[j-c]+c<F[j]) F[j]=F[j-c]+c;
		}
	}
	for (int i=0;i<=S;i++) Ans=min(Ans,max(i,F[i]));
	printf("%d\n",Ans);
}
Problem1224
#include<cstdio>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=50+19;
typedef double Db;
Db Sum[N],Tar,Eps=1e-12;
int n,m,X,Y,Ans;

void DFS(int t,int S,Db cur)
{
	if (cur+Sum[t+(n-S)-1]-Sum[t-1]<Tar-Eps) return;
	if (cur+Sum[m]-Sum[m-(n-S)]>Tar+Eps) return;
	if (S==n) {Ans++;return;}
	if (t==m+1) return;
	if (S+(m-t+1)<n) return;
	DFS(t+1,S+1,cur+1.0/t);
	DFS(t+1,S,cur);
}

int main()
{
	scanf("%d%d%d%d",&n,&m,&X,&Y);Tar=1.0*X/Y;
	for (int i=1;i<=m;i++) Sum[i]=Sum[i-1]+1.0/i;
	DFS(1,0,0);
	printf("%d\n",Ans);
}
Problem1225
#include<cstdio>
#include<cstring>
using namespace std;

const int MaxL=16000/6+19,Base=1000000,Top=2147483647/53;
int P[16]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53},A[16],n;
struct Bigint
{
	int Len;
	long long s[MaxL];
	void clear() {while (Len>1&&!s[Len-1]) Len--;}
	bool operator < (const Bigint& B) const
	{
		if (Len!=B.Len) return Len<B.Len;
		for (int i=Len-1;i>=0;i--) if (s[i]!=B.s[i]) return s[i]<B.s[i];
		return 0;
	}
	void operator *= (const int& B)
	{
		s[Len++]=0;s[Len++]=0;
		for (int i=0;i<Len;i++) s[i]*=B;
		for (int i=0;i<Len;i++) s[i+1]+=s[i]/Base,s[i]%=Base;
		clear();
	}
	void print()
	{
		printf("%d",s[Len-1]);
		for (int i=Len-2;i>=0;i--) printf("%06d",s[i]);puts("");
	}
} tmp,Ans;int ttmp;

void Check(int x)
{
	tmp.Len=1,tmp.s[0]=1;ttmp=1;
	for (int i=0;i<x;i++)
		for (int j=0;j<A[i];j++)
			if (ttmp<Top/P[i]) ttmp*=P[i];else tmp*=ttmp,ttmp=P[i];
	tmp*=ttmp;
	if (tmp<Ans) Ans=tmp;
}
void DFS(int x,int n,int top)
{
	if (n==1) {Check(x);return;}
	for (A[x]=1;A[x]<=top;A[x]++)
		if (n%(A[x]+1)==0) DFS(x+1,n/(A[x]+1),A[x]);
}

int main()
{
	scanf("%d",&n);Ans.Len=MaxL;
	DFS(0,n,n-1);
	Ans.print();
}
Problem1226
#include<cstdio>
#include<cstring>
using namespace std;

const int N=1000+19,oo=(1<<30)-1;
int f[N][1<<8][16],t[N],b[N];
int T,n,Ans;

void Update(int &a,int b) {a=(a<b?a:b);}
int Cost(int a,int b) {return !a?0:(t[a]|t[b])-(t[a]&t[b]);}

int main()
{
	scanf("%d",&T);
	while (T--)
	{
		scanf("%d",&n);
		memset(f,64,sizeof(f));
		f[1][0][-1+8]=0;Ans=oo;
		for (int i=1;i<=n;i++) scanf("%d%d",&t[i],&b[i]);
		for (int i=1;i<=n;i++)
			for (int j=0;j<(1<<8);j++)
				for (int k=-8;k<=7;k++)
					if (f[i][j][k+8]<oo)
						if (j&1) Update(f[i+1][j>>1][k-1+8],f[i][j][k+8]);else
							for (int l=0,R=oo;i+l<=R;l++)
								if (!(j>>l&1))
									Update(f[i][j|(1<<l)][l+8],f[i][j][k+8]+Cost(i+k,i+l)),
									Update(R,i+l+b[i+l]);
		for (int i=-8;i<=7;i++) Update(Ans,f[n+1][0][i+8]);
		printf("%d\n",Ans);
	}
}
Problem1227
#include<cstdio>
#include<algorithm>

#define Mid (L+R>>1)
using namespace std;

const int W=100000+19;
typedef long long LL;
const LL Mod=2147483648LL;
struct node
{
	int x,y;
	bool operator < (const node& B) const {return x<B.x||x==B.x&&y<B.y;}
} A[W];
int n,m,w,k,Ans,L,R,t;
int C[W][11],F[W],y[W],Up[W],Dn[W];

void Update(int x,int v) {for (;x<=t;x+=x&-x) F[x]=(1LL*F[x]+v+Mod)%Mod;}
int Query(int x) {int Ans=0;for (;x;x-=x&-x) Ans=(1LL*Ans+F[x])%Mod;return Ans;}
int Find(int x)
{
	int L=1,R=t,res;
	while (L<=R) if (y[Mid]>=x) res=Mid,R=Mid-1;else L=Mid+1;
	return res;
}

int main()
{
	scanf("%d%d%d",&n,&m,&w);
	for (int i=1;i<=w;i++) scanf("%d%d",&A[i].x,&A[i].y),y[i]=A[i].y;
	scanf("%d",&k);
	for (int i=0;i<=w;i++)
	{
		C[i][0]=1;
		for (int j=1;j<=i&&j<=k;j++) C[i][j]=(1LL*C[i-1][j]+C[i-1][j-1])%Mod;
	}
	sort(y+1,y+w+1);t=unique(y+1,y+w+1)-y-1;
	for (int i=1;i<=w;i++) Dn[A[i].y=Find(A[i].y)]++;
	sort(A+1,A+w+1);
	for (int i=1;i<=w;i++)
	{
		if (i!=1&&A[i].x==A[i-1].x)
		{
			if (A[i-1].y+1<A[i].y)
				Ans=(Ans+1LL*(Query(A[i].y-1)-Query(A[i-1].y)+Mod)*C[L][k]%Mod*C[R][k]%Mod)%Mod;
		} else {L=R=0;for (int j=i;j<=w&&A[j].x==A[i].x;j++) R++;}
		L++,R--;
		int pre=1LL*C[Up[A[i].y]][k]*C[Dn[A[i].y]][k]%Mod;
		Up[A[i].y]++,Dn[A[i].y]--;
		Update(A[i].y,1LL*C[Up[A[i].y]][k]*C[Dn[A[i].y]][k]%Mod-pre);
	}
	printf("%d\n",Ans);
}
Problem1227
#include<cstdio>
#include<cctype>
#include<algorithm>

#define Mid (L+R>>1)
using namespace std;

const int W=100000+19;
typedef long long LL;
const LL Mod=2147483648LL;
struct node
{
	int x,y;
	bool operator < (const node& B) const {return x<B.x||x==B.x&&y<B.y;}
} A[W];
int n,m,w,k,Ans,L,R,t;
int C[W][11],F[W],y[W],Up[W],Dn[W];

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Update(int x,int v) {for (;x<=t;x+=x&-x) F[x]=(1LL*F[x]+v+Mod)%Mod;}
int Query(int x) {int Ans=0;for (;x;x-=x&-x) Ans=(1LL*Ans+F[x])%Mod;return Ans;}
int Find(int x)
{
	int L=1,R=t,res;
	while (L<=R) if (y[Mid]>=x) res=Mid,R=Mid-1;else L=Mid+1;
	return res;
}

int main()
{
	read(n),read(m),read(w);
	for (int i=1;i<=w;i++) read(A[i].x),read(A[i].y),y[i]=A[i].y;
	read(k);
	for (int i=0;i<=w;i++)
	{
		C[i][0]=1;
		for (int j=1;j<=i&&j<=k;j++) C[i][j]=(1LL*C[i-1][j]+C[i-1][j-1])%Mod;
	}
	sort(y+1,y+w+1);t=unique(y+1,y+w+1)-y-1;
	for (int i=1;i<=w;i++) Dn[A[i].y=Find(A[i].y)]++;
	sort(A+1,A+w+1);
	for (int i=1;i<=w;i++)
	{
		if (i!=1&&A[i].x==A[i-1].x)
		{
			if (A[i-1].y+1<A[i].y)
				Ans=(Ans+1LL*(Query(A[i].y-1)-Query(A[i-1].y)+Mod)*C[L][k]%Mod*C[R][k]%Mod)%Mod;
		} else {L=R=0;for (int j=i;j<=w&&A[j].x==A[i].x;j++) R++;}
		L++,R--;
		int pre=1LL*C[Up[A[i].y]][k]*C[Dn[A[i].y]][k]%Mod;
		Up[A[i].y]++,Dn[A[i].y]--;
		Update(A[i].y,1LL*C[Up[A[i].y]][k]*C[Dn[A[i].y]][k]%Mod-pre);
	}
	printf("%d\n",Ans);
}
Problem1228
#include<cstdio>
using namespace std;

int T,x,y,n,Ans;

int sg(int x,int y)
{
	int a=31;
	for (int i=31;i>=1;i--)
	{
		int t=1<<i-1;
		if (x<=t&&y<=t) a=i-1;
		if (x>t) x-=t;
		if (y>t) y-=t;
	}
	return a;
}

int main()
{
	scanf("%d",&T);
	while (T--)
	{
		scanf("%d",&n);
		for (Ans=0,n>>=1;n--;) scanf("%d%d",&x,&y),Ans^=sg(x,y);
		puts(Ans?"YES":"NO");
	}
}
Problem1230
#include<cstdio>
#include<cctype>

#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int Maxn=100000*4+19;
int sum[Maxn],rev[Maxn];
int n,Q,opt,Ql,Qr;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Push_down(int x,int L,int R)
{
	if (!rev[x]) return;rev[x]=0;
	rev[Lsn]^=1,rev[Rsn]^=1;
	sum[Lsn]=(Mid-L+1)-sum[Lsn];
	sum[Rsn]=(R-Mid)-sum[Rsn];
}
void Update(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {rev[x]^=1;sum[x]=(R-L+1)-sum[x];return;}
	Push_down(x,L,R);
	if (Ql<=Mid) Update(Lsn,L,Mid);
	if (Qr>Mid) Update(Rsn,Mid+1,R);
	sum[x]=sum[Lsn]+sum[Rsn];
}
int Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return sum[x];
	Push_down(x,L,R);
	int tmp=0;
	if (Ql<=Mid) tmp+=Query(Lsn,L,Mid);
	if (Qr>Mid) tmp+=Query(Rsn,Mid+1,R);
	return tmp;
}

int main()
{
	read(n),read(Q);
	while (Q--)
	{
		read(opt),read(Ql),read(Qr);
		if (opt==0) Update(1,1,n);else printf("%d\n",Query(1,1,n));
	}
}
Problem1231
#include<cstdio>
#include<algorithm>
using namespace std;

long long F[1<<16][17],Ans;
int n,K,S[17];

int main()
{
	scanf("%d%d",&n,&K);
	for (int i=0;i<n;i++) scanf("%d",&S[i]);
	for (int i=0;i<n;i++) F[1<<i][i]=1;
	for (int i=0;i<(1<<n);i++)
		for (int j=0;j<n;j++)
			if (F[i][j])
				for (int k=0;k<n;k++)
					if (!(i>>k&1)&&abs(S[k]-S[j])>K) F[i|(1<<k)][k]+=F[i][j];
	for (int i=0;i<n;i++) Ans+=F[(1<<n)-1][i];
	printf("%lld\n",Ans);
}
Problem1232
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=10000+19;
struct Edge 
{
	int a,b,c;
	bool operator < (const Edge& B) const {return c<B.c;}
} E[Maxn*10];
int n,p,Ans=(1<<30),A[Maxn],Fa[Maxn];

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int getf(int x) {return Fa[x]==x?x:Fa[x]=getf(Fa[x]);}

int main()
{
	read(n),read(p);
	for (int i=1;i<=n;i++) read(A[i]),Ans=min(Ans,A[i]),Fa[i]=i;
	for (int i=1;i<=p;i++)
		read(E[i].a),read(E[i].b),read(E[i].c),
		E[i].c=E[i].c*2+A[E[i].a]+A[E[i].b];
	sort(E+1,E+p+1);
	for (int i=1;i<=p;i++)
	{
		int fx=getf(E[i].a),fy=getf(E[i].b);
		if (fx!=fy) Fa[fx]=fy,Ans+=E[i].c;
	}
	printf("%d\n",Ans);
}
Problem1233
#include<cstdio>
using namespace std;

const int N=100000+19;
int n,x,f=1,w=1,S[N],F[N],G[N],Q[N];

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&x),S[i]=S[i-1]+x;
	Q[1]=n+1;
	for (int i=n;i>=1;i--)
	{
		while (f>w&&S[Q[w+1]-1]-S[i-1]>=F[Q[w+1]]) w++;
		F[i]=S[Q[w]-1]-S[i-1];
		G[i]=G[Q[w]]+1;
		while (f>w&&S[Q[f]-1]-F[Q[f]]<=S[i-1]-F[i]) f--;
		Q[++f]=i;
	}
	printf("%d\n",G[1]);
}
Problem1237
#include<cstdio>
#include<algorithm>
using namespace std;

const int N=1e5+19;
const long long oo=(1LL<<60)/100000LL;
int n,A[N],B[N];
long long F[N];

int Cmp(int A,int B) {return A==B?oo:abs(A-B);}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d%d",&A[i],&B[i]);
	sort(A+1,A+n+1);
	sort(B+1,B+n+1);
	for (int i=1;i<=n;i++)
	{
		F[i]=F[i-1]+Cmp(A[i],B[i]);
		if (i>1) F[i]=min(F[i],F[i-2]+Cmp(A[i-1],B[i])+Cmp(A[i],B[i-1]));
		if (i>2)
			F[i]=min(F[i],F[i-3]+Cmp(A[i-2],B[i-1])+Cmp(A[i-1],B[i])+Cmp(A[i],B[i-2])),
			F[i]=min(F[i],F[i-3]+Cmp(A[i-2],B[i])+Cmp(A[i-1],B[i-2])+Cmp(A[i],B[i-1]));
	}
	if (F[n]>=oo) puts("-1");else printf("%lld\n",F[n]);
}
Problem1249
#include<set>
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define CH isdigit(c=getchar())
#define Be begin()
#define Ed end()
#define Update S[f].erase(x),Ans+=(t>0?t:-t)
using namespace std;

int IN()
{
	int c,x,f;
	while (!CH&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (CH) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=100000+19;
typedef long long LL;
struct Point
{
	int x,y;
	Point() {}
	Point(int _x,int _y) {x=_x,y=_y;}
	void In() {x=IN(),y=IN();}
	bool operator < (const Point& B) const {return x<B.x||x==B.x&&y<B.y;}
} A,B,C;
typedef Point Vector;
set<Point> S[2];	//0:U,1:D
typedef set<Point>::iterator It;
LL Ans,t;
int n;

Vector operator - (Point A,Point B) {return Vector(A.x-B.x,A.y-B.y);}
LL Cross(Vector A,Vector B) {return 1LL*A.x*B.y-1LL*A.y*B.x;}
LL Cross(Point A,Point B,Point C) {return Cross(B-A,C-B);}
int cmp(LL x) {return x>0?1:x==0?0:-1;}

void Insert(int f,Point A)
{
	It D=S[f].lower_bound(A),x,y,L,R;int k=(!f?1:-1);
	if (D==S[f].Be) for (x=D,y=++D;  y!=S[f].Ed&&cmp(t=Cross(A,*x,*y))==k;x=y++) Update;else
	if (D==S[f].Ed) for (x=--D,y=--D;x!=S[f].Be&&cmp(t=Cross(*y,*x,A))==k;x=y--) Update;
		else
		{
			R=D,L=--D;
			if (cmp(t=Cross(A,*R,*L))==k) return;Ans+=(t>0?t:-t);
			for (x=L,y=--L;x!=S[f].Be&&cmp(t=Cross(*y,*x,A))==k;x=y--) Update;
			for (x=R,y=++R;y!=S[f].Ed&&cmp(t=Cross(A,*x,*y))==k;x=y++) Update;
		}
	S[f].insert(A);
}

int main()
{
	A.In(),B.In(),C.In();
	if (C<B) swap(B,C);
	if (B<A) swap(A,B);
	if (C<B) swap(B,C);
	For(i,0,2) S[i].insert(A),S[i].insert(C);
	S[(t=Cross(A,B,C))>0].insert(B),Ans=(t>0?t:-t);
	for (n=IN();n--;) {A.In();For(i,0,2) Insert(i,A);printf("%lld\n",Ans);}
}
Problem1249
#include<set>
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define CH isdigit(c=getchar())
#define Be begin()
#define Ed end()
#define Update S[f].erase(x),Ans+=(t>0?t:-t)
using namespace std;

int IN()
{
	int c,x,f;
	while (!CH&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (CH) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=100000+19;
typedef long long LL;
struct Point
{
	int x,y;
	Point() {}
	Point(int _x,int _y) {x=_x,y=_y;}
	void In() {x=IN(),y=IN();}
	bool operator < (const Point& B) const {return x<B.x||x==B.x&&y<B.y;}
} A,B,C;
typedef Point Vector;
set<Point> S[2];	//0:U,1:D
typedef set<Point>::iterator It;
LL Ans,t;
int n;

Vector operator - (Point A,Point B) {return Vector(A.x-B.x,A.y-B.y);}
inline LL Cross(Vector A,Vector B) {return 1LL*A.x*B.y-1LL*A.y*B.x;}
inline LL Cross(Point A,Point B,Point C) {return Cross(B-A,C-B);}
inline int cmp(LL x) {return x>0?1:x==0?0:-1;}

void Insert(int f,Point A)
{
	It D=S[f].lower_bound(A),x,y,L,R;int k=(!f?1:-1);
	if (D==S[f].Be) for (x=D,y=++D;  y!=S[f].Ed&&cmp(t=Cross(A,*x,*y))==k;x=y++) Update;else
	if (D==S[f].Ed) for (x=--D,y=--D;x!=S[f].Be&&cmp(t=Cross(*y,*x,A))==k;x=y--) Update;
		else
		{
			R=D,L=--D;
			if (cmp(t=Cross(A,*R,*L))==k) return;Ans+=(t>0?t:-t);
			for (x=L,y=--L;x!=S[f].Be&&cmp(t=Cross(*y,*x,A))==k;x=y--) Update;
			for (x=R,y=++R;y!=S[f].Ed&&cmp(t=Cross(A,*x,*y))==k;x=y++) Update;
		}
	S[f].insert(A);
}

int main()
{
	A.In(),B.In(),C.In();
	if (C<B) swap(B,C);
	if (B<A) swap(A,B);
	if (C<B) swap(B,C);
	For(i,0,2) S[i].insert(A),S[i].insert(C);
	S[(t=Cross(A,B,C))>0].insert(B),Ans=(t>0?t:-t);
	for (n=IN();n--;) {A.In();For(i,0,2) Insert(i,A);printf("%lld\n",Ans);}
}
Problem1251
#include<cstdio>
#include<cctype>
#include<algorithm>

#define Mid (L+R>>1)
#define Fir first
#define Sec second
using namespace std;

const int Maxn=50000+19,oo=(1<<30)-1;
struct Treap;typedef Treap* rt;rt null;
struct Treap
{
	rt L,R;
	int rev,Add,key,Max,fix,sz;
	void Setrev() {if (this!=null) swap(L,R);}
	void Setadd(int v) {if (this!=null) key+=v,Max+=v;}
	void Down()
	{
		if (this==null) return;
		if (rev) L->rev^=1,R->rev^=1,L->Setrev(),R->Setrev(),rev=0;
		if (Add) L->Add+=Add,R->Add+=Add,L->Setadd(Add),R->Setadd(Add),Add=0;
	}
	void Update()
	{
		if (this==null) return;
		sz=L->sz+R->sz+1;
		Max=max(key,max(L->Max,R->Max));
	}
} treap[Maxn];rt Rt;
typedef pair<rt,rt> Drt;
int tcnt,n,Q,k,Ql,Qr,v;

int c,f;
void read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}

rt Merge(rt A,rt B)
{
	if (A==null) return B;if (B==null) return A;
	A->Down(),B->Down();
	if (A->fix<B->fix) return A->R=Merge(A->R,B),A->Update(),A;
		else return B->L=Merge(A,B->L),B->Update(),B;
}
Drt Split(rt A,int k)
{
	if (A==null) return Drt(null,null);
	A->Down();Drt x;
	if (A->L->sz>=k) x=Split(A->L,k),A->L=x.Sec,x.Sec=A,A->Update();
		else x=Split(A->R,k-A->L->sz-1),A->R=x.Fir,x.Fir=A,A->Update();
	return x;
}
int Query(int L,int R)
{
	Drt A=Split(Rt,L-1),B=Split(A.Sec,R-L+1);
	int Ans=B.Fir->Max;
	Rt=Merge(A.Fir,Merge(B.Fir,B.Sec));
	return Ans;
}
void Setit(int L,int R,int v)
{
	Drt A=Split(Rt,L-1),B=Split(A.Sec,R-L+1);
	if (v) B.Fir->Add+=v,B.Fir->Setadd(v);
		else B.Fir->rev^=1,B.Fir->Setrev();
	Rt=Merge(A.Fir,Merge(B.Fir,B.Sec));
}
void Build(rt &x,int L,int R,int Fr)
{
	if (L>R) return;
	if (x==null)
	{
		x=treap+(++tcnt);
		x->L=x->R=null,x->key=x->Max=x->rev=x->Add=0;
		x->fix=rand()+Fr+1,x->sz=1;
	}
	Build(x->L,L,Mid-1,x->fix);
	Build(x->R,Mid+1,R,x->fix);x->Update();
}

int main()
{
	read(n),read(Q);
	Rt=null=treap;null->L=null->R=null,null->sz=0,null->Max=-oo;
	Build(Rt,1,n,0);
	while (Q--)
	{
		read(k),read(Ql),read(Qr);
		if (k==1) {read(v);if (v) Setit(Ql,Qr,v);}
		if (k==2) Setit(Ql,Qr,0);
		if (k==3) printf("%d\n",Query(Ql,Qr));
	}
}
Problem1257
#include<iostream>
using namespace std;

typedef long long LL;
int main()
{
	LL n,k,Ans=0;cin>>n>>k;
	for (LL i=1;i<=n;i++)
	{
		LL A=k/i,L=k/(A+1)+1,R=A?k/A:n;
		if (R>n) R=n;
		Ans+=LL(k)*(R-L+1)-LL(A)*(L+R)*(R-L+1)/2;
		i=R;
	}
	cout<<Ans<<endl;
	//for (;;);
	return 0;
}
Problem1258
#include<cstdio>
#include<string>
#include<iostream>
#include<algorithm>
using namespace std;

string s,Ans[5];
int cnt;

void calc1(string s)
{
	int Len=s.length();
	if (s[Len-1]=='2'||s[Len-1]=='3') 
	{
		if (Len==2) return;
		if (s[Len-2]=='2'||s[Len-2]=='3') calc1(s.substr(0,Len-2)+s[Len-1]);
		if (s[Len-2]=='1') Ans[cnt++]=s.substr(0,Len-2)+'4';
	}
	if (s[Len-1]=='1') Ans[cnt++]=s.substr(0,Len-1)+'4';
	if (s[Len-1]=='4') Ans[cnt++]=s.substr(0,Len-1)+'1';
}
void calc2(string s)
{
	int Len=s.length();
	if (s[Len-1]=='1'||s[Len-1]=='3') 
	{
		if (Len==2) return;
		if (s[Len-2]=='1'||s[Len-2]=='3') calc2(s.substr(0,Len-2)+s[Len-1]);
		if (s[Len-2]=='2') Ans[cnt++]=s.substr(0,Len-2)+'4';
	}
	if (s[Len-1]=='2') Ans[cnt++]=s.substr(0,Len-1)+'4';
	if (s[Len-1]=='4') Ans[cnt++]=s.substr(0,Len-1)+'2';
}
void calc3(string s)
{
	int Len=s.length();
	if (s[Len-1]=='1'||s[Len-1]=='2') 
	{
		if (Len==2) return;
		if (s[Len-2]=='1'||s[Len-2]=='2') calc3(s.substr(0,Len-2)+s[Len-1]);
		if (s[Len-2]=='3') Ans[cnt++]=s.substr(0,Len-2)+'4';
	}
	if (s[Len-1]=='3') Ans[cnt++]=s.substr(0,Len-1)+'4';
	if (s[Len-1]=='4') Ans[cnt++]=s.substr(0,Len-1)+'3';
}

int main()
{
	cin>>s;
	calc1(s);
	calc2(s);
	calc3(s);
	sort(Ans,Ans+cnt);
	for (int i=0;i<cnt;i++) printf("%s\n",Ans[i].c_str());
}
Problem1260
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;

const int oo=1<<29;
int F[60][60],Len;
char s[60];

int Solve(int L,int R)
{
	if (F[L][R]) return F[L][R];
	if (L==R) return 1;
	F[L][R]=oo;
	for (int i=L;i<R;i++) F[L][R]=min(F[L][R],Solve(L,i)+Solve(i+1,R));
	return F[L][R]-=(s[L]==s[R]);
}

int main()
{
	scanf("%s",s);
	printf("%d\n",Solve(0,strlen(s)-1));
	return 0;
}
Problem1263
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int L=5000+19;
struct Bigint
{
	int s[L],Len;
	void clear() {while (Len>1&&!s[Len-1]) Len--;}
	void operator *= (int x)
	{
		for (int i=0;i<Len;i++) s[i]*=x;
		for (int i=0;i<Len;i++) s[i+1]+=s[i]/10,s[i]%=10;
		Len++;clear();
	}
	void print()
	{
		printf("%d\n",Len);
		for (int i=Len-1;i>=max(Len-100,0);i--) printf("%d",s[i]);puts("");
	}
} Ans;
int n;

int main()
{
	memset(Ans.s,0,sizeof(Ans.s));
	Ans.Len=Ans.s[0]=1;
	scanf("%d",&n);
	if (n%3==0) for (int i=0;i<n/3;i++) Ans*=3;
	if (n%3==1) {for (int i=0;i<n/3-1;i++) Ans*=3;Ans*=4;}
	if (n%3==2) {for (int i=0;i<n/3;i++) Ans*=3;Ans*=2;}
	Ans.print();
}
Problem1264
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int N=20000+19;
int A[N*5],C[N*5],D[N][6];
int n,Ans,x;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int Query(int x) {int Ans=0;for (;x;x-=x&-x) Ans=max(Ans,C[x]);return Ans;}
void Update(int x,int v) {for (;x<=5*n;x+=x&-x) C[x]=max(C[x],v);}

int main()
{
	read(n);
	for (int i=1;i<=5*n;i++) read(A[i]);
	for (int i=1;i<=5*n;i++) read(x),D[x][++D[x][0]]=i;
	for (int i=1;i<=5*n;i++)
		for (int j=5;j;j--)
		{
			int x=D[A[i]][j],tmp=Query(x-1)+1;
			Ans=max(Ans,tmp);Update(x,tmp);
		}
	printf("%d\n",Ans);
}
Problem1266
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=500+19,M=124750+19,oo=(1<<30)-1;
struct Edge {int x,y,z,f,nxt;} E[M*2];
typedef int one[Maxn];
int n,m,x,y,z,f,w,cnt,pcnt,Flow;
one Dis[2],Last,vis,D,Q;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Add_Edge(int x,int y,int z,int f)
{
	E[cnt]=(Edge){x,y,z,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){y,x,z,f,Last[y]};Last[y]=cnt++;
}
void Add_Flow_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){x,y,0,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){y,x,0,0,Last[y]};Last[y]=cnt++;
}
void SPFA(int s,int p)
{
	memset(Dis[p],60,sizeof(Dis[p]));
	f=1;w=0;Dis[p][s]=0;Q[1]=s;
	int ff=1,ww=0;
	while (ff>ww)
	{
		int x=Q[w=(w+1)%Maxn];ww++;vis[x]=0;
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (Dis[p][x]+E[i].z<Dis[p][E[i].y]) 
			{
				Dis[p][E[i].y]=Dis[p][x]+E[i].z;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[f=(f+1)%Maxn]=E[i].y,ff++;
			}
	}
}
int BFS()
{
	memset(D,-1,sizeof(D));D[1]=0;
	f=1;w=0;Q[1]=1;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&D[E[i].y]==-1) D[E[i].y]=D[x]+1,Q[++f]=E[i].y;
	}
	return D[n]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==n||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&D[E[i].y]==D[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			res+=tmp;E[i].f-=tmp;E[i^1].f+=tmp;Flow-=tmp;
		}
	if (!res) D[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n);read(m);
	for (int i=0;i<m;i++)
	{
		read(x),read(y),read(z),read(f);
		Add_Edge(x,y,z,f);
	}
	SPFA(1,0);
	SPFA(n,1);
	printf("%d\n",Dis[0][n]);
	memset(Last,-1,sizeof(Last));
	int pcnt=cnt;cnt=0;
	for (int i=0;i<pcnt;i++)
		if (Dis[0][E[i].x]+E[i].z+Dis[1][E[i].y]==Dis[0][n]) 
			Add_Flow_Edge(E[i].x,E[i].y,E[i].f);
	while (BFS()) Flow+=Dinic(1,oo);
	printf("%d\n",Flow);
}
Problem1267
#include<cstdio>
#include<cctype>
#include<queue>
#include<cstring>
#include<algorithm>
 
#define For(x) for (int i=Last[x];~i;i=E[i].nxt) if (!vis[E[i].y])
using namespace std;
 
const int N=50000+19,oo=(1<<30)-1;
struct Edge {int y,z,nxt;} E[N*2];
typedef int NlogN[N*40];
int vis[N],Last[N],S[N],Log[N],ID[N*40][17];
int n,m,cnt,tot,Fcen,Cen,Min,cL,cR,x,y,z;
NlogN A,L,R;
struct node
{
	int i,L,R,t,v;
	bool operator < (const node& B) const {return v<B.v;}
};priority_queue<node> Q;
 
void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}
 
void Findcen(int x,int Fa,int n)
{
	S[x]=1;int res=0;
	For(x) if (E[i].y!=Fa) Findcen(E[i].y,x,n),S[x]+=S[E[i].y],res=max(res,S[E[i].y]);
	res=max(res,n-S[x]);
	if (res<Min) Min=res,Cen=x,Fcen=Fa;
}
void DFS(int x,int Fa,int t)
{
	A[++tot]=t,L[tot]=cL,R[tot]=cR;
	For(x) if (E[i].y!=Fa) DFS(E[i].y,x,t+E[i].z);
}
void Solve(int x,int n)
{
	Min=oo;Findcen(x,-1,n);vis[x=Cen]=1;
	if (~Fcen) S[Fcen]=n-S[x];
	A[cL=cR=++tot]=0;
	For(x) DFS(E[i].y,-1,E[i].z),cR=tot;
	For(x) Solve(E[i].y,S[E[i].y]);
}
 
void Push(int i,int L,int R)
{
	int k=Log[R-L+1];node x=(node){i,L,R,0,0};
	if (A[ID[L][k]]>A[ID[R-(1<<k)+1][k]])
		x.v=A[x.t=ID[L][k]]+A[i];else x.v=A[x.t=ID[R-(1<<k)+1][k]]+A[i];
	Q.push(x);
}
 
int main()
{
	memset(Last,-1,sizeof(Last));
	read(n),read(m);
	for (int i=1;i<n;i++) read(x),read(y),read(z),Link(x,y,z);
	Solve(1,n);
	for (int i=1;i<=tot;i++) ID[i][0]=i;
	for (int i=2;i<=n;i++) Log[i]=Log[i>>1]+1;
	for (int x=1;x<17;x++)
		for (int i=1;i+(1<<x)-1<=tot;i++)
			if (A[ID[i][x-1]]>A[ID[i+(1<<x-1)][x-1]])
				ID[i][x]=ID[i][x-1];else ID[i][x]=ID[i+(1<<x-1)][x-1];
	for (int i=1;i<=tot;i++) if (L[i]) Push(i,L[i],R[i]);
	while (m--)
	{
		node x=Q.top();Q.pop();
		printf("%d\n",x.v);
		if (x.L<=x.t-1) Push(x.i,x.L,x.t-1);
		if (x.t+1<=x.R) Push(x.i,x.t+1,x.R);
	}
}
Problem1269
#include<cstdio>
#include<cctype>
#include<algorithm>
#define Fir first
#define Sec second
using namespace std;
 
const int Maxn=5000000+19;
struct Treap;typedef Treap* rt;
struct Treap
{
    rt L,R;
    int fix,ch,rev,size;
    Treap():fix(rand()),ch(),size(1),rev(0),L(0),R(0) {}
    int sz() {return this?size:0;}
    void Down() 
    {
        if (!rev) return;swap(L,R);
        if (L) L->rev^=1;if (R) R->rev^=1;rev=0;
    }
    void Update() {size=L->sz()+R->sz()+1;}
} treap[Maxn];int tcnt;rt RT;
typedef pair<rt,rt> Drt;
 
rt Merge(rt A,rt B)
{
    if (!A) return B;if (!B) return A;
    A->Down();B->Down();
    if (A->fix<B->fix) return A->R=Merge(A->R,B),A->Update(),A;
        else return B->L=Merge(A,B->L),B->Update(),B;
}
Drt Split(rt A,int k)
{
    if (!A) return Drt();
    Drt x;A->Down();
    if (A->L->sz()>=k) x=Split(A->L,k),A->L=x.Sec,x.Sec=A,A->Update();
        else x=Split(A->R,k-A->L->sz()-1),A->R=x.Fir,x.Fir=A,A->Update();
    return x;
}
void Insert(rt A,int k)
{
    Drt x=Split(RT,k);
    RT=Merge(Merge(x.Fir,A),x.Sec);
}
void Delete(int k,int L)
{
    Drt x=Split(RT,k),y=Split(x.Sec,L);
    RT=Merge(x.Fir,y.Sec);
}
void Reverse(int k,int L)
{
    Drt x=Split(RT,k),y=Split(x.Sec,L);
    y.Fir->rev^=1;
    RT=Merge(Merge(x.Fir,y.Fir),y.Sec);
}
void Print(int k)
{
    Drt x=Split(RT,k),y=Split(x.Sec,1);
    putchar(y.Fir->ch);
    RT=Merge(Merge(x.Fir,y.Fir),y.Sec);
}
 
int c;
void read(int &x) 
{
    while (!isdigit(c=getchar()));x=c-'0';
    while (isdigit(c=getchar())) x=x*10+c-'0';
}
 
int Q,k,at;
char s[10];
 
int main()
{
    read(Q);
    while (Q--)
    {
        scanf("%s",s);
        if (s[0]=='M') read(at);else
        if (s[0]=='I')
        {
            read(k);
            rt A=0;
            for (int i=0;i<k;i++)
            {
                while ((c=getchar())<32||c>126);
                rt B=&treap[++tcnt];B->ch=c;
                A=Merge(A,B);
            }
            Insert(A,at);
        } else
        if (s[0]=='D') read(k),Delete(at,k);else
        if (s[0]=='R') read(k),Reverse(at,k);else
        if (s[0]=='G') Print(at),puts("");else
        if (s[0]=='P') at--;else at++;
    }
}
Problem1270
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int N=2000+19;
int A[N][N],F[N][N];
int n,h,d,x,y,Max,Ans;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	read(n),read(h),read(d);
	for (int i=1;i<=n;i++) {read(x);while (x--) read(y),A[i][y]++;}
	for (int H=h;H>=1;H--)
	{
		if (H+d<=h) for (int i=1;i<=n;i++) Max=max(Max,F[i][H+d]);
		for (int i=1;i<=n;i++) F[i][H]=max(F[i][H],max(Max,F[i][H+1]))+A[i][H];
	}
	for (int i=1;i<=n;i++) Ans=max(Ans,F[i][1]);
	printf("%d\n",Ans);
}
Problem1271
#include<cstdio>
using namespace std;

const int Maxn=200000+19;
typedef long long LL;
int n,t,S[Maxn],E[Maxn],D[Maxn];

LL min(LL A,LL B) {return A<B?A:B;}
LL Bef(LL x)
{
	LL Ans=0;
	for (int i=0;i<n;i++)
		if (S[i]<=x) Ans+=(min(x,E[i])-S[i])/D[i]+1;
	return Ans;
}
void Doit()
{
	LL L=0,R=2147483647;
	while (L<R)
	{
		LL Mid=(L+R)>>1;
		if (Bef(Mid)&1) R=Mid;else L=Mid+1;
	}
	printf("%lld %lld\n",R,Bef(R)-Bef(R-1));
}

int main()
{
	scanf("%d",&t);
	while (t--)
	{
		scanf("%d",&n);
		for (int i=0;i<n;i++) scanf("%d%d%d",&S[i],&E[i],&D[i]);
		if (!(Bef(2147483647)&1)) printf("Poor QIN Teng:(\n");
			else Doit();
	}
}
Problem1273
#include<cstdio>
#include<cctype>
using namespace std;

int S[16][1<<16],n,Q,x,Add;
char s[3];long long Ans;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	read(n),read(Q);
	while (n--)
	{
		read(x);
		for (int i=0;i<16;i++) S[i][x&((1<<i+1)-1)]++;
	}
	for (int i=0;i<16;i++)
		for (int j=1;j<(1<<i+1);j++) S[i][j]+=S[i][j-1];
	while (Q--)
	{
		scanf("%s",s);read(x);
		if (s[0]=='A') (Add+=x)&=65535;else
			if (x<16)
			{
				int t=(1<<x+1)-1;
				int L=((1<<x)-1-(Add&t)+(1<<x+1))&t;
				int R=((1<<x+1)-1-(Add&t)+(1<<x+1))&t;
				Ans+=(L<=R?S[x][R]-S[x][L]:S[x][t]-S[x][L]+S[x][R]);
			}
	}
	printf("%lld\n",Ans);
}
Problem1293
#include<cstdio>
#include<queue>
#include<vector>
using namespace std;

const int Maxn=1000000+19,oo=(1<<30)-1;
struct gift
{
	int k,dis;
	bool operator <(gift b) const {return dis>b.dis;}
};
priority_queue<gift> Q;
int nxt[60+19],Cnt[60+19];
vector<int> A[60+19];

inline int max(int a,int b) {return a>b?a:b;}
inline int min(int a,int b) {return a<b?a:b;}

int main()
{
	int n,k,R=0,dis,cnt,Ans,L=oo;
	scanf("%d%d",&n,&k);
	for (int i=0;i<k;i++)
	{
		scanf("%d",&cnt);
		for (int j=0;j<cnt;j++)
		{
			scanf("%d",&dis);
			A[i].push_back(dis);
		}
		Cnt[i]=A[i].size();
		Q.push((gift){i,A[i][0]});
		R=max(R,A[i][0]);L=min(L,A[i][0]);
	}
	Ans=R-L;
	for (;;)
	{
		int Kind=Q.top().k;
		Q.pop();
		nxt[Kind]++;
		if (nxt[Kind]>=Cnt[Kind]) break;
		int ttmp=A[Kind][nxt[Kind]];
		Q.push((gift){Kind,ttmp});
		R=max(R,ttmp);
		Ans=min(Ans,R-Q.top().dis);
	}
	printf("%d\n",Ans);
	//for (;;);
	return 0;
}
Problem1294
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=11;
struct Point {int x,y;} B[N];
struct node {Point P;int S;} Q[N*N*(1<<9)];
char s[N][N];
int v[N],Dis[N][N][1<<9],n,m,D,Ans,f,w;
int Dx[4]={1,0,-1,0},Dy[4]={0,1,0,-1};

int Calc(int S,int Sx,int Sy,int x)
{
	For(i,1,D+1)
		if (Sy>B[i].y&&(x==B[i].x&&Sx>B[i].x||Sx==B[i].x&&x>B[i].x)) S^=1<<i-1;
	return S;
}
void BFS(int Sx,int Sy)
{
	memset(Dis,-1,sizeof(Dis));
	f=1,w=0,Q[1]=(node){(Point){Sx,Sy},0};
	Dis[Sx][Sy][0]=0;
	while (f>w)
	{
		node A=Q[++w];
		For(i,0,4)
		{
			int x=A.P.x+Dx[i],y=A.P.y+Dy[i],S=Calc(A.S,A.P.x,A.P.y,x);
			if (x>=1&&x<=n&&y>=1&&y<=m&&s[x][y]=='0'&&!~Dis[x][y][S])
				Dis[x][y][S]=Dis[A.P.x][A.P.y][A.S]+1,Q[++f]=(node){(Point){x,y},S};
		}
	}
	For(i,0,1<<D) if (~Dis[Sx][Sy][i])
	{
		int Sum=0;
		For(j,1,D+1) if ((i>>j-1)&1) Sum+=v[j];
		Ans=max(Ans,Sum-Dis[Sx][Sy][i]);
	}
}

int main()
{
	scanf("%d%d%d",&n,&m,&D);
	For(i,1,D+1) scanf("%d",&v[i]);
	For(i,1,n+1) scanf("%s",s[i]+1);
	For(i,1,n+1) For(j,1,m+1)
		if (s[i][j]>='1'&&s[i][j]<='9') B[s[i][j]-'0']=(Point){i,j};
	For(i,1,n+1) For(j,1,m+1) if (s[i][j]=='0') BFS(i,j);
	printf("%d\n",Ans);
}
Problem1295
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;

const int Maxn=32;
int Map[Maxn][Maxn],Dis[Maxn][Maxn],vis[Maxn][Maxn];
int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};
int n,m,t,Ans,f,w;
char s[Maxn];
pair<int,int> Q[Maxn*Maxn*10];

void SPFA(int px,int py)
{
	f=1;w=0;Q[1]=make_pair(px,py);
	memset(Dis,60,sizeof(Dis));
	Dis[px][py]=Map[px][py];
	while (f>w)
	{
		int x=Q[++w].first,y=Q[w].second;
		vis[x][y]=0;
		for (int i=0;i<4;i++)
		{
			int nx=x+dx[i],ny=y+dy[i];
			if (nx<1||nx>n||ny<1||ny>m) continue;
			if (Dis[x][y]+(Map[nx][ny])<Dis[nx][ny])
			{
				Dis[nx][ny]=Dis[x][y]+(Map[nx][ny]);
				if (!vis[nx][ny]) vis[nx][ny]=1,Q[++f]=make_pair(nx,ny);
			}
		}
	}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++) 
			if (Dis[i][j]<=t) Ans=max(Ans,(px-i)*(px-i)+(py-j)*(py-j));
}

int main()
{
	scanf("%d%d%d",&n,&m,&t);
	for (int i=1;i<=n;i++) 
	{
		scanf("%s",s);
		for (int j=1;j<=m;j++) Map[i][j]=s[j-1]-'0';
	}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) SPFA(i,j);
	printf("%.6lf\n",sqrt(Ans));
}
Problem1296
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=2500+19;
int g[Maxn][50+19],f[Maxn][50+19];
int n,m,t,cnt[50+19];
char s[Maxn];

int main()
{
	scanf("%d%d%d",&n,&m,&t);
	for (int x=1;x<=n;x++)
	{
		scanf("%s",s);
		for (int i=1;i<=m;i++) cnt[i]=cnt[i-1]+(s[i-1]=='1');
		memset(g,0,sizeof(g));
		for (int i=1;i<=m;i++)
			for (int j=1;j<=m;j++)
				for (int k=0;k<j;k++) 
				{
					int tmp=cnt[j]-cnt[k];
					g[i][j]=max(g[i][j],g[i-1][k]+max(tmp,j-k-tmp));
				}
		for (int i=1;i<=t;i++)
			for (int j=0,_=min(m,i);j<=_;j++)
				f[i][x]=max(f[i][x],f[i-j][x-1]+g[j][m]);
	}
	printf("%d\n",f[t][n]);
}
Problem1297
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;

const int N=11*10+19,Mod=2009;
struct Matrix
{
	int n,s[N][N];
} A;
int n,T;
char s[12];

Matrix operator * (Matrix A,Matrix B)
{
	Matrix C;C.n=A.n;
	for (int i=0;i<C.n;i++)
		for (int j=0;j<C.n;j++)
		{
			C.s[i][j]=0;
			for (int k=0;k<C.n;k++) (C.s[i][j]+=A.s[i][k]*B.s[k][j])%=Mod;
		}
	return C;
}
Matrix Pow(Matrix A,int b)
{
	Matrix res=A;
	for (--b;b;b>>=1,A=A*A) if (b&1) res=res*A;
	return res;
}

int main()
{
	scanf("%d%d",&n,&T);
	for (int i=0;i<n;i++)
		for (int j=0;j<9;j++) A.s[i*10+j][i*10+j+1]=1;
	A.n=10*n;
	for (int i=0;i<n;i++)
	{
		scanf("%s",s);
		for (int j=0;j<n;j++) if (s[j]!='0') A.s[i*10+s[j]-'0'-1][j*10]=1;
	}
	A=Pow(A,T);
	printf("%d\n",A.s[0][(n-1)*10]);
}
Problem1299
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)

int A[20],n,f;

void DFS(int x,int c,int S)
{
	if (x==n+1) {f|=c&&!S;return;}
	DFS(x+1,c,S),DFS(x+1,1,S^A[x]);
}

int main()
{
	For(i,0,10)
	{
		scanf("%d",&n),f=0;
		For(j,1,n+1) scanf("%d",&A[j]);
		DFS(1,0,0);
		puts(!f?"YES":"NO");
	}
}
Problem1301
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;

const int N=1e5+19,M=N*10;
struct Edge {int y,nxt;} E[M*2];
int Last[N],Fa[N],Ans[N],vis[N];
int n,m,a,b,cnt,tot;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Link(int a,int b)
{
	E[cnt]=(Edge){b,Last[a]};Last[a]=cnt++;
	E[cnt]=(Edge){a,Last[b]};Last[b]=cnt++;
}
int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}
void DFS(int x)
{
	Ans[tot++]=x;vis[x]=-1;Fa[x]=x+1;
	for (int i=Last[x];i!=-1;i=E[i].nxt) if (~vis[E[i].y]) vis[E[i].y]=x;
	for (int i=Getf(1);i<=n;i=Getf(i+1))
		if (vis[i]!=x&&(~vis[i])) {DFS(i);break;}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n),read(m);
	for (int i=0;i<m;i++) read(a),read(b),Link(a,b);
	for (int i=1;i<=n;i++) Fa[i]=i;Fa[n+1]=n+1;
	DFS(1);
	for (int i=0;i<tot;i++) printf("%d\n",Ans[i]);
}
Problem1303
var i,j,k,Cnt,B,m,n,dis,Ans,Tmp:Longint;
    A,C:array[0..100000] of Longint;
    L,R:array[-100000..100000] of Longint;
Begin
Readln(N,B);
For i:=1 to n do Begin read(A[i]);If A[i]=B then Dis:=i;End;
For i:=1 to N do
  If A[i]<B then C[i]:=-1 else
    If A[i]=B then C[i]:=0 else C[i]:=1;
Tmp:=0;
For i:=Dis downto 1 do
  Begin
  Inc(Tmp,C[i]);
  Inc(L[Tmp]);
  End;
Tmp:=0;
For i:=Dis to N do
  Begin
  Inc(Tmp,C[i]);
  Inc(R[Tmp]);
  End;
For i:=-n to n do Inc(Ans,L[i]*R[-i]);
Writeln(Ans);
End.
Problem1303
#include<iostream>
#include<cstdio>
using namespace std;

const int Maxn=100000+19;
int A[Maxn],C[Maxn],L[Maxn*2],R[Maxn*2];
int main()
{
	int n,b,Dis;
	scanf("%d%d",&n,&b);
	for (int i=1;i<=n;i++) 
	{
		scanf("%d",&A[i]);
		if (A[i]==b) Dis=i;
	}
	for (int i=1;i<=n;i++) C[i]=A[i]<b?-1:(A[i]==b?0:1);
	int tmp=Maxn;
	for (int i=Dis;i>=1;i--)
	{
		tmp+=C[i];L[tmp]++;
	}
	tmp=Maxn;
	for (int i=Dis;i<=n;i++)
	{
		tmp+=C[i];R[tmp]++;
	}
	int Ans=0;
	for (int i=Maxn-n;i<=Maxn+n;i++) Ans+=L[i]*R[Maxn*2-i];
	printf("%d\n",Ans);
	//system("pause");
	return 0;
}
Problem1305
#include<cstdio>
using namespace std;

char s[69][69];
inline int min(int a,int b) {return a<b?a:b;}
int main()
{
	int n,k,Ans=(1<<30)-1;
	scanf("%d%d",&n,&k);
	for (int i=0;i<n;i++) scanf("%s",s[i]);
	for (int i=0;i<n;i++)
	{
		int tmp1=0,tmp2=0;
		for (int j=0;j<n;j++) 
		{
			if (s[i][j]=='Y') tmp1++;
			if (s[j][i]=='Y') tmp2++;
		}
		Ans=min(Ans,tmp1);Ans=min(Ans,tmp2);
	}
	printf("%d\n",min(Ans+k,n));
	//for(;;);
	return 0;
}
Problem1306
#include<cstdio>
using namespace std;

int s[]={3,1,0,0};
int A[9],C[9],n,Ans;

void DFS(int x,int y)
{
	if (C[x]>A[x]) return;
	if (C[x]+(n-y+1)*3<A[x]) return;
	if (x==n) {Ans++;return;}
	if (y==n)
	{
		int tmp=A[x]-C[x];
		if (tmp==2) return;
		C[y]+=s[tmp];DFS(x+1,x+2);C[y]-=s[tmp];
		return;
	}
	C[x]+=3;DFS(x,y+1);C[x]-=3;
	C[y]+=3;DFS(x,y+1);C[y]-=3;
	C[x]++;C[y]++;DFS(x,y+1);C[x]--;C[y]--;
}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&A[i]);
	DFS(1,2);
	printf("%d\n",Ans);
}
Problem1324
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=100*100+19,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[N*5];
int Last[N],Q[N],Dis[N],ID[109][109];
int n,m,tot,Ans,x,cnt,f,w,S,T;
int Dx[4]={1,0,-1,0},Dy[4]={0,1,0,-1};

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(E[i].f,Flow));
			res+=tmp,Flow-=tmp,E[i].f-=tmp,E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	For(i,1,n+1) For(j,1,m+1) ID[i][j]=++tot;S=++tot;T=++tot;
	For(i,1,n+1) For(j,1,m+1)
	{
		scanf("%d",&x);Ans+=x;
		if ((i&1)==(j&1))
		{
			Add_Edge(S,ID[i][j],x);
			For(k,0,4)
			{
				int nx=i+Dx[k],ny=j+Dy[k];
				if (nx>=1&&nx<=n&&ny>=1&&ny<=m) Add_Edge(ID[i][j],ID[nx][ny],oo);
			}
		} else Add_Edge(ID[i][j],T,x);
	}
	while (BFS()) Ans-=Dinic(S,oo);
	printf("%d\n",Ans);
}
Problem1334
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<functional>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19;
int f[N],A[N],S,n;

int main()
{
	n=IN();
	For(i,1,n+1) S+=(A[i]=IN());
	sort(A+1,A+n+1,greater<int>());
	f[0]=1;
	For(i,1,n+1) for (int j=S/2;~j;j--) f[j+A[i]]|=f[j];
	for (int i=S;~i;i--) if (f[i]) return printf("%d\n",i),0;
}
Problem1336
#include<cstdio>
#include<cmath>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

typedef double Db;
const int N=100000+19;
struct Point
{
	Db x,y;
	Point() {}
	Point(Db _x,Db _y) {x=_x,y=_y;}
} A[N];

Db Dis(Point A,Point B) {return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));}

struct Circle
{
	Point x;Db r;
	bool In(const Point &A) {return Dis(x,A)<=r;}
} Ans;

Circle Make(Point A,Point B,Point C)
{
	Db a1=2.0*(A.x-B.x),b1=2.0*(A.y-B.y),c1=(A.x*A.x+A.y*A.y)-(B.x*B.x+B.y*B.y);
	Db a2=2.0*(B.x-C.x),b2=2.0*(B.y-C.y),c2=(B.x*B.x+B.y*B.y)-(C.x*C.x+C.y*C.y);
	if (fabs(b1)<1e-8) swap(a1,a2),swap(b1,b2),swap(c1,c2);
	Db x=(c2-c1*b2/b1)/(a2-a1*b2/b1),y=(c1-a1*x)/b1;
	Point res=Point(x,y);
	return (Circle){res,Dis(res,A)};
}

double x,y;
int n;

int main()
{
	scanf("%d",&n);
	For(i,0,n) scanf("%lf%lf",&A[i].x,&A[i].y);
	random_shuffle(A,A+n);
	For(i,0,n)
		if (!Ans.In(A[i]))
		{
			Ans=(Circle){A[i],0};
			For(j,0,i) if (!Ans.In(A[j]))
			{
				Ans=(Circle){Point(0.5*(A[i].x+A[j].x),0.5*(A[i].y+A[j].y)),0.5*Dis(A[i],A[j])};
				For(k,0,j) if (!Ans.In(A[k])) Ans=Make(A[i],A[j],A[k]);
			}
		}
	printf("%.10lf\n",Ans.r);
	printf("%.10lf %.10lf\n",Ans.x.x,Ans.x.y);
}
Problem1337
#include<cstdio>
#include<cmath>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

typedef double Db;
const int N=100000+19;
struct Point
{
	Db x,y;
	Point() {}
	Point(Db _x,Db _y) {x=_x,y=_y;}
} A[N];

Db Dis(Point A,Point B) {return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));}

struct Circle
{
	Point x;Db r;
	bool In(const Point &A) {return Dis(x,A)<=r;}
} Ans;

Circle Make(Point A,Point B,Point C)
{
	Db a1=2.0*(A.x-B.x),b1=2.0*(A.y-B.y),c1=(A.x*A.x+A.y*A.y)-(B.x*B.x+B.y*B.y);
	Db a2=2.0*(B.x-C.x),b2=2.0*(B.y-C.y),c2=(B.x*B.x+B.y*B.y)-(C.x*C.x+C.y*C.y);
	if (fabs(b1)<1e-8) swap(a1,a2),swap(b1,b2),swap(c1,c2);
	Db x=(c2-c1*b2/b1)/(a2-a1*b2/b1),y=(c1-a1*x)/b1;
	Point res=Point(x,y);
	return (Circle){res,Dis(res,A)};
}

double x,y;
int n;

int main()
{
	scanf("%d",&n);
	For(i,0,n) scanf("%lf%lf",&A[i].x,&A[i].y);
	random_shuffle(A,A+n);
	For(i,0,n)
		if (!Ans.In(A[i]))
		{
			Ans=(Circle){A[i],0};
			For(j,0,i) if (!Ans.In(A[j]))
			{
				Ans=(Circle){Point(0.5*(A[i].x+A[j].x),0.5*(A[i].y+A[j].y)),0.5*Dis(A[i],A[j])};
				For(k,0,j) if (!Ans.In(A[k])) Ans=Make(A[i],A[j],A[k]);
			}
		}
	printf("%.3lf\n",Ans.r);
}
Problem1342
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=1000000+19;
int Max[2][Maxn],Min[2][Maxn],A[Maxn];
int n,m,c,x,cur=0,pre=1,none=1;

int ch;
void read(int &x)
{
	while (!isdigit(ch=getchar()));x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
}

int main()
{
	read(n),read(m),read(c);
	for (int i=1;i<=n;i++) read(A[i]);
	for (int i=1;i<=n;i++) Max[cur][i]=Min[cur][i]=A[i];
	for (x=1;1<<x<m;x++)
	{
		cur^=1;pre^=1;
		for (int i=1;i+(1<<x)-1<=n;i++)
		{
			Max[cur][i]=max(Max[pre][i],Max[pre][i+(1<<x-1)]);
			Min[cur][i]=min(Min[pre][i],Min[pre][i+(1<<x-1)]);
		}
	} x--;
	for (int i=1;i+m-1<=n;i++)
	{
		int _Max=max(Max[cur][i],Max[cur][i+m-(1<<x)]);
		int _Min=min(Min[cur][i],Min[cur][i+m-(1<<x)]);
		if (_Max-_Min<=c) printf("%d\n",i),none=0;
	}
	if (none) puts("NONE");
}
Problem1345
#include<cstdio>
#include<cctype>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

int n,x,y;
long long Ans; 

int main()
{
	for (n=IN()-1,y=IN();n--;) x=IN(),Ans+=x>y?x:y,y=x;
	printf("%lld\n",Ans);
}
Problem1355
#include<cstdio>
using namespace std;

const int Maxn=1000000+19;
int Len,nxt[Maxn];
char s[Maxn];

int main()
{
	scanf("%d%s",&Len,s);
	nxt[0]=nxt[1]=0;
	for (int i=1;i<Len;i++)
	{
		int j=nxt[i];
		while (j&&s[i]!=s[j]) j=nxt[j];
		nxt[i+1]=(s[i]==s[j]?j+1:0);
	}
	printf("%d\n",Len-nxt[Len]);
}
Problem1356
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=1500+19;
typedef long long LL;
struct Point 
{
	int x,y;
	Point() {}
	Point(int _x,int _y):x(_x),y(_y){}
	bool operator == (const Point& B) const {return x==B.x&&y==B.y;}
} P[Maxn];
struct Line
{
	Point *A,*B;
	Point Mid;LL Len;
	bool operator < (const Line& B) const 
	{
		if (Len!=B.Len) return Len<B.Len;
		return Mid.x!=B.Mid.x?Mid.x<B.Mid.x:Mid.y<B.Mid.y;
	}
} L[Maxn*Maxn];
typedef Point Vector;
int n,tot;LL Ans;

LL sqr(LL x) {return 1LL*x*x;}
LL Abs(LL x) {return x>0?x:-x;}
Vector operator - (Point A,Point B) {return Vector(A.x-B.x,A.y-B.y);}
LL operator * (Vector A,Vector B) {return 1LL*A.x*B.y-1LL*A.y*B.x;}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d%d",&P[i].x,&P[i].y);
	for (int i=0;i<n;i++)
		for (int j=0;j<i;j++)
		{
			L[tot].A=&P[i];L[tot].B=&P[j];
			L[tot].Mid=Point(P[i].x+P[j].x,P[i].y+P[j].y);
			L[tot].Len=1LL*sqr(P[i].x-P[j].x)+1LL*sqr(P[i].y-P[j].y);
			tot++;
		}
	sort(L,L+tot);
	for (int i=0;i<tot;i++)
		for (int j=i-1;j>=0&&L[i].Len==L[j].Len&&L[i].Mid==L[j].Mid;j--)
			Ans=max(Ans,Abs((*(L[i].A)-*(L[j].A))*(*(L[i].B)-*(L[j].A))));
	printf("%lld\n",Ans);
}
Problem1367
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';return x;
}

const int N=1e6+19;

struct node *null;
struct node
{
	int S,key,npl;
	node *L,*R;
	void Update() {S=L->S+R->S+1,npl=R->npl+1;}
} Nd[N],*cur=Nd,*rt[N];

node *Merge(node *A,node *B)
{
	if (A==null) return B;
	if (B==null) return A;
	if (A->key<B->key) swap(A,B);
	A->R=Merge(A->R,B);
	if (A->R->npl>A->L->npl) swap(A->L,A->R);
	return A->Update(),A;
}

int A[N],L[N],R[N],n,c;
long long Ans;

int main()
{
	n=IN();
	For(i,1,n+1) A[i]=IN()-i;
	null=cur++;*null=(node){0,0,-1,null,null};
	For(i,1,n+1)
	{
		rt[++c]=cur++;
		*rt[c]=(node){1,A[i],0,null,null};L[c]=R[c]=i;
		while (c>1&&rt[c-1]->key>rt[c]->key)
		{
			R[c-1]=i,rt[c-1]=Merge(rt[c-1],rt[c]),c--;
			while (rt[c]->S>(R[c]-L[c]+2)/2) rt[c]=Merge(rt[c]->L,rt[c]->R);
		}
	}
	For(i,1,c+1) For(j,L[i],R[i]+1) Ans+=abs(rt[i]->key-A[j]);
	printf("%lld\n",Ans);
}
Problem1391
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1200*2+19,M=3000000,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[M];
int Last[N],Dis[N],Q[N],Cur[N],f,w;
int n,m,Ans,S,T,x,c,y,cnt;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	For(i,1,T+1) Cur[i]=Last[i];
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Cur[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(E[i].f,Flow));
			res+=tmp,Flow-=tmp,E[i].f-=tmp,E[i^1].f+=tmp;
			if (E[i].f>0) Cur[x]=i;
			if (!Flow) return res;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	S=n+m+1,T=S+1;
	For(i,1,n+1)
	{
		scanf("%d%d",&x,&c),Ans+=x,Add_Edge(S,i,x);
		while (c--) scanf("%d%d",&x,&y),Add_Edge(i,x+n,y);
	}
	For(i,1,m+1) scanf("%d",&x),Add_Edge(i+n,T,x);
	while (BFS()) Ans-=Dinic(S,oo);
	printf("%d\n",Ans);
}
Problem1406
#include<set>
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

set<int> S;
int n;

int main()
{
	scanf("%d",&n);
	if (n==1) return puts("None"),0;
	for (int i=1;i*i<=n;i++)
		if (n%i==0)
		{
			int a=i,b=n/i;
			for (int x=1;x<=n+3;x+=b)
			{
				if (x<n&&(x+1)%a==0) S.insert(x);
				if (x>=3&&(x-3)%a==0) S.insert(x-2);
			}
		}
	for (set<int>::iterator it=S.begin();it!=S.end();it++) printf("%d\n",*it);
}
Problem1412
#include<cstdio>
#include<queue>
#include<cstring>
#define Dis(x,y) (x*m+y)
using namespace std;

const int Maxn=100+19,oo=(1<<30)-1,MaxM=Maxn*Maxn*4*2;
struct Edge {int s,t,c,nxt;} E[MaxM];
int Map[Maxn][Maxn],Last[Maxn*Maxn],vis[Maxn*Maxn],pre[Maxn*Maxn];
int Dx[4]={1,0,-1,0},Dy[4]={0,1,0,-1};
int n,m,S,T,cnt=0;

inline void Add_Edge(int s,int t,int f)
{
	E[cnt]=(Edge){s,t,f,Last[s]};
	Last[s]=cnt++;
	E[cnt]=(Edge){t,s,0,Last[t]};
	Last[t]=cnt++;
}	
inline int BFS()
{
	queue<int> Q;
	memset(vis,255,sizeof(vis));
	Q.push(S);vis[S]=0;
	while (!Q.empty())
	{
		int x=Q.front();Q.pop();
		if (x==T) return 1;
		for (int i=Last[x];i!=-1;i=E[i].nxt)
		{
			int to=E[i].t;
			if (vis[to]==-1&&E[i].c>0) {vis[to]=vis[x]+1;Q.push(to);}
		}
	}
	return 0;
}
inline int DFS(int x,int flow)
{
	int Ret=0;
	if (x==T||!flow) return flow;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
	{
		int to=E[i].t,c=E[i].c;
		if (c>0&&vis[to]==vis[x]+1)
		{
			int Go=DFS(to,min(flow-Ret,c));
			E[i].c-=Go;
			E[i^1].c+=Go;
			Ret+=Go;
			if (Ret==flow) return Ret;
		}
	}
	if (!Ret) vis[x]=-1;
	return Ret;
}
inline int Dinic()
{
	int Ans=0;
	while (BFS()) Ans+=DFS(S,oo);
	return Ans;
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=0;i<n;i++)
		for (int j=0;j<m;j++) scanf("%d",&Map[i][j]);
	S=n*m;T=S+1;
	memset(Last,255,sizeof(Last));
	for (int i=0;i<n;i++)
		for (int j=0;j<m;j++)
		{
			if (Map[i][j]==1) Add_Edge(S,Dis(i,j),oo);
			if (Map[i][j]==2) Add_Edge(Dis(i,j),T,oo);
			for (int k=0;k<4;k++)
			{
				int nx=i+Dx[k],ny=j+Dy[k];
				if (nx<0||nx>=n||ny<0||ny>=m) continue;
				if (Map[nx][ny]==Map[i][j] && Map[i][j]!=0) continue;
				Add_Edge(Dis(i,j),Dis(nx,ny),1);
			}
		}
	printf("%d\n",Dinic());
	return 0;
}
Problem1415
#include<cstdio>
#include<cstring>
#include<cmath>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1000+19,oo=(1<<30)-1;
struct Edge {int y,nxt;} E[N*2];
int Last[N],Dis[N],Q[N],Next[N][N];
int n,cnt,m,S,T,x,y;
double f[N][N];

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void GetNext(int S)
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=0;
	int f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	For(x,1,n+1)
	{
		int Min=oo,ID;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (Dis[E[i].y]<Min||Dis[E[i].y]==Min&&E[i].y<ID) Min=Dis[E[i].y],ID=E[i].y;
		Next[x][S]=ID;
	}
}
double Calc(int S,int T)
{
	if (S==T) return 0.0;
	double &res=f[S][T];
	if (fabs(res)>1e-9) return res;
	if (Next[S][T]==T||Next[Next[S][T]][T]==T) return res=1.0;
	int x=Next[Next[S][T]][T],cnt=0;double tmp=0.0;
	for (int i=Last[T];~i;i=E[i].nxt) tmp+=Calc(x,E[i].y)+1.0,cnt++;
	return res=(tmp+Calc(x,T)+1.0)/(cnt+1);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d%d%d",&n,&m,&S,&T);
	For(i,0,m) scanf("%d%d",&x,&y),Link(x,y);
	For(i,1,n+1) GetNext(i);
	printf("%.3lf\n",Calc(S,T));
}
Problem1432
#include<cstdio>
using namespace std;

int n,k;

int main()
{
	scanf("%d%d",&n,&k);
	printf("%d\n",n==1?1:(2*(k<n-k+1?k:n-k+1)));
}
Problem1433
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int K=50+19,N=K*2,M=N*N,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[M*2];
int Last[N],Dis[N],Q[N],A[N],B[N];
int cnt,tot,n,S,T,Te,x,Flow;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	int f=1,w=0;Q[1]=S;
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(E[i].f,Flow));
			E[i].f-=tmp,E[i^1].f+=tmp;Flow-=tmp,res+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	for (scanf("%d",&Te);Te--;)
	{
		memset(Last,-1,sizeof(Last));cnt=tot=0;
		scanf("%d",&n);S=2*n+1,T=S+1;
		For(i,1,n+1) {scanf("%d",&A[i]);if (A[i]) Add_Edge(i+n,T,1);}
		For(i,1,n+1) {scanf("%d",&B[i]);if (!A[i]||!B[i]) Add_Edge(S,i,1),tot++;}
		For(i,1,n+1) For(j,1,n+1) {scanf("%d",&x);if (i==j||x) Add_Edge(i,j+n,1);}
		Flow=0;while (BFS()) Flow+=Dinic(S,oo);
		puts(Flow==tot?"^_^":"T_T");
	}
}
Problem1441
#include<stdio.h>

int A,x,n;
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}

main()
{
	for (scanf("%d",&n);n--;) scanf("%d",&x),A=gcd(A,x>0?x:-x);
	printf("%d\n",A);
}
Problem1452
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=300+19;
int C[101][Maxn][Maxn],A[Maxn][Maxn];
int n,m,Q,x,y,c,x1,x2,y1,y2,opt;

int ch;
void In(int &x)
{
	while (!isdigit(ch=getchar()));x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
}

void Add(int c,int a,int b,int v)
{
	for (int x=a;x<=n;x+=x&-x)
		for (int y=b;y<=n;y+=y&-y) C[c][x][y]+=v;
}
int Query(int c,int x)
{
	int Ans=0;
	for (;x;x-=x&-x)
	{
		for (int y=y2;y;y-=y&-y) Ans+=C[c][x][y];
		for (int y=y1-1;y;y-=y&-y) Ans-=C[c][x][y];
	}
	return Ans;
}

int main()
{
	In(n),In(m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) In(c),Add(c,i,j,1),A[i][j]=c;
	In(Q);
	while (Q--)
	{
		In(opt);
		if (opt==1) 
			In(x),In(y),In(c),
			Add(A[x][y],x,y,-1),Add(c,x,y,1),A[x][y]=c;
		if (opt==2) 
			In(x1),In(x2),In(y1),In(y2),In(c),
			printf("%d\n",Query(c,x2)-Query(c,x1-1));
	}
}
Problem1455
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=1000000+19;
int Dead[N],Fa[N],n,Q,x,y;
char s[3];

struct node;node *null;
struct node
{
	node *L,*R;
	int key,npl;
} Nd[N];node *rt[N];

node *Merge(node *A,node *B)
{
	if (A==null) return B;
	if (B==null) return A;
	if (A->key>B->key) swap(A,B);
	A->R=Merge(A->R,B);
	if (A->R->npl>A->L->npl) swap(A->L,A->R);
	return A->npl=A->R->npl+1,A;
}

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}

int main()
{
	null=Nd;Nd[0]=(node){null,null,0,-1};
	read(n);
	For(i,1,n+1) read(x),Nd[i]=(node){null,null,x,0},Fa[i]=i,rt[i]=Nd+i;
	read(Q);
	while (Q--)
	{
		scanf("%s",s);
		if (s[0]=='M')
		{
			read(x),read(y);
			if (Dead[x]||Dead[y]) continue;
			int fx=Getf(x),fy=Getf(y);
			if (fx!=fy) Fa[fx]=fy,rt[fy]=Merge(rt[fx],rt[fy]);
		} else
		{
			read(x);
			if (Dead[x]) {puts("0");continue;}
			x=Getf(x);printf("%d\n",rt[x]->key);
			Dead[rt[x]-Nd]=1;
			rt[x]=Merge(rt[x]->L,rt[x]->R);
		}
	}
}
Problem1457
#include<cstdio>
#include<cstring>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=100+19;
int Sg[N][N],Flag,res,n,x,y,T;

int DFS(int x,int y)
{
	int& Ans=Sg[x][y];
	if (~Ans) return Ans;
	int s[300]={0};
	For(i,1,x) if (x-i!=y) s[DFS(x-i,y)]=1;
	For(i,1,y) if (x!=y-i) s[DFS(x,y-i)]=1;
	for (int i=1;i<x&&i<y;i++) s[DFS(x-i,y-i)]=1;
	For(i,0,300) if (!s[i]) return Ans=i;
}

int main()
{
	memset(Sg,-1,sizeof(Sg));
	For(i,0,100) Sg[i][0]=Sg[0][i]=Sg[i][i]=0;
	For(i,0,100) For(j,0,100) DFS(i,j);
	scanf("%d",&T);
	while (T--)
	{
		Flag=res=0;
		scanf("%d",&n);
		while (n--) scanf("%d%d",&x,&y),res^=Sg[x][y],Flag|=(x*y==0||x==y);
		puts(res||Flag?"^o^":"T_T");
	}
}
Problem1458
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=100*2+19,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[N*N*2];
int L[N],C[N],Lx[N],Last[N],Q[N],Dis[N],Cx[N],A[N][N];
int n,m,S,T,cnt,x,y,k,Ans;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	int f=1,w=0;Q[1]=S;
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			res+=tmp,Flow-=tmp,E[i].f-=tmp,E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d%d",&n,&m,&k);Ans=n*m;
	S=n+m+1,T=S+1;
	For(i,1,n+1) scanf("%d",&L[i]);
	For(i,1,m+1) scanf("%d",&C[i]);
	For(i,0,k) scanf("%d%d",&x,&y),A[x][y]=1,Lx[x]++,Cx[y]++,Ans--;
	For(i,1,n+1) if (m-Lx[i]<L[i]) return puts("JIONG!"),0;else Add_Edge(S,i,m-Lx[i]-L[i]);
	For(i,1,m+1) if (n-Cx[i]<C[i]) return puts("JIONG!"),0;else Add_Edge(i+n,T,n-Cx[i]-C[i]);
	For(i,1,n+1) For(j,1,m+1) if (!A[i][j]) Add_Edge(i,j+n,1);
	while (BFS()) Ans-=Dinic(S,oo);
	printf("%d\n",Ans);
}
Problem1465
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
 
const int Maxn=1000000+19;
typedef long long LL;
int n,A[Maxn];
LL Ans,S[Maxn],Cn,sum;
 
int c;
void read(int &x)
{
    while (!isdigit(c=getchar()));x=c-'0';
    while (isdigit(c=getchar())) x=x*10+c-'0';
}
 
int main()
{
    read(n);
    for (int i=1;i<=n;i++) read(A[i]),sum+=A[i];sum/=n;
    for (int i=1;i<=n;i++) S[i]=S[i-1]-(A[i]-sum);
    sort(S+1,S+n+1);Cn=S[n/2+1];
    for (int i=1;i<=n;i++) Ans+=(Cn>S[i]?Cn-S[i]:S[i]-Cn);
    printf("%lld\n",Ans);
}
Problem1468
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=40000+19,oo=(1<<30)-1;
struct Edge {int y,z,nxt;} E[Maxn*2];
int Last[Maxn],S[Maxn],vis[Maxn],Dis[Maxn],A[Maxn];
int n,k,cnt,Ans,Cen,Min,tot,x,y,z;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

void Find_Cen(int x,int Fa,int n)
{
	S[x]=1;int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa&&!vis[E[i].y])
			Find_Cen(E[i].y,x,n),S[x]+=S[E[i].y],res=max(res,S[E[i].y]);
	res=max(res,n-S[x]);
	if (res<Min) Min=res,Cen=x;
}
void DFS(int x,int Fa,int Dis)
{
	A[tot++]=Dis;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa&&!vis[E[i].y]) DFS(E[i].y,x,Dis+E[i].z);
}
int Calc(int x,int tmp)
{
	tot=0;DFS(x,-1,tmp);sort(A,A+tot);
	int res=0;
	for (int L=0,R=tot-1;L<R;L++) 
		{while (L<R&&A[R]+A[L]>k) R--;res+=R-L;}
	return res;
}
void Solve(int x,int Fa,int n)
{
	Min=oo,Find_Cen(x,-1,n);x=Cen;
	Ans+=Calc(x,0);vis[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (!vis[E[i].y])
		{
			Ans-=Calc(E[i].y,E[i].z);
			Solve(E[i].y,x,E[i].y==Fa?n-S[x]:S[E[i].y]);
		}
}

int main()
{
	read(n);
	memset(Last,-1,sizeof(Last));
	for (int i=1;i<n;i++) read(x),read(y),read(z),Link(x,y,z);
	read(k);
	Solve(1,-1,n);
	printf("%d\n",Ans);
}
Problem1468
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=40000+19,oo=(1<<30)-1;
struct Edge {int y,z,nxt;} E[Maxn*2];
int Last[Maxn],S[Maxn],vis[Maxn],Dis[Maxn],A[Maxn];
int n,k,cnt,Ans,Cen,Min,tot,x,y,z,Fcen;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

void Find_Cen(int x,int Fa,int n)
{
	S[x]=1;int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa&&!vis[E[i].y])
			Find_Cen(E[i].y,x,n),S[x]+=S[E[i].y],res=max(res,S[E[i].y]);
	res=max(res,n-S[x]);
	if (res<Min) Min=res,Cen=x,Fcen=Fa;
}
void DFS(int x,int Fa,int Dis)
{
	A[tot++]=Dis;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa&&!vis[E[i].y]) DFS(E[i].y,x,Dis+E[i].z);
}
int Calc(int x,int tmp)
{
	tot=0;DFS(x,-1,tmp);sort(A,A+tot);
	int res=0;
	for (int L=0,R=tot-1;L<R;L++) 
		{while (L<R&&A[R]+A[L]>k) R--;res+=R-L;}
	return res;
}
void Solve(int x,int n)
{
	Min=oo,Find_Cen(x,-1,n);x=Cen;
	Ans+=Calc(x,0);vis[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (!vis[E[i].y])
		{
			Ans-=Calc(E[i].y,E[i].z);
			Solve(E[i].y,E[i].y==Fcen?n-S[x]:S[E[i].y]);
		}
}

int main()
{
	read(n);
	memset(Last,-1,sizeof(Last));
	for (int i=1;i<n;i++) read(x),read(y),read(z),Link(x,y,z);
	read(k);
	Solve(1,n);
	printf("%d\n",Ans);
}
Problem1475
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=39,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[N*N*6];
int A[N][N],Last[N*N],Q[N*N],Dis[N*N];
int n,S,T,cnt,Flow;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	int f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			E[i].f-=tmp,E[i^1].f+=tmp,res+=tmp,Flow-=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);S=n*n,T=S+1;
	for (int i=0;i<n;i++) for (int j=0;j<n;j++)
	{
		scanf("%d",&A[i][j]),Flow+=A[i][j];	
		if ((i&1)^(j&1))
		{
			Add_Edge(S,i*n+j,A[i][j]);
			if (i) Add_Edge(i*n+j,(i-1)*n+j,oo);
			if (j) Add_Edge(i*n+j,i*n+(j-1),oo);
		} else
		{
			Add_Edge(i*n+j,T,A[i][j]);
			if (i) Add_Edge((i-1)*n+j,i*n+j,oo);
			if (j) Add_Edge(i*n+(j-1),i*n+j,oo);
		}
	}
	while (BFS()) Flow-=Dinic(S,oo);
	printf("%d\n",Flow);
}
Problem1483
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=1000000+19;
struct node;typedef node* nd;
struct node {nd nxt;int Dis;} ND[Maxn/10];
nd A[Maxn],Last[Maxn];
int n,Q,pre,x,y,f,Ans,opt,tot,Len[Maxn];

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void out(int x) {if (!x) return;out(x/10);putchar(x%10+'0');}
void print(int x)
{
	if (!x) {puts("0");return;}
	out(x);puts("");
}

void Merge(int x,int y)
{
	if (!A[x]||x==y) return;
	if (!A[y]) {A[y]=A[x],Len[y]=Len[x],A[x]=0;return;}
	if (f=(Len[x]>Len[y])) swap(x,y);
	Len[y]+=Len[x];
	nd xx=A[x],yy=A[y],z=0,Fir;
	while (xx&&yy)
	{
		Ans-=(abs(xx->Dis-yy->Dis)==1);
		if (xx->Dis>yy->Dis) 
		{
			if (!z) Fir=yy;else z->nxt=yy;
			z=yy,yy=yy->nxt;
		} else
		{
			if (!z) Fir=xx;else z->nxt=xx;
			z=xx,xx=xx->nxt;
		}
	}
	while (xx) z->nxt=xx,z=xx,xx=xx->nxt;
	while (yy) z->nxt=yy,z=yy,yy=yy->nxt;
	A[y]=Fir;
	if (f) A[x]=A[y],Len[x]=Len[y],A[y]=0;else A[x]=0;
}
 
int main()
{
	read(n);read(Q);
	for (int i=1;i<=n;i++)
	{
		read(x);Ans+=(i==1||x!=pre);pre=x;
		nd a=&ND[i];a->Dis=i;
		if (Last[x]) Last[x]->nxt=a;else A[x]=a;
		Last[x]=a;Len[x]++;
	}
	while (Q--)
	{
		read(opt);
		if (opt==2) print(Ans);else read(x),read(y),Merge(x,y);
	}
}
Problem1486
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;

const double Eps=1e-10;
const int Maxn=3000+19;
struct Edge {int to;double w;};
vector<Edge> A[Maxn]; 
int n,m,u,v,vis[Maxn];
double L=1e7,R=-1e7,Mid,w,Dis[Maxn];

int SPFA_DFS(int x)
{
	vis[x]=1;
	for (int i=0;i<A[x].size();i++)
	{
		int nxt=A[x][i].to;
		if (Dis[x]+A[x][i].w-Mid<Dis[nxt])
		{
			Dis[nxt]=Dis[x]+A[x][i].w-Mid;
			if (vis[nxt]||SPFA_DFS(nxt)) return 1;
		}
	}
	return vis[x]=0;
}
int check(double x)
{
	memset(Dis,0,sizeof(Dis));
	for (int i=1;i<=n;i++)
	{
		memset(vis,0,sizeof(vis));
		if (SPFA_DFS(i)) return 1;
	}
	return 0;
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=0;i<m;i++) 
	{
		scanf("%d%d%lf",&u,&v,&w);
		A[u].push_back((Edge){v,w});
		if (w>R) R=w;if (w<L) L=w;
	}
	while (R-L>Eps)
	{
		Mid=(L+R)/2.;
		if (check(Mid)) R=Mid;else L=Mid;
	}
	printf("%.8lf\n",Mid);
	return 0;
}
Problem1491
#include<cstdio>
#include<cstring>
using namespace std;

const int Maxn=100+19;
int Dis[Maxn][Maxn];
double cnt[Maxn][Maxn];
int n,m,x,y,z;

int main()
{
	scanf("%d%d",&n,&m);
	memset(Dis,60,sizeof(Dis));
	for (int i=1;i<=n;i++) Dis[i][i]=0;
	for (int i=0;i<m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		Dis[x][y]=Dis[y][x]=z;
		cnt[x][y]=cnt[y][x]=1;
	}
	for (int k=1;k<=n;k++)
		for (int i=1;i<=n;i++)
			if (i!=k) for (int j=1;j<=n;j++)
				if (j!=i&&j!=k)
				{
					if (Dis[i][k]+Dis[k][j]<Dis[i][j]) 
					{
						Dis[i][j]=Dis[i][k]+Dis[k][j];
						cnt[i][j]=0;
					}
					if (Dis[i][k]+Dis[k][j]==Dis[i][j]) cnt[i][j]+=cnt[i][k]*cnt[k][j];
				}
	for (int v=1;v<=n;v++)
	{
		double Ans=0;
		for (int i=1;i<=n;i++)
			if (v!=i) for (int j=1;j<=n;j++)
				if (v!=j&&i!=j&&Dis[i][v]+Dis[v][j]==Dis[i][j])
					Ans+=(1.0*cnt[i][v]*cnt[v][j])/(1.0*cnt[i][j]);
		printf("%.3lf\n",Ans);
	}
}
Problem1492
#include<set>
#include<map>
#include<cmath>
#include<string>
#include<cstdio>
#include<vector>
#include<cctype>
#include<cstdlib>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define Mid (L+R>>1)

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;

const int N=100000+19;
struct Point
{
	db x,y;
	bool operator < (const Point& B) const {return x<B.x||fabs(x-B.x)<1e-9&&y<B.y;}
} p[N],__p[N];
db A[N],B[N],r[N],f[N],v[N];
int id[N],__id[N],stk[N],n,S,tmp,top;

bool cmp(int x,int y) {return v[x]>v[y];}
db slope(int i,int j)
{
	return fabs(p[j].x-p[i].x)<1e-9?1e60:(p[j].y-p[i].y)/(p[j].x-p[i].x);
}
void CDQ(int L,int R)
{
	if (L==R)
	{
		f[L]=max(f[L],f[L-1]);
		p[L].x=f[L]*r[L]/(A[L]*r[L]+B[L]);
		p[L].y=p[L].x/r[L];
		return;
	}
	int t1=L,t2=Mid+1,t;
	For(i,L,R+1) if (id[i]<=Mid) __id[t1++]=id[i];else __id[t2++]=id[i];
	For(i,L,R+1) id[i]=__id[i];
	CDQ(L,Mid);
	stk[top=1]=0;
	For(i,L,Mid+1)
	{
		while (top>1&&slope(stk[top-1],stk[top])<=slope(stk[top],i)) top--;
		stk[++top]=i;
	}
	tmp=2;
	For(i,Mid+1,R+1)
	{
		int t=id[i];
		while (tmp+1<=top&&slope(stk[tmp],stk[tmp+1])>v[t]) tmp++;
		f[t]=max(f[t],p[stk[tmp]].x*A[t]+p[stk[tmp]].y*B[t]);
	}
	CDQ(Mid+1,R);
	t1=L,t2=Mid+1,t=L;
	while (t1<=Mid&&t2<=R)
		if (p[t1]<p[t2]) __p[t++]=p[t1++];else __p[t++]=p[t2++];
	while (t1<=Mid) __p[t++]=p[t1++];
	while (t2<=R) __p[t++]=p[t2++];
	For(i,L,R+1) p[i]=__p[i];
}

int main()
{
	n=IN(),S=IN();
	For(i,1,n+1)
	{
		scanf("%lf%lf%lf",&A[i],&B[i],&r[i]);
		v[i]=-A[i]/B[i];
		id[i]=i;
	}
	sort(id+1,id+n+1,cmp);
	f[1]=S;
	CDQ(1,n);
	printf("%.3lf\n",f[n]);
}
Problem1493
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=500000+19;
char s[5];
int rot=1,flp,x,y,n,c,cx,cy;

int Get(int x)
{
	x=!flp?rot+x-1:rot-x+1;
	return (x+n-1)%n+1;
}

//SegTree
struct node
{
	int Ans,Set,Lc,Rc;
	node() {}
	node(int A,int L,int R) {Ans=A,Lc=L,Rc=R,Set=0;}
} S[N*4];
int Ql,Qr,Qv;

node operator + (node A,node B)
{
	return node(A.Ans+B.Ans-(A.Rc==B.Lc),A.Lc,B.Rc);
}
void SetS(int x,int v) {S[x]=node(1,v,v),S[x].Set=v;}
void Down(int x)
{
	if (S[x].Set)
		SetS(Lsn,S[x].Set),SetS(Rsn,S[x].Set),S[x].Set=0;
}
void Build(int x,int L,int R)
{
	if (L==R) {int v=IN();S[x]=node(1,v,v);return;}
	Build(Lsn,L,Mid);
	Build(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
node Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return S[x];
	Down(x);
	if (Qr<=Mid) return Query(Lsn,L,Mid);
	if (Ql>Mid) return Query(Rsn,Mid+1,R);
	return Query(Lsn,L,Mid)+Query(Rsn,Mid+1,R);
}
void Modify(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {SetS(x,Qv);return;}
	Down(x);
	if (Ql<=Mid) Modify(Lsn,L,Mid);
	if (Qr>Mid) Modify(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
node Query(int L,int R) {return Ql=L,Qr=R,Query(1,1,n);}
void Update(int L,int R,int v) {Ql=L,Qr=R,Qv=v,Modify(1,1,n);}

int main()
{
	n=IN(),c=IN();
	Build(1,1,n);
	for (int Q=IN();Q--;)
	{
		scanf("%s",s);
		if (s[0]=='R') !flp?rot-=IN():rot+=IN(),rot=(rot+n-1)%n+1;
		if (s[0]=='F') flp^=1;
		if (s[0]=='S')
		{
			x=Get(IN()),y=Get(IN());
			cx=Query(x,x).Lc,cy=Query(y,y).Lc;
			Update(x,x,cy),Update(y,y,cx);
		}
		if (s[0]=='P')
		{
			x=Get(IN()),y=Get(IN()),Qv=IN();
			if (flp) swap(x,y);
			if (x<=y) Update(x,y,Qv);else Update(x,n,Qv),Update(1,y,Qv);
		}
		if (s[0]=='C'&&s[1]!='S')
		{
			int res=S[1].Ans;
			if (res!=1&&S[1].Lc==S[1].Rc) res--;
			printf("%d\n",res);
		}
		if (s[0]=='C'&&s[1]=='S')
		{
			x=Get(IN()),y=Get(IN());
			if (flp) swap(x,y);
			if (x<=y) printf("%d\n",Query(x,y).Ans);else
				printf("%d\n",(Query(x,n)+Query(1,y)).Ans);
		}
	}
}
Problem1497
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=5000+50000+19,M=1000000+19,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[M];
int Last[N],Dis[N],Q[N];
int cnt,n,S,T,tot,a,b,c,Ans,m;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	int f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(E[i].f,Flow));
			res+=tmp,Flow-=tmp,E[i].f-=tmp,E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	tot=n=IN(),m=IN(),S=++tot,T=++tot;
	For(i,1,n+1) Add_Edge(S,i,IN());
	For(i,0,m)
	{
		tot++;
		a=IN(),b=IN(),c=IN(),Ans+=c;
		Add_Edge(a,tot,oo),Add_Edge(b,tot,oo);
		Add_Edge(tot,T,c);
	}
	while (BFS()) Ans-=Dinic(S,oo);
	printf("%d\n",Ans);
}
Problem1497
#include<set>
#include<map>
#include<cmath>
#include<string>
#include<cstdio>
#include<vector>
#include<cctype>
#include<cstdlib>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double Db;
typedef pair<int,int> pii;

const int N=5000+19,M=5000000;
const ll oo=1ll<<60;
typedef int one[N];
struct Edge {int y,f,nxt;} E[M];
one Last,Q,Dis,sum,p;
int n,m,cnt,S,T,U,x,y,z;
ll Ans;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
}
bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=0;
	int f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if (E[i].f&&Dis[y=E[i].y]==-1) Dis[y]=Dis[x]+1,Q[++f]=y;
	}
	return Dis[T]!=-1;
}
ll Dinic(int x,ll Flow)
{
	if (x==T||!Flow) return Flow;
	ll res=0;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (E[i].f&&Dis[y=E[i].y]==Dis[x]+1)
		{
			ll tmp=Dinic(y,min(1ll*E[i].f,Flow));
			E[i].f-=tmp,E[i^1].f+=tmp,Flow-=tmp,res+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,n+1) p[i]=IN();
	For(i,0,m)
	{
		x=IN(),y=IN(),z=IN();
		sum[x]+=z,sum[y]+=z;
		Add_Edge(x,y,z),Add_Edge(y,x,z);
	}
	For(i,1,n+1) U=max(U,sum[i]);
	S=n+1,T=S+1;
	For(i,1,n+1)
	{
		Add_Edge(S,i,U),Add_Edge(i,S,0);
		Add_Edge(i,T,2*p[i]-sum[i]+U),Add_Edge(T,i,0);
	}
	while (BFS()) Ans+=Dinic(S,oo);
	printf("%lld\n",(1ll*U*n-Ans)/2);
}
Problem1497
#include<set>
#include<map>
#include<cmath>
#include<string>
#include<cstdio>
#include<vector>
#include<cctype>
#include<cstdlib>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double Db;
typedef pair<int,int> pii;

const int N=5000+19,M=5000000;
const ll oo=1ll<<60;
typedef int one[N];
struct Edge {int y,f,nxt;} E[M];
one Last,Q,Dis,sum,p,cur;
int n,m,cnt,S,T,U,x,y,z;
ll Ans;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
}
bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=0;
	int f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if (E[i].f&&Dis[y=E[i].y]==-1) Dis[y]=Dis[x]+1,Q[++f]=y;
	}
	return Dis[T]!=-1;
}
ll Dinic(int x,ll Flow)
{
	if (x==T||!Flow) return Flow;
	ll res=0;
	for (int i=cur[x],y;~i;i=E[i].nxt)
		if (E[i].f&&Dis[y=E[i].y]==Dis[x]+1)
		{
			ll tmp=Dinic(y,min(1ll*E[i].f,Flow));
			E[i].f-=tmp,E[i^1].f+=tmp,Flow-=tmp,res+=tmp;
			if (E[i].f) cur[x]=i;
			if (!Flow) return res;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,n+1) p[i]=IN();
	For(i,0,m)
	{
		x=IN(),y=IN(),z=IN();
		sum[x]+=z,sum[y]+=z;
		Add_Edge(x,y,z),Add_Edge(y,x,z);
	}
	For(i,1,n+1) U=max(U,sum[i]);
	S=n+1,T=S+1;
	For(i,1,n+1)
	{
		Add_Edge(S,i,U),Add_Edge(i,S,0);
		Add_Edge(i,T,2*p[i]-sum[i]+U),Add_Edge(T,i,0);
	}
	while (BFS()){
		For(i,1,T+1) cur[i]=Last[i];
		Ans+=Dinic(S,oo);
	}
	printf("%lld\n",(1ll*U*n-Ans)/2);
}
Problem1500
#include<cstdio>
#include<cctype>
#include<algorithm>
#define Fir first
#define Sec second
using namespace std;

const int Maxn=1200000+19,oo=(1<<29)-1;

int f,ch;
void read(int &x)
{
	while (!isdigit(ch=getchar())&&ch!='-');
	if (ch=='-') f=-1,x=0;else f=1,x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
	x*=f;
}
int Max3(int a,int b,int c) {int x=a>b?a:b;return x>c?x:c;}

struct Treap;typedef Treap* rt;rt null;
struct Treap
{
	rt L,R;
	int key,fix,size,Sum,Max,Lmax,Rmax;bool rev,same;
	void Setrev() {swap(L,R),swap(Lmax,Rmax);}
	void Setsame(int x) {key=x;Sum=size*x;Max=Lmax=Rmax=x*(x>0?size:1);}
	void Down()
	{
		if (this==null) return;
		if (rev) L->Setrev(),R->Setrev(),L->rev^=1,R->rev^=1,rev=0;
		if (same) L->Setsame(key),R->Setsame(key),L->same=R->same=1,same=0;
	}
	void Update()
	{
		if (this==null) return;
		size=L->size+R->size+1;
		Sum=L->Sum+R->Sum+key;
		Max=max(Max3(key,L->Max,R->Max),Max3(L->Rmax+key,key+R->Lmax,L->Rmax+key+R->Lmax));
		Lmax=Max3(L->Lmax,L->Sum+key,L->Sum+key+R->Lmax);
		Rmax=Max3(R->Rmax,R->Sum+key,R->Sum+key+L->Rmax);
	}
} treap[Maxn];int tcnt;rt RT,S[Maxn],node[Maxn];

typedef pair<rt,rt> Drt;
int n,Q,k,L,x,col,top;
int A[Maxn];
char s[10];

rt New(int key)
{
	rt x=node[top--];
	x->key=x->Max=x->Sum=x->Lmax=x->Rmax=key;
	x->fix=rand();x->size=1;x->rev=0;x->same=0;
	x->L=x->R=null;
	return x;
}
void recycle(rt A)
{
	if (A==null) return;
	node[++top]=A;recycle(A->L);recycle(A->R);
}
rt Merge(rt A,rt B)
{
	if (A==null) return B;if (B==null) return A;
	A->Down();B->Down();
	if (A->fix<B->fix) return A->R=Merge(A->R,B),A->Update(),A;
		else return B->L=Merge(A,B->L),B->Update(),B;
}
Drt Split(rt A,int k)
{
	if (A==null) return Drt(null,null);
	A->Down();Drt x;
	if (A->L->size>=k) x=Split(A->L,k),A->L=x.Sec,x.Sec=A,A->Update();
		else x=Split(A->R,k-A->L->size-1),A->R=x.Fir,x.Fir=A,A->Update();
	return x;
}
int Querysum(int k,int L)
{
	Drt x=Split(RT,k-1),y=Split(x.Sec,L);
	int Ans=y.Fir->Sum;
	RT=Merge(Merge(x.Fir,y.Fir),y.Sec);return Ans;
}
void Reverse(int k,int L)
{
	Drt x=Split(RT,k-1),y=Split(x.Sec,L);
	y.Fir->Setrev(),y.Fir->rev^=1;
	RT=Merge(Merge(x.Fir,y.Fir),y.Sec);
}
void Same(int k,int L,int c)
{
	Drt x=Split(RT,k-1),y=Split(x.Sec,L);
	y.Fir->Setsame(c);y.Fir->same=1;
	RT=Merge(Merge(x.Fir,y.Fir),y.Sec);
}
void Delete(int k,int L) 
{
	Drt x=Split(RT,k-1),y=Split(x.Sec,L);
	recycle(y.Fir),RT=Merge(x.Fir,y.Sec);
}
void Insert(rt A,int k) {Drt x=Split(RT,k);RT=Merge(Merge(x.Fir,A),x.Sec);}
void Build()
{
	rt x,Last;int top=0;
	for (int i=1;i<=n;i++)
	{
		Last=null;x=New(A[i]);
		while (top&&S[top]->fix>x->fix) Last=S[top],S[top--]->Update();
		if (top) S[top]->R=x;x->L=Last;S[++top]=x;
	}
	while (top) S[top--]->Update();
	RT=S[1];
}

int main()
{
	read(n),read(Q);
	for (int i=1;i<Maxn;i++) node[i]=&treap[i];top=Maxn-1;
	null=new Treap();null->size=0;
	null->Max=null->Lmax=null->Rmax=-oo;
	for (int i=1;i<=n;i++) read(A[i]);
	Build();
	while (Q--)
	{
		scanf("%s",s);
		if (s[0]!='M'||s[2]!='X') read(k),read(L);
		if (s[0]=='I') 
		{
			rt A=null;
			for (int i=0;i<L;i++) {read(x);rt B=New(x);A=Merge(A,B);}
			Insert(A,k);
		} else
		if (s[0]=='D') Delete(k,L);else
		if (s[0]=='M'&&s[2]=='K') read(col),Same(k,L,col);else
		if (s[0]=='R') Reverse(k,L);else
		if (s[0]=='G') printf("%d\n",Querysum(k,L));else printf("%d\n",RT->Max);
	}
}
Problem1501
#include<cstdio>
#define Rep(i,j,k) for (int i=j;i<=k;i++)
using namespace std;

int A[60][4][2]=
{
    {{0,1},{1,0}},{{0,1},{1,1}},{{0,1},{-1,1}},{{1,0},{1,1}},
    {{0,1},{0,2},{0,3}},{{1,0},{2,0},{3,0}},
    {{0,1},{0,2},{1,0}},{{0,-1},{1,0},{2,0}},
        {{0,-1},{-1,0},{-2,0}},{{-1,0},{0,1},{0,2}},{{0,1},{1,0},{2,0}},
		{{0,-2},{0,-1},{-1,0}},{{-1,0},{-2,0},{0,1}},{{0,-2},{0,-1},{1,0}},
    {{0,1},{1,0},{1,1}},
    {{1,0},{2,0},{2,1},{2,2}},{{1,0},{2,0},{0,1},{0,2}},
        {{1,0},{2,0},{2,-1},{2,-2}},{{0,-1},{0,-2},{1,0},{2,0}},
    {{0,1},{0,2},{0,3},{1,1}},{{0,1},{0,2},{0,3},{-1,1}},
        {{1,0},{2,0},{3,0},{1,1}},{{1,0},{2,0},{3,0},{1,-1}},
        {{-1,0},{-2,0},{1,0},{0,1}},{{-1,0},{-2,0},{1,0},{0,-1}},
        {{0,-1},{0,-2},{0,-3},{1,-1}},{{0,-1},{0,-2},{0,-3},{-1,-1}},
    {{1,0},{0,1},{0,2},{1,2}},{{1,0},{1,1},{1,2},{0,2}},
        {{0,1},{1,1},{2,1},{2,0}},{{0,1},{1,0},{2,0},{2,1}},
    {{0,1},{0,2},{1,0},{1,1}},{{0,1},{1,0},{1,1},{1,2}},
        {{0,1},{1,0},{1,1},{2,1}},{{0,1},{1,0},{1,1},{2,0}},
        {{0,1},{0,2},{1,1},{1,2}},{{0,1},{0,2},{-1,1},{-1,2}},
        {{1,0},{2,0},{1,1},{2,1}},{{1,0},{2,0},{1,-1},{2,-1}},
    {{0,1},{0,2},{1,2},{1,3}},{{0,1},{0,2},{-1,2},{-1,3}},
        {{1,0},{2,0},{2,1},{3,1}},{{1,0},{2,0},{2,-1},{3,-1}},
        {{0,1},{-1,1},{-1,2},{-1,3}},{{0,1},{1,1},{1,2},{1,3}},
        {{1,0},{1,1},{2,1},{3,1}},{{1,0},{1,-1},{2,-1},{3,-1}},
    {{0,-1},{0,1},{1,0},{-1,0}},
    {{1,0},{1,1},{2,1},{2,2}},{{1,0},{1,-1},{2,-1},{2,-2}},
        {{0,1},{1,1},{1,2},{2,2}},{{-1,0},{-1,1},{-2,1},{-2,2}},
    {{0,1},{1,0},{2,0},{3,0}},{{0,1},{1,1},{2,1},{3,1}},
        {{1,0},{1,1},{1,2},{1,3}},{{1,0},{1,-1},{1,-2},{1,-3}},
        {{0,-1},{-1,-1},{-2,-1},{-3,-1}},{{0,1},{-1,1},{-2,1},{-3,1}},
		{{-1,0},{-1,1},{-1,2},{-1,3}},{{-1,-3},{-1,-2},{-1,-1},{-1,0}}
};

const int R=60*55+19,C=67+19;
struct node;typedef node* nd;
struct node
{
    nd L,R,U,D,col;
    int sz,row;
} ND[R*C];
nd Col[C],Row[R],rt;
int Len[60],B[60],RID[55][2],cnt,a,b,c;
char s[11][11];
 
int ID(int x,int y) {return x*(x+1)/2+y;}       //0..54
int IDx(int t,int x,int y) {return t*55+ID(x,y)+1;} //1..60*55
int IDy(int t,int x,int y) {return (!t?x:ID(x,y)+12)+1;}    //1..12,13..67
void reIDx(int x,int &a,int &b,int &c) {x--;b=RID[x%55][0],c=RID[x%55][1],a=x/55;}
 
inline void Bel(int L,int R,int x) {Rep(i,L,R) B[i]=x;}
int check(int t,int x,int y)
{
    int f=s[x][y];
    if (f!='.'&&f!=B[t]+'A'-1) return 0;
    for (int i=0;i<Len[t];i++)
    {
        int xx=x+A[t][i][0],yy=y+A[t][i][1];
        if (xx<0||xx>9||yy<0||yy>9||xx<yy) return 0;
        if (s[xx][yy]!=f) return 0;
    }
    return 1;
}
 
void Add_node(int r,int c)
{
    nd x=&ND[++cnt];x->row=r;x->col=Col[c];
    if (Row[r]==0) {Row[r]=x;x->L=x->R=x;}
    Row[r]->L->R=x,x->L=Row[r]->L,x->R=Row[r],Row[r]->L=x;
    Col[c]->U->D=x,x->U=Col[c]->U,x->D=Col[c],Col[c]->U=x,Col[c]->sz++;
}
void remove(nd x)
{
    x->L->R=x->R;x->R->L=x->L;
    for (nd i=x->D;i!=x;i=i->D)
        for (nd j=i->R;j!=i;j=j->R) j->U->D=j->D,j->D->U=j->U,j->col->sz--;
}
void remuse(nd x)
{
    for (nd i=x->U;i!=x;i=i->U)
        for (nd j=i->R;j!=i;j=j->R) j->U->D=j->D->U=j,j->col->sz++;
    x->L->R=x->R->L=x;
}
int Dancing()
{
    if (rt->R==rt) return 1;
    int Min=1<<30;nd x;
    for (nd i=rt->R;i!=rt;i=i->R) if (i->sz<Min) Min=i->sz,x=i;
    remove(x);
    for (nd i=x->D;i!=x;i=i->D)
    {
        reIDx(i->row,a,b,c);s[b][c]=B[a]+'A'-1;
        for (int j=0;j<Len[a];j++) s[b+A[a][j][0]][c+A[a][j][1]]=B[a]+'A'-1;
        for (nd j=i->R;j!=i;j=j->R) remove(j->col);
        if (Dancing()) return 1;
        for (nd j=i->L;j!=i;j=j->L) remuse(j->col);
        reIDx(i->row,a,b,c);s[b][c]=0;
        for (int j=0;j<Len[a];j++) s[b+A[a][j][0]][c+A[a][j][1]]=0;
    }
    remuse(x);
    return 0;
}
 
int main()
{
    Bel(0,3,1),Bel(4,5,2),Bel(6,13,3),
    Bel(15,18,5),Bel(19,26,6),Bel(27,30,7),
	Bel(31,38,8),Bel(39,46,9),Bel(48,51,11),Bel(52,59,12);B[47]=10,B[14]=4;
    Rep(i,0,3) Len[i]=2;Rep(i,4,14) Len[i]=3;Rep(i,15,59) Len[i]=4;
     
    rt=Col[0]=&ND[0];
    for (int i=1;i<=67;i++)  Col[i]=&ND[i];
    for (int i=1;i<=67;i++) 
        Col[i]->L=Col[i-1],Col[i]->R=Col[i+1],
        Col[i]->U=Col[i]->D=Col[i],Col[i]->sz=0;
    rt->L=Col[67],rt->R=Col[1],Col[cnt=67]->R=rt;
     
    Rep(i,0,9) scanf("%s",s[i]);
    Rep(i,0,9) Rep(j,0,i) RID[ID(i,j)][0]=i,RID[ID(i,j)][1]=j;
    Rep(k,0,59) Rep(i,0,9) Rep(j,0,i)
        if (check(k,i,j))
        {
            int r=IDx(k,i,j);
            Add_node(r,IDy(0,B[k]-1,0));
            Add_node(r,IDy(1,i,j));
            for (int x=0;x<Len[k];x++)
                Add_node(r,IDy(1,i+A[k][x][0],j+A[k][x][1]));
        }
    if (!Dancing()) puts("No solution");else Rep(i,0,9) puts(s[i]);
}
Problem1501
#include<cstdio>
#define Rep(i,j,k) for (int i=j;i<=k;i++)
using namespace std;

int A[60][4][2]=
{
	{{0,1},{1,0}},{{0,1},{1,1}},{{0,1},{-1,1}},{{1,0},{1,1}},
	{{0,1},{0,2},{0,3}},{{1,0},{2,0},{3,0}},
	{{0,1},{0,2},{1,0}},{{0,-1},{1,0},{2,0}},
		{{0,-1},{-1,0},{-2,0}},{{-1,0},{0,1},{0,2}},{{0,1},{1,0},{2,0}},
		{{0,-2},{0,-1},{-1,0}},{{-1,0},{-2,0},{0,1}},{{0,-2},{0,-1},{1,0}},
	{{0,1},{1,0},{1,1}},
	{{1,0},{2,0},{2,1},{2,2}},{{1,0},{2,0},{0,1},{0,2}},
		{{1,0},{2,0},{2,-1},{2,-2}},{{0,-1},{0,-2},{1,0},{2,0}},
	{{0,1},{0,2},{0,3},{1,1}},{{0,1},{0,2},{0,3},{-1,1}},
		{{1,0},{2,0},{3,0},{1,1}},{{1,0},{2,0},{3,0},{1,-1}},
		{{-1,0},{-2,0},{1,0},{0,1}},{{-1,0},{-2,0},{1,0},{0,-1}},
		{{0,-1},{0,-2},{0,-3},{1,-1}},{{0,-1},{0,-2},{0,-3},{-1,-1}},
	{{1,0},{0,1},{0,2},{1,2}},{{1,0},{1,1},{1,2},{0,2}},
		{{0,1},{1,1},{2,1},{2,0}},{{0,1},{1,0},{2,0},{2,1}},
	{{0,1},{0,2},{1,0},{1,1}},{{0,1},{1,0},{1,1},{1,2}},
		{{0,1},{1,0},{1,1},{2,1}},{{0,1},{1,0},{1,1},{2,0}},
		{{0,1},{0,2},{1,1},{1,2}},{{0,1},{0,2},{-1,1},{-1,2}},
		{{1,0},{2,0},{1,1},{2,1}},{{1,0},{2,0},{1,-1},{2,-1}},
	{{0,1},{0,2},{1,2},{1,3}},{{0,1},{0,2},{-1,2},{-1,3}},
		{{1,0},{2,0},{2,1},{3,1}},{{1,0},{2,0},{2,-1},{3,-1}},
		{{0,1},{-1,1},{-1,2},{-1,3}},{{0,1},{1,1},{1,2},{1,3}},
		{{1,0},{1,1},{2,1},{3,1}},{{1,0},{1,-1},{2,-1},{3,-1}},
	{{0,-1},{0,1},{1,0},{-1,0}},
	{{1,0},{1,1},{2,1},{2,2}},{{1,0},{1,-1},{2,-1},{2,-2}},
		{{0,1},{1,1},{1,2},{2,2}},{{-1,0},{-1,1},{-2,1},{-2,2}},
	{{0,1},{1,0},{2,0},{3,0}},{{0,1},{1,1},{2,1},{3,1}},
		{{1,0},{1,1},{1,2},{1,3}},{{1,0},{1,-1},{1,-2},{1,-3}},
		{{0,-1},{-1,-1},{-2,-1},{-3,-1}},{{0,1},{-1,1},{-2,1},{-3,1}},
		{{-1,0},{-1,1},{-1,2},{-1,3}},{{-1,-3},{-1,-2},{-1,-1},{-1,0}}
};

const int R=60*55+19,C=67+19;
struct node;typedef node* nd;
struct node
{
	nd L,R,U,D,col;
	int sz,row;
} ND[R*C];
nd Col[C],Row[R],rt;
int Len[60],B[60],RID[55][2],cnt,a,b,c;
char s[11][11];
 
int ID(int x,int y) {return x*(x+1)/2+y;}	   //0..54
int IDx(int t,int x,int y) {return t*55+ID(x,y)+1;} //1..60*55
int IDy(int t,int x,int y) {return (!t?x:ID(x,y)+12)+1;}	//1..12,13..67
void reIDx(int x,int &a,int &b,int &c) {x--;b=RID[x%55][0],c=RID[x%55][1],a=x/55;}
 
inline void Bel(int L,int R,int x) {Rep(i,L,R) B[i]=x;}
int check(int t,int x,int y)
{
	int f=s[x][y];
	if (f!='.'&&f!=B[t]+'A'-1) return 0;
	for (int i=0;i<Len[t];i++)
	{
		int xx=x+A[t][i][0],yy=y+A[t][i][1];
		if (xx<0||xx>9||yy<0||yy>9||xx<yy) return 0;
		if (s[xx][yy]!=f) return 0;
	}
	return 1;
}
 
void Add_node(int r,int c)
{
	nd x=&ND[++cnt];x->row=r;x->col=Col[c];
	if (Row[r]==0) {Row[r]=x;x->L=x->R=x;}
	Row[r]->L->R=x,x->L=Row[r]->L,x->R=Row[r],Row[r]->L=x;
	Col[c]->U->D=x,x->U=Col[c]->U,x->D=Col[c],Col[c]->U=x,Col[c]->sz++;
}
void remove(nd x)
{
	x->L->R=x->R;x->R->L=x->L;
	for (nd i=x->D;i!=x;i=i->D)
		for (nd j=i->R;j!=i;j=j->R) j->U->D=j->D,j->D->U=j->U,j->col->sz--;
}
void remuse(nd x)
{
	for (nd i=x->U;i!=x;i=i->U)
		for (nd j=i->R;j!=i;j=j->R) j->U->D=j->D->U=j,j->col->sz++;
	x->L->R=x->R->L=x;
}
int Dancing()
{
	if (rt->R==rt) return 1;
	int Min=1<<30;nd x;
	for (nd i=rt->R;i!=rt;i=i->R) if (i->sz<Min) Min=i->sz,x=i;
	remove(x);
	for (nd i=x->D;i!=x;i=i->D)
	{
		reIDx(i->row,a,b,c);s[b][c]=B[a]+'A'-1;
		for (int j=0;j<Len[a];j++) s[b+A[a][j][0]][c+A[a][j][1]]=B[a]+'A'-1;
		for (nd j=i->R;j!=i;j=j->R) remove(j->col);
		if (Dancing()) return 1;
		for (nd j=i->L;j!=i;j=j->L) remuse(j->col);
		reIDx(i->row,a,b,c);s[b][c]=0;
		for (int j=0;j<Len[a];j++) s[b+A[a][j][0]][c+A[a][j][1]]=0;
	}
	remuse(x);
	return 0;
}
 
int main()
{
	Bel(0,3,1),Bel(4,5,2),Bel(6,13,3),
	Bel(15,18,5),Bel(19,26,6),Bel(27,30,7),
	Bel(31,38,8),Bel(39,46,9),Bel(48,51,11),Bel(52,59,12);B[47]=10,B[14]=4;
	Rep(i,0,3) Len[i]=2;Rep(i,4,14) Len[i]=3;Rep(i,15,59) Len[i]=4;
	 
	rt=Col[0]=&ND[0];
	for (int i=1;i<=67;i++)  Col[i]=&ND[i];
	for (int i=1;i<=67;i++) 
		Col[i]->L=Col[i-1],Col[i]->R=Col[i+1],
		Col[i]->U=Col[i]->D=Col[i],Col[i]->sz=0;
	rt->L=Col[67],rt->R=Col[1],Col[cnt=67]->R=rt;
	 
	Rep(i,0,9) scanf("%s",s[i]);
	Rep(i,0,9) Rep(j,0,i) RID[ID(i,j)][0]=i,RID[ID(i,j)][1]=j;
	Rep(k,0,59) Rep(i,0,9) Rep(j,0,i)
		if (check(k,i,j))
		{
			int r=IDx(k,i,j);
			Add_node(r,IDy(0,B[k]-1,0));
			Add_node(r,IDy(1,i,j));
			for (int x=0;x<Len[k];x++)
				Add_node(r,IDy(1,i+A[k][x][0],j+A[k][x][1]));
		}
	if (!Dancing()) puts("No solution");else Rep(i,0,9) puts(s[i]);
}
Problem1503
#include<cstdio>
#include<cctype>
using namespace std;

int n,Min,c,d,x,Delta=0;

namespace SBT
{
	const int Maxn=100000+19;
	int Lsn[Maxn],Rsn[Maxn],s[Maxn],key[Maxn];
	int Tree_Size=0,Root=0;
	
	void Right_Rotate(int &t) 
	{
		int k=Lsn[t];Lsn[t]=Rsn[k];Rsn[k]=t;
		s[k]=s[t];s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
		t=k;
	}
	void Left_Rotate(int &t) 
	{
		int k=Rsn[t];Rsn[t]=Lsn[k];Lsn[k]=t;
		s[k]=s[t];s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
		t=k;
	}
	void Maintain(int &t,int Flag) 
	{
		if (!Flag)
		{
			if (s[Lsn[Lsn[t]]]>s[Rsn[t]]) Right_Rotate(t);
				else 
			if (s[Rsn[Lsn[t]]]>s[Rsn[t]]) Left_Rotate(Lsn[t]),Right_Rotate(t);
				else return;
		} else
		{
			if (s[Rsn[Rsn[t]]]>s[Lsn[t]]) Left_Rotate(t);
				else
			if (s[Lsn[Rsn[t]]]>s[Lsn[t]]) Right_Rotate(Rsn[t]),Left_Rotate(t);
				else return;
		}
		Maintain(Lsn[t],0);Maintain(Rsn[t],1);
		Maintain(t,1);Maintain(t,0);	//
	}
	void Insert(int &t,int x) 
	{
		if (!t) 
		{
			t=++Tree_Size;
			key[t]=x;Lsn[t]=Rsn[t]=0;s[t]=1;
		} else
		{
			s[t]++;
			Insert(x<key[t]?Lsn[t]:Rsn[t],x);
			Maintain(t,x>=key[t]);
		}
	}
	int Delete(int &t,int v)
	{
		s[t]--;
		if (key[t]==v || v<key[t]&&!Lsn[t] || v>key[t]&&!Rsn[t])
		{
			int Del=key[t];
			if (!Lsn[t]||!Rsn[t]) t=Lsn[t]+Rsn[t];
				else key[t]=Delete(Lsn[t],key[t]+1);
			return Del;
		}
		return Delete(v<key[t]?Lsn[t]:Rsn[t],v);
	}
	void Delete(int &t) 
	{
		if (!t) return;
		if (key[t]+Delta<Min) t=Rsn[t],Delete(t);
			else Delete(Lsn[t]),s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
	}
	int Select(int &t,int kth) 
	{
		if (kth==s[Lsn[t]]+1) return key[t];
		if (kth<s[Lsn[t]]+1) return Select(Lsn[t],kth);
			else return Select(Rsn[t],kth-s[Lsn[t]]-1);
	}
};

int main()
{
	scanf("%d%d",&n,&Min);
	for (int i=0;i<n;i++)
	{
		x=0;
		while (!isalpha(c=getchar()));getchar();
		while (isdigit(d=getchar())) x=x*10+d-'0';
		if (c=='I') 
			if (x>=Min) SBT::Insert(SBT::Root,x-Delta);
		if (c=='A') Delta+=x;
		if (c=='S')	Delta-=x,SBT::Delete(SBT::Root);
		if (c=='F') 
		{
			int tmp=SBT::s[SBT::Root];
			if (x>tmp) printf("-1\n");
				else printf("%d\n",SBT::Select(SBT::Root,tmp-x+1)+Delta);
		}
	}
	printf("%d\n",SBT::Tree_Size-SBT::s[SBT::Root]);
	return 0;
}
Problem1503
#include<cstdio>
#include<cctype>
using namespace std;

int n,Min,c,d,x,Delta=0;

void Write(int x)
{
	if (x>=10) Write(x/10);
	putchar(x%10+'0');
}

namespace SBT
{
	const int Maxn=100000+19;
	int Lsn[Maxn],Rsn[Maxn],s[Maxn],key[Maxn];
	int Tree_Size=0,Root=0;
	
	void Right_Rotate(int &t) 
	{
		int k=Lsn[t];Lsn[t]=Rsn[k];Rsn[k]=t;
		s[k]=s[t];s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
		t=k;
	}
	void Left_Rotate(int &t) 
	{
		int k=Rsn[t];Rsn[t]=Lsn[k];Lsn[k]=t;
		s[k]=s[t];s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
		t=k;
	}
	void Maintain(int &t,int Flag) 
	{
		if (!Flag)
		{
			if (s[Lsn[Lsn[t]]]>s[Rsn[t]]) Right_Rotate(t);
				else 
			if (s[Rsn[Lsn[t]]]>s[Rsn[t]]) Left_Rotate(Lsn[t]),Right_Rotate(t);
				else return;
		} else
		{
			if (s[Rsn[Rsn[t]]]>s[Lsn[t]]) Left_Rotate(t);
				else
			if (s[Lsn[Rsn[t]]]>s[Lsn[t]]) Right_Rotate(Rsn[t]),Left_Rotate(t);
				else return;
		}
		Maintain(Lsn[t],0);Maintain(Rsn[t],1);
		Maintain(t,1);Maintain(t,0);	//
	}
	void Insert(int &t,int x) 
	{
		if (!t) 
		{
			t=++Tree_Size;
			key[t]=x;Lsn[t]=Rsn[t]=0;s[t]=1;
		} else
		{
			s[t]++;
			Insert(x<key[t]?Lsn[t]:Rsn[t],x);
			Maintain(t,x>=key[t]);
		}
	}
	int Delete(int &t,int v)
	{
		s[t]--;
		if (key[t]==v || v<key[t]&&!Lsn[t] || v>key[t]&&!Rsn[t])
		{
			int Del=key[t];
			if (!Lsn[t]||!Rsn[t]) t=Lsn[t]+Rsn[t];
				else key[t]=Delete(Lsn[t],key[t]+1);
			return Del;
		}
		return Delete(v<key[t]?Lsn[t]:Rsn[t],v);
	}
	void Delete(int &t) 
	{
		if (!t) return;
		if (key[t]+Delta<Min) t=Rsn[t],Delete(t);
			else Delete(Lsn[t]),s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
	}
	int Select(int &t,int kth) 
	{
		if (kth==s[Lsn[t]]+1) return key[t];
		if (kth<s[Lsn[t]]+1) return Select(Lsn[t],kth);
			else return Select(Rsn[t],kth-s[Lsn[t]]-1);
	}
};

int main()
{
	scanf("%d%d",&n,&Min);
	for (int i=0;i<n;i++)
	{
		x=0;
		while (!isalpha(c=getchar()));getchar();
		while (isdigit(d=getchar())) x=x*10+d-'0';
		if (c=='I') 
			if (x>=Min) SBT::Insert(SBT::Root,x-Delta);
		if (c=='A') Delta+=x;
		if (c=='S')	Delta-=x,SBT::Delete(SBT::Root);
		if (c=='F') 
		{
			int tmp=SBT::s[SBT::Root];
			if (x>tmp) printf("-1\n");
				else Write(SBT::Select(SBT::Root,tmp-x+1)+Delta),putchar('\n');
		}
	}
	printf("%d\n",SBT::Tree_Size-SBT::s[SBT::Root]);
	return 0;
}
Problem1507
#include<cstdio>
#include<cctype>
#include<algorithm>
#define Fir first
#define Sec second
using namespace std;

const int Maxn=5000000+19;
struct Treap;typedef Treap* rt;
struct Treap
{
	rt L,R;
	int fix,ch,size;
	Treap():fix(rand()),size(1),L(0),R(0) {}
	int sz() {return this?size:0;}
	void Update() {size=L->sz()+R->sz()+1;}
} treap[Maxn];int tcnt;rt RT;
typedef pair<rt,rt> Drt;

rt Merge(rt A,rt B)
{
	if (!A) return B;if (!B) return A;
	if (A->fix<B->fix) return A->R=Merge(A->R,B),A->Update(),A;
		else return B->L=Merge(A,B->L),B->Update(),B;
}
Drt Split(rt A,int k)
{
	if (!A) return Drt();
	Drt x;
	if (A->L->sz()>=k) x=Split(A->L,k),A->L=x.Sec,A->Update(),x.Sec=A;
		else x=Split(A->R,k-A->L->sz()-1),A->R=x.Fir,A->Update(),x.Fir=A;
	return x;
}
void print(rt A) {if (!A) return;print(A->L),putchar(A->ch),print(A->R);}
void Print(int v,int k)
{
	Drt x=Split(RT,v),y=Split(x.Sec,k);
	print(y.Fir);
	RT=Merge(Merge(x.Fir,y.Fir),y.Sec);
}
void Insert(rt A,int v)
{
	Drt x=Split(RT,v);
	RT=Merge(Merge(x.Fir,A),x.Sec);
}
void Delete(int v,int k)
{
	k=min(k,RT->sz()-v);
	Drt x=Split(RT,v),y=Split(x.Sec,k);
	RT=Merge(x.Fir,y.Sec);
}

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int Q,pos,k,ch;
char s[10];

int main()
{
	read(Q);
	while (Q--)
	{
		scanf("%s",s);
		if (s[0]=='M') read(pos);else
		if (s[0]=='I')
		{
			read(k);
			rt x=0;
			for (int i=pos;i<pos+k;i++)
			{
				while ((ch=getchar())<32||ch>126);
				rt y=&treap[++tcnt];y->ch=ch;x=Merge(x,y);
			}
			Insert(x,pos);
		} else
		if (s[0]=='D') read(k),Delete(pos,k);else
		if (s[0]=='G') read(k),Print(pos,k),puts("");else
		if (s[0]=='P') pos--;else pos++;
	}
}
Problem1507
#include<cmath>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Rep(i,x,y) for (int i=x;i<=y;i++)
#define Fir first
#define Sec second
using namespace std;

int IN()
{
	char c;int x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

//Block_Chain
const int Sz=2500,Max=Sz*2,Min=Sz/2,Top=3000;
struct node *null;
struct node
{
	char s[Max*2];int S;
	node *L,*R;
	node() {}
	node(int _S) {S=_S,s[S+1]=0;}
} B[Top],*St[Top],*Fir;
typedef pair<node*,node*> Seq;
int t,cur,x,k,T,c,d;

node *New(int S) {return *St[t]=node(S),St[t--];}
void Del(node *A) {St[++t]=A;}
void Link(node *A,node *B) {if (A!=null) A->R=B;if (B!=null) B->L=A;}
void Split(node *A,int k)
{
//	if (!k||k==A->S) return;
	node *C=A->R,*B=New(A->S-k);
	Rep(i,k+1,A->S) B->s[i-k]=A->s[i];
	A->S=k;Link(A,B),Link(B,C);
}
void Merge(node *A)
{
	node *B=A->R;
//	if (B==null) return;
	Rep(i,1,B->S) A->s[i+A->S]=B->s[i];
	A->S+=B->S;Link(A,B->R);Del(B);
}
void Balance()
{
	for (node *i=Fir;i!=null;i=i->R)
		while ((i->S<Min&&i->R!=null)||i->S>Max)
			if (i->S<Min) Merge(i);else Split(i,Sz);
}
Seq Getseq(int L,int R)
{
	Seq Res;node *i;
	for (i=Fir,x=L-1;x>i->S;x-=i->S,i=i->R);
	Split(i,x);Res.Fir=i->R;
	for (i=i->R,x=R-L+1;x>i->S;x-=i->S,i=i->R);
	Split(i,x);Res.Sec=i->R;return Res;
}
void Delete()
{
	node *i;k=IN();
	Seq tmp=Getseq(cur+1,cur+k);
	Link(tmp.Fir->L,tmp.Sec);
	for (i=tmp.Fir;i!=tmp.Sec;i=i->R) Del(i);
	Balance();
}
void Insert()
{
	k=IN();node *F=New(0),*A=F,*i;
	For(i,0,k)
	{
		int c;
		while ((c=getchar())<32||c>126);
		if (A->S==Sz) {node *B=New(0);Link(A,B),A=B;}
		A->s[++A->S]=c;
	}
	for (i=Fir,x=cur;x>i->S;x-=i->S,i=i->R);
	Split(i,x),Link(A,i->R),Link(i,F);
	if (!cur) Fir=F;
//	Balance();
}
void Print()
{
	node *i;k=IN();
	if (k==1)
	{
		for (i=Fir,x=cur+1;x>i->S;x-=i->S,i=i->R);
		printf("%c\n",i->s[x]);
	} else
	{
		Seq tmp=Getseq(cur+1,cur+k);
		for (i=tmp.Fir;i!=tmp.Sec;i=i->R) For(j,1,i->S+1) putchar(i->s[j]);
		puts("");
		Balance();
	}
}

int main()
{
	Fir=null=B;For(i,1,Top) St[++t]=B+i;null->L=null->R=null;
	for (T=IN();T--;)
	{
		while ((c=getchar())!='M'&&c!='I'&&c!='D'&&c!='G'&&c!='P'&&c!='N');
		if (c=='M') cur=IN();
		if (c=='I') Insert();
		if (c=='D') Delete();
		if (c=='G') Print();
		if (c=='P') cur--;
		if (c=='N') cur++;
	}
}
Problem1526
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000+19,oo=(1<<30)-1;
struct node
{
	char x;short nxt[10];
	node(char _x) {x=_x;}
};vector<node> V[N];
char s[10000+19];
int n,t,Ans;

bool Run(int i,int a,int b,int c,int d)
{
	int x=0;
	x=V[i][x].nxt[a];if (x>=V[i].size()) return 0;
	x=V[i][x].nxt[b];if (x>=V[i].size()) return 0;
	x=V[i][x].nxt[c];if (x>=V[i].size()) return 0;
	x=V[i][x].nxt[d];if (x>=V[i].size()) return 0;
	return 1;
}
bool Check(int x)
{
	For(i,1,n+1) if (!Run(i,x/1000,x/100%10,x/10%10,x%10)) return 0;
	return 1;
}

int main()
{
	n=IN();
	For(i,1,n+1)
	{
		t=IN();scanf("%s",s);
		For(j,0,t) V[i].Pb(node(s[j]-'0'));
	}
	For(i,1,n+1)
		for (int j=V[i].size()-1;~j;j--)
		{
			For(k,0,10) V[i][j].nxt[k]=(j==V[i].size()-1)?oo:V[i][j+1].nxt[k];
			V[i][j].nxt[V[i][j].x]=j;
		}
	For(i,0,10000) if (Check(i)) Ans++;
	printf("%d\n",Ans);
}
Problem1526
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000+19,oo=(1<<30)-1;
struct node
{
	char x;short nxt[10];
	node(char _x) {x=_x;}
};vector<node> V[N];
char s[10000+19];
int n,t,Ans;

bool Run(short i,char a,char b,char c,char d)
{
	short x=0;
	x=V[i][x].nxt[a];if (x>=V[i].size()) return 0;
	x=V[i][x].nxt[b];if (x>=V[i].size()) return 0;
	x=V[i][x].nxt[c];if (x>=V[i].size()) return 0;
	x=V[i][x].nxt[d];if (x>=V[i].size()) return 0;
	return 1;
}
bool Check(short x)
{
	For(i,1,n+1) if (!Run(i,x/1000,x/100%10,x/10%10,x%10)) return 0;
	return 1;
}

int main()
{
	n=IN();
	For(i,1,n+1)
	{
		t=IN();scanf("%s",s);
		For(j,0,t) V[i].Pb(node(s[j]-'0'));
	}
	For(i,1,n+1)
		for (int j=V[i].size()-1;~j;j--)
		{
			For(k,0,10) V[i][j].nxt[k]=(j==V[i].size()-1)?oo:V[i][j+1].nxt[k];
			V[i][j].nxt[V[i][j].x]=j;
		}
	For(i,0,10000) if (Check(i)) Ans++;
	printf("%d\n",Ans);
}
Problem1528
#include<cstdio>
#include<cctype>
#include<queue>
using namespace std;

const int Maxn=100000+19,MaxQ=500000+19,oo=(1<<30)-1;
struct toy
{
	int ID,nxt;
	bool operator < (const toy& B) const {return nxt<B.nxt;}
};
priority_queue<toy> Q;
int Last[Maxn],inH[Maxn],nxt[MaxQ],A[MaxQ];
int n,k,p,x,Ans;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	read(n),read(k),read(p);
	for (int i=1;i<=p;i++) read(A[i]);
	for (int i=1;i<=n;i++) Last[i]=oo;
	for (int i=p;i;i--) nxt[i]=Last[A[i]],Last[A[i]]=i;
	for (int i=1;i<=p;i++)
		if (inH[A[i]]) Q.push((toy){A[i],nxt[i]});
			else
			{
				Ans++;
				if (!k) inH[Q.top().ID]=0,Q.pop();else k--;
				Q.push((toy){A[i],nxt[i]}),inH[A[i]]=1;
			}
	printf("%d\n",Ans);
}
Problem1529
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=1000000+19;
int Fa[Maxn],n,x,Ans;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int getf(int x) {return Fa[x]==x?x:Fa[x]=getf(Fa[x]);}

int main()
{
	read(n);
	for (int i=1;i<=n;i++) Fa[i]=i;
	for (int i=1;i<=n;i++)
	{
		read(x);
		int Fx=getf(x),Fy=getf(i);
		if (Fx!=Fy) Fa[Fx]=Fy;
	}
	for (int i=1;i<=n;i++) Ans+=(Fa[i]==i);
	printf("%d\n",Ans);
}
Problem1531
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=200*15+19;
int w[Maxn],v[Maxn],b[219],c[219],f[20000+19];
int n,tot,k;

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&b[i]);
	for (int i=1;i<=n;i++) scanf("%d",&c[i]);
	scanf("%d",&k);
	for (int i=1;i<=n;i++)
	{
		for (int j=0;(1<<j+1)-1<=c[i];j++) tot++,v[tot]=(1<<j),w[tot]=b[i]*(1<<j);
		if (c[i]-v[tot]) tot++,v[tot]=c[i]-v[tot-1],w[tot]=b[i]*v[tot];
	}
	memset(f,60,sizeof(f));f[0]=0;
	for (int i=1;i<=tot;i++)
		for (int j=k;j>=w[i];j--) f[j]=min(f[j],f[j-w[i]]+v[i]);
	printf("%d\n",f[k]);
}
Problem1532
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>

#define Mid (L+R>>1)
using namespace std;

const int Maxn=20000+19,oo=(1<<30)-1;
typedef int one[Maxn];
struct Edge {int y,f,nxt;} E[Maxn*4*2];
one x,y,Last,Q,Dis;
int S,T,n,m,L,R,res,cnt,Flow,f,w;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

inline int BFS()
{
	f=1,w=0;Q[1]=S;
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
inline int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&Dis[x]+1==Dis[E[i].y])
		{
			int tmp=Dinic(E[i].y,min(E[i].f,Flow));
			Flow-=tmp;res+=tmp;
			E[i].f-=tmp;E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}
inline int check(int t)
{
	memset(Last,-1,sizeof(Last));cnt=Flow=0;
	for (int i=0;i<m;i++) Add_Edge(i,x[i]+m-1,1),Add_Edge(i,y[i]+m-1,1);
	for (int i=0;i<m;i++) Add_Edge(S,i,1);
	for (int i=0;i<n;i++) Add_Edge(i+m,T,t);
	while (BFS()) Flow+=Dinic(S,oo);
	return Flow==m;
}

int main()
{
	read(n),read(m);S=n+m;T=S+1;
	for (int i=0;i<m;i++) read(x[i]),read(y[i]);
	L=0,R=m;
	while (L<=R) if (check(Mid)) res=Mid,R=Mid-1;else L=Mid+1;
	printf("%d\n",res);
}
Problem1533
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000000+19;
bool st;
int Q[2*N],A[2*N],B[2*N],a[N],b[N],L,R,n;
bool v1[N],v2[N];
bool ed;

void Solve(bool *v)
{
	For(i,1,2*n) A[i]+=A[i-1],B[i]+=B[i-1];
	For(i,1,2*n) A[i]-=B[i];
	L=1,R=0;
	For(i,1,n)
	{
		while (L<=R&&A[i]<=A[Q[R]]) R--;
		Q[++R]=i;
	}
	For(i,n,2*n)
	{
		while (L<=R&&Q[L]<i-n+1) L++;
		while (L<=R&&A[i]<=A[Q[R]]) R--;
		Q[++R]=i;
		if (A[Q[L]]>=A[i-n]) v[i-n+1]=1;
	}
}

int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
//	printf("%d\n",((&ed)-(&st))/1000/1000);
	n=IN();
	For(i,1,n+1) a[i]=IN(),b[i]=IN();
	For(i,1,n+1) A[i]=A[i+n]=a[i],B[i]=B[i+n]=b[i];
	Solve(v1);
	For(i,1,n+1) A[i]=A[i+n]=a[n-i+1],B[i]=B[i+n]=b[n-i];
	B[n]=b[n];
	Solve(v2);
	For(i,1,n+1) puts(v1[i]||v2[n-i+1]?"TAK":"NIE");
}
Problem1533
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000000+19;
bool st;
int Q[2*N],A[2*N],B[2*N],a[N],b[N],L,R,n;
bool v[N];
bool ed;

void Solve(int f)
{
	For(i,1,2*n) A[i]+=A[i-1],B[i]+=B[i-1];
	For(i,1,2*n) A[i]-=B[i];
	L=1,R=0;
	For(i,1,n)
	{
		while (L<=R&&A[i]<=A[Q[R]]) R--;
		Q[++R]=i;
	}
	For(i,n,2*n)
	{
		while (L<=R&&Q[L]<i-n+1) L++;
		while (L<=R&&A[i]<=A[Q[R]]) R--;
		Q[++R]=i;
		if (A[Q[L]]>=A[i-n]) !f?(v[i-n+1]=1):(v[n-(i-n+1)+1]=1);
	}
}

int main()
{
	n=IN();
	For(i,1,n+1) a[i]=IN(),b[i]=IN();
	For(i,1,n+1) A[i]=A[i+n]=a[i],B[i]=B[i+n]=b[i];
	Solve(0);
	For(i,1,n+1) A[i]=A[i+n]=a[n-i+1],B[i]=B[i+n]=b[n-i];
	B[n]=b[n];
	Solve(1);
	For(i,1,n+1) puts(v[i]?"TAK":"NIE");
}
Problem1537
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1e5+19,Top=5000000,oo=(1<<30)-1;
struct node
{
	int x,y,v;
	bool operator < (const node& B) const {return x>B.x||x==B.x&&y>B.y;}
} A[N];
int Max[Top],Lsn[Top],Rsn[Top],Ql,Qx,Qv,tmp,Ans,n,m,k,tot,rt;

void Update(int &x,int L,int R)
{
	if (!x) x=++tot;
	if (L==R) {Max[x]=Qv;return;}
	Qx<=Mid?Update(Lsn[x],L,Mid):Update(Rsn[x],Mid+1,R);
	Max[x]=max(Max[Lsn[x]],Max[Rsn[x]]);
}
int Query(int x,int L,int R)
{
	if (!x) return 0;
	if (Ql<=L) return Max[x];
	int tmp=Query(Rsn[x],Mid+1,R);
	if (Ql<=Mid) tmp=max(tmp,Query(Lsn[x],L,Mid));
	return tmp;
}

int main()
{
	n=IN(),m=IN(),k=IN();
	For(i,1,k+1) A[i]=(node){IN(),IN(),IN()};
	sort(A+1,A+k+1);
	For(i,1,k+1)
		Ql=Qx=A[i].y,Ans=max(Ans,Qv=Query(rt,1,m)+A[i].v),Update(rt,1,m);
	printf("%d\n",Ans);
}
Problem1552
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=100000+19;
struct things
{
	int key,ID;
	bool operator < (const things& B) const {return key<B.key||key==B.key&&ID<B.ID;}
} S[N];
int A[N],n,L,R;

struct node;node *null,*rt;
struct node
{
	node *L,*R,*Fa;
	int rev,S;
	
	void Setrev() {rev^=1,swap(L,R);}
	void Down() {if (rev) L->Setrev(),R->Setrev(),rev=0;}
	void Update()
	{
		if (this==null) return;
		S=L->S+R->S+1;
	}
	
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (z->L==y) z->L=this;else z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (z->L==y) z->L=this;else z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N];

void Splay(node *x,node *Aim)
{
	static node *S[N];
	node *tmp=x;int k=0;
	while (tmp->Fa!=Aim) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (x->Fa!=Aim)
	{
		node *y=x->Fa,*z=y->Fa;
		if (y->Fa!=Aim)
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
	if (Aim==null) rt=x;
}
node *Findkth(node *x,int k)
{
	x->Down();
	if (x->L->S+1==k) return x;
	return x->L->S+1>k?Findkth(x->L,k):Findkth(x->R,k-x->L->S-1);
}

int main()
{
	null=Nd;
	read(n);
	For(i,0,n+1) Nd[i]=(node){null,null,null,0,1};
	For(i,1,n+1) read(S[i].key),S[i].ID=i;
	sort(S+1,S+n+1);
	For(i,1,n+1) A[S[i].ID]=i;
	For(i,1,n+1) Nd[A[i-1]].R=Nd+A[i],Nd[A[i]].Fa=Nd+A[i-1],Nd[A[i]].S=n-i+1;
	null->S=0,null->R=null;rt=Nd+A[1];
	For(i,1,n+1)
	{
		Splay(Nd+i,null);
		printf("%d%c",R=rt->L->S+1," \n"[i==n]);
		L=i;
		if (L==1&&R==n) rt->Setrev();else
			if (L==1) Splay(Findkth(rt,R+1),null),rt->L->Setrev();else
			if (R==n) Splay(Findkth(rt,L-1),null),rt->R->Setrev();else
				Splay(Findkth(rt,L-1),null),Splay(Findkth(rt,R+1),rt),rt->R->L->Setrev();
	}
}
Problem1552
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=100000+19;
struct things
{
	int key,ID;
	bool operator < (const things& B) const {return key<B.key||key==B.key&&ID<B.ID;}
} S[N];
int A[N],n,L,R;

struct node;node *null,*rt;
struct node
{
	node *L,*R,*Fa;
	int rev,S;
	
	void Setrev() {rev^=1,swap(L,R);}
	void Down() {if (rev) L->Setrev(),R->Setrev(),rev=0;}
	void Update()
	{
		if (this==null) return;
		S=L->S+R->S+1;
	}
	
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (z->L==y) z->L=this;else z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (z->L==y) z->L=this;else z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N];

void Splay(node *x,node *Aim)
{
	static node *S[N];
	node *tmp=x;int k=0;
	while (tmp->Fa!=Aim) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (x->Fa!=Aim)
	{
		node *y=x->Fa,*z=y->Fa;
		if (y->Fa!=Aim)
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
	if (Aim==null) rt=x;
}
node *Findkth(node *x,int k)
{
	x->Down();
	if (x->L->S+1==k) return x;
	return x->L->S+1>k?Findkth(x->L,k):Findkth(x->R,k-x->L->S-1);
}
void Build(int L,int R,node *Fa,bool f)
{
	if (L>R) return;
	node *t=Nd+A[Mid];
	t->Fa=Fa;
	if (Fa!=null) if (!f) Fa->L=t;else Fa->R=t;else rt=t;
	Build(L,Mid-1,t,0);
	Build(Mid+1,R,t,1);
	t->S=t->L->S+t->R->S+1;
}

int main()
{
	null=Nd;
	read(n);
	For(i,0,n+1) Nd[i]=(node){null,null,null,0,1};
	null->S=0;
	For(i,1,n+1) read(S[i].key),S[i].ID=i;
	sort(S+1,S+n+1);
	For(i,1,n+1) A[S[i].ID]=i;
	Build(1,n,null,0);
	For(i,1,n+1)
	{
		Splay(Nd+i,null);
		printf("%d%c",R=rt->L->S+1," \n"[i==n]);
		L=i;
		if (L==1&&R==n) rt->Setrev();else
			if (L==1) Splay(Findkth(rt,R+1),null),rt->L->Setrev();else
			if (R==n) Splay(Findkth(rt,L-1),null),rt->R->Setrev();else
				Splay(Findkth(rt,L-1),null),Splay(Findkth(rt,R+1),rt),rt->R->L->Setrev();
	}
}
Problem1565
#include<set>
#include<map>
#include<cmath>
#include<string>
#include<cstdio>
#include<vector>
#include<cctype>
#include<cstdlib>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double Db;
typedef pair<int,int> pii;


const int N=600+19,M=5000000,oo=(1<<30)-1;
typedef int one[N];
struct Edge {int y,f,nxt;} E[M];
one Last,Q,Dis,can,In,v;
int n,m,s,c,x,y,S,T,cnt,Ans;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
	In[x]++;
}
void Toposort()
{
	int f=0,w=0;
	For(i,1,T+1) if (!In[i]) Q[++f]=i;
	while (f>w)
	{
		int x=Q[++w];
		can[x]=1;if (v[x]>0) Ans+=v[x];
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if (i&1) if (--In[y=E[i].y]==0) Q[++f]=y;
	}
}
bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=0;
	int f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if (E[i].f&&Dis[y=E[i].y]==-1&&can[y]) Dis[y]=Dis[x]+1,Q[++f]=y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (E[i].f&&Dis[y=E[i].y]==Dis[x]+1&&can[y])
		{
			int tmp=Dinic(y,min(E[i].f,Flow));
			E[i].f-=tmp,E[i^1].f+=tmp,Flow-=tmp,res+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	S=n*m,T=S+1;
	For(i,0,n) For(j,0,m)
	{
		v[i*m+j]=s=IN();
		if (s<0) Add_Edge(i*m+j,T,-s);else Add_Edge(S,i*m+j,s);
		for (int c=IN();c--;) x=IN(),y=IN(),Add_Edge(x*m+y,i*m+j,oo);
		if (j!=m-1) Add_Edge(i*m+j,i*m+j+1,oo);
	}
	Toposort();
	while (BFS()) Ans-=Dinic(S,oo);
	printf("%d\n",Ans);
}
Problem1567
#include<cstdio>

#define For(i,x,y) for (int i=x;i<=y;i++)
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))

const int N=51;
int A[N][N],B[N][N],F[N][N][N][N],Ans,n;

int main()
{
	scanf("%d",&n);
	For(i,1,n) For(j,1,n) scanf("%d",&A[i][j]);
	For(i,1,n) For(j,1,n) scanf("%d",&B[i][j]);
	For(i,1,n) For(j,1,n) For(k,1,n) For(l,1,n)
		if (A[i][j]==B[k][l])
			F[i][j][k][l]=min(min(F[i-1][j][k-1][l],F[i][j-1][k][l-1]),F[i-1][j-1][k-1][l-1])+1,
			Ans=max(Ans,F[i][j][k][l]);
	printf("%d\n",Ans);
}
Problem1572
#include<map>
#include<set>
#include<queue>
#include<ctime>
#include<vector>
#include<cstdio>
#include<string>
#include<cstdlib>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
#define Mp make_pair
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19;
struct node
{
	int t,v;
	bool operator < (const node& B) const {return t<B.t;}
} A[N];
priority_queue<int,vector<int>,greater<int> > Q;
int n;
long long Ans;

int main()
{
	n=IN();
	For(i,1,n+1) A[i]=(node){IN(),IN()};
	sort(A+1,A+n+1);
	For(i,1,n+1)
		if (A[i].t>Q.size()) Q.push(A[i].v);
			else if (A[i].v>Q.top()) Q.pop(),Q.push(A[i].v);
	while (!Q.empty()) Ans+=Q.top(),Q.pop();
	printf("%lld\n",Ans);
}
Problem1576
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

typedef long long LL;
typedef double Db;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=100000+19,M=200000+19;
struct node
{
	int ID,Dis;
	bool operator < (const node &B) const {return Dis>B.Dis;}
};priority_queue<node> Q;
struct Edge {int y,z,nxt;} E[M*2];
typedef int one[N];
one Dep,Dis,Fa,Ans,Last,pre,vis;
int n,m,x,y,z,cnt;

struct __Edge
{
	int x,y,z;
	bool operator < (const __Edge &B) const
	{
		return Dis[x]+Dis[y]+z<Dis[B.x]+Dis[B.y]+B.z;
	}
} __E[M];

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}
void Dijkstra()
{
	memset(Dis,60,sizeof(Dis));Dis[1]=0;
	Q.push((node){1,0});
	For(i,1,n+1)
	{
		int x,D;
		while (vis[Q.top().ID]) Q.pop();
		vis[x=Q.top().ID]=1,D=Q.top().Dis;Q.pop();
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if (!vis[y=E[i].y]&&D+E[i].z<Dis[y])
			{
				Dis[y]=D+E[i].z,Dep[y]=Dep[x]+1,pre[y]=i;
				Q.push((node){y,Dis[y]});
			}
	}
}

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}

int main()
{
	memset(Last,-1,sizeof(Last));
	memset(Ans,-1,sizeof(Ans));
	n=IN(),m=IN();
	For(i,0,m) x=IN(),y=IN(),z=IN(),Link(x,y,z),__E[i]=(__Edge){x,y,z};
	Dijkstra();
	sort(__E,__E+m);
	For(i,1,n+1) Fa[i]=i;
	For(i,0,m)
	{
		x=__E[i].x,y=__E[i].y,z=__E[i].z;
		if (Dis[x]+z==Dis[y]||Dis[y]+z==Dis[x]) continue;
		int key=Dis[x]+Dis[y]+z;
		while ((x=Getf(x))!=(y=Getf(y)))
		{
			if (Dep[x]>Dep[y]) swap(x,y);
			Ans[y]=key-Dis[y];y=Fa[y]=E[pre[y]^1].y;
		}
	}
	For(i,2,n+1) printf("%d\n",Ans[i]);
}
Problem1579
#include<map>
#include<set>
#include<queue>
#include<ctime>
#include<vector>
#include<cstdio>
#include<string>
#include<cstdlib>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
#define Mp make_pair
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=10000*25+19;
typedef long long LL;
struct Edge {int y,z,nxt;} E[100000];
LL Dis[N];int Last[N],Pos[N];
int cnt,n,m,K,x,y,z;

int ID(int x,int k) {return (x-1)*(K+1)+k;}
void reID(int v,int &x,int &k) {k=v%(K+1),x=v/(K+1)+1;}
void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}
struct Heap
{
	int n,s[N];
	void Up(int x)
	{
		while (x>1&&Dis[s[x]]<Dis[s[x>>1]])
			swap(Pos[s[x]],Pos[s[x>>1]]),swap(s[x],s[x>>1]),x>>=1;
	}
	void Dn(int x)
	{
		for (;;)
		{
			int t=x;
			if ((x<<1)<=n&&Dis[s[x<<1]]<Dis[s[t]]) t=x<<1;
			if ((x<<1|1)<=n&&Dis[s[x<<1|1]]<Dis[s[t]]) t=x<<1|1;
			if (t==x) break;swap(Pos[s[x]],Pos[s[t]]),swap(s[x],s[t]),x=t;
		}
	}
	void Ins(int x) {s[++n]=x;Pos[x]=n;Up(n);}
	int Top() {int v=s[1];Pos[s[1]=s[n--]]=1;Dn(1);return v;}
} H;

void Update(LL D,int x,int k)
{
	int t=ID(x,k);
	if (D<Dis[t]) Dis[t]=D,H.Up(Pos[t]);
}
void Dijkstra(int S)
{
	int tot=ID(n,K);
	memset(Dis,60,sizeof(Dis));Dis[S]=0;
	For(i,0,tot+1) H.Ins(i);
	while (H.n)
	{
		int t=H.Top(),x,k;
		reID(t,x,k);
		if (k<K) Update(Dis[t],x,k+1);
		for (int i=Last[x];~i;i=E[i].nxt)
		{
			Update(Dis[t]+E[i].z,E[i].y,k);
			if (k<K) Update(Dis[t],E[i].y,k+1);
		}
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN(),K=IN();
	For(i,0,m) x=IN(),y=IN(),z=IN(),Link(x,y,z);
	Dijkstra(ID(1,0));
	printf("%lld\n",Dis[ID(n,K)]);
}
Problem1588
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=35000+19,oo=(1<<30)-1;
typedef int one[Maxn];
int n,x,Ans;

int rt,cnt;
struct Splay_tree
{
	one s,key,Fa,Lsn,Rsn;
	
	inline void Update(int x) {s[x]=s[Lsn[x]]+s[Rsn[x]]+1;}
	inline void Zig(int x)
	{
		int y=Fa[x],z=Fa[y],t=Rsn[x];
		if (z) if (Lsn[z]==y) Lsn[z]=x;else Rsn[z]=x;
		Fa[y]=x;Lsn[y]=t;Fa[x]=z;Rsn[x]=y;
		if (t) Fa[t]=y;Update(y);
	}
	inline void Zag(int x)
	{
		int y=Fa[x],z=Fa[y],t=Lsn[x];
		if (z) if (Lsn[z]==y) Lsn[z]=x;else Rsn[z]=x;
		Fa[y]=x;Rsn[y]=t;Fa[x]=z;Lsn[x]=y;
		if (t) Fa[t]=y;Update(y);
	}
	inline void Splay(int x)
	{
		while (Fa[x])
		{
			int y=Fa[x],z=Fa[y];
			if (z)
				if (y==Lsn[z])
					if (x==Lsn[y]) Zig(y),Zig(x);else Zag(x),Zig(x);
				else
					if (x==Lsn[y]) Zig(x),Zag(x);else Zag(y),Zag(x);
			else if (x==Lsn[y]) Zig(x);else Zag(x);
		}
		Update(x);rt=x;
	}
	inline void Insert(int &x,int v,int F)
	{
		if (!x) {x=++cnt;key[x]=v;Fa[x]=F;return;}
		Insert(v<=key[x]?Lsn[x]:Rsn[x],v,x);
	}
	inline int Find(int v)
	{
		int x=rt;
		while (1)
		{
			if (key[x]==v) return x;
			x=(v<key[x]?Lsn[x]:Rsn[x]);
		}
	}
	inline int Pred(int x) {Splay(x);x=Lsn[x];while (Rsn[x]) x=Rsn[x];return key[x];}
	inline int Succ(int x) {Splay(x);x=Rsn[x];while (Lsn[x]) x=Lsn[x];return key[x];}
	
} Splay;

int main()
{
	scanf("%d",&n);
	Splay.Insert(rt,oo,0);
	Splay.Insert(rt,-oo,0);
	while (n--)
	{
		if (scanf("%d",&x)==EOF) x=0;
		Splay.Insert(rt,x,0);
		if (cnt==3) {Ans+=x;continue;}
		int pre=Splay.Pred(Splay.Find(x));
		int suc=Splay.Succ(Splay.Find(x));
		Ans+=min(1LL*(x-pre),1LL*(suc-x));
	}
	printf("%d\n",Ans);
}
Problem1588
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=35000+19,oo=(1<<30)-1;
typedef int one[Maxn];
int n,x,Ans;

int rt,cnt;
struct Splay_tree
{
	one s,key,Fa,Lsn,Rsn;
	
	inline void Update(int x) {s[x]=s[Lsn[x]]+s[Rsn[x]]+1;}
	inline void Zig(int x)
	{
		int y=Fa[x],z=Fa[y],t=Rsn[x];
		if (z) if (Lsn[z]==y) Lsn[z]=x;else Rsn[z]=x;
		Fa[y]=x;Lsn[y]=t;Fa[x]=z;Rsn[x]=y;
		if (t) Fa[t]=y;Update(y);
	}
	inline void Zag(int x)
	{
		int y=Fa[x],z=Fa[y],t=Lsn[x];
		if (z) if (Lsn[z]==y) Lsn[z]=x;else Rsn[z]=x;
		Fa[y]=x;Rsn[y]=t;Fa[x]=z;Lsn[x]=y;
		if (t) Fa[t]=y;Update(y);
	}
	inline void Splay(int x)
	{
		while (Fa[x])
		{
			int y=Fa[x],z=Fa[y];
			if (z)
				if (y==Lsn[z])
					if (x==Lsn[y]) Zig(y),Zig(x);else Zag(x),Zig(x);
				else
					if (x==Lsn[y]) Zig(x),Zag(x);else Zag(y),Zag(x);
			else if (x==Lsn[y]) Zig(x);else Zag(x);
		}
		Update(x);rt=x;
	}
	inline void Insert(int &x,int v,int F)
	{
		if (!x) {x=++cnt;key[x]=v;Fa[x]=F;return;}
		Insert(v<=key[x]?Lsn[x]:Rsn[x],v,x);
	}
	inline int Find(int v)
	{
		int x=rt;
		while (1)
		{
			if (key[x]==v) return x;
			x=(v<key[x]?Lsn[x]:Rsn[x]);
		}
	}
	inline int Pred(int x) 
	{
		Splay(x);x=Lsn[x];
		while (Rsn[x]) x=Rsn[x];
		Splay(x);return key[x];
	}
	inline int Succ(int x) 
	{
		Splay(x);x=Rsn[x];
		while (Lsn[x]) x=Lsn[x];
		Splay(x);return key[x];
	}
	
} Splay;

int main()
{
	scanf("%d",&n);
	Splay.Insert(rt,oo,0);
	Splay.Insert(rt,-oo,0);
	while (n--)
	{
		if (scanf("%d",&x)==EOF) x=0;
		Splay.Insert(rt,x,0);Splay.Splay(cnt);
		if (cnt==3) {Ans+=x;continue;}
		int pre=Splay.Pred(Splay.Find(x));
		int suc=Splay.Succ(Splay.Find(x));
		Ans+=min(1LL*(x-pre),1LL*(suc-x));
	}
	printf("%d\n",Ans);
}
Problem1592
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=2000+19;
typedef long long LL;
int A[N],B[N],n,c;
LL F[2][N],Ans=1LL<<60;

int main()
{
	n=IN();
	For(i,1,n+1) A[i]=B[i]=IN();
	sort(B+1,B+n+1);
	For(i,1,n+1)
	{
		c^=1;
		LL Min=1LL<<60;
		For(j,1,n+1) Min=min(Min,F[c^1][j]),F[c][j]=Min+abs(A[i]-B[j]);
	}
	For(i,1,n+1) Ans=min(Ans,F[c][i]);
	printf("%lld\n",Ans);
}
Problem1594
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000000+19;
struct Event
{
	int L,R,x;
	bool operator < (const Event& B) const {return x>B.x;}
} A[N],B[N];
int Fa[N],n,m,L,R,res;

int Getf(int x)
{
	static int S[N];int k=0;
	while (Fa[x]!=x) S[++k]=x,x=Fa[x];
	while (k) Fa[S[k--]]=x;return x;
}
bool Check(int k)
{
	For(i,1,k+1) B[i]=A[i];
	sort(B+1,B+k+1);
	For(i,1,n+2) Fa[i]=i;
	for (int i=1;i<=k;)
	{
		int L=0,R=n+1,tL=n+1,tR=0,x=B[i].x;
		while (i<=k&&B[i].x==x)
			L=max(L,B[i].L),R=min(R,B[i].R),
			tL=min(tL,B[i].L),tR=max(tR,B[i].R),i++;
		if (Getf(L)>R) return 0;
		for (int j=Getf(tL);j<=tR;j=Getf(j+1)) Fa[j]=j+1;
	}
	return 1;
}

int main()
{
	n=IN(),m=IN();
	For(i,1,m+1) A[i]=(Event){IN(),IN(),IN()};
	L=1,R=m;
	while (L<=R)
		if (Check(Mid)) res=Mid,L=Mid+1;else R=Mid-1;
	printf("%d\n",res==m?0:res+1);
}
Problem1597
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int N=50000+19;
struct Land
{
	int x,y;
	bool operator < (const Land& B) const {return x>B.x||x==B.x&&y>B.y;}
} A[N];
int Q[N],n,f,w,Max,cnt;
long long F[N];

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

double g(int i,int j)
{
	return (1.0*(F[i]-F[j]))/(1.0*(A[j+1].x-A[i+1].x));
}

int main()
{
	read(n);
	for (int i=1;i<=n;i++) read(A[i].x),read(A[i].y);
	sort(A+1,A+n+1);
	for (int i=1;i<=n;i++)
		if (A[i].y>Max) Max=A[i].y,A[++cnt]=A[i];
	F[0]=0;w=1;f=1;
	for (int i=1;i<=cnt;i++)
	{
		while (f>w&&A[i].y>g(Q[w],Q[w+1])) w++;
		F[i]=F[Q[w]]+1LL*A[Q[w]+1].x*A[i].y;
		while (f>w&&g(Q[f-1],Q[f])>g(Q[f],i)) f--;
		Q[++f]=i;
	}
	printf("%lld\n",F[cnt]);
}
Problem1598
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=1000+19,M=10000+19,Top=5000000,oo=(1<<30)-1;
struct Edge {int y,z,nxt;} E[M*2];
typedef int one[N];
one Last,Dis,vis,pre;int Que[N*50];
int n,m,k,cnt,D,tot,x,y,z;

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

void SPFA()
{
	For(i,1,n+1) Dis[i]=oo;Dis[n]=0;
	int f=1,w=0;Que[1]=n;
	while (f>w)
	{
		int x=Que[++w];vis[x]=0;
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if ((i&1)&&Dis[x]+E[i].z<Dis[y=E[i].y])
			{
				Dis[y]=Dis[x]+E[i].z;pre[y]=i;
				if (!vis[y]) vis[y]=1,Que[++f]=y;
			}
	}
	f=1,w=0;Que[1]=n;
	while (f>w)
	{
		int x=Que[++w];
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if ((i&1)&&pre[y=E[i].y]==i) Que[++f]=y;
	}
}

struct Type
{
	int v,Pos;
	bool operator < (const Type& B) const {return v<B.v;}
} A[M];

struct node *null;
struct node
{
	node *L,*R;
	int v,Pos,npl;
	void Update()
	{
		if (this==null) return;
		if (L->npl<R->npl) swap(L,R);
		npl=R->npl+1;
	}
} Nd[Top],*cur=Nd+1,*rt[N];

node *Merge(node *A,node *B)
{
	if (A==null) return B;
	if (B==null) return A;
	if (A->v>B->v) swap(A,B);
	node *x=cur++;*x=*A;
	x->R=Merge(A->R,B);
	return x->Update(),x;
}
node *Build(int c)
{
	if (c>tot) return null;
	node *x=cur++;
	x->v=A[c].v;
	x->Pos=A[c].Pos;
	x->L=Build(c<<1);
	x->R=Build(c<<1|1);
	return x->Update(),x;
}

struct QType
{
	int v;node *x;
	bool operator < (const QType& B) const {return v>B.v;}
};priority_queue<QType> Q;

int main()
{
	null=Nd;
	*null=(node){null,null,0,0,-1};
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN(),k=IN();
	For(i,1,m+1) x=IN(),y=IN(),z=IN(),Link(y,x,z);
	SPFA();D=Dis[1];
	For(t,1,n+1)
	{
		int x=Que[t];tot=0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (!(i&1)&&(i^1)!=pre[x]) A[++tot]=(Type){E[i].z-Dis[x]+Dis[E[i].y],i};
		sort(A+1,A+tot+1);
		rt[x]=x==n?Build(1):Merge(rt[E[pre[x]^1].y],Build(1));
	}
	k--,printf("%d\n",D==oo?-1:D);
	Q.push((QType){D+rt[1]->v,rt[1]});
	while (k--)
	{
		if (Q.empty()) {puts("-1");continue;}
		int v=Q.top().v;node *x=Q.top().x;Q.pop();
		printf("%d\n",v);
		if (x->L!=null) Q.push((QType){v-x->v+x->L->v,x->L});
		if (x->R!=null) Q.push((QType){v-x->v+x->R->v,x->R});
		if (rt[E[x->Pos].y]!=null) Q.push((QType){v+rt[E[x->Pos].y]->v,rt[E[x->Pos].y]});
	}
}
Problem1599
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
 
#define rep( i , n ) for( int i = 0 ;  i < n ; ++i )
#define clr( x , c ) memset( x , c , sizeof( x ) )
#define Rep( i , n ) for( int i = 1 ; i<= n ; ++i ) 
 
using namespace std;
 
const int maxn = 80 + 5;
  
int cnt[ maxn ];

 
int main() {
	
	clr( cnt , 0 );
	
	int x[ 3 ];
	
	rep( i , 3 )
	    scanf( "%d" , x + i );
	    
	Rep( i , x[ 0 ] )
	    Rep( j , x[ 1 ] )
	        Rep( k , x[ 2 ] )
	            cnt[ i + j + k ]++;
	        
	int Max = 0 , ans;
	
	rep( i , maxn )
	    if( cnt[ i ] > Max )
	        Max = cnt[ ans = i ];
	
	cout << ans << "\n";
		
	return 0;
}
Problem1600
#include<cstdio>

int F[5][2500+19],n;

int main()
{
	F[0][0]=1;
	scanf("%d",&n);
	for (int i=1;i<=4;i++)
		for (int j=1;j<=n;j++)
			for (int k=1;k<(n+1)/2&&k<=j;k++) F[i][j]+=F[i-1][j-k];
	printf("%d\n",F[4][n]);
}
Problem1601
#include<cstdio>
#include<cstring>
using namespace std;

const int Maxn=300+19;
int A[Maxn][Maxn],Dis[Maxn],vis[Maxn];
int n,Ans;

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&A[0][i]);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++) scanf("%d",&A[i][j]);
	memset(Dis,60,sizeof(Dis));Dis[0]=0;
	for (int t=0;t<=n;t++)
	{
		int Min=(1<<30)-1,k;
		for (int i=0;i<=n;i++)
			if (!vis[i]&&Dis[i]<Min) Min=Dis[i],k=i;
		Ans+=Dis[k],vis[k]=1;
		for (int i=0;i<=n;i++)
			if (!vis[i]&&A[k][i]<Dis[i]) Dis[i]=A[k][i];
	}
	printf("%d\n",Ans);
}
Problem1602
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=1000+19;
struct Edge {int y,z,nxt;} E[Maxn*2];
int Deep[Maxn],Fa[Maxn][11],Dis[Maxn][11],Last[Maxn];
int n,Q,x,y,z,cnt;

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

void DFS(int x)
{
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x][0])
			Deep[E[i].y]=Deep[x]+1,Dis[E[i].y][0]=E[i].z,
			Fa[E[i].y][0]=x,DFS(E[i].y);
}
int Query(int x,int y)
{
	if (Deep[x]>Deep[y]) swap(x,y);
	int Ans=0;
	for (int k=Deep[y]-Deep[x],i=0;k;k>>=1,i++)
		if (k&1) Ans+=Dis[y][i],y=Fa[y][i];
	if (x==y) return Ans;
	for (int i=10;i>=0;i--)
		if (Fa[x][i]!=Fa[y][i])
			Ans+=Dis[x][i]+Dis[y][i],x=Fa[x][i],y=Fa[y][i];
	return Ans+Dis[x][0]+Dis[y][0];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&Q);
	for (int i=1;i<n;i++) scanf("%d%d%d",&x,&y,&z),Link(x,y,z);
	DFS(1);
	for (int x=1;x<=10;x++)
		for (int i=1;i<=n;i++)
			Dis[i][x]=Dis[i][x-1]+Dis[Fa[i][x-1]][x-1],
			Fa[i][x]=Fa[Fa[i][x-1]][x-1];
	while (Q--)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",Query(x,y));
	}
}
Problem1603
#include<cstdio>
using namespace std;

const int Maxn=1000+19;
int n,x,y,z,Ans;
int vis[Maxn],E[Maxn][2],A[Maxn][2];

int main()
{
	scanf("%d",&n);
	for (int i=1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if (!E[x][0]) E[x][0]=y,A[x][0]=z;else E[x][1]=y,A[x][1]=z;
		if (!E[y][0]) E[y][0]=x,A[y][0]=z;else E[y][1]=x,A[y][1]=z;
	}
	for (int i=1;i!=n;)
	{
		vis[i]=1;
		if (!vis[E[i][0]]) Ans^=A[i][0],i=E[i][0];
			else Ans^=A[i][1],i=E[i][1];
	}
	printf("%d\n",Ans);
}
Problem1604
#include<cstdio>
#include<cctype>
#include<set>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c,f;
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}

const int N=100000+19;
struct Point
{
	long long x,y;int ID;
	bool operator < (const Point& B) const {return y<B.y;}
} A[N];
multiset<Point> S;
typedef multiset<Point>::iterator it;
int Fa[N],Sz[N],Q[N];
int cur=1,n,C,x,y,Cnt,Max;

bool cmp(Point A,Point B) {return A.x<B.x;}

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}
void Union(int x,int y)
{
	int fx=Getf(x),fy=Getf(y);
	if (fx!=fy) Fa[fx]=fy;
}

int main()
{
	read(n),read(C);
	For(i,1,n+1) read(x),read(y),A[i]=(Point){x+y,x-y,i},Fa[i]=i;
	sort(A+1,A+n+1,cmp);
	S.insert((Point){0,1LL<<40,0});
	S.insert((Point){0,-(1LL<<40),0});
	For(i,1,n+1)
	{
		while (abs(A[i].x-A[cur].x)>C) S.erase(S.find(A[cur++]));		
		it k=S.insert(A[i]),t;
		t=k,--t;if (k!=S.begin()&&abs(k->y-t->y)<=C) Union(k->ID,t->ID);
		t=k,++t;if (k!=--S.end()&&abs(k->y-t->y)<=C) Union(k->ID,t->ID);
	}
	For(i,1,n+1) Sz[Getf(i)]++;
	For(i,1,n+1) if (Getf(i)==i) Cnt++,Max=max(Max,Sz[i]);
	printf("%d %d\n",Cnt,Max);
}
Problem1606
#include<iostream>
#include<cstdio>
using namespace std;
int c,h,a[5001];bool f[50001];
int main()
{
	scanf("%d%d",&c,&h);
	for(int i=1;i<=h;i++)scanf("%d",&a[i]);
	f[0]=1;
	for(int i=1;i<=h;i++)
	   for(int j=c;j>=a[i];j--)
          if(f[j-a[i]])f[j]=1;
    for(int i=c;i>=0;i--)if(f[i]){printf("%d",i);break;}
	return 0;
}
Problem1607
#include<iostream>
#include<cstdio>
#include<cstring>
#define inf 0x7fffffff
using namespace std;
inline int read()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
int n,mx;
int a[100005],cnt[1000005],s[1000005];
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		cnt[a[i]]++;
		mx=max(a[i],mx);
	}
	for(int i=1;i<=mx;i++)
	    if(cnt[i])
		for(int j=i;j<=mx;j+=i)
		    s[j]+=cnt[i];
	for(int i=1;i<=n;i++)
	    printf("%d\n",s[a[i]]-1); 
	return 0;
}
Problem1609
#include<iostream>
#include<cstdio>
#include<cstring>
#define inf 1000000000
using namespace std;
int n,ans=inf,a[30001],f[30001][4];
void dp()
{
	memset(f,127,sizeof(f));
	f[0][1]=f[0][2]=f[0][3]=0;
	for(int i=1;i<=n;i++)
	   for(int j=1;j<=3;j++)
	      for(int k=1;k<=j;k++) 
	          if(a[i]==j)
	          f[i][j]=min(f[i][j],f[i-1][k]);
	          else f[i][j]=min(f[i][j],f[i-1][k]+1);
	ans=min(ans,f[n][1]);
    ans=min(ans,f[n][2]);
	ans=min(ans,f[n][3]);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	   scanf("%d",&a[i]);
	dp();
	for(int i=1;i<=(n>>1);i++)
	   swap(a[i],a[n-i+1]);
	dp();
	printf("%d",ans);
	return 0;
}
Problem1610
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
double r[40001];
int sum,n,x[201],y[201],m;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d%d",&x[i],&y[i]);
        for(int j=i-1;j>=1;--j)
             if(x[i]==x[j])r[++m]=0x7f7f7f7f;
             else r[++m]=(double)((y[i]-y[j]))/(x[i]-x[j]);
    }
    sort(r+1,r+1+m);
    for(int i=2;i<=m;++i)if(fabs(r[i]-r[i-1])>1e-9)++sum;
    printf("%d\n",sum+1);
}
Problem1611
#include<cstdio>
#include<cstring>
#include<cstdlib>
#define min(x,y) (((x)<(y))?(x):(y))
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
const int N=300+10,x[4]={-1,1,0,0},y[4]={0,0,-1,1};
int t,n,INF;
int T[N][N],dis[N][N],q[100000][2];
void move(int x,int y,int time)
{
	if(x>=0&&y>=0&&time<T[x][y]&&time<dis[x][y])
	{
		if(T[x][y]>=INF){printf("%d\n",time);exit(0);}
		dis[x][y]=time;
		q[++t][0]=x;q[t][1]=y;
	}
}

int main()
{
	n=read();
	memset(dis,60,sizeof(dis));
	memset(T,60,sizeof(T));INF=dis[1][1];
	for(int i=1;i<=n;i++)
	{
		int x=read(),y=read(),t=read();
		T[x][y]=min(T[x][y],t);
		if(x)T[x-1][y]=min(T[x-1][y],t);
		if(y)T[x][y-1]=min(T[x][y-1],t);
		T[x+1][y]=min(T[x+1][y],t);
		T[x][y+1]=min(T[x][y+1],t);
	}
	move(0,0,0);
	for(int i=1;i<=t;i++)
		for(int j=0;j<4;j++)
			move(q[i][0]+x[j],q[i][1]+y[j],dis[q[i][0]][q[i][1]]+1);
	puts("-1");
}	
Problem1612
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
using namespace std;

int s1[101],s2[101],n1[10000],n2[10000],e1[10000],e2[10000],num;
int n,m,i,j,k,u,v,ans;
bool visit[101];

void dfs(int p)
{
   ++num;
   visit[p]=false;
   for(int i=s1[p];i;i=n1[i])
   if(visit[e1[i]])dfs(e1[i]);
}
void dfs0(int p)
{
   ++num;
   visit[p]=false;
   for(int i=s2[p];i;i=n2[i])
   if(visit[e2[i]])dfs0(e2[i]);
}
int main()
{
   scanf("%d%d",&n,&m);
   for(i=1;i<=m;++i)
   {
       scanf("%d%d",&u,&v);
       n1[i]=s1[u];
       s1[u]=i;
       e1[i]=v;
       n2[i]=s2[v];
       s2[v]=i;
       e2[i]=u;
   }
   for(i=1;i<=n;++i)
   {
       num=0;
       memset(visit,true,sizeof(visit));
       dfs(i);
       dfs0(i);
       if(num==n+1)++ans;
   }
   printf("%d\n",ans);
}
Problem1613
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

const int maxn = 10010;
int n, m, dp[maxn], sum[maxn], d[maxn];

int main() {
        scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &d[i]);
		sum[i] = sum[i-1] + d[i];
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= m && j * 2 <= i; j++) 
			dp[i] = max(dp[i], dp[i-j*2] + sum[i-j] - sum[i-j*2]);
		dp[i] = max(dp[i], dp[i-1]);
	}
	printf("%d\n", dp[n]);
	return 0;
}
Problem1614
#include<stdio.h>
#include<cstring>
using namespace std;
const int Edge=20000+10,Vertex=1000+10;
struct arr{int l,r,s,next;}a[Edge];
int x[10*Vertex],dis[Vertex],begin[Vertex],end[Vertex];
bool flag[Vertex];
int n,m,k,xx,y,z,i,max,cnt,ans;
void make_up(int u,int v,int w)
{
  	cnt++;
  	a[cnt].l=u;a[cnt].r=v;a[cnt].s=w;a[cnt].next=-1;
  	if(begin[u]==0)begin[u]=cnt,end[u]=cnt;else a[end[u]].next=cnt,end[u]=cnt;
}
bool check(int mid)
{
  	x[1]=1;int h=0,t=1;
  	memset(flag,0,sizeof(flag));
  	memset(dis,1,sizeof(dis));
  	flag[1]=1;dis[1]=0;
  	while(h<t)
  	{
	    int now=x[++h];
	    int p=begin[now];
	    while(a[p].l==now)
	    {
	      	int go=a[p].r;int w=a[p].s>mid?1:0;
	      	if(dis[now]+w<dis[go])
      		{
        		dis[go]=dis[now]+w;
        		if(!flag[go]){x[++t]=go;flag[go]=1;}
      		}
      		p=a[p].next;
    	}
   		flag[now]=0;
  	}
  	if(dis[n]>k)return 0;return 1;
}     
int erfen(int l,int r)
{
  	if(l==r)return l;
  	int mid=(l+r)/2;
  	if(check(mid))return erfen(l,mid);
  	return erfen(mid+1,r);
}
  
int main()
{
	scanf("%ld%ld%ld",&n,&m,&k);
  	for(i=1;i<=m;i++)
  	{
    	scanf("%ld%ld%ld",&xx,&y,&z);
    	if(z>max)max=z;
    	make_up(xx,y,z);
  		make_up(y,xx,z);
  	}	
  	ans=erfen(0,max+1);
  	if(ans==max+1)printf("-1");else printf("%ld\n",ans);
}
Problem1616
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=110;
const int dx[4]={0,0,1,-1};
const int dy[4]={-1,1,0,0};
int n,m,T,Sx,Sy,Tx,Ty;
int map[maxn][maxn];
int f[maxn][maxn][22];
void dp(int i,int j,int step)
{
 if (abs(i-Sx)+abs(j-Sy)>T) { f[i][j][step]=0; return; }
 if (step==0) if (i==Tx && j==Ty) { f[i][j][0]=1; return; } else { f[i][j][0]=0; return; }
 f[i][j][step]=0; if (map[i][j]==0) return;
 for (int k=0;k<=3;k++)
 {
  int x=i+dx[k],y=j+dy[k]; if (x>n || x<1 || y>m || y<1) continue;
  if (f[x][y][step-1]==-1) dp(x,y,step-1);
  f[i][j][step]+=f[x][y][step-1];
 }
}
int main()
{
 scanf("%d%d%d",&n,&m,&T); memset(map,0,sizeof(map));
 for (int i=1;i<=n;i++)
 {
  char str[maxn]; scanf("%s",str+1);
  for (int j=1;j<=m;j++) if (str[j]=='.') map[i][j]=1; 
 }
 scanf("%d%d%d%d",&Sx,&Sy,&Tx,&Ty); memset(f,0xff,sizeof(f)); dp(Sx,Sy,T);
 printf("%d\n",f[Sx][Sy][T]);
 return 0;
}
Problem1617
#include<iostream>
#include<cstdio>
using namespace std;
inline int read(){  
    int x=0,f=1;char ch=getchar();  
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}  
    while(ch>='0'&&ch<='9'){x*=10;x+=ch-'0';ch=getchar();}  
    return x*f;  
}
int n,m[2501],f[2501];
int main(){
	n=read();m[0]=read();
	for(int i=1;i<=n;i++)m[i]=read()+m[i-1];
	for(int i=1;i<=n;i++){
		f[i]=0x7fffffff;
		for(int j=1;j<=i;j++)
			f[i]=min(f[i],f[i-j]+m[j]+m[0]);
	}
	printf("%d",f[n]-m[0]);
	return 0;
}
Problem1621
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int top=10000000;
int f[top+19],n,k;

int F(int x)
{
	if (x<=top)
	{
		int &res=f[x];
		if (~res) return res;
		return res=x>k&&!(x-k&1)?F(x-k>>1)+F(x-(x-k>>1)):1;
	} else return x>k&&!(x-k&1)?F(x-k>>1)+F(x-(x-k>>1)):1;
}

int main()
{
	memset(f,-1,sizeof(f));
	scanf("%d%d",&n,&k);
	printf("%d\n",F(n));
}
Problem1625
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
 
#define clr( x , c ) memset( x , c , sizeof( x ) )
 
using namespace std;
 
const int maxn = 12880 + 5;
 
int dp[ maxn ];
 
int main() {
	
	clr( dp , 0 );
	
	int n , m;
	cin >> n >> m;
	
	while( n-- ) {
		
		int w , v;
		scanf( "%d%d" , &w , &v );
		
		for( int i = m ; i >= w ; i-- ) 
		    dp[ i ] = max( dp[ i ] , dp[ i - w ] + v );
		    
	}
	
	int ans = 0;
	
	for( int i = 0 ; i <= m ; i++ ) ans = max( ans , dp[ i ] );
	
	cout << ans << "\n";
	
	return 0;
}
Problem1626
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define re(i,l,r) for(int i=l;i<=r;i++)
using namespace std;
double ans,dis[1001],x[1001],y[1001],map[1001][1001];
bool v[1001];
int n,m,k,xx,yy;
int main()
{
 cin>>n>>m;
 re(i,1,n)cin>>x[i]>>y[i];
 re(i,1,n)re(j,1,n)
   map[i][j]=sqrt(pow((x[i]-x[j]),2)+pow((y[i]-y[j]),2));
 re(i,1,m){
   cin>>xx>>yy;
   map[xx][yy]=map[yy][xx]=0;
 }
 re(i,2,n)dis[i]=map[1][i];
 v[1]=1;
 re(i,1,n-1){
   double sum=1e50;
   re(j,1,n)
     if(!v[j]&&dis[j]<sum)sum=dis[j],k=j;
   ans+=dis[k];v[k]=1;
   re(j,1,n)
     if(!v[j])dis[j]=min(dis[j],map[k][j]);
 }
 printf("%.2f",ans);
 return 0;
}
Problem1633
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=600+19,Le=300+19;
int f[Le],w,L,t;
char s[Le],S[N][30];

int Calc(int x,int j)
{
	int Len=strlen(S[j]+1),res=0;
	For(i,1,Len+1)
	{
		while (x<=L&&s[x]!=S[j][i]) x++,res++; 
		if (x>L) return -1;x++;
	}
	return res;
}

int main()
{
	scanf("%d%d",&w,&L);
	scanf("%s",s+1);
	For(i,1,w+1) scanf("%s",S[i]+1);
	for (int i=L;i;i--)
	{
		f[i]=f[i+1]+1;
		For(j,1,w+1)
			if (~(t=Calc(i,j))) f[i]=min(f[i],f[i+strlen(S[j]+1)+t]+t);
	}
	printf("%d\n",f[1]);
}
Problem1666
#include<cstdio>

int main()

{

       int n, ans = 0;

       scanf("%d", &n);

       while(n != 1)

       {

              if(n % 2) n = n * 3 + 1;

              else n /= 2;

              ++ans;

       }

printf("%d", ans);

return 0;

}
Problem1669
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=5000+10;
int n,Ans,a[N],f[N];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		f[i]=1;
		for(int j=1;j<i;j++)
			if(a[i]>a[j]&&f[j]+1>f[i])f[i]=f[j]+1;
		Ans=max(Ans,f[i]);
	}
	printf("%d\n",Ans);
}
Problem1672
#include<cstdio>
#include<algorithm>
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int Maxn=86400;
typedef long long LL;
struct cow 
{
	int L,R,s;
	bool operator < (const cow& B) const {return R<B.R||R==B.R&&L>B.L;}
} A[10000+19];
int n,s,t,_t,Ql,Qr;
LL Min[Maxn*4+19],F[Maxn],v;

void Update(int x,int L,int R)
{
	Min[x]=min(Min[x],v);
	if (L==R) return;
	if (_t<=Mid) Update(Lsn,L,Mid);else Update(Rsn,Mid+1,R);
}
LL Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return Min[x];
	LL tmp=1LL<<60;
	if (Ql<=Mid) tmp=min(tmp,Query(Lsn,L,Mid));
	if (Qr>Mid) tmp=min(tmp,Query(Rsn,Mid+1,R));
	return tmp;
}

int main()
{
	scanf("%d%d%d",&n,&s,&t);s+=2;t+=2;
	for (int i=0;i<n;i++) scanf("%d%d%d",&A[i].L,&A[i].R,&A[i].s),A[i].L+=2,A[i].R+=2;
	for (int i=0;i<=Maxn*4;i++) Min[i]=1LL<<60;
	for (int i=0;i<Maxn;i++) F[i]=1LL<<60;
	v=0;_t=s-1;Update(1,1,Maxn);
	sort(A,A+n);
	for (int i=0;i<n;i++) 
	{
		Ql=A[i].L-1;Qr=A[i].R-1;
		F[A[i].R]=min(F[A[i].R],Query(1,1,Maxn)+A[i].s);
		_t=A[i].R;v=F[A[i].R];Update(1,1,Maxn);
	}
	(F[t]==(1LL<<60))?puts("-1"):printf("%lld\n",F[t]);
}
Problem1672
#include<cstdio>
#include<cctype>
#include<algorithm>
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int Maxn=86400;
typedef long long LL;
struct cow 
{
	int L,R,s;
	bool operator < (const cow& B) const {return R<B.R||R==B.R&&L>B.L;}
} A[10000+19];
int n,s,t,_t,Ql,Qr;
LL Min[Maxn*4+19],F[Maxn],v;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Update(int x,int L,int R)
{
	Min[x]=min(Min[x],v);
	if (L==R) return;
	if (_t<=Mid) Update(Lsn,L,Mid);else Update(Rsn,Mid+1,R);
}
LL Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return Min[x];
	LL tmp=1LL<<60;
	if (Ql<=Mid) tmp=min(tmp,Query(Lsn,L,Mid));
	if (Qr>Mid) tmp=min(tmp,Query(Rsn,Mid+1,R));
	return tmp;
}

int main()
{
	read(n),read(s),read(t);s+=2;t+=2;
	for (int i=0;i<n;i++) read(A[i].L),read(A[i].R),read(A[i].s),A[i].L+=2,A[i].R+=2;
	for (int i=0;i<=Maxn*4;i++) Min[i]=1LL<<60;
	for (int i=0;i<Maxn;i++) F[i]=1LL<<60;
	v=0;_t=s-1;Update(1,1,Maxn);
	sort(A,A+n);
	for (int i=0;i<n;i++) 
	{
		Ql=A[i].L-1;Qr=A[i].R-1;
		F[A[i].R]=min(F[A[i].R],Query(1,1,Maxn)+A[i].s);
		_t=A[i].R;v=F[A[i].R];Update(1,1,Maxn);
	}
	(F[t]==(1LL<<60))?puts("-1"):printf("%lld\n",F[t]);
}
Problem1699
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n,q,x,y,a[50001],mn[50001][16],mx[50001][16];
void pre()
{
	for(int i=1;i<=n;i++)
	   mx[i][0]=mn[i][0]=a[i];
	int t=log(n)/log(2);
    for(int i=1;i<=t;i++)
       for(int j=n;j>0;j--)
       {
       	   mx[j][i]=mx[j][i-1];
       	   if(j+(1<<(i-1))<=n)
       	   mx[j][i]=max(mx[j][i],mx[j+(1<<(i-1))][i-1]); 
       }
    for(int i=1;i<=t;i++)
       for(int j=n;j>0;j--)
       {
       	   mn[j][i]=mn[j][i-1];
       	   if(j+(1<<(i-1))<=n)
       	   mn[j][i]=min(mn[j][i],mn[j+(1<<(i-1))][i-1]); 
       }
}
int rmq(int l,int r)
{
    int m=log(r-l+1)/log(2);
    int a=max(mx[l][m],mx[r-(1<<m)+1][m]);
    int b=min(mn[l][m],mn[r-(1<<m)+1][m]);
    return a-b;
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)
	    scanf("%d",&a[i]);
	pre();
	while(q--)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",rmq(x,y));
	}
	return 0;
}
Problem1706
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=100+19,oo=(1<<30)-1;
struct Matrix
{
	int n,m,s[N][N];
} F,A;
int ID[N*10];
int n,T,S,E,tot,L,x,y;

void Get(int &x) {if (!ID[x]) ID[x]=++tot;x=ID[x];}

Matrix operator * (Matrix A,Matrix B)
{
	Matrix C;C.n=A.n,C.m=B.m;
	For(i,1,C.n+1) For(j,1,C.m+1) C.s[i][j]=oo;
	For(i,1,C.n+1) For(k,1,A.m+1) For(j,1,C.m+1) C.s[i][j]=min(C.s[i][j],A.s[i][k]+B.s[k][j]);
	return C; 
}
Matrix Pow(Matrix A,int b)
{
	Matrix res=A;
	for (--b;b;b>>=1,A=A*A) if (b&1) res=res*A;
	return res;
}

int main()
{
	scanf("%d%d%d%d",&n,&T,&S,&E);Get(S),Get(E);
	memset(F.s,60,sizeof(F.s));
	memset(A.s,60,sizeof(A.s)),A.s[1][S]=0;
	For(i,0,T)
		scanf("%d%d%d",&L,&x,&y),Get(x),Get(y),
		F.s[x][y]=F.s[y][x]=min(F.s[x][y],L);
	F.n=F.m=tot;
	A.n=1,A.m=tot;
	A=A*Pow(F,n);
	printf("%d\n",A.s[1][E]);
}
Problem1708
#include<map>
#include<set>
#include<ctime>
#include<vector>
#include<cstdio>
#include<string>
#include<cstdlib>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
#define Mp make_pair
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=10000+19;
int V,n;
long long f[N];

int main()
{
	V=IN(),n=IN();
	f[0]=1;
	while (V--)
	{
		int x=IN();
		For(i,x,n+1) f[i]+=f[i-x];
	}
	printf("%lld\n",f[n]);
}
Problem1708
#include<stdio.h>
long long f[10001];
main(V,n,x)
{
	for(f[0]=1,scanf("%d%d",&V,&n);V--;)
	{
		scanf("%d",&x);
		for(int i=x;i<=n;i++) f[i]+=f[i-x];
	} printf("%lld\n",f[n]);
}
Problem1708
#include<map>
#include<set>
#include<ctime>
#include<vector>
#include<cstdio>
#include<string>
#include<cstdlib>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
#define Mp make_pair
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=10000+19;
int V,n;
long long f[N];

int main()
{
	V=IN(),n=IN();
	f[0]=1;
	while (V--)
	{
		int x=IN();
		For(i,x,n+1) f[i]+=f[i-x];
	}
	printf("%lld\n",f[n]);	
}
Problem1717
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Rep(i,x,y) for (int i=x;i<=y;i++)
#define Dep(i,x,y) for (int i=x;i>=y;i--)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=20000+19;
int SA[N],rk[2*N],h[N],tmp[N],cnt[N],trk[N],p;
int A[N],s[N],Q[N];
int n,k,f,w,Ans,m;

void Build_SA()
{
	Rep(i,1,n) p=max(p,s[i]);
	Rep(i,1,n) cnt[s[i]]++;
	Rep(i,1,p) cnt[i]+=cnt[i-1];
	Dep(i,n,1) SA[cnt[s[i]]--]=i;
	rk[SA[1]]=p=1;
	Rep(i,1,n) rk[SA[i]]=(s[SA[i]]==s[SA[i-1]])?p:++p;
	for (int k=1;k<=n;k<<=1)
	{
		memset(cnt,0,sizeof(cnt));
		Rep(i,1,n) cnt[rk[i+k]]++;
		Rep(i,1,p) cnt[i]+=cnt[i-1];
		Dep(i,n,1) tmp[cnt[rk[i+k]]--]=i;
		memset(cnt,0,sizeof(cnt));
		Rep(i,1,n) cnt[rk[i]]++;
		Rep(i,1,p) cnt[i]+=cnt[i-1];
		Dep(i,n,1) SA[cnt[rk[tmp[i]]]--]=tmp[i];
		trk[SA[1]]=p=1;
		Rep(i,2,n) trk[SA[i]]=(rk[SA[i]]==rk[SA[i-1]]&&rk[SA[i]+k]==rk[SA[i-1]+k])?p:++p;
		Rep(i,1,n) rk[i]=trk[i];
	}
	for (int i=1,j=0;i<=n;i++)
	{
		if (rk[i]==1) continue;
		while (s[i+j]==s[SA[rk[i]-1]+j]) j++;
		h[rk[i]]=j;if (j) j--;
	}
}

int main()
{
	n=IN(),k=IN()-1;
	Rep(i,1,n) A[i]=s[i]=IN();
	sort(A+1,A+n+1);m=unique(A+1,A+n+1)-A;
	Rep(i,1,n) s[i]=lower_bound(A+1,A+n+1,s[i])-A;
	Build_SA();
	Rep(i,2,n)
	{
		while (w<f&&i-Q[w+1]>=k) w++;
		while (w<f&&h[i]<h[Q[f]]) f--;Q[++f]=i;
		Ans=max(Ans,h[Q[w+1]]);
	}
	printf("%d\n",Ans);
}
Problem1718
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

typedef long long LL;
typedef double Db;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=5000+19,M=10000+19;
struct Edge {int y,is_b,nxt;} E[M*2];
typedef int one[N];
one Last,DFN,Low,S,BCC,Deg;
int n,m,cnt,tot,top,ID,Ans;

void Link(int x,int y)
{
	E[cnt]=(Edge){y,0,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}
void Tarjan(int x,int pre)
{
	DFN[x]=Low[x]=++tot;
	S[++top]=x;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (i!=pre)
			if (!DFN[y=E[i].y])
			{
				Tarjan(y,i^1);Low[x]=min(Low[x],Low[y]);
				if (Low[y]>DFN[x])
				{
					int u;ID++;
					do {u=S[top--];BCC[u]=ID;} while (u!=y);
				}
			} else Low[x]=min(Low[x],DFN[y]);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,m+1) Link(IN(),IN());
	For(i,1,n+1) if (!DFN[i])
	{
		Tarjan(i,-1);
		for (ID++;top;) BCC[S[top--]]=ID;
	}
	For(x,1,n+1) for (int i=Last[x],y;~i;i=E[i].nxt)
		if (BCC[x]!=BCC[y=E[i].y]) Deg[BCC[x]]++,Deg[BCC[y]]++;
	For(i,1,ID+1) if (Deg[i]==2) Ans++;
	printf("%d\n",(Ans+1)/2);
}
Problem1724
#include<cstdio>
#include<queue>
using namespace std;
inline int read()
{
	int x=0,c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x;
}
struct Node
{
	int l;
	bool operator <(const Node &b)const{return l>b.l;};
};
long long Ans;
priority_queue<Node>Q;
int main()
{
	int n=read();
	for(int i=1;i<=n;i++)Q.push((Node){read()});
	for(int i=1,x,y;i<n;i++)
	{
		x=Q.top().l;Q.pop();
		y=Q.top().l;Q.pop();
		Ans+=x+y;
		Q.push((Node){x+y});
	}
	printf("%lld\n",Ans);
}
Problem1726
#include<map>
#include<set>
#include<ctime>
#include<vector>
#include<cstdio>
#include<string>
#include<cstdlib>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
#define Mp make_pair
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=5000+19,M=100000+19;
struct Edge {int y,z,nxt;} E[M*2];
int Last[N],Q[N*100],D1[N],D2[N],vis[N];
int cnt,n,m,f,w,x,y,z;

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}
void Upd(int D,int x)
{
	int b=0;
	if (D<D1[x]) D2[x]=D1[x],D1[x]=D,b=1;else
		if (D1[x]<D&&D<D2[x]) D2[x]=D,b=1;
	if (b&&!vis[x]) vis[x]=1,Q[++f]=x;
}
void SPFA()
{
	memset(D1,60,sizeof(D1));
	memset(D2,60,sizeof(D2));D1[1]=0;
	f=1,w=0;Q[1]=1;
	while (f>w)
	{
		int x=Q[++w];vis[x]=0;
		for (int i=Last[x];~i;i=E[i].nxt)
		{
			Upd(D1[x]+E[i].z,E[i].y);
			Upd(D2[x]+E[i].z,E[i].y);
		}
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,0,m) x=IN(),y=IN(),z=IN(),Link(x,y,z);
	SPFA();
	printf("%d\n",D2[n]);
}
Problem1756
#include<cstdio>
#include<cctype>
#include<algorithm>

#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int Maxn=500000+19;
typedef long long LL;
struct Seg {LL Sum,Max,Lmax,Rmax;} S[Maxn*4];
int n,m,opt,Ql,Qr,t,v;

int c,f;
void read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}

Seg Calc(Seg Al,Seg Ar)
{
	Seg tmp;
	tmp.Sum=Al.Sum+Ar.Sum;
	tmp.Lmax=max(Al.Lmax,Al.Sum+Ar.Lmax);
	tmp.Rmax=max(Ar.Rmax,Ar.Sum+Al.Rmax);
	tmp.Max=max(max(Al.Max,Ar.Max),Al.Rmax+Ar.Lmax);
	return tmp;
}
Seg Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return S[x];
	if (Ql<=Mid&&Mid<Qr) return Calc(Query(Lsn,L,Mid),Query(Rsn,Mid+1,R));
		else if (Ql<=Mid) return Query(Lsn,L,Mid);
			else return Query(Rsn,Mid+1,R);
}
void Update(int x,int L,int R)
{
	if (L==R) {S[x].Sum=S[x].Max=S[x].Lmax=S[x].Rmax=v;return;}
	if (t<=Mid) Update(Lsn,L,Mid);else Update(Rsn,Mid+1,R);
	S[x]=Calc(S[Lsn],S[Rsn]);
}
void Build(int x,int L,int R)
{
	if (L==R) {read(v);S[x].Sum=S[x].Max=S[x].Lmax=S[x].Rmax=v;return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	S[x]=Calc(S[Lsn],S[Rsn]);
}

int main()
{
	read(n),read(m);
	Build(1,1,n);
	while (m--)
	{
		read(opt);
		if (opt==1)
		{
			read(Ql),read(Qr);
			if (Ql>Qr) swap(Ql,Qr);
			printf("%lld\n",Query(1,1,n).Max);
		} else read(t),read(v),Update(1,1,n);
	}
}
Problem1758
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Rep(x) for (int i=Last[x],y;~i;i=E[i].nxt) if (vis[y=E[i].y]!=Time)
using namespace std;

typedef long long LL;
typedef double Db;

const int N=100000+19,oo=(1<<30)-1,Len=2000000;
struct Edge {int y,z,nxt;} E[N*2];
int Last[N],S[N],vis[N];
int cnt,n,cen,Fcen,Time,Ql,Qr,Min,MaxL,x,y,z;
Db A[N],B[N],L,R,Mid,MaxD;
char Buf[Len],*b=Buf;

int IN()
{
	int c,f,x;
	while (!isdigit(c=*b++)&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=*b++)) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

struct Queue
{
	int Ql[N],L,R;
	Db Qd[N];
	void Clear() {L=0,R=-1;}
	void Ins(int Lx,Db Dx)
	{
		while (L<=R&&Qd[R]<=Dx) R--;
		R++,Ql[R]=Lx,Qd[R]=Dx;
	}
	Db Query(int Lx)
	{
		while (L<=R&&Ql[L]>Lx) L++;
		return L<=R?Qd[L]:-(1e60);
	}
} Q;

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++; 
}

void Findcen(int x,int Fa,int n)
{
	S[x]=1;int tmp=0;
	Rep(x) if (y!=Fa)
		Findcen(y,x,n),S[x]+=S[y],tmp=max(tmp,S[y]);
	tmp=max(tmp,n-S[x]);
	if (tmp<Min) Min=tmp,cen=x,Fcen=Fa;
}
void DFS(int x,int Fa,int Len,Db Dis)
{
	A[Len]=max(A[Len],Dis);
	Rep(x) if (y!=Fa) DFS(y,x,Len+1,Dis+E[i].z-Mid);
}
int Solve(int x,int n)
{
	Min=oo,Findcen(x,-1,n),vis[x=cen]=Time;
	if (~Fcen) S[Fcen]=n-S[x];
	For(i,0,n) B[i]=-(1e60);
	B[0]=0;MaxL=oo,MaxD=-(1e60);
	Rep(x)
	{
		For(j,0,S[y]+1) A[j]=-(1e60);
		DFS(y,x,1,E[i].z-Mid);
		Q.Clear();Q.Ins(MaxL,MaxD);
		For(j,1,S[y]+1)
		{
			if (0<=Ql-j&&Ql-j<n) Q.Ins(Ql-j,B[Ql-j]);
			if (A[j]+Q.Query(Qr-j)>=0) return 1;
		}
		For(j,1,S[y]+1) if (A[j]>B[j])
		{
			B[j]=A[j];
			if (Ql<=j&&j<=Qr&&B[j]>MaxD) MaxD=B[j],MaxL=j;
		}
	}
	Rep(x) if (Solve(y,S[y])) return 1;
	return 0;
}

int main()
{
	fread(Buf,1,Len,stdin);
	memset(Last,-1,sizeof(Last));
	n=IN(),Ql=IN(),Qr=IN();
	For(i,1,n) x=IN(),y=IN(),z=IN(),Link(x,y,z),R=max(R,1.0*z);
	while (R-L>1e-5)
	{
		Mid=(L+R)/2.0;Time++;
		if (Solve(1,n)) L=Mid;else R=Mid;
	}
	printf("%.3lf\n",L);
}
Problem1758
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Rep(x) for (int i=Last[x],y;~i;i=E[i].nxt) if (vis[y=E[i].y]!=Time)
using namespace std;

typedef long long LL;
typedef double Db;

const int N=100000+19,oo=(1<<30)-1,Len=2000000;
struct Edge {int y,z,nxt;} E[N*2];
int Last[N],S[N],vis[N];
int cnt,n,cen,Fcen,Time,Ql,Qr,Min,MaxL,x,y,z;
Db A[N],B[N],L,R,Mid,MaxD;
char Buf[Len],*b=Buf;

int IN()
{
	int c,f,x;
	while (!isdigit(c=*b++)&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=*b++)) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

struct Queue
{
	int Ql[N],L,R;
	Db Qd[N];
	void Clear() {L=0,R=-1;}
	void Ins(int Lx,Db Dx)
	{
		while (L<=R&&Qd[R]<=Dx) R--;
		R++,Ql[R]=Lx,Qd[R]=Dx;
	}
	Db Query(int Lx)
	{
		while (L<=R&&Ql[L]>Lx) L++;
		return L<=R?Qd[L]:-(1e60);
	}
} Q;

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++; 
}

void Findcen(int x,int Fa,int n)
{
	S[x]=1;int tmp=0;
	Rep(x) if (y!=Fa)
		Findcen(y,x,n),S[x]+=S[y],tmp=max(tmp,S[y]);
	tmp=max(tmp,n-S[x]);
	if (tmp<Min) Min=tmp,cen=x,Fcen=Fa;
}
void DFS(int x,int Fa,int Len,Db Dis)
{
	A[Len]=max(A[Len],Dis);
	Rep(x) if (y!=Fa) DFS(y,x,Len+1,Dis+E[i].z-Mid);
}
void BFS(int S,Db D)
{
	static int Q[N],Len[N],v[N],Clo;
	static Db Dis[N];
	int f=1,w=0;Q[1]=S,Len[S]=1,Dis[S]=D,v[S]=++Clo;
	while (f>w)
	{
		int x=Q[++w];A[Len[x]]=max(A[Len[x]],Dis[x]);
		Rep(x) if (v[y]!=Clo)
			v[y]=Clo,Q[++f]=y,Dis[y]=Dis[x]+E[i].z-Mid,Len[y]=Len[x]+1;
	}
}
int Solve(int x,int n)
{
	Min=oo,Findcen(x,-1,n),vis[x=cen]=Time;
	if (~Fcen) S[Fcen]=n-S[x];
	For(i,0,n) B[i]=-(1e60);
	B[0]=0;MaxL=oo,MaxD=-(1e60);
	Rep(x)
	{
		For(j,0,S[y]+1) A[j]=-(1e60);
		BFS(y,E[i].z-Mid);
		Q.Clear();Q.Ins(MaxL,MaxD);
		For(j,1,S[y]+1)
		{
			if (0<=Ql-j&&Ql-j<n) Q.Ins(Ql-j,B[Ql-j]);
			if (A[j]+Q.Query(Qr-j)>=0) return 1;
		}
		For(j,1,S[y]+1) if (A[j]>B[j])
		{
			B[j]=A[j];
			if (Ql<=j&&j<=Qr&&B[j]>MaxD) MaxD=B[j],MaxL=j;
		}
	}
	Rep(x) if (Solve(y,S[y])) return 1;
	return 0;
}

int main()
{
	fread(Buf,1,Len,stdin);
	memset(Last,-1,sizeof(Last));
	n=IN(),Ql=IN(),Qr=IN();
	For(i,1,n) x=IN(),y=IN(),z=IN(),Link(x,y,z),R=max(R,1.0*z);
	while (R-L>1e-5)
	{
		Mid=(L+R)/2.0;Time++;
		if (Solve(1,n)) L=Mid;else R=Mid;
	}
	printf("%.3lf\n",L);
}
Problem1765
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=1500+19;
typedef long long LL;
struct Point 
{
	int x,y;
	Point() {}
	Point(int _x,int _y):x(_x),y(_y){}
	bool operator == (const Point& B) const {return x==B.x&&y==B.y;}
} P[Maxn];
struct Line
{
	Point *A,*B;
	Point Mid;LL Len;
	bool operator < (const Line& B) const 
	{
		if (Len!=B.Len) return Len<B.Len;
		return Mid.x!=B.Mid.x?Mid.x<B.Mid.x:Mid.y<B.Mid.y;
	}
} L[Maxn*Maxn];
typedef Point Vector;
int n,tot;LL Ans;

LL sqr(LL x) {return 1LL*x*x;}
LL Abs(LL x) {return x>0?x:-x;}
Vector operator - (Point A,Point B) {return Vector(A.x-B.x,A.y-B.y);}
LL operator * (Vector A,Vector B) {return 1LL*A.x*B.y-1LL*A.y*B.x;}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d%d",&P[i].x,&P[i].y);
	for (int i=0;i<n;i++)
		for (int j=0;j<i;j++)
		{
			L[tot].A=&P[i];L[tot].B=&P[j];
			L[tot].Mid=Point(P[i].x+P[j].x,P[i].y+P[j].y);
			L[tot].Len=1LL*sqr(P[i].x-P[j].x)+1LL*sqr(P[i].y-P[j].y);
			tot++;
		}
	sort(L,L+tot);
	for (int i=0;i<tot;i++)
		for (int j=i-1;j>=0&&L[i].Len==L[j].Len&&L[i].Mid==L[j].Mid;j--)
			Ans=max(Ans,Abs((*(L[i].A)-*(L[j].A))*(*(L[i].B)-*(L[j].A))));
	printf("%lld\n",Ans);
}
Problem1765
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=1500+19;
typedef long long LL;
struct Point 
{
	int x,y;
	Point() {}
	Point(int _x,int _y):x(_x),y(_y){}
	bool operator == (const Point& B) const {return x==B.x&&y==B.y;}
} P[Maxn];
struct Line
{
	Point *A,*B;
	Point Mid;LL Len;
	bool operator < (const Line& B) const 
	{
		if (Len!=B.Len) return Len<B.Len;
		return Mid.x!=B.Mid.x?Mid.x<B.Mid.x:Mid.y<B.Mid.y;
	}
} L[Maxn*Maxn];
typedef Point Vector;
int n,tot;LL Ans;

inline LL sqr(LL x) {return 1LL*x*x;}
inline LL Abs(LL x) {return x>0?x:-x;}
Vector operator - (Point A,Point B) {return Vector(A.x-B.x,A.y-B.y);}
LL operator * (Vector A,Vector B) {return 1LL*A.x*B.y-1LL*A.y*B.x;}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d%d",&P[i].x,&P[i].y);
	for (int i=0;i<n;i++)
		for (int j=0;j<i;j++)
		{
			L[tot].A=&P[i];L[tot].B=&P[j];
			L[tot].Mid=Point(P[i].x+P[j].x,P[i].y+P[j].y);
			L[tot].Len=1LL*sqr(P[i].x-P[j].x)+1LL*sqr(P[i].y-P[j].y);
			tot++;
		}
	sort(L,L+tot);
	for (int i=0;i<tot;i++)
		for (int j=i-1;j>=0&&L[i].Len==L[j].Len&&L[i].Mid==L[j].Mid;j--)
			Ans=max(Ans,Abs((*(L[i].A)-*(L[j].A))*(*(L[i].B)-*(L[j].A))));
	printf("%lld\n",Ans);
}
Problem1786
#include<cstdio>
#include<cctype>
#include<cstring>

#define min(a,b) ((a)<(b)?(a):(b))
using namespace std;

const int Maxn=10000+19,top=100+19,oo=(1<<30)-1;
int Up[Maxn][top],Dn[Maxn][top],f[2][top];
int n,k,pre,nxt,Ans=oo,tmp,cur,now;
int A[Maxn],b[top];

int c,F;
void read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') F=1,x=0;else F=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (F) x=-x;
}

int main()
{
	read(n),read(k);
	for (int i=1;i<=n;i++) read(A[i]);
	for (int x=n;x;x--)
		if (A[x]!=-1)
		{
			for (int i=A[x]-1;i;i-=i&-i) tmp+=b[i];
			for (int i=A[x];i<=k;i+=i&-i) b[i]++;
		}
	memset(b,0,sizeof(b));
	for (int i=1;i<=n;i++)
		if (A[i]==-1)
		{
			now++;
			for (int j=1,_=b[1];j<=k;_+=b[++j]) Up[now][j]=_;
		} else b[1]++,b[A[i]]--;
	memset(b,0,sizeof(b));
	for (int i=n;i;i--)
		if (A[i]==-1)
		{
			for (int j=1,_=b[1];j<=k;_+=b[++j]) Dn[now][j]=_;
			now--;
		} else b[A[i]+1]++,b[k+1]--;
	memset(f,60,sizeof(f));
	cur=1,pre=0;f[cur][1]=0;
	for (int i=1;i<=n;i++)
		if (A[i]==-1)
		{
			cur^=1,pre^=1,now++;int Min=oo;
			for (int j=1;j<=k;j++) Min=min(Min,f[pre][j]),f[cur][j]=Min+Up[now][j]+Dn[now][j];
		}
	for (int i=1;i<=k;i++) Ans=min(Ans,f[cur][i]);
	printf("%d\n",Ans+tmp);
}
Problem1787
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=500000+19;
typedef pair<int,int> Ques;
struct Edge {int y,nxt;} E[Maxn*2];
int Fa[21][Maxn],Deep[Maxn];
int Last[Maxn],cnt,n,Q,a,b,c,x,y;

void Add_Edge(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x)
{
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].y!=Fa[0][x])
		{
			Fa[0][E[i].y]=x;
			Deep[E[i].y]=Deep[x]+1;
			DFS(E[i].y);
		}
}
Ques Lca(int x,int y)
{
	if (x==y) return make_pair(0,x);
	int Ans=0;
	if (Deep[x]>Deep[y]) swap(x,y);
	for (int i=20;i>=0;i--)
		if (Deep[Fa[i][y]]>Deep[x]) Ans+=(1<<i),y=Fa[i][y];
	if (Fa[0][y]==x) return make_pair(Ans+1,x);
	if (Deep[y]>Deep[x]) Ans++,y=Fa[0][y];
	for (int i=20;i>=0;i--)
		if (Fa[i][x]!=Fa[i][y]) Ans+=(1<<i+1),x=Fa[i][x],y=Fa[i][y];
	return make_pair(Ans+2,Fa[0][y]);
}
Ques Query(int a,int b,int c)
{
	Ques A1=Lca(a,b),B1=Lca(A1.second,c);int Ans1=A1.first+B1.first;
	Ques A2=Lca(b,c),B2=Lca(A2.second,a);int Ans2=A2.first+B2.first;
	Ques A3=Lca(c,a),B3=Lca(A3.second,b);int Ans3=A3.first+B3.first;
	int Min=min(min(Ans1,Ans2),Ans3);
	if (Min==Ans1) return make_pair(Ans1,A1.second);
	if (Min==Ans2) return make_pair(Ans2,A2.second);
	return make_pair(Ans3,A3.second);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&Q);
	for (int i=1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		Add_Edge(x,y);
	}
	DFS(1);
	for (int x=1;x<=20;x++)
		for (int i=1;i<=n;i++) Fa[x][i]=Fa[x-1][Fa[x-1][i]];
	while (Q--)
	{
		scanf("%d%d%d",&a,&b,&c);
		Ques A=Query(a,b,c);
		printf("%d %d\n",A.second,A.first);
	}
}
Problem1789
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=60;
char A[N],B[N],C[N];
int ca,cb,cc,t,p,M;

int Calc(char *A,char *B,char *C)
{
	ca=strlen(A),cb=strlen(B),cc=strlen(C);
	t=0;while (t<ca&&t<cb&&A[t]==B[t]) t++;
	p=0;while (p<t&&A[p]==C[p]) p++;
	return (ca-t)+(cb-t)+(cc-p+t-p);
}

int main()
{
	scanf("%*d%s",A),scanf("%*d%s",B),scanf("%*d%s",C);
	printf("%d\n",min(min(Calc(A,B,C),Calc(A,C,B)),Calc(B,C,A)));
}
Problem1797
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
#define maxn 4200
#define maxm 130000
#define inf 0x3fffffff
int e[maxn],ne[maxm],v[maxm],u[maxm];
int nn=1;
void add(int x,int y,int uu){
  ne[++nn]=e[x],e[x]=nn,v[nn]=y,u[nn]=uu;    
}
int s,t,n,m,ch[maxn];
int x,qu[maxn],he,bo,low[maxn],stn,st[maxn],dfn[maxn],been[maxn];
bool bfs(){    
    memset(ch,-1,sizeof(ch));
    ch[qu[he=bo=1]=s]=0;
    while(he>=bo)for(int i=e[x=qu[bo++]];i;i=ne[i])if(ch[v[i]]==-1&&u[i])qu[++he]=v[i],ch[v[i]]=ch[x]+1;    
    return ch[t]==-1;
} 
int zeng(int no,int mm){
    if(no==t)return mm;
    int k,r=mm;
    for(int i=e[no];i&&r;i=ne[i])if(u[i]&&ch[v[i]]==ch[no]+1){
        k=zeng(v[i],min(r,u[i]));
        u[i]-=k,u[i^1]+=k,r-=k;
    }
    if(r==mm)return ch[no]=-1,0;
    return mm-r;
}
int tot,in[maxn],kk;
void tarjan(int x){
    dfn[x]=low[x]=++tot;
    been[st[++stn]=x]=1;
    for(int i=e[x];i;i=ne[i])if(u[i])
        if(!dfn[v[i]]){
          tarjan(v[i]);
          low[x]=min(low[x],low[v[i]]);    
        }else if(been[v[i]])low[x]=min(low[x],dfn[v[i]]);
    if(low[x]==dfn[x]){
        kk++;
        do{
            in[st[stn]]=kk;
           been[st[stn]]=0;    
        }while(st[stn--]!=x);
    }
}
int main(){
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1;i<=m;i++){
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
        add(b,a,0);    
    }
    while(!bfs())while(zeng(s,inf));    
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
    for(int i=1;i<=m;i++){
        if(in[v[i<<1]]!=in[v[(i<<1)+1]]&&!u[(i<<1)])printf("1 ");
        else printf("0 ");
        if(in[v[i<<1]]==in[t]&&in[v[(i<<1)+1]]==in[s]&&!u[(i<<1)])printf("1\n");
        else printf("0\n");
    }    
}
Problem1798
#include<cstdio>
#include<cctype>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=100000+19;
typedef int Seg[N*4];
Seg Sum,Add,Mul;
int A[N],n,Q,Ql,Qr,Qm,Qa,Mod,s;

void Build(int x,int L,int R)
{
	Add[x]=0,Mul[x]=1;
	if (L==R) {Sum[x]=A[L];return;}
	Build(Lsn,L,Mid);Build(Rsn,Mid+1,R);
	Sum[x]=(Sum[Lsn]+Sum[Rsn])%Mod;
}
void Change(int x,int L,int R,int Qm,int Qa)
{
	Sum[x]=(1LL*Sum[x]*Qm+1LL*Qa*(R-L+1))%Mod;
	Mul[x]=(1LL*Mul[x]*Qm)%Mod;
	Add[x]=(1LL*Add[x]*Qm+Qa)%Mod;
}
void Push_down(int x,int L,int R)
{
	Change(Lsn,L,Mid,Mul[x],Add[x]);
	Change(Rsn,Mid+1,R,Mul[x],Add[x]);
	Mul[x]=1,Add[x]=0;
}
void Update(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {Change(x,L,R,Qm,Qa);return;}
	Push_down(x,L,R);
	if (Ql<=Mid) Update(Lsn,L,Mid);
	if (Qr>Mid) Update(Rsn,Mid+1,R);
	Sum[x]=(Sum[Lsn]+Sum[Rsn])%Mod;
}
int Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return Sum[x];
	Push_down(x,L,R);
	int tmp=0;
	if (Ql<=Mid) (tmp+=Query(Lsn,L,Mid))%=Mod;
	if (Qr>Mid) (tmp+=Query(Rsn,Mid+1,R))%=Mod;
	return tmp;
}

int main()
{
	read(n),read(Mod);
	For(i,1,n+1) read(A[i]);
	Build(1,1,n);
	read(Q);
	while (Q--)
	{
		read(s),read(Ql),read(Qr);
		if (s==1) read(Qm),Qa=0,Update(1,1,n);
		if (s==2) read(Qa),Qm=1,Update(1,1,n);
		if (s==3) printf("%d\n",Query(1,1,n));
	}
}
Problem1800
#include<cstdio>
using namespace std;

int s[49],a[29];
int num(int a,int b) {return s[b]-s[a];}
int main()
{
	int n,Ans=0;
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",&a[i]);
	for (int i=1;i<=n;i++) s[i]=s[i-1]+a[i-1];
	for (int i=n+1;i<=2*n;i++) s[i]=s[i-1]+a[i-n-1];
	for (int i1=0;i1<n;i1++)
		for (int i2=i1+1;i2<i1+n;i2++)
			for (int i3=i2+1;i3<i1+n;i3++)
				for (int i4=i3+1;i4<i1+n;i4++)
					if (num(i1,i2)==num(i3,i4)&&num(i2,i3)==num(i4,i1+n)) Ans++;
	printf("%d\n",Ans/4);
	//for(;;);
	return 0;
}
Problem1800
#include<cstdio>
using namespace std;

int n,A[49],Ans,sum;

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&A[i]),A[i+n]=A[i],sum+=A[i];
	for (int i=1;i<=n;i++)
	{
		int tmp=0;
		for (int j=i;j<=i+n;j++)
		{
			tmp+=A[j];
			if (tmp==sum/2) Ans++;
		}
	}
	Ans/=2;
	printf("%d\n",Ans*(Ans-1)/2);
}
Problem1801
#include<cstdio>
#include<algorithm>
using namespace std;

const int N=100+19,Mod=9999973;
int F[N][N][N];
int n,m,Ans;

int main()
{
	scanf("%d%d",&n,&m);
	F[0][m][0]=1;
	for (int i=0;i<n;i++)
		for (int j=0;j<=m;j++)
			for (int k=0;j+k<=m;k++)
				if (F[i][j][k])
				{
					(F[i+1][j][k]+=F[i][j][k])%=Mod;
					if (j) (F[i+1][j-1][k+1]+=F[i][j][k]*j)%=Mod;
					if (k) (F[i+1][j][k-1]+=F[i][j][k]*k)%=Mod;
					if (j>=2) (F[i+1][j-2][k+2]+=1LL*F[i][j][k]*j*(j-1)/2LL%Mod)%=Mod;
					if (k>=2) (F[i+1][j][k-2]+=1LL*F[i][j][k]*k*(k-1)/2LL%Mod)%=Mod;
					if (j&&k) (F[i+1][j-1][k]+=1LL*F[i][j][k]*j*k%Mod)%=Mod;
				}
	for (int i=0;i<=m;i++)
		for (int j=0;j+i<=m;j++) (Ans+=F[n][i][j])%=Mod;
	printf("%d\n",Ans);
}
Problem1803
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19,Top=3000000;
struct Edge {int y,nxt;} E[N*2];
int A[N],B[N],Last[N],I[N],O[N],re[N],Sum[Top],Lsn[Top],Rsn[Top],rt[N];
int tot,cnt,n,Tl,Tr,Qx;

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x,int Fa)
{
	I[x]=++tot;re[tot]=x;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa) DFS(E[i].y,x);
	O[x]=tot;
}

void Build(int y,int &x,int L,int R)
{
	Sum[x=++tot]=Sum[y]+1;
	Lsn[x]=Lsn[y],Rsn[x]=Rsn[y];
	if (L==R) return;
	Qx<=Mid?Build(Lsn[y],Lsn[x],L,Mid):Build(Rsn[y],Rsn[x],Mid+1,R);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN();
	For(i,1,n+1) B[i]=A[i]=IN();
	sort(B+1,B+n+1);
	For(i,1,n+1) A[i]=lower_bound(B+1,B+n+1,A[i])-B;
	For(i,1,n+1) B[A[i]]=i;
	For(i,1,n) Link(IN(),IN());
	DFS(1,-1);tot=0;
	For(i,1,n+1) Qx=A[re[i]],Build(rt[i-1],rt[i],1,n);
	for (int Q=IN(),x,k,L,R;Q--;)
	{
		x=IN(),k=IN(),Tl=rt[I[x]-1],Tr=rt[O[x]];L=1,R=n;
		while (L!=R)
			if (k<=Sum[Lsn[Tr]]-Sum[Lsn[Tl]]) R=Mid,Tl=Lsn[Tl],Tr=Lsn[Tr];
				else k-=Sum[Lsn[Tr]]-Sum[Lsn[Tl]],L=Mid+1,Tl=Rsn[Tl],Tr=Rsn[Tr];
		printf("%d\n",B[L]);
	}
}
Problem1806
#include<cstdio>
#include<cstring>
using namespace std;

int f[2][4][4][4][4];
char s[100000+19];
int num(char c) {return c=='M'?1:(c=='F'?2:3);}
inline int check(int i,int j,int k)
{
	return (i==1||j==1||k==1)+(i==2||j==2||k==2)+(i==3||j==3||k==3);
}
inline void Max(int &a,int b) {if (b>a) a=b;}

int main()
{
	int n,Ans=0,now=1,nxt=0;
	scanf("%d",&n);
	scanf("%s",s);
	memset(f[0],255,sizeof(f[0]));
	f[0][0][0][0][0]=0;
	for (int i=0;i<n;i++)
	{
		now^=1;nxt^=1;
		memset(f[nxt],255,sizeof(f[nxt]));
		for (int j=0;j<4;j++) for (int k=0;k<4;k++)
		for (int l=0;l<4;l++) for (int m=0;m<4;m++)
			if (f[now][j][k][l][m]>=0)
			{
				int x=num(s[i]),tmp=f[now][j][k][l][m];
				Max(f[nxt][k][x][l][m],tmp+check(j,k,x));
				Max(f[nxt][j][k][m][x],tmp+check(l,m,x));
			}
	}
	for (int j=0;j<4;j++) for (int k=0;k<4;k++)
	for (int l=0;l<4;l++) for (int m=0;m<4;m++) Max(Ans,f[nxt][j][k][l][m]);
	printf("%d\n",Ans);
	//for(;;);
	return 0;
}
Problem1806
#include<cstdio>
#include<cstring>

#define For(a,b,c,d) \
	for (int a=0;a<=3;a++) for (int b=0;b<=3;b++) \
		for (int c=0;c<=3;c++) for (int d=0;d<=3;d++)
using namespace std;

int F[2][4][4][4][4],n,pre=0,cur=1,Ans;
char s[100000+19];

void Check(int &a,int b) {a=(a>b?a:b);}
int Score(int a,int b,int c)
{
	int s[4]={0};
	s[a]=s[b]=s[c]=1;
	return s[1]+s[2]+s[3];
}

int main()
{
	scanf("%d",&n);
	scanf("%s",s);
	memset(F,-1,sizeof(F));
	F[cur][0][0][0][0]=0;
	for (int T=1;T<=n;T++)
	{
		cur^=1;pre^=1;
		int x=(s[T-1]=='F'?1:(s[T-1]=='M'?2:3));
		For(i,j,k,l) F[cur][i][j][k][l]=-1;
		For(i,j,k,l)
			if (~F[pre][i][j][k][l])
				Check(F[cur][j][x][k][l],F[pre][i][j][k][l]+Score(i,j,x)),
				Check(F[cur][i][j][l][x],F[pre][i][j][k][l]+Score(k,l,x));
	}
	For(i,j,k,l) Check(Ans,F[cur][i][j][k][l]);
	printf("%d\n",Ans);
}
Problem1807
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19,M2=75000,M3=75,oo=(1<<30)-1;
int B,n,D,m,f,w=1,Q[N];
long long Ans;

namespace S_1D
{
	int A[N];
	void work()
	{
		For(i,0,n) A[i]=IN();
		sort(A,A+n);
		For(i,0,n) {while (f>=w&&A[i]-A[Q[w]]>D) w++;Ans+=f-w+1,Q[++f]=i;}
		printf("%lld\n",Ans);
	}
}

namespace S_2D
{
	int C[M2*2+19],a,b,Min=oo,Max=-oo;
	struct node
	{
		int x,y;
		void Input() {a=IN(),b=IN(),x=a+b,y=a-b,Min=min(Min,y),Max=max(Max,y);}
		bool operator < (const node& B) const {return x<B.x;}
	} A[N];
	void Update(int x,int v) {for (int i=x;i<=Max;i+=i&-i) C[i]+=v;}
	int Query(int x) {int Ans=0;for (int i=x;i;i-=i&-i) Ans+=C[i];return Ans;}
	void work()
	{
		For(i,0,n) A[i].Input();
		For(i,0,n) A[i].y-=Min-1;Max-=Min-1;
		sort(A,A+n);
		For(i,0,n)
		{
			while (f>=w&&A[i].x-A[Q[w]].x>D) Update(A[Q[w++]].y,-1);
			Ans+=Query(min(A[i].y+D,Max))-Query(max(A[i].y-D,1)-1);
			Update(A[Q[++f]=i].y,1);
		}
		printf("%lld\n",Ans);
	}
}

namespace S_3D
{
	int S[M3+19][M3*2+19][M3*2+19],x,y,Min=oo;
	struct node
	{
		int a,b,c;
		void Input() {a=IN(),x=IN(),y=IN(),b=x+y,c=x-y,Min=min(Min,c);}
	} A[N];
	inline int Query(int a,int x,int y,int d)
	{
		int D=min(x+d,2*m),U=max(x-d,1),L=max(y-d,1),R=min(y+d,2*m);
		return S[a][D][R]-S[a][D][L-1]-S[a][U-1][R]+S[a][U-1][L-1];
	}
	void work()
	{
		For(i,0,n) A[i].Input();
		For(i,0,n) A[i].c-=Min-1;
		For(i,0,n) S[A[i].a][A[i].b][A[i].c]++;
		For(i,1,m+1) For(j,1,2*m+1) For(k,1,2*m+1) S[i][j][k]+=S[i][j][k-1]+S[i][j-1][k]-S[i][j-1][k-1];
		For(i,0,n)
			for (int j=max(A[i].a-D,1),_=min(A[i].a+D,m);j<=_;j++)
				Ans+=Query(j,A[i].b,A[i].c,D-abs(A[i].a-j));
		printf("%lld\n",(Ans-n)/2LL);
	}
}

int main()
{
	B=IN(),n=IN(),D=IN(),m=IN();
	if (B==1) S_1D::work();
	if (B==2) S_2D::work();
	if (B==3) S_3D::work();
}
Problem1816
#include<cstdio>
using namespace std;

const int Maxn=50+19;
typedef long long LL;
LL A[Maxn];
int main()
{
	int n;
	scanf("%d",&n);
	for (int i=0;i<=n;i++) scanf("%d",&A[i]);
	LL L=0,R=(1<<31)-1;
	while (L+1<R)
	{
		LL M=(L+R)>>1,S=0;
		for (int i=0;i<=n;i++) if (A[i]<M) S+=M-A[i];
		if (S<=M) L=M;else R=M;
	}
	printf("%d\n",L);
	//for(;;);
	return 0;
}
Problem1821
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;

const int Maxn=1000+19;
struct Edge {int x,y,z;} E[Maxn*Maxn*2];
int Fa[Maxn],n,k,cnt,X[Maxn],Y[Maxn];

inline int cmp(Edge A,Edge B) {return A.z<B.z;}
inline int sqr(int x) {return x*x;}
inline int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}

int main()
{
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++) scanf("%d%d",&X[i],&Y[i]),Fa[i]=i;
	for (int i=1;i<=n;i++)
		for (int j=i+1;j<=n;j++) 
			E[++cnt]=(Edge){i,j,sqr(X[i]-X[j])+sqr(Y[i]-Y[j])};
	sort(E+1,E+cnt+1,cmp);
	int num=n-k;
	for (int i=1;i<=cnt;i++)
	{
		int Fx=Getf(E[i].x),Fy=Getf(E[i].y);
		if (Fx==Fy) continue;
		if (num==0) {printf("%.2lf\n",sqrt(E[i].z));break;}
		Fa[Fx]=Fy,num--;
	}
	return 0;
}
Problem1822
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

const int Maxn=200*2+19,N=200+19,Eps=1e-9,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[N*N*2];
struct WuYao {int x,y,r,t;} A[N];
struct JingLing {int x,y;} B[N];
struct Circle {int x,y,r;} C[N];
int Last[Maxn],pLast[Maxn],pf[N*N*2],cnt,pcnt;
int canW[N],canJ[N],Q[Maxn],Dis[Maxn];
int n,m,k,s,t,L,R,res,Flow,f,w;

struct Point
{
	double x,y;
	Point(double x=0,double y=0):x(x),y(y) {}
};
typedef Point Vector;
Vector operator - (Point A,Point B) {return Vector(A.x-B.x,A.y-B.y);}
double Dist(Point A,Point B) {return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));}
double Cross(Vector A,Vector B) {return A.x*B.y-A.y*B.x;}
double Dis_to_Line(Point A,Point B,Point P)
{
	Vector v1=B-A,v2=P-A;
	return fabs(Cross(v1,v2)/Dist(A,B));
}

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}
int BFS()
{
	f=1,w=0,Q[1]=s;
	memset(Dis,-1,sizeof(Dis));Dis[s]=0;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt) 
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[t]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==t||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&Dis[x]+1==Dis[E[i].y]) 
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			res+=tmp;Flow-=tmp;E[i].f-=tmp;E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}
inline int check(int time)
{
	memcpy(Last,pLast,sizeof(pLast));
	cnt=pcnt;Flow=0;
	for (int i=0;i<cnt;i++) E[i].f=pf[i];
	for (int i=1;i<=n;i++) 
		if (canW[i]) Add_Edge(s,i,time/A[i].t+1);
	while (BFS()) Flow+=Dinic(s,oo);
	return Flow==m;
}

int main()
{
	scanf("%d%d%d",&n,&m,&k);
	s=n+m+1,t=n+m+2;
	for (int i=1;i<=n;i++) scanf("%d%d%d%d",&A[i].x,&A[i].y,&A[i].r,&A[i].t);
	for (int i=1;i<=m;i++) scanf("%d%d",&B[i].x,&B[i].y);
	for (int i=1;i<=k;i++) scanf("%d%d%d",&C[i].x,&C[i].y,&C[i].r);
	memset(Last,-1,sizeof(Last));
	for (int i=1;i<=n;i++)
	{
		Point x=Point(A[i].x,A[i].y);
		for (int j=1;j<=m;j++)
		{
			int tmp=1;Point y=Point(B[j].x,B[j].y);
			if (Dist(x,y)>A[i].r+Eps) tmp=0;
			for (int p=1;p<=k&&tmp;p++)
			{
				Point z=Point(C[p].x,C[p].y);
				if (Dis_to_Line(x,y,z)<C[p].r+Eps) tmp=0;
			}
			if (tmp) canW[i]=canJ[j]=1,Add_Edge(i,j+n,1);
		}
	}
	for (int i=1;i<=m;i++) 
		if (canJ[i]) Add_Edge(i+n,t,1);else {puts("-1");return 0;}
	memcpy(pLast,Last,sizeof(Last));
	pcnt=cnt;
	for (int i=0;i<cnt;i++) pf[i]=E[i].f;
	L=0,R=200*20000;
	while (L<=R)
	{
		int Mid=(L+R)>>1;
		if (check(Mid)) res=Mid,R=Mid-1;else L=Mid+1;
	}
	printf("%d\n",res);
}
Problem1823
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=100*2+19,M=1000*2+19;
struct Edge {int y,nxt;} E[M];
int T,n,m,cnt,Time,Top,tot,x,y;
int SCC[N],DFN[N],Low[N],S[N],Last[N];
char s,t;

void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
void Tarjan(int x)
{
	DFN[x]=Low[x]=++Time;
	S[++Top]=x;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (!DFN[E[i].y]) Tarjan(E[i].y),Low[x]=min(Low[x],Low[E[i].y]);
			else if (!SCC[E[i].y]) Low[x]=min(Low[x],DFN[E[i].y]);
	if (DFN[x]==Low[x])
	{
		int t;tot++;
		do t=S[Top--],SCC[t]=tot; while (t!=x);
	}
}

int main()
{
	scanf("%d",&T);
	while (T--)
	{
		memset(Last,-1,sizeof(Last));
		memset(SCC,0,sizeof(SCC));
		memset(DFN,0,sizeof(DFN));
		cnt=Time=tot=0;
		scanf("%d%d",&n,&m);
		for (int i=0;i<m;i++)
		{
			getchar();
			scanf("%c%d %c%d",&s,&x,&t,&y);
			x=((x-1)<<1)+(s=='m');
			y=((y-1)<<1)+(t=='m');
			Add_Edge(x^1,y),Add_Edge(y^1,x);
		}
		for (int i=0;i<2*n;i++) if (!DFN[i]) Tarjan(i);
		int f=1;
		for (int i=0;i<2*n;i+=2) if (SCC[i]==SCC[i^1]) {f=0;break;}
		puts(f?"GOOD":"BAD");
	}
}
Problem1826
#include<cstdio>
#include<cstring>
#include<queue>
#include<map>
using namespace std;

const int Maxn=100000+19;
struct state
{
	int num,nxt;
	bool operator < (const state& B) const {return nxt<B.nxt;}
};
map<int,int> InH;
priority_queue<state> H;
int A[Maxn],Nxt[Maxn],k,n,tmp,cnt=0,Ans=0;

int main()
{
	scanf("%d%d",&n,&k);
	for (int i=0;i<n;i++) scanf("%d",&A[i]);
	memset(Nxt,60,sizeof(Nxt));
	for (int i=0;i<n;i++)
		for (int j=i+1;j<n;j++)	if (A[j]==A[i]) {Nxt[i]=j;break;}
	for (int i=0;i<n;i++)
		if (!InH[A[i]])
		{
			Ans++;
			InH[A[i]]=1;
			if (cnt<k) 
			{
				cnt++;H.push((state){A[i],Nxt[i]});
				continue;
			}
			state now=H.top();H.pop();
			InH[now.num]=0;
			H.push((state){A[i],Nxt[i]});
		} else H.push((state){A[i],Nxt[i]});
	printf("%d\n",Ans);
	return 0;
}
Problem1826
#include<cstdio>
#include<cstring>
#include<queue>
#include<map>
#include<cctype>
using namespace std;

const int Maxn=100000+19;
struct state
{
	int num,nxt;
	bool operator < (const state& B) const {return nxt<B.nxt;}
};
map<int,int> InH,Map;
priority_queue<state> H;
int A[Maxn],Nxt[Maxn],k,n,tmp,cnt=0,Ans=0;

int f,c;
inline void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	scanf("%d%d",&n,&k);
	for (int i=0;i<n;i++) Read(A[i]);
	memset(Nxt,60,sizeof(Nxt));
	for (int i=n-1;i>=0;i--)
	{
		if (Map[A[i]]!=0) Nxt[i]=Map[A[i]];
		Map[A[i]]=i;
	}
	for (int i=0;i<n;i++)
		if (!InH[A[i]])
		{
			Ans++;
			InH[A[i]]=1;
			if (cnt<k) 
			{
				cnt++;H.push((state){A[i],Nxt[i]});
				continue;
			}
			state now=H.top();H.pop();
			InH[now.num]=0;
			H.push((state){A[i],Nxt[i]});
		} else H.push((state){A[i],Nxt[i]});
	printf("%d\n",Ans);
	return 0;
}
Problem1826
#include<cstdio>
#include<cctype>
#include<queue>
#include<algorithm>

#define Mid (L+R>>1)
using namespace std;

const int Maxn=100000+19,oo=(1<<30)-1;
struct node
{
	int ID,nxt;
	bool operator < (const node& B) const {return nxt<B.nxt;}
};
priority_queue<node> Q;
int Last[Maxn],inH[Maxn],nxt[Maxn],A[Maxn],b[Maxn];
int k,p,x,Ans;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int Find(int x)
{
	int L=1,R=p,res;
	while (L<=R) if (b[Mid]>=x) res=Mid,R=Mid-1;else L=Mid+1;
	return res;
}

int main()
{
	read(p),read(k);
	for (int i=1;i<=p;i++) read(A[i]),b[i]=A[i];
	sort(b+1,b+p+1);
	for (int i=1;i<=p;i++) A[i]=Find(A[i]);
	for (int i=1;i<=p;i++) Last[i]=oo;
	for (int i=p;i;i--) nxt[i]=Last[A[i]],Last[A[i]]=i;
	for (int i=1;i<=p;i++)
		if (inH[A[i]]) Q.push((node){A[i],nxt[i]});
			else
			{
				Ans++;
				if (!k) inH[Q.top().ID]=0,Q.pop();else k--;
				Q.push((node){A[i],nxt[i]}),inH[A[i]]=1;
			}
	printf("%d\n",Ans);
}
Problem1830
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=60;
char A[N],B[N],C[N];
int ca,cb,cc,t,p,M;

int Calc(char *A,char *B,char *C)
{
	ca=strlen(A),cb=strlen(B),cc=strlen(C);
	t=0;while (t<ca&&t<cb&&A[t]==B[t]) t++;
	p=0;while (p<t&&A[p]==C[p]) p++;
	return (ca-t)+(cb-t)+(cc-p+t-p);
}

int main()
{
	scanf("%*d%s",A),scanf("%*d%s",B),scanf("%*d%s",C);
	printf("%d\n",min(min(Calc(A,B,C),Calc(A,C,B)),Calc(B,C,A)));
}
Problem1831
#include<cstdio>
#include<cctype>
#include<cstring>

#define min(a,b) ((a)<(b)?(a):(b))
using namespace std;

const int Maxn=10000+19,top=100+19,oo=(1<<30)-1;
int Up[Maxn][top],Dn[Maxn][top],f[2][top];
int n,k,pre,nxt,Ans=oo,tmp,cur,now;
int A[Maxn],b[top];

int c,F;
void read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') F=1,x=0;else F=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (F) x=-x;
}

int main()
{
	read(n),read(k);
	for (int i=1;i<=n;i++) read(A[i]);
	for (int x=n;x;x--)
		if (A[x]!=-1)
		{
			for (int i=A[x]-1;i;i-=i&-i) tmp+=b[i];
			for (int i=A[x];i<=k;i+=i&-i) b[i]++;
		}
	memset(b,0,sizeof(b));
	for (int i=1;i<=n;i++)
		if (A[i]==-1)
		{
			now++;
			for (int j=1,_=b[1];j<=k;_+=b[++j]) Up[now][j]=_;
		} else b[1]++,b[A[i]]--;
	memset(b,0,sizeof(b));
	for (int i=n;i;i--)
		if (A[i]==-1)
		{
			for (int j=1,_=b[1];j<=k;_+=b[++j]) Dn[now][j]=_;
			now--;
		} else b[A[i]+1]++,b[k+1]--;
	memset(f,60,sizeof(f));
	cur=1,pre=0;f[cur][1]=0;
	for (int i=1;i<=n;i++)
		if (A[i]==-1)
		{
			cur^=1,pre^=1,now++;int Min=oo;
			for (int j=1;j<=k;j++) Min=min(Min,f[pre][j]),f[cur][j]=Min+Up[now][j]+Dn[now][j];
		}
	for (int i=1;i<=k;i++) Ans=min(Ans,f[cur][i]);
	printf("%d\n",Ans+tmp);
}
Problem1832
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#define mp make_pair
using namespace std;

const int Maxn=500000+19;
typedef pair<int,int> Que;
struct Edge {int y,nxt;} E[Maxn*2];
int Last[Maxn],Fa[21][Maxn],Deep[Maxn],cnt;
int n,m,x,y,a,b,c,top,Log;

int ch;
void read(int &x)
{
	while (!isdigit(ch=getchar()));x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
}

void Add_Edge(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x)
{
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].y!=Fa[0][x])
		{
			Fa[0][E[i].y]=x;
			Deep[E[i].y]=Deep[x]+1;
			top=max(top,Deep[E[i].y]);
			DFS(E[i].y);
		}
}
Que Lca(int x,int y)
{
	if (x==y) return mp(0,x);
	int Ans=0;
	if (Deep[x]>Deep[y]) swap(x,y);
	for (int i=Log;i>=0;i--)
		if (Deep[Fa[i][y]]>Deep[x]) Ans+=1<<i,y=Fa[i][y];
	if (Fa[0][y]==x) return mp(Ans+1,x);
	if (Deep[y]>Deep[x]) y=Fa[0][y],Ans++;
	for (int i=Log;i>=0;i--)
		if (Fa[i][y]!=Fa[i][x]) x=Fa[i][x],y=Fa[i][y],Ans+=2<<i;
	return mp(Ans+2,Fa[0][x]);
}
Que Query(int a,int b,int c)
{
	Que A1=Lca(a,b),B1=Lca(A1.second,c);int C1=A1.first+B1.first;
	Que A2=Lca(b,c),B2=Lca(A2.second,a);int C2=A2.first+B2.first;
	Que A3=Lca(a,c),B3=Lca(A3.second,b);int C3=A3.first+B3.first;
	int Min=min(C1,min(C2,C3));
	if (C1==Min) return mp(Min,A1.second);
	if (C2==Min) return mp(Min,A2.second);
	return mp(Min,A3.second);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n),read(m);
	for (int i=1;i<n;i++) read(x),read(y),Add_Edge(x,y);
	DFS(1);
	for (Log=1;(1<<Log)<=top;Log++);
	for (int x=1;x<=Log;x++)
		for (int i=1;i<=n;i++) Fa[x][i]=Fa[x-1][Fa[x-1][i]];
	while (m--)
	{
		read(a),read(b),read(c);
		Que A=Query(a,b,c);
		printf("%d %d\n",A.second,A.first);
	}
}
Problem1833
#include<cstdio>
#include<cmath>
using namespace std;

typedef long long LL;
LL L,R,cnt[10],F[20],Pow[20];

LL Min(LL a,LL b) {return a<b?a:b;}
LL Zero(LL x)
{
	LL Ans=0;
	for (int i=1;i<=16;i++)
		if (Pow[i]>x) break;else Ans+=Min(x,Pow[i]);
	return Ans;
}
void count(LL A,int Len,int I_D)
{
	if (!Len) return;
	for (int i=0;i<A/Pow[Len-1];i++)
	{
		cnt[i]+=I_D*Pow[Len-1];
		for (int j=0;j<10;j++) cnt[j]+=I_D*F[Len-1];
	}
	int Stl=A/Pow[Len-1];
	cnt[Stl]+=I_D*(A%Pow[Len-1]+1);
	count(A%Pow[Len-1],Len-1,I_D);
}

int main()
{
	scanf("%lld%lld",&L,&R);
	Pow[0]=1; 
	for (int i=1;i<=16;i++)
	{
		Pow[i]=Pow[i-1]*10;
		F[i]=i;
		for (int k=0;k<i-1;k++) F[i]*=10;
	}
 	count(R,(int)log10(R)+1,1);
	count(L-1,(int)log10(L-1>0?L-1:1)+1,-1);
	printf("%lld",cnt[0]-(Zero(R)-Zero(L-1)));
	for (int i=1;i<10;i++) printf(" %lld",cnt[i]);
	printf("\n");
	return 0;
}
Problem1834
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=1000+19,M=5000+19,oo=(1<<30)-1;
struct Edge {int x,y,f,c,nxt;} E[M*4];
int Last[N],cnt;
int Dis[N],Q[N],pre[N],vis[N],C[M];
int n,m,k,x,y,f,c,t;
int Flow,Cost;

void Add_Edge(int x,int y,int f,int c)
{
	E[cnt]=(Edge){x,y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){y,x,0,-c,Last[y]};Last[y]=cnt++;
}

int BFS()
{
	int f=1,w=0;Q[1]=1;
	memset(Dis,-1,sizeof(Dis));Dis[1]=0;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[n]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==n||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&Dis[x]+1==Dis[E[i].y]) 
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			Flow-=tmp;res+=tmp;E[i].f-=tmp;E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int SPFA()
{
	int f=1,w=0;Q[1]=1;
	memset(Dis,64,sizeof(Dis));Dis[1]=0;pre[1]=-1;
	while (f!=w)
	{
		w=(w+1)%1000;
		int x=Q[w];vis[x]=0;
		for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&Dis[x]+E[i].c<Dis[E[i].y])
			{
				Dis[E[i].y]=Dis[x]+E[i].c;
				pre[E[i].y]=i;
				if (!vis[E[i].y]) vis[E[i].y]=1,f=(f+1)%1000,Q[f]=E[i].y;
			}
	}
	return Dis[t]<oo;
}
void Update()
{
	int Min=oo;
	for (int i=pre[t];i!=-1;i=pre[E[i].x]) Min=min(Min,E[i].f);
	for (int i=pre[t];i!=-1;i=pre[E[i].x]) E[i].f-=Min,E[i^1].f+=Min;
	Cost+=Min*Dis[t];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d%d",&n,&m,&k);
	t=n+1;
	for (int i=0;i<m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&f,&c);
		Add_Edge(x,y,f,0);C[i]=c;
	}
	while (BFS()) Flow+=Dinic(1,oo);
	printf("%d ",Flow);
	for (int i=0,_=cnt;i<_;i+=2) Add_Edge(E[i].x,E[i].y,oo,C[i/2]);
	Add_Edge(n,t,k,0);
	while (SPFA()) Update();
	printf("%d\n",Cost);
}
Problem1835
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=20000+19,oo=(1<<30)-1;
int C[N],W[N],S[N],D[N],L[N],R[N],f[N],n,k;
vector<int> V[N];
typedef vector<int>::iterator Vit;
int Min[N*4],Add[N*4],Ql,Qr,v,Ans;

void Build(int x,int L,int R)
{
	Add[x]=0;
	if (L==R) {Min[x]=f[L];return;}
	Build(Lsn,L,Mid);Build(Rsn,Mid+1,R);
	Min[x]=min(Min[Lsn],Min[Rsn]);
}
void Push_down(int x)
{
	if (Add[x])
		Min[Lsn]+=Add[x],Min[Rsn]+=Add[x],
		Add[Lsn]+=Add[x],Add[Rsn]+=Add[x],Add[x]=0;
}
void Update(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {Min[x]+=v,Add[x]+=v;return;}
	Push_down(x);
	if (Ql<=Mid) Update(Lsn,L,Mid);
	if (Qr>Mid) Update(Rsn,Mid+1,R);
	Min[x]=min(Min[Lsn],Min[Rsn]);
}
int Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return Min[x];
	Push_down(x);
	int res=oo;
	if (Ql<=Mid) res=min(res,Query(Lsn,L,Mid));
	if (Qr>Mid) res=min(res,Query(Rsn,Mid+1,R));
	return res;
}

int main()
{
	n=IN(),k=IN();
	For(i,2,n+1) D[i]=IN();
	For(i,1,n+1) C[i]=IN();
	For(i,1,n+1) S[i]=IN();
	For(i,1,n+1) W[i]=IN();
	D[++n]=oo;
	For(i,1,n)
		L[i]=lower_bound(D+1,D+n+1,D[i]-S[i])-D-1,
		R[i]=upper_bound(D+1,D+n+1,D[i]+S[i])-D,
		V[R[i]].push_back(i);

	for (int i=1,_=0;i<=n;i++)
	{
		for (Vit it=V[i].begin();it!=V[i].end();it++) _+=W[*it];f[i]=_+C[i];
	}
	Ans=f[n];
	For(i,2,k+2)
	{
		Build(1,1,n);
		For(j,1,n+1)
		{
			for (Vit it=V[j].begin();it!=V[j].end();it++)
			{
				Ql=1,Qr=L[*it],v=W[*it];if (Ql<=Qr) Update(1,1,n);
			}
			Ql=1,Qr=j-1;if (Ql<=Qr) f[j]=Query(1,1,n)+C[j];else f[j]=oo;
		}
		Ans=min(Ans,f[n]);
	}
	printf("%d\n",Ans);
}
Problem1853
#include<cstdio>
#include<algorithm>
#include<functional>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

typedef unsigned long long LL;
LL L,R,A[1<<15],B[1<<15],Ans;
int v[1<<15],cnt,n;

void Getnum(LL x)
{
	if (x) A[cnt++]=x;
	if (x*10+6<=R) Getnum(x*10+6);
	if (x*10+8<=R) Getnum(x*10+8);
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
void Calc(int x,LL Lcm,int c)
{
	if (Lcm>R) return;
	if (x==n) {if (Lcm!=1) Ans+=(c?1:-1)*(R/Lcm-(L-1)/Lcm);return;}
	Calc(x+1,Lcm,c);
	Calc(x+1,Lcm/gcd(Lcm,B[x])*B[x],c^1);
}

int main()
{
	scanf("%lld%lld",&L,&R);
	Getnum(0);
	sort(A,A+cnt);
	For(i,0,cnt)
		if (!v[i])
		{
			B[n++]=A[i];
			For(j,i+1,cnt) if (A[j]%A[i]==0) v[j]=1;
		}
	sort(B,B+n,greater<int>());
	Calc(0,1,0);
	printf("%lld\n",Ans);
}
Problem1854
#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
#include<bitset>
using namespace std;

const int Maxn=1000000+19,Maxs=10000+19;
int L[Maxn];
vector<int> G[Maxs];
bitset<Maxn> marked;
int n,s;

int find(int v)
{
	for (int i=0;i<G[v].size();i++)
	{
		int nxt=G[v][i];
		if (!marked.test(nxt))
		{
			marked.set(nxt);
			if (!L[nxt]||find(L[nxt]))
			{
				L[nxt]=v;return 1;
			}
		}
	}
	return 0;
}

int main()
{
	//freopen("1854.in","r",stdin);
	//freopen("1854.out","w",stdout);
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		G[a].push_back(i);
		G[b].push_back(i);
		s=max(s,max(a,b));
	}
	int ans=0;
	for (int i=1;i<=s;i++) 
	{
		marked.reset();
		if (find(i)) ans++;else break;
	}
	printf("%d\n",ans);
	//system("pause");
}
Problem1856
#include<cstdio>
using namespace std;

const int Mod=20100403;
int D[2000000+19],n,m;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%Mod) if (b&1) res=1LL*res*a%Mod;
	return res;
}

int main()
{
	scanf("%d%d",&n,&m);
	D[0]=1;
	for (int i=1;i<=n+m;i++) D[i]=1LL*D[i-1]*i%Mod;
	int res=1LL*D[n+m]*Pow(D[n],Mod-2)%Mod*Pow(D[m],Mod-2)%Mod;
	res=(res-1LL*D[n+m]*Pow(D[n+1],Mod-2)%Mod*Pow(D[m-1],Mod-2)%Mod+Mod)%Mod;
	printf("%d\n",res);
}
Problem1857
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;

typedef double Db;
const Db eps=1e-3;
int Ax,Ay,Bx,By,Cx,Cy,Dx,Dy;
Db Lx,Rx,Ly,Ry;
int P,Q,R;

Db Dis(Db x,Db y,Db x2,Db y2) {return sqrt((x-x2)*(x-x2)+(y-y2)*(y-y2));}
Db calc(Db x,Db y)
{
	double Lx=Cx,Rx=Dx,Ly=Cy,Ry=Dy;
	while (fabs(Rx-Lx)>eps||fabs(Ry-Ly)>eps)
	{
		Db c1x=Lx+(Rx-Lx)/3.0,c1y=Ly+(Ry-Ly)/3.0;
		Db c2x=Rx-(Rx-Lx)/3.0,c2y=Ry-(Ry-Ly)/3.0;
		Db Ans1=Dis(Ax,Ay,x,y)/P+Dis(c1x,c1y,Dx,Dy)/Q+Dis(x,y,c1x,c1y)/R;
		Db Ans2=Dis(Ax,Ay,x,y)/P+Dis(c2x,c2y,Dx,Dy)/Q+Dis(x,y,c2x,c2y)/R;
		if (Ans1>Ans2) Lx=c1x,Ly=c1y;else Rx=c2x,Ry=c2y;
	}
	return Dis(Ax,Ay,x,y)/P+Dis(Lx,Ly,Dx,Dy)/Q+Dis(x,y,Lx,Ly)/R;
}

int main()
{
	scanf("%d%d%d%d",&Ax,&Ay,&Bx,&By);
	scanf("%d%d%d%d",&Cx,&Cy,&Dx,&Dy);
	scanf("%d%d%d",&P,&Q,&R);
	Lx=Ax,Rx=Bx,Ly=Ay,Ry=By;
	while (fabs(Rx-Lx)>eps||fabs(Ry-Ly)>eps)
	{
		Db c1x=Lx+(Rx-Lx)/3.0,c1y=Ly+(Ry-Ly)/3.0;
		Db c2x=Rx-(Rx-Lx)/3.0,c2y=Ry-(Ry-Ly)/3.0;
		if (calc(c1x,c1y)>calc(c2x,c2y)) Lx=c1x,Ly=c1y;else Rx=c2x,Ry=c2y;
	}
	printf("%.2lf\n",calc(Lx,Ly));
}
Problem1858
#include<cstdio>
#include<cctype>
#include<algorithm>

#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int N=100000+19;
struct Segnode
{
	int L,R,Ml0,Mr0,Ml1,Mr1,M0,M1,Sum,Rev,Set;
} S[N*4];
int A[N],n,Q,Ql,Qr,opt;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

Segnode operator + (Segnode A,Segnode B)
{
	Segnode C;C.L=A.L,C.R=B.R;
	C.Ml0=A.Ml0;if (A.Sum==0) C.Ml0+=B.Ml0;
	C.Mr0=B.Mr0;if (B.Sum==0) C.Mr0+=A.Mr0;
	C.Ml1=A.Ml1;if (A.Sum==A.R-A.L+1) C.Ml1+=B.Ml1;
	C.Mr1=B.Mr1;if (B.Sum==B.R-B.L+1) C.Mr1+=A.Mr1;
	C.Sum=A.Sum+B.Sum;
	C.M0=max(max(A.M0,B.M0),A.Mr0+B.Ml0);
	C.M1=max(max(A.M1,B.M1),A.Mr1+B.Ml1);
	C.Set=-1,C.Rev=0;
	return C;
}
void set_Set(int x,int L,int R,int v)
{
	S[x].Ml0=S[x].Mr0=S[x].M0=(v?0:R-L+1);
	S[x].Ml1=S[x].Mr1=S[x].M1=S[x].Sum=(v?R-L+1:0);
	S[x].Rev=0;
}
void set_Rev(int x,int L,int R)
{
	swap(S[x].Ml0,S[x].Ml1);swap(S[x].Mr0,S[x].Mr1);swap(S[x].M0,S[x].M1);
	S[x].Sum=(R-L+1)-S[x].Sum;
	if (~S[x].Set) S[x].Set^=1;
}
void Push_down(int x,int L,int R)
{
	if (L==R) return;
	if (S[x].Rev)
	{
		S[Lsn].Rev^=1,S[Rsn].Rev^=1;S[x].Rev=0;
		set_Rev(Lsn,L,Mid),set_Rev(Rsn,Mid+1,R);
	}
	if (~S[x].Set)
	{
		int v=S[x].Set;
		S[Lsn].Set=S[Rsn].Set=v;S[x].Set=-1;
		set_Set(Lsn,L,Mid,v),set_Set(Rsn,Mid+1,R,v);
	}
}
void Build(int x,int L,int R)
{
	if (L==R)
	{
		int s=A[L];S[x]=(Segnode){L,R,!s,!s,s,s,!s,s,s,0,-1};return;
	}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
void Change(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr)
	{
		if (opt<=1) S[x].Set=opt,set_Set(x,L,R,opt);
			else S[x].Rev^=1,set_Rev(x,L,R);
		return;
	}
	Push_down(x,L,R);
	if (Ql<=Mid) Change(Lsn,L,Mid);
	if (Qr>Mid) Change(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
Segnode Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return S[x];
	Push_down(x,L,R);
	if (Ql<=Mid&&Qr<=Mid) return Query(Lsn,L,Mid);
	if (Ql>Mid&&Qr>Mid) return Query(Rsn,Mid+1,R);
	return Query(Lsn,L,Mid)+Query(Rsn,Mid+1,R);
}

int main()
{
	read(n);read(Q);
	for (int i=1;i<=n;i++) read(A[i]);
	Build(1,1,n);
	while (Q--)
	{
		read(opt),read(Ql),read(Qr);Ql++,Qr++;
		if (opt<=2) Change(1,1,n);
		if (opt==3) printf("%d\n",Query(1,1,n).Sum);
		if (opt==4) printf("%d\n",Query(1,1,n).M1);
	}
}
Problem1858
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define maxn 100100
#define Rt tree[rt]
#define lson tree[rt<<1]
#define rson tree[rt<<1|1]
#define Rep(x, a, b) for(int x=a; x<=b; x++)
int op, a, b, n, m;
struct Node{
	int l, r, llen[2], rlen[2], tlen[2], sum, set, rev;
	inline int mid(){ return l+r>>1; }
	inline int len(){ return r-l+1; }
}tree[maxn<<2];
inline void Down(int rt){
	if(Rt.set!=-1)
	{
		int c=Rt.set; Rt.set=-1; Rt.rev=0;
		lson.set=rson.set=c; lson.rev=rson.rev=0;
		lson.llen[c]=lson.rlen[c]=lson.tlen[c]=lson.len();
		rson.llen[c]=rson.rlen[c]=rson.tlen[c]=rson.len();
		lson.llen[c^1]=lson.rlen[c^1]=lson.tlen[c^1]=rson.llen[c^1]=rson.rlen[c^1]=rson.tlen[c^1]=0;
		lson.sum=lson.len()*c; rson.sum=rson.len()*c;
	}
	else if(Rt.rev)
	{
		swap(lson.llen[0], lson.llen[1]);
		swap(lson.rlen[0], lson.rlen[1]);
		swap(lson.tlen[0], lson.tlen[1]);
		swap(rson.llen[0], rson.llen[1]);
		swap(rson.rlen[0], rson.rlen[1]);
		swap(rson.tlen[0], rson.tlen[1]);
		lson.sum=lson.len()-lson.sum;
		rson.sum=rson.len()-rson.sum;
		if(lson.set>-1) lson.set^=1; else lson.rev^=1;
		if(rson.set>-1) rson.set^=1; else rson.rev^=1;
		Rt.rev=0;
	}
}
inline void Up(int rt){
	for(int c=0; c<=1; c++)
	{
		Rt.llen[c]=lson.llen[c];
		if(lson.llen[c]==lson.len()) Rt.llen[c]+=rson.llen[c];
		Rt.rlen[c]=rson.rlen[c];
		if(rson.rlen[c]==rson.len()) Rt.rlen[c]+=lson.rlen[c];
		Rt.tlen[c]=max(lson.rlen[c]+rson.llen[c], max(lson.tlen[c], rson.tlen[c]));
	}
	Rt.sum=lson.sum+rson.sum;
}
inline void Build(int rt, int l, int r){
	Rt.l=l, Rt.r=r, Rt.set=-1;
	if(l==r)
	{
		int x;
		scanf("%d", &x); Rt.sum=x; Rt.set=-1;
		Rt.llen[x]=Rt.rlen[x]=Rt.tlen[x]=1;
		return;
	}
	int mid=Rt.mid();
	Build(rt<<1, l, mid);
	Build(rt<<1|1, mid+1, r);
	Up(rt);
}
inline void Set(int rt, int L, int R, int v){
	if(Rt.l>=L && Rt.r<=R)
	{
		Rt.rev=0; Rt.set=v;
		Rt.llen[v]=Rt.rlen[v]=Rt.tlen[v]=Rt.len();
		Rt.llen[v^1]=Rt.rlen[v^1]=Rt.tlen[v^1]=0;
		Rt.sum=Rt.len()*v;
		return;
	}
	Down(rt);
	int mid=Rt.mid();
	if(L<=mid) Set(rt<<1, L, R, v);
	if(mid<R) Set(rt<<1|1, L, R, v);
	Up(rt);
}
inline void Rev(int rt, int L, int R){
	if(Rt.l>=L && Rt.r<=R)
	{
		swap(Rt.llen[0], Rt.llen[1]);
		swap(Rt.rlen[0], Rt.rlen[1]);
		swap(Rt.tlen[0], Rt.tlen[1]);
		Rt.sum=Rt.len()-Rt.sum;
		if(Rt.set>-1) Rt.set^=1; else Rt.rev^=1;
		return;
	}
	Down(rt);
	int mid=Rt.mid();
	if(L<=mid) Rev(rt<<1, L, R);
	if(mid<R) Rev(rt<<1|1, L, R);
	Up(rt);
}
inline int Num(int rt, int L, int R){
	if(Rt.l>=L && Rt.r<=R) return Rt.sum;
	Down(rt);
	int mid=Rt.mid(), ret=0;
	if(L<=mid) ret+=Num(rt<<1, L, R);
	if(mid<R) ret+=Num(rt<<1|1, L, R);
	return ret;
}
inline void Merge(Node &l, Node &r, Node &ret){
	ret.llen[1]=l.llen[1];
	if(l.llen[1]==l.len()) ret.llen[1]+=r.llen[1];
	ret.rlen[1]=r.rlen[1];
	if(r.rlen[1]==r.len()) ret.rlen[1]+=l.rlen[1];
	ret.tlen[1]=max(l.rlen[1]+r.llen[1], max(l.tlen[1], r.tlen[1]));
}
inline Node Con(int rt, int L, int R){
	if(Rt.l>=L && Rt.r<=R) return Rt;
	Down(rt);
	int mid=Rt.mid(); Node lret, rret, ret;
	if(R<=mid) return Con(rt<<1, L, R);
	if(L>mid) return Con(rt<<1|1, L, R);
	lret=Con(rt<<1, L, R);
	rret=Con(rt<<1|1, L, R);
	Merge(lret, rret, ret);
	return ret;
}
int main(){
	scanf("%d%d", &n, &m);
	Build(1, 1, n);
	while(m--)
	{
		scanf("%d%d%d", &op, &a, &b); a++, b++;
		int hehe=0;	
		if(op==0) Set(1, a, b, 0);
		if(op==1) Set(1, a, b, 1);
		if(op==2) Rev(1, a, b);
		if(op==3) printf("%d\n", Num(1, a, b));
		if(op==4) printf("%d\n", Con(1, a, b).tlen[1]);
	}
}
Problem1861
#include<cstdio>
#include<cctype>

#define Mid (L+R>>1)
using namespace std;

const int Maxn=80000+19;
struct node;typedef node* rt;rt null;
struct node
{
	int Sz,key;
	rt L,R,F;
	void Update() {if (this==null) return;Sz=L->Sz+R->Sz+1;}
} ND[Maxn];
rt Rt,pos[Maxn];
int A[Maxn],tcnt,n,Q,x,t,v;
char s[10];

int c,f;
void read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}

rt New(int v)
{
	rt x=&ND[++tcnt];
	x->L=x->R=x->F=null,x->Sz=1,x->key=v;pos[v]=x;
	return x;
}
void Zig(rt x)
{
	rt y=x->F,z=y->F;
	(y==z->L?z->L=x:z->R=x),x->F=z;
	x->R->F=y,y->L=x->R;y->F=x,x->R=y;y->Update();
}
void Zag(rt x)
{
	rt y=x->F,z=y->F;
	(y==z->L?z->L=x:z->R=x),x->F=z;
	x->L->F=y,y->R=x->L;y->F=x,x->L=y;y->Update();
}
void Splay(rt x,rt A)
{
	while (x->F!=A)
	{
		rt y=x->F,z=y->F;
		if (y->F==A) (x==y->L?Zig(x):Zag(x));else
		if (y==z->L) (x==y->L?(Zig(y),Zig(x)):(Zag(x),Zig(x)));
			else (x==y->L?(Zig(x),Zag(x)):(Zag(y),Zag(x)));
	}
	x->Update();
	if (A==null) Rt=x;
}
rt Findkth(rt A,int k)
{
	for(;;)
		if (A->L->Sz+1==k) return A;else (A->L->Sz+1>k)?A=A->L:(k-=A->L->Sz+1,A=A->R);
}
rt Delete(rt A)
{
	Splay(A,null);
	if (A->R==null) Rt=A->L,A->L->F=null;else
	{
		rt x=A->L,y=Findkth(A->R,1);
		Splay(y,A);
		y->F=null;y->L=x,x->F=y;Rt=y;y->Update();
	}
	A->L=A->R=null;
}
void Insert(rt A,int t)
{
	Splay(A,null);
	rt x=(t==-1?Findkth(A->L,A->L->Sz):Findkth(A->R,1));Splay(x,A);
	if (t==-1) A->L=x->L,A->L->F=A,x->L=A,x->R=A->R,x->R->F=x,A->R=null;
		else A->R=x->R,A->R->F=A,x->R=A,x->L=A->L,x->L->F=x,A->L=null;
	Rt=A->F=x,x->F=null;
	x->Update();A->Update();
}
void Build(rt &x,int L,int R)
{
	if (L>R) return;
	x=New(A[Mid]);
	Build(x->L,L,Mid-1);Build(x->R,Mid+1,R);
	x->L->F=x->R->F=x;x->Update();
}

int main()
{
	Rt=null=&ND[0];
	null->L=null->R=null->F=null,null->Sz=0;
	read(n),read(Q);
	for (int i=1;i<=n;i++) read(A[i]);
	Build(Rt,1,n);
	while (Q--)
	{
		scanf("%s",s),read(x);
		if (s[0]=='T') {rt A=pos[x];Delete(A);A->R=Rt,Rt->F=A,A->Update();Rt=A;}
		if (s[0]=='B') {rt A=pos[x];Delete(A);A->L=Rt,Rt->F=A,A->Update();Rt=A;}
		if (s[0]=='I') {read(t);if (t) Insert(pos[x],t);}
		if (s[0]=='A') Splay(pos[x],null),printf("%d\n",pos[x]->L->Sz);
		if (s[0]=='Q') printf("%d\n",Findkth(Rt,x)->key);
	}
}
Problem1862
#include<map>
#include<cstdio>
#include<string>
#include<cctype>
#include<sstream>
using namespace std;

const int Maxn=250000+19;
typedef int one[Maxn];
map<string,int> Map;
int T,sco,Dis,cnt,rk,PRE,c;
char ss[19];
string s,Map2[Maxn];

int rt;
one key,Lsn,Rsn,size,Fa;
struct Splay_tree
{
	
	inline void Update(int x) {size[x]=size[Lsn[x]]+size[Rsn[x]]+1;}
	inline void Zig(int x)
	{
		int y=Fa[x],z=Fa[y],t=Rsn[x];
		if (z) if (y==Lsn[z]) Lsn[z]=x;else Rsn[z]=x;
		Fa[x]=z;Rsn[x]=y;Fa[y]=x;Lsn[y]=t;
		if (t) Fa[t]=y;
		Update(y);
	}
	inline void Zag(int x)
	{
		int y=Fa[x],z=Fa[y],t=Lsn[x];
		if (z) if (y==Lsn[z]) Lsn[z]=x;else Rsn[z]=x;
		Fa[x]=z;Lsn[x]=y;Fa[y]=x;Rsn[y]=t;
		if (t) Fa[t]=y;
		Update(y);
	}
	inline void Splay(int x)
	{
		while (Fa[x])
		{
			int y=Fa[x],z=Fa[y];
			if (!z) 
				if (x==Lsn[y]) Zig(x);else Zag(x);
			else
				if (x==Lsn[y])
					if (y==Lsn[z]) Zig(y),Zig(x);else Zig(x),Zag(x);
				else
					if (y==Lsn[z]) Zag(x),Zig(x);else Zag(y),Zag(x);
		}
		Update(x);rt=x;
	}
	inline void Insert(int &t,int v,int F,int x)
	{
		if (!t) {t=x;Fa[t]=F;key[t]=v;size[t]=1;Lsn[t]=Rsn[t]=0;return;}
		size[t]++;
		Insert(v>key[t]?Lsn[t]:Rsn[t],v,t,x);
	}
	inline int Rank(int x) {Splay(x);return size[Lsn[x]]+1;}
	inline int Select(int k) 
	{
		int x=rt;
		while (1)
		{
			if (size[Lsn[x]]+1==k) return x;
			(size[Lsn[x]]+1<k)?(k-=size[Lsn[x]]+1,x=Rsn[x]):(x=Lsn[x]);
		}
	}
	inline int Join(int x,int y)
	{
		Fa[x]=Fa[y]=0;
		if (!x||!y) return x+y;
		while (Rsn[x]) x=Rsn[x];
		Splay(x);
		Fa[y]=x;Rsn[x]=y;
		return x;
	}
	inline void Delete(int x) {Splay(x);rt=Join(Lsn[x],Rsn[x]);}

} Splay;

inline void Mid_vis(int x)
{
	if (!x) return;PRE=x;
	if (rk&&Lsn[x]) Mid_vis(Lsn[x]);
	if (rk) {printf(" %s",Map2[x].c_str());rk--;}
	if (rk&&Rsn[x]) Mid_vis(Rsn[x]);
}

int main()
{
	scanf("%d",&T);
	while (T--)
	{
		while ((c=getchar())!='+'&&c!='?');
		if (c=='+')
		{
			scanf("%s%d",ss,&sco);s=string(ss);
			int &x=Map[s],_new=0;
			if (x==0) x=++cnt,_new=1,Map2[x]=s;else Splay.Delete(x);
			Splay.Insert(rt,sco,0,x),Splay.Splay(x);
		}
		if (c=='?')
		{
			scanf("%s",ss);s=string(ss);
			if (isdigit(ss[0]))
			{
				stringstream t;t<<s;t>>rk;
				Splay.Splay(Splay.Select(rk));rk=9;
				printf("%s",Map2[rt].c_str());
				Mid_vis(Rsn[rt]);puts("");
				if (PRE) Splay.Splay(PRE);
			} else 
			{
				int &x=Map[s],_new=0;
				printf("%d\n",Splay.Rank(x));
			}
		}
	}
}
Problem1867
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=50+19;
typedef long long LL;
int n,m;
LL F[N][N],X,Y,t;
char S[N][N];

LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
int Getchar() {int c;while ((c=getchar())!='*'&&c!='.');return c;}

int main()
{
	scanf("%d%d",&n,&m);
	For(i,1,n+1) For(j,0,i) S[i][j]=Getchar();
	F[1][0]=1LL<<n;
	For(i,1,n+1) For(j,0,i)
		if (S[i][j]=='*') F[i+1][j]+=F[i][j]/2,F[i+1][j+1]+=F[i][j]/2;else F[i+2][j+1]+=F[i][j];
	X=F[n+1][m],Y=1LL<<n,t=gcd(X,Y);
	printf("%lld/%lld",X/t,Y/t);
}
Problem1875
#include<cstdio>
#include<cstring>
using namespace std;

const int M=120+19,Mod=45989;
struct matrix
{
	int s[M];
	matrix() {for (int i=0;i<M;i++) s[i]=0;}
} F;
struct Matrix
{
	int s[M][M];
	Matrix() {for (int i=0;i<M;i++) for (int j=0;j<M;j++) s[i][j]=0;}
} can;
struct Edge {int x,y;} A[M];
int n,m,t,a,b,x,y,Ans;

matrix operator * (matrix A,Matrix B)
{
	matrix c;
	for (int j=0;j<m;j++)
		for (int k=0;k<m;k++) (c.s[j]+=A.s[k]*B.s[k][j]%Mod)%Mod;
	return c;
}
Matrix operator * (Matrix A,Matrix B)
{
	Matrix c;
	for (int i=0;i<m;i++)
		for (int j=0;j<m;j++)
			for (int k=0;k<m;k++) (c.s[i][j]+=A.s[i][k]*B.s[k][j]%Mod)%=Mod;
	return c;
}
Matrix Pow(Matrix A,int B)
{
	Matrix tmp=A,res;
	for (int i=0;i<m;i++) res.s[i][i]=1;
	while (B)
	{
		if (B&1) res=res*tmp;
		tmp=tmp*tmp;
		B>>=1;
	}
	return res;
}

int main()
{
	scanf("%d%d%d%d%d",&n,&m,&t,&a,&b);
	for (int i=0;i<m;i++)
	{
		scanf("%d%d",&x,&y);
		A[2*i]=(Edge){x,y};
		A[2*i+1]=(Edge){y,x};
	}
	m*=2;
	for (int i=0;i<m;i++)
		for (int j=0;j<m;j++)
			can.s[i][j]=(i!=j&&(i^1)!=j&&A[i].y==A[j].x);
	for (int i=0;i<m;i++) if (A[i].x==a) F.s[i]=1;
	F=F*Pow(can,t-1);
	for (int i=0;i<m;i++) if (A[i].y==b) (Ans+=F.s[i])%=Mod;
	printf("%d\n",Ans);
}
Problem1876
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=1300+19,Base=100000000;
int cnt;
char t[10000+19];

struct BigInt
{
	int Len,s[Maxn];
	
	bool operator < (const BigInt& B) const 
	{
		if (Len!=B.Len) return Len<B.Len;
		for (int i=Len-1;i>=0;i--)
			if (s[i]!=B.s[i]) return s[i]<B.s[i];
		return 0;
	}
	
	void clear() {while (Len>1&&s[Len-1]==0) Len--;}
	void read()
	{
		scanf("%s",t);int L=strlen(t);
		for (int i=0;i<=L/8;i++)
			for (int j=max(L-i*8-8,0);j<L-i*8;j++) s[i]=s[i]*10+t[j]-'0';
		Len=L/8+1;clear();
	}
	void print()
	{
		for (int i=Len-1;i>=0;i--)
		{
			if (i!=Len-1) 
			{
				if (s[i]<10000000) putchar('0');
				if (s[i]<1000000) putchar('0');
				if (s[i]<100000) putchar('0');
				if (s[i]<10000) putchar('0');
				if (s[i]<1000) putchar('0');
				if (s[i]<100) putchar('0');
				if (s[i]<10) putchar('0');
			}
			printf("%d",s[i]);
		}
		puts("");
	}
} A,B;

BigInt operator * (BigInt A,int b)
{
	for (int i=0;i<A.Len;i++) A.s[i]*=b;
	for (int i=0;i<=A.Len;i++) A.s[i+1]+=A.s[i]/Base,A.s[i]%=Base;
	A.Len+=2;A.clear();return A;
}
BigInt operator / (BigInt A,int b)
{
	for (int i=A.Len-1;i>=0;i--)
	{
		if (i) A.s[i-1]+=A.s[i]%b*Base;
		A.s[i]/=b;
	}
	A.clear();return A;
}
BigInt operator - (BigInt A,BigInt B)
{
	for (int i=0;i<A.Len;i++)
	{
		if (A.s[i]<B.s[i]) A.s[i+1]--,A.s[i]+=Base;
		A.s[i]-=B.s[i];
	}
	A.clear();return A;
}

int main()
{
	A.read();B.read();
	for (;;)
	{
		if (A.Len==1&&A.s[0]==0) {while (cnt--) B=B*2;B.print();return 0;}
		if (B.Len==1&&B.s[0]==0) {while (cnt--) A=A*2;A.print();return 0;}
		while (!(A.s[0]&1&&B.s[0]&1))
		{
			if (A.s[0]%2==0&&B.s[0]%2==0) cnt++,A=A/2,B=B/2;
			if (A.s[0]%2==1&&B.s[0]%2==0) B=B/2;
			if (A.s[0]%2==0&&B.s[0]%2==1) A=A/2;
		}
		if (B<A) A=A-B;else B=B-A;
	}
}
Problem1876
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=1300+19,Base=100000000;
int cnt;
char t[10000+19];

struct BigInt
{
	int Len,s[Maxn];
	
	bool operator < (const BigInt& B) const 
	{
		if (Len!=B.Len) return Len<B.Len;
		for (int i=Len-1;i>=0;i--)
			if (s[i]!=B.s[i]) return s[i]<B.s[i];
		return 0;
	}
	
	void clear() {while (Len>1&&s[Len-1]==0) Len--;}
	void read()
	{
		scanf("%s",t);int L=strlen(t);
		for (int i=0;i<=L/8;i++)
			for (int j=max(L-i*8-8,0);j<L-i*8;j++) s[i]=s[i]*10+t[j]-'0';
		Len=L/8+1;clear();
	}
	void print()
	{
		for (int i=Len-1;i>=0;i--)
		{
			if (i!=Len-1) 
			{
				if (s[i]<10000000) putchar('0');
				if (s[i]<1000000) putchar('0');
				if (s[i]<100000) putchar('0');
				if (s[i]<10000) putchar('0');
				if (s[i]<1000) putchar('0');
				if (s[i]<100) putchar('0');
				if (s[i]<10) putchar('0');
			}
			printf("%d",s[i]);
		}
		puts("");
	}
} A,B;

BigInt operator * (BigInt A,int b)
{
	for (int i=0;i<A.Len;i++) A.s[i]<<=1;
	for (int i=0;i<=A.Len;i++) A.s[i+1]+=A.s[i]/Base,A.s[i]%=Base;
	A.Len+=2;A.clear();return A;
}
BigInt operator / (BigInt A,int b)
{
	for (int i=A.Len-1;i>=0;i--)
	{
		if (i&&A.s[i]&1) A.s[i-1]+=Base;
		A.s[i]>>=1;
	}
	A.clear();return A;
}
BigInt operator - (BigInt A,BigInt B)
{
	for (int i=0;i<A.Len;i++)
	{
		if (A.s[i]<B.s[i]) A.s[i+1]--,A.s[i]+=Base;
		A.s[i]-=B.s[i];
	}
	A.clear();return A;
}

int main()
{
	A.read();B.read();
	for (;;)
	{
		if (A.Len==1&&A.s[0]==0) {while (cnt--) B=B*2;B.print();return 0;}
		if (B.Len==1&&B.s[0]==0) {while (cnt--) A=A*2;A.print();return 0;}
		while (!(A.s[0]&1&&B.s[0]&1))
		{
			if (A.s[0]%2==0&&B.s[0]%2==0) cnt++,A=A/2,B=B/2;
			if (A.s[0]%2==1&&B.s[0]%2==0) B=B/2;
			if (A.s[0]%2==0&&B.s[0]%2==1) A=A/2;
		}
		if (B<A) A=A-B;else B=B-A;
	}
}
Problem1877
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=200*2+19,Maxm=20000*2+19;
const int oo=(1<<30)-1;
struct Edge
{
	int u,v,f,c,nxt;
} E[Maxm<<2];
int pre[Maxn],vis[Maxn],Dis[Maxn],Last[Maxn];
int n,m,u,v,c,cnt=0,S,T,Flow=0,Cost=0;

inline int Out(int x) {return 2*x-1;}
inline int In(int x) {return 2*x-2;}
void Add_Edge(int u,int v,int f,int c)
{
	E[cnt]=(Edge){u,v,f,c,Last[u]};
	Last[u]=cnt++;
}
int SPFA()
{
	queue<int> Q;
	memset(Dis,64,sizeof(Dis));
	pre[S]=-1;vis[S]=1;Dis[S]=0;
	Q.push(S);
	while (!Q.empty())
	{
		int x=Q.front();Q.pop();
		vis[x]=0;
		for (int i=Last[x];i!=-1;i=E[i].nxt)
		{
			int y=E[i].v;
			if (E[i].f&&Dis[x]+E[i].c<Dis[y])
			{
				Dis[y]=Dis[x]+E[i].c;
				pre[y]=i;
				if (!vis[y]) {vis[y]=1;Q.push(y);}
			}
		}
	}
	return Dis[T]<oo;
}
void Update()
{
	for (int i=pre[T];i!=-1;i=pre[E[i].u]) E[i].f--,E[i^1].f++;
	Flow++;Cost+=Dis[T];
}

int main()
{
	memset(Last,255,sizeof(Last));
	scanf("%d%d",&n,&m);
	S=In(1);T=Out(n);
	for (int i=2;i<n;i++) 
	{
		Add_Edge(In(i),Out(i),1,0);
		Add_Edge(Out(i),In(i),0,0);
	}
	Add_Edge(S,Out(1),oo,0);Add_Edge(Out(1),S,0,0);
	Add_Edge(In(n),T,oo,0);Add_Edge(T,In(n),0,0);
	for (int i=0;i<m;i++)
	{
		scanf("%d%d%d",&u,&v,&c);
		Add_Edge(Out(u),In(v),1,c);
		Add_Edge(In(v),Out(u),0,-c);
	}
	while (SPFA()) Update();
	printf("%d %d\n",Flow,Cost);
	return 0;
}
Problem1878
#include<cstdio>
#include<cmath>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=50000+19,MQ=200000+19,MC=1000000+19;
int n,Q,R;
int c[Maxn],nxt[MC],s[MC],pre[MC],L[MQ],Last[MQ],Ans[MQ];
int C[Maxn];

int cc;
void read(int &x)
{
	while (!isdigit(cc=getchar()));x=cc-'0';
	while (isdigit(cc=getchar())) x=x*10+cc-'0';
}

void Update(int x,int v) {while (x<=n) C[x]+=v,x+=x&-x;}
int Query(int x) {int Ans=0;while (x) Ans+=C[x],x-=x&-x;return Ans;}

int main()
{
	read(n);
	for (int i=1;i<=n;i++) read(c[i]);
	read(Q);
	for (int i=1;i<=Q;i++) read(L[i]),read(R),nxt[i]=Last[R],Last[R]=i;
	for (int x=1;x<=n;x++)
	{
		Update(pre[c[x]]+1,1);pre[c[x]]=x;
		Update(x+1,-1);
		for (int i=Last[x];i;i=nxt[i]) Ans[i]=Query(L[i]);
	}
	for (int i=1;i<=Q;i++) printf("%d\n",Ans[i]);
}
Problem1880
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1500+19;
int D1[N],D2[N],D3[N],D4[N],D[N],Dis[N],Q[100*N],vis[N];
int S1,T1,S2,T2,n,m,x,y,z,Ans,cnt;
struct Edge {int y,z,nxt;} E[N*N*2];
struct Graph
{
	int Last[N];
	Graph() {memset(Last,-1,sizeof(Last));}

	void Add_Edge(int x,int y,int z)
	{
		E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	}
	void Link(int x,int y,int z) {Add_Edge(x,y,z),Add_Edge(y,x,z);}
	void Toposort()
	{
		memset(Dis,0,sizeof(Dis));
		int f=0,w=0;
		For(i,1,n+1) if (!D[i]) Q[++f]=i,Dis[i]=0;
		while (f>w)
		{
			int x=Q[++w];Ans=max(Ans,Dis[x]);
			for (int i=Last[x];~i;i=E[i].nxt)
			{
				Dis[E[i].y]=max(Dis[E[i].y],Dis[x]+E[i].z);
				if (--D[E[i].y]==0) Q[++f]=E[i].y;
			}
		}
	}
} G,P1,P2;

void SPFA(int S,int *Dis)
{
	For(i,1,n+1) Dis[i]=(1<<30)-1;Dis[S]=0;
	int f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];vis[x]=0;
		for (int i=G.Last[x];~i;i=E[i].nxt)
			if (Dis[x]+E[i].z<Dis[E[i].y])
			{
				Dis[E[i].y]=Dis[x]+E[i].z;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
	}
}


int main()
{
	scanf("%d%d",&n,&m);
	scanf("%d%d%d%d",&S1,&T1,&S2,&T2);
	For(i,0,m) scanf("%d%d%d",&x,&y,&z),G.Link(x,y,z);
	SPFA(S1,D1),SPFA(T1,D2);
	SPFA(S2,D3),SPFA(T2,D4);
	for (x=1;x<=n;x++)
		for (int i=G.Last[x];~i;i=E[i].nxt)
			if (D1[x]+E[i].z+D2[E[i].y]==D1[T1]&&
				D3[x]+E[i].z+D4[E[i].y]==D3[T2]) P1.Add_Edge(x,E[i].y,E[i].z),D[E[i].y]++;
	P1.Toposort();
	memset(D,0,sizeof(D));
	SPFA(T2,D3),SPFA(S2,D4);
	for (x=1;x<=n;x++)
		for (int i=G.Last[x];~i;i=E[i].nxt)
			if (D1[x]+E[i].z+D2[E[i].y]==D1[T1]&&
				D3[x]+E[i].z+D4[E[i].y]==D3[S2]) P2.Add_Edge(x,E[i].y,E[i].z),D[E[i].y]++;
	P2.Toposort();
	printf("%d\n",Ans);
}
Problem1898
#include<cstdio>
using namespace std;

const int Mod=10000;
struct Matrix {int n,m,s[50][50];} A,B[12],C;
int D[5],n,m,S,T,k,x,y,t;

Matrix operator * (Matrix A,Matrix B)
{
	Matrix C;C.n=A.n,C.m=B.m;
	for (int i=0;i<C.n;i++)
		for (int j=0;j<C.m;j++)
		{
			C.s[i][j]=0;
			for (int k=0;k<A.m;k++) (C.s[i][j]+=A.s[i][k]*B.s[k][j])%=Mod;
		}
	return C;
}
Matrix Pow(Matrix A,int b)
{
	Matrix res;res.n=res.n=n;
	for (int i=0;i<n;i++)
		for (int j=0;j<n;j++) res.s[i][j]=(i==j);
	for (;b;b>>=1,A=A*A) if (b&1) res=res*A;
	return res;
}

int main()
{
	scanf("%d%d%d%d%d",&n,&m,&S,&T,&k);
	A.n=1,A.m=n,A.s[0][S]=1;
	for (int i=0;i<12;i++) B[i].n=B[i].m=n;
	C.n=C.m=n;
	for (int i=0;i<n;i++)
		for (int j=0;j<n;j++) C.s[i][j]=(i==j);
	for (int i=0;i<m;i++)
	{
		scanf("%d%d",&x,&y);
		for (int j=0;j<12;j++) B[j].s[x][y]++,B[j].s[y][x]++;
	}
	scanf("%d",&m);
	for (int i=0;i<m;i++)
	{
		scanf("%d",&t);
		for (int i=0;i<t;i++) scanf("%d",&D[i]);
		for (int i=0,j=0;i<12;i++,j=(j+1)%t)
		{
			for (int k=0;k<n;k++) B[!i?11:i-1].s[k][D[j]]=0;
			for (int k=0;k<n;k++) B[i].s[D[j]][k]=0;
		}
	}
	for (int i=0;i<12;i++) C=C*B[i];
	C=Pow(C,k/12);
	A=A*C;
	for (int i=0;i<k%12;i++) A=A*B[i];
	printf("%d\n",A.s[0][T]);
}
Problem1898
#include<cstdio>
using namespace std;

const int Mod=10000;
struct Matrix {int n,m,s[50][50];} A,B[12],C;
int D[5],n,m,S,T,k,x,y,t;

Matrix operator * (Matrix A,Matrix B)
{
	Matrix C;C.n=A.n,C.m=B.m;
	for (int i=0;i<C.n;i++)
		for (int j=0;j<C.m;j++) C.s[i][j]=0;
	for (int i=0;i<C.n;i++)
		for (int k=0;k<A.m;k++)
			for (int j=0;j<C.m;j++) (C.s[i][j]+=A.s[i][k]*B.s[k][j])%=Mod;
	return C;
}
Matrix Pow(Matrix A,int b)
{
	Matrix res;res.n=res.n=n;
	for (int i=0;i<n;i++)
		for (int j=0;j<n;j++) res.s[i][j]=(i==j);
	for (;b;b>>=1,A=A*A) if (b&1) res=res*A;
	return res;
}

int main()
{
	scanf("%d%d%d%d%d",&n,&m,&S,&T,&k);
	A.n=1,A.m=n,A.s[0][S]=1;
	for (int i=0;i<12;i++) B[i].n=B[i].m=n;
	C.n=C.m=n;
	for (int i=0;i<n;i++)
		for (int j=0;j<n;j++) C.s[i][j]=(i==j);
	for (int i=0;i<m;i++)
	{
		scanf("%d%d",&x,&y);
		for (int j=0;j<12;j++) B[j].s[x][y]++,B[j].s[y][x]++;
	}
	scanf("%d",&m);
	for (int i=0;i<m;i++)
	{
		scanf("%d",&t);
		for (int i=0;i<t;i++) scanf("%d",&D[i]);
		for (int i=0,j=0;i<12;i++,j=(j+1)%t)
		{
			for (int k=0;k<n;k++) B[!i?11:i-1].s[k][D[j]]=0;
			for (int k=0;k<n;k++) B[i].s[D[j]][k]=0;
		}
	}
	for (int i=0;i<12;i++) C=C*B[i];
	C=Pow(C,k/12);
	A=A*C;
	for (int i=0;i<k%12;i++) A=A*B[i];
	printf("%d\n",A.s[0][T]);
}
Problem1899
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=200+19,oo=(1<<30)-1;
struct node 
{
	int A,B;
	bool operator < (const node& C) const {return B>C.B;}
} A[Maxn];
int n,Ans=oo;
int sum[Maxn],F[Maxn][Maxn*Maxn];

void Update(int &a,int b) {if (b<a) a=b;}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d%d",&A[i].A,&A[i].B);
	sort(A+1,A+n+1);
	for (int i=1;i<=n;i++) sum[i]=sum[i-1]+A[i].A;
	memset(F,64,sizeof(F));
	F[0][0]=0;
	for (int i=0;i<n;i++)
		for (int j=0;j<=sum[i];j++)
			if (F[i][j]<oo)
			{
				int a=A[i+1].A,b=A[i+1].B;
				Update(F[i+1][j+a],max(F[i][j],j+a+b));
				Update(F[i+1][j],max(F[i][j],sum[i]-j+a+b));
			}
	for (int i=0;i<=sum[n];i++) Ans=min(Ans,F[n][i]);
	printf("%d\n",Ans);
}
Problem1901
#include<map>
#include<cctype>
#include<cstdio>
#include<algorithm>
#define VLsn (x<<1)
#define VRsn (x<<1|1)
using namespace std;

const int Maxn=20000+19;
typedef int VSegT_note[Maxn<<2];
typedef int SegT_note[Maxn*16*16];
struct Que {int opt,x,y,z;} Q[Maxn>>1];
int c,t,v,Dis,cnt,Ans,tmp,qL,qR,n,m,k,Ucnt,tot;
int A[Maxn>>1],U[Maxn<<1],_Map[Maxn<<1];
VSegT_note Root;
SegT_note Lsn,Rsn,S;
map<int,int> Map;
char s[5];

inline void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
inline void Count(int x,int L,int R)
{
	if (!x) return;
	if (qL<=L&&R<=qR) {tmp+=S[x];return;}
	int Mid=(L+R)>>1;
	if (qL<=Mid) Count(Lsn[x],L,Mid);
	if (qR>Mid) Count(Rsn[x],Mid+1,R);
}
inline int Query()
{
	int x=1,L=1,R=tot;
	while (L^R)
	{
		int Mid=(L+R)>>1;tmp=0;
		Count(Root[VLsn],1,n);
		if (tmp>=k) x=VLsn,R=Mid;else k-=tmp,x=VRsn,L=Mid+1;
	}
	return L;
}
inline void Update(int &x,int L,int R)
{
	if (!x) x=++cnt;
	S[x]+=v;
	if (L==R) return;
	int Mid=(L+R)>>1;
	if (Dis<=Mid) Update(Lsn[x],L,Mid);else Update(Rsn[x],Mid+1,R);
}
inline void Modify()
{
	int x=1,L=1,R=tot;
	while (L^R)
	{
		Update(Root[x],1,n);
		int Mid=(L+R)>>1;
		if (t<=Mid) x=VLsn,R=Mid;else x=VRsn,L=Mid+1;
	}
	Update(Root[x],1,n);
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) scanf("%d",&A[i]),U[Ucnt++]=A[i];
	for (int i=1;i<=m;i++)
	{
		scanf("%s",s);
		if (s[0]=='C') 
		{
			Q[i].opt=1;
			Read(Q[i].x);Read(Q[i].y);
			U[Ucnt++]=Q[i].y;
		} else
		{
			Q[i].opt=2;
			Read(Q[i].x);Read(Q[i].y);Read(Q[i].z);
		}
	}
	sort(U,U+Ucnt);
	for (int i=0;i<Ucnt;i++)
		if (!i||U[i]^U[i-1]) Map[U[i]]=++tot,_Map[tot]=U[i];
	for (int i=1;i<=n;i++)
	{
		v=1;t=Map[A[i]];Dis=i;
		Modify();
	}
	for (int i=1;i<=m;i++)
		if (Q[i].opt==1) 
		{
			Dis=Q[i].x;t=Map[A[Dis]];v=-1;
			Modify();
			A[Dis]=Q[i].y;t=Map[A[Dis]];v=1;
			Modify();
		} else
		{
			qL=Q[i].x;qR=Q[i].y;k=Q[i].z;
			printf("%d\n",_Map[Query()]);
		}
}
Problem1901
#include<cstdio>
#include<cctype>
#include<algorithm>

#define Mid (L+R>>1)
#define For(x) for (;x<=n;x+=x&-x)
#define Rep(x) for (;x;x-=x&-x)
using namespace std;

const int Maxn=10000+19;
typedef int one[Maxn];
typedef int Seg[2500000+19];
struct Ques {int opt,L,R,k;} Q[Maxn];
one A,rt,t,vis;
int B[Maxn*2],D[Maxn*2];
Seg sum,Lsn,Rsn;
int n,m,tot,cur,T=1,tcnt,x,V=1;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void out(int x) {if (!x) return;out(x/10);putchar(x%10+'0');}
void print(int x)
{
	if (!x) {puts("0");return;}
	out(x);puts("");
}

int low(int x)
{
	int L=1,R=tot,res;
	while (L<=R) (B[Mid]>=x)?(res=Mid,R=Mid-1):L=Mid+1;
	return res;
}
void Segins(int &x,int L,int R,int t)
{
	if (!x) x=++tcnt;
	if (L==R) {sum[x]+=V;return;}
	t<=Mid?Segins(Lsn[x],L,Mid,t):Segins(Rsn[x],Mid+1,R,t);
	sum[x]=sum[Lsn[x]]+sum[Rsn[x]];
}

void Bitins(int x,int v) {For(x) Segins(rt[x],1,tot,v);}
void Init(int x) {Rep(x) if (vis[x]!=T) vis[x]=T,t[x]=rt[x];else vis[x]=-1;}
void Turn(int x,int f) {Rep(x) if (vis[x]==T) t[x]=(f?Rsn[t[x]]:Lsn[t[x]]);}
int Query(int x) 
{
	int Ans=0;
	Rep(x) if (vis[x]==T) Ans+=sum[Lsn[t[x]]];
	return Ans;
}

int main()
{
	read(n),read(m);
	for (int i=1;i<=n;i++) read(A[i]),B[++tot]=A[i];
	for (int i=1;i<=m;i++)
	{
		char s[3];
		scanf("%s",s);
		read(Q[i].L),read(Q[i].R);
		if (s[0]=='Q') read(Q[i].k),Q[i].opt=1;else Q[i].opt=2,B[++tot]=Q[i].R;
	}
	sort(B+1,B+tot+1);
	tot=unique(B+1,B+tot+1)-B-1;
	for (int i=1;i<=n;i++) x=low(A[i]),D[x]=A[i],A[i]=x;
	for (int i=1;i<=m;i++) if (Q[i].opt==2) x=low(Q[i].R),D[x]=Q[i].R,Q[i].R=x;
	for (int i=1;i<=n;i++) Bitins(i,A[i]);
	for (int i=1;i<=m;T++,i++)
		if (Q[i].opt==1) 
		{
			Init(Q[i].R),Init(Q[i].L-1);
			int L=1,R=tot;
			while (L<=R)
			{
				if (L==R) break;
				int x=Query(Q[i].R)-Query(Q[i].L-1),f=(x<Q[i].k);
				Turn(Q[i].R,f),Turn(Q[i].L-1,f);f?(L=Mid+1,Q[i].k-=x):R=Mid;
			}
			print(D[L]);
		} else
		{
			V=-1;Bitins(Q[i].L,A[Q[i].L]);
			V=1;Bitins(Q[i].L,A[Q[i].L]=Q[i].R);
		}
}
Problem1901
#include<set>
#include<map>
#include<cmath>
#include<string>
#include<cstdio>
#include<vector>
#include<cctype>
#include<cstdlib>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define Mid (L+R>>1)

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;

const int N=30000+19;
typedef int one[N];

struct QType
{
	int o,id,x,y,k;
} Q[N],__Q[N];
one A,Ans,vis;
int n,Qc,tot,x,y,cnt;
char s[5];

one C,T;int Time;
void Add(int x,int v)
{
	for (;x<=n;x+=x&-x)
	{
		if (T[x]!=Time) T[x]=Time,C[x]=0;
		C[x]+=v;
	}
}
int Query(int x)
{
	int res=0;
	for (;x;x-=x&-x) res+=(T[x]==Time?C[x]:0);
	return res;
}

void Work(int l,int r,int L,int R)
{
	if (L==R)
	{
		For(i,l,r+1) if (Q[i].o==2) Ans[Q[i].id]=L;
		return;
	}
	Time++;
	For(i,l,r+1)
	{
		if (Q[i].o==1)
		{
			if (Q[i].y<=Mid) Add(Q[i].x,Q[i].k),vis[i]=1;else vis[i]=0;
		} else
		{
			int tmp=Query(Q[i].y)-Query(Q[i].x-1);
			if (Q[i].k<=tmp) vis[i]=1;else vis[i]=0,Q[i].k-=tmp;
		}
	}
	int t=l-1,p;
	For(i,l,r+1) if (vis[i]) __Q[++t]=Q[i];
	p=t;
	For(i,l,r+1) if (!vis[i])__Q[++t]=Q[i];
	For(i,l,r+1) Q[i]=__Q[i];
	if (l<=p) Work(l,p,L,Mid);
	if (p+1<=r) Work(p+1,r,Mid+1,R);
}

int main()
{
	n=IN(),Qc=IN();
	For(i,1,n+1) A[i]=IN(),Q[++tot]=(QType){1,0,i,A[i],1};
	For(i,1,Qc+1)
	{
		scanf("%s",s);
		if (s[0]=='C')
		{
			x=IN(),y=IN();
			Q[++tot]=(QType){1,0,x,A[x],-1};
			Q[++tot]=(QType){1,0,x,A[x]=y,1};
		} else
		{
			Q[++tot]=(QType){2,++cnt,IN(),IN(),IN()};
		}
	}
	Work(1,tot,0,int(1e9));
	For(i,1,cnt+1) printf("%d\n",Ans[i]);
}
Problem1910
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

const int M=200+3;
int s[M][M],F[3][M][M][M],G[2][M][M][M];
int n,m,Ans=0;

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) 
		{
			scanf("%d",&s[i][j]);
			s[i][j]+=s[i][j-1];
		}
	memset(F,128,sizeof(F));
	memset(G,128,sizeof(G));
	memset(F[0][0],0,sizeof(F[0][0]));
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++)
			for (int k=j;k<=m;k++)
				if (s[i][k]==s[i][j-1])
				{
					F[0][i][j][k]=max(F[0][i-1][j][k],0);
					F[1][i][j][k]=max(F[1][i-1][j][k],G[0][i-1][j-1][k+1]);
					F[2][i][j][k]=max(F[2][i-1][j][k],G[1][i-1][j+1][k-1]);
					for (int t=0;t<3;t++) F[t][i][j][k]+=k-j+1;
					Ans=max(Ans,F[2][i][j][k]);
				}		
		for (int j=1;j<=m;j++)
			for (int k=m;k>=j;k--) 	
				G[0][i][j][k]=max(max(G[0][i][j-1][k],G[0][i][j][k+1]),F[0][i][j][k]);
		for (int j=m;j>=1;j--)
			for (int k=j;k<=m;k++)
				G[1][i][j][k]=max(max(G[1][i][j+1][k],G[1][i][j][k-1]),F[1][i][j][k]);
	}
	printf("%d\n",Ans);
	return 0;
}
Problem1911
#include<cstdio>
using namespace std;

const int Maxn=1000000+19;
typedef long long LL;
int n,f,w,Q[Maxn];
LL s[Maxn],F[Maxn],a,b,c;

LL sqr(LL x) {return x*x;}
double get_y(int r) {return F[r]+a*sqr(s[r])-b*s[r];}
double get_x(int r) {return 2*a*s[r];}
double g(int i,int j) {return (get_y(i)-get_y(j))/(get_x(i)-get_x(j));}

int main()
{
	scanf("%d",&n);
	scanf("%lld%lld%lld",&a,&b,&c);
	for (int i=1;i<=n;i++) scanf("%lld",&s[i]),s[i]+=s[i-1];
	for (int i=1;i<=n;i++)
	{
		while (w<f && g(Q[w],Q[w+1])<s[i] ) w++;
		LL x=s[i]-s[Q[w]];
		F[i]=F[Q[w]]+a*sqr(x)+b*x+c;
		while (w<f && g(Q[f-1],Q[f])>g(Q[f],i)) f--;
		Q[++f]=i;
	}
	printf("%lld\n",F[n]);
	return 0;
}
Problem1911
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=1000000+19;
typedef long long LL;
int n,f,w,Q[Maxn];
LL s[Maxn],F[Maxn],a,b,c,t;

void Read(LL &x)
{
	while (!isdigit(t=getchar()));
	x=t-'0';
	while (isdigit(t=getchar())) x=x*10+t-'0';
}
LL sqr(LL x) {return x*x;}
double get_y(int r) {return F[r]+a*sqr(s[r])-b*s[r];}
double get_x(int r) {return 2*a*s[r];}
double g(int i,int j) {return (get_y(i)-get_y(j))/(get_x(i)-get_x(j));}

int main()
{
	scanf("%d",&n);
	scanf("%lld%lld%lld",&a,&b,&c);
	for (int i=1;i<=n;i++) Read(s[i]),s[i]+=s[i-1];
	for (int i=1;i<=n;i++)
	{
		while (w<f && g(Q[w],Q[w+1])<s[i] ) w++;
		LL x=s[i]-s[Q[w]];
		F[i]=F[Q[w]]+a*sqr(x)+b*x+c;
		while (w<f && g(Q[f-1],Q[f])>g(Q[f],i)) f--;
		Q[++f]=i;
	}
	printf("%lld\n",F[n]);
	return 0;
}
Problem1923
#include<cstdio>
#include<bitset>
#include<algorithm>
using namespace std;

const int M=2000+19,N=1000+19;
typedef bitset<N> Matrix[M];
Matrix A;
char s[N];
int x,n,m,Ans;

void Gauss()
{
	for (int i=1;i<=n;i++)
	{
		int r=i;
		while (r<=m&&!A[r][i]) r++;
		if (r==m+1) {Ans=-1;return;}
		if (r!=i) swap(A[i],A[r]);
		Ans=max(Ans,r);
		for (int j=1;j<=m;j++) if (i!=j&&A[j][i]) A[j]^=A[i];
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++)
	{
		scanf("%s",s);
		for (int j=0;j<n;j++) A[i][j+1]=s[j]-'0';
		scanf("%d",&x),A[i][n+1]=x;
	}
	Gauss();
	if (Ans==-1) puts("Cannot Determine");else
	{
		printf("%d\n",Ans);
		for (int i=1;i<=n;i++)
			if (A[i][n+1]) puts("?y7M#");else puts("Earth");
	}
}
Problem1924
#include<map>
#include<vector>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Rep(i,V) for (vector<int>::iterator i=V.begin();i!=V.end();i++)
#define Pb push_back
#define Mp make_pair
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19,T=N*10;
typedef pair<int,int> Pii;
struct Point {int x,y,t;} P[N];
map<Pii,int> M;
vector<int> Vx[T],Vy[T];
typedef vector<int>::iterator Vit;
int n,R,C;
int Dx[8]={1,1,1,0,0,-1,-1,-1},Dy[8]={-1,0,1,-1,1,-1,0,1};

struct Graph
{
	struct Edge {int y,nxt;} E[T];
	int Last[N],DFN[N],Low[N],S[N],ID[N],cnt,tot,num;
	Graph() {memset(Last,-1,sizeof(Last));}
	void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
	void DFS(int x)
	{
		Low[x]=DFN[x]=++tot,S[++*S]=x;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (!DFN[E[i].y]) DFS(E[i].y),Low[x]=min(Low[x],Low[E[i].y]);
				else if (!ID[E[i].y]) Low[x]=min(Low[x],DFN[E[i].y]);
		if (Low[x]==DFN[x])
		{
			num++;int u;
			do {u=S[(*S)--];ID[u]=num;} while (u!=x);
		}
	}
	void Tarjan() {For(i,1,n+1) if (!DFN[i]) DFS(i);}
	int DP(int n)
	{
		int Res=0;
		for (int x=1;x<=n;x++)
		{
			int Max=0;
			for (int i=Last[x];~i;i=E[i].nxt) Max=max(Max,S[E[i].y]);
			S[x]+=Max;Res=max(Res,S[x]);
		}
		return Res;
	}
} Gp,G;

int main()
{
	n=IN();R=IN(),C=IN();
	For(i,1,n+1)
		P[i]=(Point){IN(),IN(),IN()},M[Mp(P[i].x,P[i].y)]=i,Vx[P[i].x].Pb(i),Vy[P[i].y].Pb(i);
	For(i,0,T)
	{
		int tmp=-1;
		Rep(j,Vx[i]) if (P[*j].t==1) {tmp=*j;break;}
		Rep(j,Vx[i])
		{
			Gp.Add_Edge(tmp,*j);
			if (P[*j].t==1) Gp.Add_Edge(*j,tmp);
		}
	}
	For(i,0,T)
	{
		int tmp=-1;
		Rep(j,Vy[i]) if (P[*j].t==2) {tmp=*j;break;}
		Rep(j,Vy[i])
		{
			Gp.Add_Edge(tmp,*j);
			if (P[*j].t==2) Gp.Add_Edge(*j,tmp);
		}
	}
	For(i,1,n+1) if (P[i].t==3)
		For(j,0,8)
		{
			Pii tmp=Mp(P[i].x+Dx[j],P[i].y+Dy[j]);
			if (M.count(tmp)) Gp.Add_Edge(i,M[tmp]);
		}
	Gp.Tarjan();
	For(x,1,n+1)
	{
		G.S[Gp.ID[x]]++;
		for (int i=Gp.Last[x];~i;i=Gp.E[i].nxt)
			if (Gp.ID[x]!=Gp.ID[Gp.E[i].y]) G.Add_Edge(Gp.ID[x],Gp.ID[Gp.E[i].y]);
	}
	printf("%d\n",G.DP(Gp.num));
}
Problem1925
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)

int F[2][4200+19],cur=1,pre,n,Mod,Ans;

int main()
{
	scanf("%d%d",&n,&Mod);
	if (n==1) return puts("1"),0;
	F[cur][2]=1;
	For(i,3,n+1)
	{
		cur^=1,pre^=1;
		For(j,1,i+1) F[cur][j]=(F[cur][j-1]+F[pre][i-j+1])%Mod;
	}
	For(i,1,n+1) (Ans+=F[cur][i])%=Mod;
	printf("%d\n",Ans*2%Mod);
}
Problem1927
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=(800+19)*2,M=15000+19,oo=(1<<30)-1;
struct Edge {int x,y,f,c,nxt;} E[M*2+Maxn*6];
int Last[Maxn],vis[Maxn],Dis[Maxn],pre[Maxn];
int n,m,x,y,f,c,s,t,cnt,Cost;

void Add_Edge(int x,int y,int f,int c)
{
	E[cnt]=(Edge){x,y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){y,x,0,-c,Last[y]};Last[y]=cnt++;
}
int SPFA()
{
	queue<int> Q;
	memset(Dis,64,sizeof(Dis));
	Dis[s]=0;pre[s]=-1;Q.push(s);
	while (!Q.empty())
	{
		int x=Q.front();Q.pop();
		vis[x]=0;
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[x]+E[i].c<Dis[E[i].y])
			{
				Dis[E[i].y]=Dis[x]+E[i].c;
				pre[E[i].y]=i;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q.push(E[i].y);
			}
	}
	return Dis[t]<oo;
}
void Update()
{
	for (int i=pre[t];i!=-1;i=pre[E[i].x]) E[i].f--,E[i^1].f++;
	Cost+=Dis[t];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);s=2*n+1;t=2*n+2;
	for (int i=1;i<=n;i++) 
	{
		scanf("%d",&x);
		Add_Edge(s,i,1,0);Add_Edge(i+n,t,1,0);Add_Edge(s,i+n,1,x);
	}
	for (int i=1;i<=m;i++) 
	{
		scanf("%d%d%d",&x,&y,&c);
		if (x>y) swap(x,y);
		Add_Edge(x,y+n,1,c);
	}
	while (SPFA()) Update();
	printf("%d\n",Cost);
}
Problem1927
#include<cstdio>
#include<cctype>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=(800+19)*2,M=15000+19,oo=(1<<30)-1;
struct Edge {int x,y,f,c,nxt;} E[M*2+Maxn*6];
int Last[Maxn],vis[Maxn],Dis[Maxn],pre[Maxn];
int n,m,x,y,f,c,s,t,cnt,Cost,ch;

void read(int &x)
{
	while (!isdigit(ch=getchar()));x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
}

void Add_Edge(int x,int y,int f,int c)
{
	E[cnt]=(Edge){x,y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){y,x,0,-c,Last[y]};Last[y]=cnt++;
}
int SPFA()
{
	queue<int> Q;
	memset(Dis,64,sizeof(Dis));
	Dis[s]=0;pre[s]=-1;Q.push(s);
	while (!Q.empty())
	{
		int x=Q.front();Q.pop();
		vis[x]=0;
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[x]+E[i].c<Dis[E[i].y])
			{
				Dis[E[i].y]=Dis[x]+E[i].c;
				pre[E[i].y]=i;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q.push(E[i].y);
			}
	}
	return Dis[t]<oo;
}
void Update()
{
	for (int i=pre[t];i!=-1;i=pre[E[i].x]) E[i].f--,E[i^1].f++;
	Cost+=Dis[t];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n),read(m);s=2*n+1;t=2*n+2;
	for (int i=1;i<=n;i++) 
	{
		read(x);
		Add_Edge(s,i,1,0);Add_Edge(i+n,t,1,0);Add_Edge(s,i+n,1,x);
	}
	for (int i=1;i<=m;i++) 
	{
		read(x),read(y),read(c);
		if (x>y) swap(x,y);
		Add_Edge(x,y+n,1,c);
	}
	while (SPFA()) Update();
	printf("%d\n",Cost);
}
Problem1930
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=2000*2+19,Top=5000000;
struct Edge {int y,nxt;short f,c;} E[Top];
struct node
{
	int x,y;
	void IN() {scanf("%d%d",&x,&y);}
} A[N];
int Last[N],Dis[N],Q[N],pre[N],vis[N];
int f,n,S,S2,T,cnt,Cost;

void Add_Edge(int x,int y,short f,short c)
{
	E[cnt]=(Edge){y,Last[x],f,c};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y],0,-c};Last[y]=cnt++;
}
bool SPFA()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=0;
	Q[f=1]=S;pre[S]=-1;
	while (f)
	{
		int x=Q[f--];vis[x]=0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[x]+E[i].c>Dis[E[i].y])
			{
				Dis[E[i].y]=Dis[x]+E[i].c,pre[E[i].y]=i;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
	}
	return Dis[T]!=-1;
}
void Update()
{
	for (int i=pre[T];~i;i=pre[E[i^1].y]) E[i].f--,E[i^1].f++;
	Cost+=Dis[T];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);
	For(i,1,n+1) A[i].IN();
	S=2*n+1,S2=S+1,T=S+2;
	Add_Edge(S,S2,2,0);
	For(i,1,n+1) Add_Edge(S2,i,1,0),Add_Edge(i,i+n,1,1),Add_Edge(i+n,T,1,0);
	For(i,1,n+1) For(j,1,n+1)
		if (i!=j&&A[i].x<=A[j].x&&A[i].y<=A[j].y) Add_Edge(i+n,j,1,0);
	while (SPFA()) Update();
	printf("%d\n",Cost);
}
Problem1934
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=300+19,oo=(1<<30)-1;
struct Edge {int x,y,f,nxt;} E[Maxn*Maxn*4];
int Last[Maxn],cnt;
int Q[Maxn],Dis[Maxn],f,w;
int n,m,x,y,s,t,Flow;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){x,y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){y,x,0,Last[y]};Last[y]=cnt++;
}
int BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[s]=0;
	f=1;w=0;Q[1]=s;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[t]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==t||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(E[i].f,Flow));
			res+=tmp;Flow-=tmp;E[i].f-=tmp;E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	s=n+1;t=n+2;
	for (int i=1;i<=n;i++) 
	{
		scanf("%d",&x);
		x?Add_Edge(s,i,1):Add_Edge(i,t,1);
	}
	for (int i=0;i<m;i++)
	{
		scanf("%d%d",&x,&y);
		Add_Edge(x,y,1);
		Add_Edge(y,x,1);
	}
	while (BFS()) Flow+=Dinic(s,oo);
	printf("%d\n",Flow);
}
Problem1935
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Low(A,t,x) (lower_bound(A,A+t,x)-A+1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=500000+19;
struct Point
{
	int x,y;
	bool operator < (const Point& B) const {return x<B.x;}
} A[N];
struct Event
{
	int x,D,U,ID,f;
	bool operator < (const Event& B) const {return x<B.x;}
} Q[2*N];
int Ans[N],Lx[3*N],Ly[3*N],C[3*N],tx,ty,n,m,a,b,c,d,cnt,cur;

void Update(int x) {for (;x<=ty;x+=x&-x) C[x]++;}
int Query(int x) {int Ans=0;for (;x;x-=x&-x) Ans+=C[x];return Ans;}

int main()
{
	n=IN(),m=IN();
	For(i,0,n) A[i].x=Lx[tx++]=IN(),A[i].y=Ly[ty++]=IN();
	For(i,0,m)
	{
		Lx[tx++]=a=IN(),Ly[ty++]=b=IN(),
		Lx[tx++]=c=IN(),Ly[ty++]=d=IN();
		Q[cnt++]=(Event){c,b,d,i,1};
		Q[cnt++]=(Event){a,b,d,i,-1};
	}
	sort(Lx,Lx+tx),sort(Ly,Ly+ty);
	tx=unique(Lx,Lx+tx)-Lx,ty=unique(Ly,Ly+ty)-Ly;
	For(i,0,n) A[i].x=Low(Lx,tx,A[i].x),A[i].y=Low(Ly,ty,A[i].y);
	For(i,0,cnt)
		Q[i].x=Low(Lx,tx,Q[i].x),
		Q[i].U=Low(Ly,ty,Q[i].U),Q[i].D=Low(Ly,ty,Q[i].D);
	For(i,0,cnt) if (Q[i].f<0) Q[i].x--;
	sort(A,A+n),sort(Q,Q+cnt);
	For(i,0,cnt)
	{
		while (cur<n&&A[cur].x<=Q[i].x) Update(A[cur++].y);
		Ans[Q[i].ID]+=Q[i].f*(Query(Q[i].U)-Query(Q[i].D-1));
	}
	For(i,0,m) printf("%d\n",Ans[i]);
}
Problem1951
#include<cstdio>
using namespace std;

typedef long long LL;
const LL Mod=999911659LL;
LL P[4]={2,3,4679,35617},A[4];
LL n,g,exp,tmp,x,y,fac[4][35618];

LL Power(LL a,LL b,LL P)
{
	LL res=1;
	while (b) {if (b&1) (res*=a)%=P;(a*=a)%=P;b>>=1;}
	return res;
}
void exEuclid(LL a,LL b,LL &x,LL &y) 
{
	if (!b) {x=1;y=0;return;}
	exEuclid(b,a%b,x,y);
	LL tmp=x;x=y;y=tmp-a/b*y;
}
LL C(LL n,LL k,LL i)
{
	if (n<k) return 0;
	return fac[i][n]*Power(fac[i][k]*fac[i][n-k],P[i]-2,P[i])%P[i];
}
LL Lucas(LL n,LL k,LL i) 
{
	if (n<P[i]&&k<P[i]) return C(n,k,i);
	return Lucas(n/P[i],k/P[i],i)*C(n%P[i],k%P[i],i)%P[i];
}
LL Solve(LL k)
{
	for (int i=0;i<4;i++) A[i]=Lucas(n,k,i);
	tmp=0;
	for (int i=0;i<4;i++) 
	{
		exEuclid((Mod-1)/P[i],P[i],x,y);if (x<0) x+=P[i];
		(tmp+=(Mod-1)/P[i]*A[i]%(Mod-1)*x%(Mod-1))%=Mod-1;
	}
	return tmp;
}

int main()
{
	scanf("%lld%lld",&n,&g);
	if (g%Mod==0) {puts("0");return 0;}
	for (int i=0;i<4;i++)
	{
		fac[i][0]=1;
		for (int j=1;j<=P[i];j++) fac[i][j]=(fac[i][j-1]*j)%P[i];
	}
	for (int i=1;i*i<=n;i++)
		if (n%i==0)
		{
			(exp+=Solve(i))%=Mod-1;
			if (i*i!=n) (exp+=Solve(n/i))%=Mod-1;
		}
	printf("%lld\n",Power(g,exp,Mod));
}
Problem1968
#include<cstdio>
using namespace std;

int main()
{
	int n,ans=0;
	scanf("%d",&n);
	for (int i=1;i<=n;i++) ans+=n/i;
	printf("%d\n",ans);
	//for(;;);
	return 0;
}
Problem1972
#include<cstdio>
#include<cctype>
#include<cstring>

#define For(x,i) for(int i=0;i<A[x].cnt;i++)
#define can(x,i,c) (!A[x].use[i]&&A[x].s[i]==c)
using namespace std;

const int oo=(1<<30)-1;
struct Player
{
	int is_F,show,like,dead,ZG,hp,K;
	int cnt,use[2000+19];
	char s[2000+19];
} A[11];
char P[2000+19],s[4];
int n,m,End=1,Fnum,ccnt,j;

int Getchar() {int c;while (!isalpha(c=getchar()));return c;}
int Dis(int x,int y)
{
	int Ans=0;
	for (int i=x;i!=y;i=i%n+1) Ans+=!A[i].dead;
	return Ans;
}
void Show(int x) {A[x].like=0;A[x].show=1;}
void Get_card(int x) {A[x].s[A[x].cnt++]=(ccnt==m?P[ccnt-1]:P[ccnt++]);}

int Out_D(int x) {For(x,i) if (can(x,i,'D')) return A[x].use[i]=1;return 0;}
int Out_P(int x) {For(x,i) if (can(x,i,'P')) return A[x].hp++,A[x].use[i]=1;return 0;}
int Out_K(int x) {For(x,i) if (can(x,i,'K')) return A[x].use[i]=1;return 0;}
int Out_Wuxie(int x) {For(x,i) if (can(x,i,'J')) return A[x].use[i]=1;return 0;}

int Solve_Wuxie(int x,int f)
{
	for (int i=x,_=0;_<n;_++,i=i%n+1)
		if (!A[i].dead&&A[i].is_F==f&&Out_Wuxie(i))
		{
			Show(i);
			return Solve_Wuxie(x,f^1)^1;
		}
	return 0;
}
int Solve_Dead(int x,int y)
{
	A[y].dead=1;
	if (A[y].is_F)
	{
		if (--Fnum==0) return End=2;
		Get_card(x),Get_card(x),Get_card(x);
	} else if (x==1)
	{
		for (int i=0;i<A[1].cnt;i++) A[1].use[i]=1;
		A[1].ZG=0;
	}
	if (y==1) return End=1;else return 0;
}
void Solve_K(int x,int y)
{
	A[x].K--;Show(x);
	if (!Out_D(y)) if (--A[y].hp==0&&!Out_P(y)) Solve_Dead(x,y);
}
void Solve_F(int x,int y)
{
	Show(x);
	if (A[y].show&&Solve_Wuxie(x,A[y].is_F)) return;
	for(;;)
	{
		if (x==1&&!A[y].is_F||!Out_K(y))
			{if (--A[y].hp==0&&!Out_P(y)) Solve_Dead(x,y);return;}
		if (!Out_K(x)) {if (--A[x].hp==0&&!Out_P(x)) Solve_Dead(y,x);return;}
	}
}
void Solve_Aoe(int x,char c)
{
	for (int i=x%n+1,_=1;_<n;_++,i=i%n+1)
		if (!A[i].dead)
		{
			if (A[i].show) if (Solve_Wuxie(x,A[i].is_F)) continue;
			if (c=='N'&&!Out_K(i)||c=='W'&&!Out_D(i))
			{
				if (--A[i].hp==0&&!Out_P(i)) if (Solve_Dead(x,i)) return;
				if (i==1&&!A[x].show) A[x].like=1;
			}
		}
}

int Use(int x,char c)
{
	if (c=='D'||c=='J') return 0;
	if (c=='P') return (A[x].hp<4)?(A[x].hp++,1):0;
	if (c=='Z') return A[x].ZG=1,A[x].K=oo,1;
	if (c=='N'||c=='W') return Solve_Aoe(x,c),1;
	if (c=='K')
	{
		if (!A[x].K) return 0;
		for (int i=1;i<=n;i++)
			if (Dis(x,i)==1&&!A[i].dead)
				if (x==1&&A[i].like||A[i].is_F!=A[x].is_F&&A[i].show)
					return Solve_K(x,i),1;else return 0;
	}
	if (c=='F')
	{
		if (A[x].is_F) return Solve_F(x,1),1;else
			for (int i=x%n+1,_=1;_<n;_++,i=i%n+1)
				if (!A[i].dead&&(x==1&&A[i].like||A[i].is_F!=A[x].is_F&&A[i].show))
					return Solve_F(x,i),1;
		return 0;
	}
}
void calc()
{
	for (int i=1;i<=n;i++)
		if (!A[i].dead)
		{
			A[i].K=(A[i].ZG?oo:1);int f;
			Get_card(i),Get_card(i);
			do
			{
				f=0;
				for (int j=0;j<A[i].cnt;j++)
					if (!A[i].use[j]&&Use(i,A[i].s[j])) {f=1;A[i].use[j]=1;break;}
				if (A[i].dead) break;
				if (End) return;
			} while (f);
		}
}

int main()
{
	scanf("%d%d",&n,&m);
	A[1].show=1;
	for (int i=1;i<=n;i++)
	{
		scanf("%s",s);
		if (s[0]=='F') A[i].is_F=1,End=0,Fnum++;
		A[i].cnt=A[i].hp=4;for (int j=0;j<4;j++) A[i].s[j]=Getchar();
	}
	for (int i=0;i<m;i++) P[i]=Getchar();
	while (!End) calc();
	puts(Fnum?"FP":"MP");
	for (int i=1;i<=n;i++)
	{
		if (A[i].dead) {puts("DEAD");continue;}
		for (j=0;j<A[i].cnt;j++) if (!A[i].use[j]) {putchar(A[i].s[j]);break;}
		for (j++;j<A[i].cnt;j++) if (!A[i].use[j]) printf(" %c",A[i].s[j]);
		puts("");
	}
}
Problem1975
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

typedef long long LL;
typedef double Db;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=5000+19,M=200000+19,Top=500000;
struct Edge {int y,nxt;Db z;} E[M*2];
int Last[N],Que[N*50],vis[N],pre[N];
int n,m,tot,Ans,cnt,x,y;
Db Dis[N],Sum,D,z;

void Link(int x,int y,Db z)
{
	E[cnt]=(Edge){y,Last[x],z};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y],z};Last[y]=cnt++;
}
void SPFA()
{
	For(i,1,n+1) Dis[i]=1e30;Dis[n]=0;
	int f=1,w=0;Que[1]=n;pre[n]=-1;
	while (f>w)
	{
		int x=Que[++w];vis[x]=0;
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if ((i&1)&&(Dis[x]+E[i].z<Dis[y=E[i].y]))
			{
				Dis[y]=Dis[x]+E[i].z,pre[y]=i;
				if (!vis[y]) vis[y]=1,Que[++f]=y;
			}
	}
	f=1,w=0;Que[1]=n;
	while (f>w)
	{
		int x=Que[++w];
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if ((i&1)&&pre[y=E[i].y]==i) Que[++f]=y;
	}
}

struct Type
{
	Db v;int Pos;
	bool operator < (const Type& B) const {return v<B.v;}
} A[M];

struct node *null;
struct node
{
	node *L,*R;
	Db v;int Pos,npl;
	void Update()
	{
		if (this==null) return;
		if (L->npl<R->npl) swap(L,R);
		npl=R->npl+1;
	}
} Nd[Top],*cur,*rt[N];
node *Merge(node *A,node *B)
{
	if (A==null) return B;
	if (B==null) return A;
	if (A->v>B->v) swap(A,B);
	node *x=cur++;*x=*A;
	x->R=Merge(A->R,B);
	return x->Update(),x;
}
node *Build(int c)
{
	if (c>tot) return null;
	node *x=cur++;
	x->v=A[c].v,x->Pos=A[c].Pos;
	x->L=Build(c<<1);
	x->R=Build(c<<1|1);
	return x->Update(),x;
}

struct QType
{
	Db v;node *x;
	bool operator < (const QType& B) const {return v>B.v;}
};
priority_queue<QType> Q;
void Ins(Db v,node *x) {if (v<=Sum) Q.push((QType){v,x});}

int main()
{
	cur=null=Nd;
	null->L=null->R=null,null->npl=-1;
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN(),scanf("%lf",&Sum);
	For(i,1,m+1) x=IN(),y=IN(),scanf("%lf",&z),Link(x,y,z);
	SPFA();D=Dis[1];
	For(t,1,n+1)
	{
		int x=Que[t];tot=0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (!(i&1)&&(i^1)!=pre[x]) A[++tot]=(Type){E[i].z-Dis[x]+Dis[E[i].y],i};
		sort(A+1,A+tot+1);
		rt[x]=x==n?Build(1):Merge(rt[E[pre[x]^1].y],Build(1));
	}
	if (Sum<D) return puts("0"),0;
	Sum-=D;Ans++;
	Q.push((QType){D+rt[1]->v,rt[1]});
	while (!Q.empty())
	{
		Db v=Q.top().v;node *x=Q.top().x;Q.pop();
		if (v>Sum) break;Sum-=v,Ans++;
		if (x->L!=null) Ins(v-x->v+x->L->v,x->L);
		if (x->R!=null) Ins(v-x->v+x->R->v,x->R);
		Ins(v+rt[E[x->Pos].y]->v,rt[E[x->Pos].y]);
	}
	printf("%d\n",Ans);
}
Problem1975
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

typedef long long LL;
typedef double Db;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=5000+19,M=200000+19,Top=500000;
struct Edge {int y,nxt;Db z;} E[M*2];
int Last[N],Que[N*50],vis[N],pre[N];
int n,m,tot,Ans,cnt,x,y;
Db Dis[N],Sum,D,z;

void Link(int x,int y,Db z)
{
	E[cnt]=(Edge){y,Last[x],z};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y],z};Last[y]=cnt++;
}
void SPFA()
{
	For(i,1,n+1) Dis[i]=1e30;Dis[n]=0;
	int f=1,w=0;Que[1]=n;pre[n]=-1;
	while (f>w)
	{
		int x=Que[++w];vis[x]=0;
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if ((i&1)&&(Dis[x]+E[i].z<Dis[y=E[i].y]))
			{
				Dis[y]=Dis[x]+E[i].z,pre[y]=i;
				if (!vis[y]) vis[y]=1,Que[++f]=y;
			}
	}
	f=1,w=0;Que[1]=n;
	while (f>w)
	{
		int x=Que[++w];
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if ((i&1)&&pre[y=E[i].y]==i) Que[++f]=y;
	}
}

struct Type
{
	Db v;int Pos;
	bool operator < (const Type& B) const {return v<B.v;}
} A[M];

struct node *null;
struct node
{
	node *L,*R;
	Db v;int Pos,npl;
	void Update()
	{
		if (this==null) return;
		if (L->npl<R->npl) swap(L,R);
		npl=R->npl+1;
	}
} Nd[Top],*cur,*rt[N];
node *Merge(node *A,node *B)
{
	if (A==null) return B;
	if (B==null) return A;
	if (A->v>B->v) swap(A,B);
	node *x=cur++;*x=*A;
	x->R=Merge(A->R,B);
	return x->Update(),x;
}
node *Build(int c)
{
	if (c>tot) return null;
	node *x=cur++;
	x->v=A[c].v,x->Pos=A[c].Pos;
	x->L=Build(c<<1);
	x->R=Build(c<<1|1);
	return x->Update(),x;
}

struct QType
{
	Db v;node *x;
	bool operator < (const QType& B) const {return v>B.v;}
};
priority_queue<QType> Q;
void Ins(Db v,node *x) {if (v<=Sum) Q.push((QType){v,x});}

int main()
{
	cur=null=Nd;
	null->L=null->R=null,null->npl=-1;
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN(),scanf("%lf",&Sum);
	For(i,1,m+1) x=IN(),y=IN(),scanf("%lf",&z),Link(x,y,z);
	SPFA();D=Dis[1];
	For(t,1,n+1)
	{
		int x=Que[t];tot=0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (!(i&1)&&(i^1)!=pre[x]) A[++tot]=(Type){E[i].z-Dis[x]+Dis[E[i].y],i};
		sort(A+1,A+tot+1);
		rt[x]=x==n?Build(1):Merge(rt[E[pre[x]^1].y],Build(1));
	}
	if (Sum<D) return puts("0"),0;
	Sum-=D;Ans++;
	Q.push((QType){D+rt[1]->v,rt[1]});
	while (!Q.empty())
	{
		Db v=Q.top().v;node *x=Q.top().x;Q.pop();
		if (v>Sum) break;Sum-=v,Ans++;
		if (x->L!=null) Ins(v-x->v+x->L->v,x->L);
		if (x->R!=null) Ins(v-x->v+x->R->v,x->R);
		if (rt[E[x->Pos].y]!=null) Ins(v+rt[E[x->Pos].y]->v,rt[E[x->Pos].y]);
	}
	printf("%d\n",Ans);
}
Problem1977
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=100000+19,M=300000+19;
typedef pair<int,int> PII;
typedef long long LL;
struct Edge 
{
	int x,y,z,used;
	bool operator < (const Edge& B) const {return z<B.z;}
} Eg[M];
struct _Edge {int y,z,nxt;} E[N*2];
int n,m,x,y,z;
int Pa[N],Last[N],Deep[N],cnt;
int Fa[N][21],Fir[N][21],Sec[N][21];
LL pre_Ans,Ans=1LL<<60;

int Getf(int x) {return Pa[x]==x?x:Pa[x]=Getf(Pa[x]);}

void Link(Edge A)
{
	E[cnt]=(_Edge){A.y,A.z,Last[A.x]};Last[A.x]=cnt++;
	E[cnt]=(_Edge){A.x,A.z,Last[A.y]};Last[A.y]=cnt++;
}

void check(int &fir,int &sec,int Fir,int Sec)
{
	if (Fir>fir) fir=Fir,sec=max(sec,Sec);else sec=max(sec,Fir);
}
void DFS(int x)
{
	for (int i=Last[x];i!=-1;i=E[i].nxt) 
		if (E[i].y!=Fa[x][0]) 
			Deep[E[i].y]=Deep[x]+1,Fa[E[i].y][0]=x,Fir[E[i].y][0]=E[i].z,DFS(E[i].y);
}

PII Query(int x,int y)
{
	int fir=-1,sec=-1;
	if (Deep[y]<Deep[x]) swap(x,y);
	for (int i=20;i>=0;i--)
		if (Deep[Fa[y][i]]>Deep[x]) 
		{
			check(fir,sec,Fir[y][i],Sec[y][i]);
			y=Fa[y][i];
		}
	if (Fa[y][0]==x) return make_pair(fir,sec);
	if (Deep[y]>Deep[x]) check(fir,sec,Fir[y][0],Sec[y][0]),y=Fa[y][0];
	for (int i=20;i>=0;i--)
		if (Fa[x][i]^Fa[y][i]) 
		{
			check(fir,sec,Fir[x][i],Sec[x][i]);
			check(fir,sec,Fir[y][i],Sec[y][i]);
			x=Fa[x][i],y=Fa[y][i];
		}
	check(fir,sec,Fir[x][0],Sec[x][0]);
	check(fir,sec,Fir[y][0],Sec[y][0]);
	return make_pair(fir,sec);
}

int main()
{
	memset(Fir,-1,sizeof(Fir));
	memset(Sec,-1,sizeof(Sec));
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) Pa[i]=i;
	for (int i=0;i<m;i++) scanf("%d%d%d",&Eg[i].x,&Eg[i].y,&Eg[i].z);
	sort(Eg,Eg+m);
	for (int i=0;i<m;i++)
	{
		int x=Eg[i].x,y=Eg[i].y;
		if (Getf(x)==Getf(y)) continue;
		Link(Eg[i]);pre_Ans+=Eg[i].z;
		Eg[i].used=1;Pa[Getf(x)]=Getf(y);
	}
	DFS(1);
	for (int x=1;x<21;x++)
		for (int i=1;i<=n;i++)
		{
			int P=Fa[i][x-1];
			Fa[i][x]=Fa[P][x-1];
			if (!Fa[i][x]) continue;
			if (Fir[i][x-1]==Fir[P][x-1])
			{
				Fir[i][x]=Fir[i][x-1];
				Sec[i][x]=max(Sec[i][x-1],Sec[P][x-1]);
			} else
			{
				Fir[i][x]=max(Fir[i][x-1],Fir[P][x-1]);
				Sec[i][x]=min(Fir[i][x-1],Fir[P][x-1]);
			}
		}
	for (int i=0;i<m;i++)
		if (!Eg[i].used)
		{
			PII tmp=Query(Eg[i].x,Eg[i].y);
			if (tmp.first!=Eg[i].z) Ans=min(Ans,pre_Ans-tmp.first+Eg[i].z);
				else Ans=min(Ans,pre_Ans-tmp.second+Eg[i].z);
		}
	printf("%lld\n",Ans);
}
Problem1977
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=100000+19,M=300000+19;
typedef pair<int,int> PII;
typedef long long LL;
struct Edge 
{
	int x,y,z,used;
	bool operator < (const Edge& B) const {return z<B.z;}
} Eg[M];
struct _Edge {int y,z,nxt;} E[N*2];
int n,m,x,y,z;
int Pa[N],Last[N],Deep[N],cnt;
int Fa[N][21],Fir[N][21],Sec[N][21];
LL pre_Ans,Ans=1LL<<60;

int f,c;
void Read(int &x) 
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int Getf(int x) {return Pa[x]==x?x:Pa[x]=Getf(Pa[x]);}
void Link(Edge A)
{
	E[cnt]=(_Edge){A.y,A.z,Last[A.x]};Last[A.x]=cnt++;
	E[cnt]=(_Edge){A.x,A.z,Last[A.y]};Last[A.y]=cnt++;
}
void check(int &fir,int &sec,int Fir,int Sec)
{
	if (Fir>fir) fir=Fir,sec=max(sec,Sec);else sec=max(sec,Fir);
}
void DFS(int x)
{
	for (int i=Last[x];i!=-1;i=E[i].nxt) 
		if (E[i].y!=Fa[x][0]) 
			Deep[E[i].y]=Deep[x]+1,Fa[E[i].y][0]=x,Fir[E[i].y][0]=E[i].z,DFS(E[i].y);
}

PII Query(int x,int y)
{
	int fir=-1,sec=-1;
	if (Deep[y]<Deep[x]) swap(x,y);
	for (int i=20;i>=0;i--)
		if (Deep[Fa[y][i]]>Deep[x]) 
		{
			check(fir,sec,Fir[y][i],Sec[y][i]);
			y=Fa[y][i];
		}
	if (Fa[y][0]==x) return make_pair(fir,sec);
	if (Deep[y]>Deep[x]) check(fir,sec,Fir[y][0],Sec[y][0]),y=Fa[y][0];
	for (int i=20;i>=0;i--)
		if (Fa[x][i]^Fa[y][i]) 
		{
			check(fir,sec,Fir[x][i],Sec[x][i]);
			check(fir,sec,Fir[y][i],Sec[y][i]);
			x=Fa[x][i],y=Fa[y][i];
		}
	check(fir,sec,Fir[x][0],Sec[x][0]);
	check(fir,sec,Fir[y][0],Sec[y][0]);
	return make_pair(fir,sec);
}

int main()
{
	memset(Fir,-1,sizeof(Fir));
	memset(Sec,-1,sizeof(Sec));
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) Pa[i]=i;
	for (int i=0;i<m;i++) Read(Eg[i].x),Read(Eg[i].y),Read(Eg[i].z);
	sort(Eg,Eg+m);
	for (int i=0;i<m;i++)
	{
		int x=Eg[i].x,y=Eg[i].y;
		if (Getf(x)==Getf(y)) continue;
		Link(Eg[i]);pre_Ans+=Eg[i].z;
		Eg[i].used=1;Pa[Getf(x)]=Getf(y);
	}
	DFS(1);
	for (int x=1;x<21;x++)
		for (int i=1;i<=n;i++)
		{
			int P=Fa[i][x-1];
			Fa[i][x]=Fa[P][x-1];
			if (!Fa[i][x]) continue;
			if (Fir[i][x-1]==Fir[P][x-1])
			{
				Fir[i][x]=Fir[i][x-1];
				Sec[i][x]=max(Sec[i][x-1],Sec[P][x-1]);
			} else
			{
				Fir[i][x]=max(Fir[i][x-1],Fir[P][x-1]);
				Sec[i][x]=min(Fir[i][x-1],Fir[P][x-1]);
			}
		}
	for (int i=0;i<m;i++)
		if (!Eg[i].used)
		{
			PII tmp=Query(Eg[i].x,Eg[i].y);
			if (tmp.first!=Eg[i].z) Ans=min(Ans,pre_Ans-tmp.first+Eg[i].z);
				else Ans=min(Ans,pre_Ans-tmp.second+Eg[i].z);
		}
	printf("%lld\n",Ans);
}
Problem1978
#include<cstdio>
#define max(a,b) (a>b?a:b)
using namespace std;

const int Maxn=1000000+19;
int F[Maxn],tmp[Maxn>>3];
int n,x,L,cnt=0,Max=0;

int main()
{
	scanf("%d%d",&n,&L);
	for (int i=0;i<n;i++)
	{
		scanf("%d",&x);
		int Ans=0,tot=0;
		for (int i=1;i*i<=x;i++) 
			if (!(x%i)) 
			{
				if (i>=L) tmp[tot++]=i;
				if (x/i>=L) tmp[tot++]=x/i;
			}
		for (int i=0;i<tot;i++) Ans=max(Ans,F[tmp[i]]);
		Ans++;
		for (int i=0;i<tot;i++) F[tmp[i]]=Ans;
		Max=max(Max,Ans);
	}
	printf("%d\n",Max);
	return 0;
}
Problem1978
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=50000+19,MaxL=1000000+19;
int A[Maxn],Ans[MaxL],List[MaxL];
int n,L,cnt,tmp,res;

int main()
{
	scanf("%d%d",&n,&L);
	for (int i=1;i<=n;i++) scanf("%d",&A[i]);
	for (int i=1;i<=n;i++)
	{
		tmp=1;cnt=0;
		for (int j=1;j*j<=A[i];j++)
			if (A[i]%j==0) 
			{
				if (j>=L) tmp=max(tmp,Ans[j]+1),List[cnt++]=j;
				if (A[i]/j>=L) tmp=max(tmp,Ans[A[i]/j]+1),List[cnt++]=A[i]/j;
			}
		for (int j=0;j<cnt;j++) Ans[List[j]]=max(Ans[List[j]],tmp);
		if (tmp>res) res=tmp;
	}
	printf("%d\n",res);
}
Problem1984
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x,f;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=100000+19;
struct Edge {int y,z,ID,nxt;} E[N*2];
typedef int one[N];
one S,Fa,Top,D,ID,Last,P,reID,son;
int n,tot,x,y,z,cnt;

void Link(int x,int y,int z,int ID)
{
	E[cnt]=(Edge){y,z,ID,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,ID,Last[y]};Last[y]=cnt++;
}

//SegTree
char s;
int Set[N*4],Add[N*4],Max[N*4],key[N],Ql,Qr,Qv;

void SetA(int x,int v) {Max[x]+=v;if (~Set[x]) Set[x]+=v;else Add[x]+=v;}
void SetS(int x,int v) {Max[x]=v;Set[x]=v;Add[x]=0;}
void Down(int x)
{
	if (~Set[x]) SetS(Lsn,Set[x]),SetS(Rsn,Set[x]),Set[x]=-1;
	if (Add[x]) SetA(Lsn,Add[x]),SetA(Rsn,Add[x]),Add[x]=0;
}
void Build(int x,int L,int R)
{
	Set[x]=-1,Add[x]=0;
	if (L==R) {Max[x]=key[L];return;}
	Build(Lsn,L,Mid);Build(Rsn,Mid+1,R);
	Max[x]=max(Max[Lsn],Max[Rsn]);
}
void Update(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {s=='d'?SetA(x,Qv):SetS(x,Qv);return;}
	Down(x);
	if (Ql<=Mid) Update(Lsn,L,Mid);
	if (Qr>Mid) Update(Rsn,Mid+1,R);
	Max[x]=max(Max[Lsn],Max[Rsn]);
}
int Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return Max[x];
	Down(x);int res=0;
	if (Ql<=Mid) res=max(res,Query(Lsn,L,Mid));
	if (Qr>Mid) res=max(res,Query(Rsn,Mid+1,R));
	return res;
}

void DFS(int x)
{
	S[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x])
		{
			D[E[i].y]=D[x]+1,Fa[E[i].y]=x,P[E[i].y]=E[i].z,reID[E[i].ID]=E[i].y;
			DFS(E[i].y),S[x]+=S[E[i].y];
			if (S[E[i].y]>S[son[x]]) son[x]=E[i].y;
		}
}
void DFS(int x,int Anc)
{
	ID[x]=++tot,key[tot]=P[x],Top[x]=Anc;
	if (son[x]) DFS(son[x],Anc);
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x]&&E[i].y!=son[x]) DFS(E[i].y,E[i].y);
}
int Solve(int x,int y)
{
	int a=Top[x],b=Top[y],Ans=0;
	while (a!=b)
	{
		if (D[a]>D[b]) swap(a,b),swap(x,y);
		Ql=ID[b],Qr=ID[y];
		if (s=='a') Ans=max(Ans,Query(1,1,n));else Update(1,1,n);
		y=Fa[b],b=Top[y];
	}
	Ql=ID[x],Qr=ID[y];
	if (Ql>Qr) swap(Ql,Qr);Ql++;
	if (Ql<=Qr)
		if (s=='a') Ans=max(Ans,Query(1,1,n));else Update(1,1,n);
	return Ans;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN();
	For(i,1,n) x=IN(),y=IN(),z=IN(),Link(x,y,z,i);
	DFS(1);
	DFS(1,1);
	Build(1,1,n);
	for (;;)
	{
		while (!isalpha(s=getchar()));s=getchar();
		if (s=='t') break;
		if (s=='h') Ql=Qr=ID[reID[IN()]],Qv=IN(),Update(1,1,n);
			else
			{
				x=IN(),y=IN();
				if (s!='a') Qv=IN(),Solve(x,y);else printf("%d\n",Solve(x,y));
			}
	}
}
Problem1996
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)

const int N=1000+19,Mod=19650827;
int F[N][N][2],A[N];
int n;

int main()
{
	scanf("%d",&n);
	For(i,1,n+1) scanf("%d",&A[i]),F[i][i][0]=1;
	For(Len,2,n+1) For(L,1,n+1)
	{
		int R=L+Len-1;
		F[L][R][0]=(F[L+1][R][0]*(A[L]<A[L+1])+F[L+1][R][1]*(A[L]<A[R]))%Mod;
		F[L][R][1]=(F[L][R-1][0]*(A[R]>A[L])+F[L][R-1][1]*(A[R]>A[R-1]))%Mod;
	}
	printf("%d\n",(F[1][n][0]+F[1][n][1])%Mod);
}
Problem1997
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int M=10000+19,N=600*2+19;
struct Edge {int y,nxt;} E[600*600*4+19];
int x[M],y[M],Last[N],DFN[N],SCC[N],Low[N],S[N],Pos[N];
int T,n,m,t,cnt,tot,Time,Top,a;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void Add_Edge(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void Tarjan(int x)
{
	DFN[x]=Low[x]=++Time;
	S[++Top]=x;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (!DFN[E[i].y]) Tarjan(E[i].y),Low[x]=min(Low[x],Low[E[i].y]);
			else if (!SCC[E[i].y]) Low[x]=min(Low[x],DFN[E[i].y]);
	if (DFN[x]==Low[x])
	{
		int t;tot++;
		do t=S[Top--],SCC[t]=tot;while (t!=x);
	}
}

int main()
{
	read(T);
	while (T--)
	{
		read(n),read(m);
		For(i,0,m) read(x[i]),read(y[i]);
		For(i,0,n) read(a),Pos[a]=i+1;
		if (m>3*n-6) {puts("NO");continue;}
		memset(Last,-1,sizeof(Last));
		memset(DFN,0,sizeof(DFN));
		memset(SCC,0,sizeof(SCC));
		Time=t=tot=cnt=0;
		For(i,0,m)
		{
			x[i]=Pos[x[i]];y[i]=Pos[y[i]];
			if (x[i]>y[i]) swap(x[i],y[i]);
			if (!(y[i]-x[i]==1||x[i]==1&&y[i]==n)) x[t]=x[i],y[t++]=y[i];
		}
		For(i,0,t) For(j,i+1,t)
			if (x[i]<x[j]&&x[j]<y[i]&&y[i]<y[j]||x[j]<x[i]&&x[i]<y[j]&&y[j]<y[i])
				Add_Edge(i<<1|1,j<<1),Add_Edge(j<<1|1,i<<1);
		For(i,0,t<<1) if (!DFN[i]) Tarjan(i);
		int f=1;
		For(i,0,t) if (SCC[i<<1]==SCC[i<<1|1]) {f=0;break;}
		puts(f?"YES":"NO");
	}
}
Problem2001
#include<set>
#include<map>
#include<cmath>
#include<string>
#include<cstdio>
#include<vector>
#include<cctype>
#include<cstdlib>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define Mid (L+R>>1)

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

const int len=200000;
inline int nc()
{
	static char buf[len],*b=buf+len;
	if (b==buf+len) fread(buf,1,len,stdin),b=buf;
	return *b++;
}
int IN()
{
	int c,f,x;
	while (!isdigit(c=nc())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=nc())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;

const int N=20000+19,M=50000+19;
struct QType {int x,v;} Q[M];
int key[M],vis[M],id[N];
int Time,n,m,Qc;

struct USet
{
	int fa[N];
	void Reset(int n) {For(i,1,n+1) fa[i]=i;}
	int getf(int x) {return fa[x]==x?x:fa[x]=getf(fa[x]);}
} U[20],tmp;

struct Graph
{
	struct Edge
	{
		int x,y,id;
		bool operator < (const Edge &B) const {return key[id]<key[B.id];}
	} E[M];
} G[20];

void Solve(int L,int R,int d,int n,int m,ll res)
{
	Graph &g=G[d];
	USet &u=U[d];
	For(i,0,m) g.E[i]=G[d-1].E[i];
	if (L==R)
	{
		key[Q[L].x]=Q[L].v;
		u.Reset(n);
		sort(g.E,g.E+m);
		For(i,0,m)
		{
			int fx=u.getf(g.E[i].x),fy=u.getf(g.E[i].y);
			if (fx!=fy) u.fa[fx]=fy,res+=key[g.E[i].id];
		}
		printf("%lld\n",res);
		return;
	}
	Time++;
	For(i,L,R+1) vis[Q[i].x]=Time;
	//Reduction
	int __m=0,__n;
	u.Reset(n);
	sort(g.E,g.E+m);
	For(i,0,m)
		if (vis[g.E[i].id]!=Time)
		{
			int fx=u.getf(g.E[i].x),fy=u.getf(g.E[i].y);
			if (fx!=fy) u.fa[fx]=fy,g.E[__m++]=g.E[i];
		} else g.E[__m++]=g.E[i];
	m=__m;
	//Contraction
	u.Reset(n);
	tmp.Reset(n);
	For(i,0,m) if (vis[g.E[i].id]==Time)
	{
		int fx=u.getf(g.E[i].x),fy=u.getf(g.E[i].y);
		if (fx!=fy) u.fa[fx]=fy;
	}
	For(i,0,m) if (vis[g.E[i].id]!=Time)
	{
		int x=g.E[i].x,y=g.E[i].y;
		int fx=u.getf(x),fy=u.getf(y);
		if (fx!=fy)
		{
			tmp.fa[tmp.getf(x)]=y;
			u.fa[fx]=fy;
			res+=key[g.E[i].id];
		}
	}
	//...
	__n=__m=0;
	For(i,1,n+1) if (tmp.getf(i)==i) id[i]=++__n;
	For(i,0,m)
	{
		int x=tmp.getf(g.E[i].x);
		int y=tmp.getf(g.E[i].y);
		if (x!=y) g.E[__m++]=(Graph::Edge){id[x],id[y],g.E[i].id};
	}
	Solve(L,Mid,d+1,__n,__m,res);
	Solve(Mid+1,R,d+1,__n,__m,res);
}

int main()
{
	n=IN(),m=IN(),Qc=IN();
	For(i,0,m) G[0].E[i]=(Graph::Edge){IN(),IN(),i},key[i]=IN();
	For(i,1,Qc+1) Q[i]=(QType){IN()-1,IN()};
	Solve(1,Qc,1,n,m,0);
}
Problem2002
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=200000+19;
int n,Q,x,y,s;

struct node;node *null;
struct node
{
	node *L,*R,*Fa;
	int S;
	
	bool Top() {return Fa==null||Fa->L!=this&&Fa->R!=this;}
	void Update() {if (this!=null) S=L->S+R->S+1;}
	
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		y->Fa=this;R=y;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		y->Fa=this;L=y;y->Update();
	}
} Nd[N];

void Splay(node *x)
{
	while (!x->Top())
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top())
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}
node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa) Splay(x),x->R=y,x->Update();
	return y;
}
void Link(node *x,node *y) {Access(x),Splay(x),x->L=x->L->Fa=null,x->Fa=y,x->Update();}

int main()
{
	read(n);
	null=Nd+n;
	For(i,0,n+1) Nd[i]=(node){null,null,null,1};null->S=0;
	For(i,0,n) {read(x);if (i+x<n) Nd[i].Fa=Nd+i+x;}
	read(Q);
	while (Q--)
	{
		read(s);
		if (s==1) read(x),printf("%d\n",Access(Nd+x)->S);
		if (s==2) read(x),read(y),Link(Nd+x,x+y<n?Nd+x+y:null);
	}
}
Problem2005
#include<cstdio>
#include<algorithm>
using namespace std;

const int top=100000,Maxn=top+19;
long long phi[Maxn],Ans;
int p[Maxn],vis[Maxn],n,m,cnt;

int main()
{
	phi[1]=1;
	for (int i=2;i<=top;i++)
	{
		if (!vis[i]) p[cnt++]=i,phi[i]=i-1;
		for (int j=0;j<cnt&&p[j]*i<=top;j++)
		{
			vis[p[j]*i]=1;
			if (i%p[j]==0) {phi[p[j]*i]=phi[i]*p[j];break;}
				else phi[p[j]*i]=phi[i]*(p[j]-1);
		}
	}
	for (int i=2;i<=top;i++) phi[i]+=phi[i-1];
	scanf("%d%d",&n,&m);if (n>m) swap(n,m);
	for (int L=1,R;L<=n;L=R+1)
	{
		R=min(n/(n/L),m/(m/L));
		Ans+=(phi[R]-phi[L-1])*(n/L)*(m/L);
	}
	Ans*=2;Ans-=1LL*n*m;
	printf("%lld\n",Ans);
}
Problem2006
#include<cstdio>
#include<cctype>
#include<queue>
#include<algorithm>
using namespace std;

const int N=500000+19;
struct node
{
	int i,L,R,t,v;
	bool operator < (const node& B) const {return v<B.v;}
};priority_queue<node> Q;
int Max[N][20],A[N],T[N][20],Log[N],n,L,R,k;
long long Ans;

void read(int &x)
{
	int c,f;
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}

node Query(int i,int L,int R)
{
	int k=Log[R-L+1],t,v;
	if (Max[L][k]>Max[R-(1<<k)+1][k]) t=T[L][k],v=Max[L][k];
		else t=T[R-(1<<k)+1][k],v=Max[R-(1<<k)+1][k];
	return (node){i,L,R,t,v-A[i-1]};
}

int main()
{
	scanf("%d%d%d%d",&n,&k,&L,&R);
	for (int i=1;i<=n;i++) read(A[i]),A[i]+=A[i-1],Max[i][0]=A[i],T[i][0]=i;
	for (int i=2;i<=n;i++) Log[i]=Log[i>>1]+1;
	for (int x=1;x<20;x++)
		for (int i=1;i+(1<<x)-1<=n;i++)
			if (Max[i][x-1]>Max[i+(1<<x-1)][x-1])
				Max[i][x]=Max[i][x-1],T[i][x]=T[i][x-1];else
				Max[i][x]=Max[i+(1<<x-1)][x-1],T[i][x]=T[i+(1<<x-1)][x-1];
	for (int i=1;i+L-1<=n;i++) Q.push(Query(i,i+L-1,min(i+R-1,n)));
	while (k--)
	{
		node x=Q.top();Q.pop();
		Ans+=x.v;
		if (x.L<=x.t-1) Q.push(Query(x.i,x.L,x.t-1));
		if (x.t+1<=x.R) Q.push(Query(x.i,x.t+1,x.R));
	}
	printf("%lld\n",Ans);
}
Problem2007
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int M=500+19,N=M*M;
struct Edge {int y,z,nxt;} E[N*4];
int ID[M][M],Dis[N],Last[N],Pos[N],vis[N];
int n,tot,x,cnt,S,T;

struct Heap
{
	int Len,s[N];
	bool Empty() {return !Len;}
	void Up(int x)
	{
		while (x>1&&Dis[s[x>>1]]>Dis[s[x]])
			swap(Pos[s[x]],Pos[s[x>>1]]),swap(s[x],s[x>>1]),x>>=1;
	}
	void Down(int x)
	{
		for(;;)
		{
			int t=x;
			if (x<<1<=Len&&Dis[s[x<<1]]<Dis[s[t]]) t=x<<1;
			if ((x<<1|1)<=Len&&Dis[s[x<<1|1]]<Dis[s[t]]) t=x<<1|1;
			if (t==x) break;swap(Pos[s[x]],Pos[s[t]]),swap(s[x],s[t]),x=t;
		}
	}
	void Push(int x) {s[++Len]=x;Pos[x]=Len,Up(Len);}
	int Top() {int Ans=s[1];Pos[s[1]=s[Len--]]=1,Down(1);return Ans;}
} H;

void Add_Edge(int x,int y,int z) {E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;}
int Dijkstra()
{
	memset(Dis,60,sizeof(Dis));Dis[S]=0;
	H.Push(S);vis[S]=1;
	while (!H.Empty())
	{
		int x=H.Top();
		for (int i=Last[x];~i;i=E[i].nxt)
			if (Dis[x]+E[i].z<Dis[E[i].y])
			{
				Dis[E[i].y]=Dis[x]+E[i].z;
				if (vis[E[i].y]) H.Up(Pos[E[i].y]);else vis[E[i].y]=1,H.Push(E[i].y);
			}
	}
	return Dis[T];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);
	For(i,0,n) For(j,0,n) ID[i][j]=++tot;
	S=++tot,T=++tot;

	For(i,0,n) scanf("%d",&x),Add_Edge(ID[0][i],T,x);
	For(i,0,n-1) For(j,0,n) scanf("%d",&x),Add_Edge(ID[i+1][j],ID[i][j],x);
	For(i,0,n) scanf("%d",&x),Add_Edge(S,ID[n-1][i],x);
	
	For(i,0,n)
	{
		scanf("%d",&x),Add_Edge(S,ID[i][0],x);
		For(j,0,n-1) scanf("%d",&x),Add_Edge(ID[i][j],ID[i][j+1],x);
		scanf("%d",&x),Add_Edge(ID[i][n-1],T,x);
	}
	
	For(i,0,n) scanf("%d",&x),Add_Edge(T,ID[0][i],x);
	For(i,0,n-1) For(j,0,n) scanf("%d",&x),Add_Edge(ID[i][j],ID[i+1][j],x);
	For(i,0,n) scanf("%d",&x),Add_Edge(ID[n-1][i],S,x);
	
	For(i,0,n)
	{
		scanf("%d",&x),Add_Edge(ID[i][0],S,x);
		For(j,0,n-1) scanf("%d",&x),Add_Edge(ID[i][j+1],ID[i][j],x);
		scanf("%d",&x),Add_Edge(T,ID[i][n-1],x);
	}
	
	printf("%d\n",Dijkstra());
}
Problem2034
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

typedef long long LL;
typedef double Db;

const int N=5000+19;
struct Mission
{
	int S,T,v;
	bool operator < (const Mission& B) const {return v>B.v;}
} A[N];
int S[N],P[N],L[N];
int x,n;
LL Ans;

bool Find(int x,int c)
{
	if (P[c]>A[x].T) return 0;
	if (!L[c]) return L[c]=x,1;
	if (A[x].T>A[L[c]].T) return Find(x,c+1);
		else if (Find(L[c],c+1)) return L[c]=x,1;
	return 0;
}

int main()
{
	n=IN();
	For(i,1,n+1) A[i]=(Mission){S[i]=IN(),IN(),IN()};
	sort(S+1,S+n+1);
	For(i,1,n+1) P[i]=x=max(x+1,S[i]);
	sort(A+1,A+n+1);
	For(i,1,n+1)
	{
		int x=1;
		while (P[x]<A[i].S) x++;
		if (Find(i,x)) Ans+=A[i].v;
	}
	printf("%lld\n",Ans);
}
Problem2038
#include<cstdio>
#include<cctype>
#include<algorithm>
#include<cmath>
using namespace std;

const int Maxn=50000+19;
struct Ques {int L,R,Ans,ID;} A[Maxn];
int c[Maxn],s[Maxn];
int n,m,Ans,L,R,size;

int cc;
void read(int &x)
{
	while (!isdigit(cc=getchar()));x=cc-'0';
	while (isdigit(cc=getchar())) x=x*10+cc-'0';
}

int cmp1(Ques A,Ques B) {return A.L/size<B.L/size||A.L/size==B.L/size&&A.R<B.R;}
int cmp2(Ques A,Ques B) {return A.ID<B.ID;}

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}

void Update(int x,int v)
{
	if (x==0) return;
	Ans-=1LL*s[c[x]]*(s[c[x]]-1)/2LL;
	s[c[x]]+=v;
	Ans+=1LL*s[c[x]]*(s[c[x]]-1)/2LL;
}	

int main()
{
	read(n);read(m);
	for (int i=1;i<=n;i++) read(c[i]);
	for (int i=0;i<m;i++) read(A[i].L),read(A[i].R),A[i].ID=i;
	size=sqrt(n)+1;
	sort(A,A+m,cmp1);
	L=R=0;Ans=0;
	for (int i=0;i<m;i++)
	{
		while (L<A[i].L) Update(L++,-1);
		while (L>A[i].L) Update(--L,1);
		while (R>A[i].R) Update(R--,-1);
		while (R<A[i].R) Update(++R,1);
		A[i].Ans=Ans;
	}
	sort(A,A+m,cmp2);
	for (int i=0;i<m;i++) 
	{
		int x=A[i].Ans,y=1LL*(A[i].R-A[i].L+1)*(A[i].R-A[i].L)/2LL,z=gcd(x,y);
		printf("%d/%d\n",x/z,y/z);
	}
}
Problem2038
#include<cstdio>
#include<cctype>
#include<algorithm>
#include<cmath>
using namespace std;

const int Maxn=50000+19;
struct Ques {int L,R,Ans,ID;} A[Maxn];
int c[Maxn],s[Maxn];
int n,m,Ans,L,R,size;

int cc;
void read(int &x)
{
	while (!isdigit(cc=getchar()));x=cc-'0';
	while (isdigit(cc=getchar())) x=x*10+cc-'0';
}

int cmp1(Ques A,Ques B) {return A.L/size!=B.L/size?A.L<B.L:A.R<B.R;}
int cmp2(Ques A,Ques B) {return A.ID<B.ID;}

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}

void Update(int x,int v)
{
	if (x==0) return;
	Ans-=1LL*s[c[x]]*(s[c[x]]-1)/2LL;
	s[c[x]]+=v;
	Ans+=1LL*s[c[x]]*(s[c[x]]-1)/2LL;
}	

int main()
{
	read(n);read(m);
	for (int i=1;i<=n;i++) read(c[i]);
	for (int i=0;i<m;i++) read(A[i].L),read(A[i].R),A[i].ID=i;
	size=sqrt(n)+1;
	sort(A,A+m,cmp1);
	L=R=0;Ans=0;
	for (int i=0;i<m;i++)
	{
		while (L<A[i].L) Update(L++,-1);
		while (L>A[i].L) Update(--L,1);
		while (R>A[i].R) Update(R--,-1);
		while (R<A[i].R) Update(++R,1);
		A[i].Ans=Ans;
	}
	sort(A,A+m,cmp2);
	for (int i=0;i<m;i++) 
	{
		int x=A[i].Ans,y=1LL*(A[i].R-A[i].L+1)*(A[i].R-A[i].L)/2LL,z=gcd(x,y);
		printf("%d/%d\n",x/z,y/z);
	}
}
Problem2045
#include<cstdio>
#include<algorithm>

using namespace std;

const int top=1e6+19,N=top+19;
int vis[N],p[N],mu[N],cnt,A,B,d;
long long Ans;

int main()
{
	scanf("%d%d%d",&A,&B,&d);A/=d,B/=d;
	mu[1]=1;
	for (int i=2;i<=top;i++)
	{
		if (!vis[i]) {p[cnt++]=i;mu[i]=-1;}
		for (int j=0;j<cnt&&p[j]*i<=top;j++)
		{
			vis[p[j]*i]=1;
			if (i%p[j]==0) {mu[p[j]*i]=0;break;} else mu[p[j]*i]=-mu[i];
		}
	}
	for (int d=1;d<=A&&d<=B;d++) Ans+=1LL*mu[d]*(A/d)*(B/d);
	printf("%lld\n",Ans);
}
Problem2049
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=10000+19;
int n,m,a,b;
char s[10];

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

struct node;node *null;
struct node
{
	node *L,*R,*Fa;
	int rev;
	
	bool Top() {return Fa==null||Fa->L!=this&&Fa->R!=this;}
	void Setrev() {rev^=1,swap(L,R);}
	void Down() {if (rev) rev=0,L->Setrev(),R->Setrev();}
	
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (z!=null) if (z->L==y) z->L=this;else if (z->R==y) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (z!=null) if (z->L==y) z->L=this;else if (z->R==y) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;
	}
} Nd[N];

void Splay(node *x)
{
	static node *S[N];
	node *tmp=x;int k=0;
	while (!tmp->Top()) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (!x->Top())
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top())
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
}
node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa) Splay(x),x->R=y;
	return y;
}
void Evert(node *x) {Access(x)->Setrev();}
node *Root(node *x)
{
	Access(x),Splay(x);
	while (x->L!=null) x=x->L,x->Down();
	return x;
}
void Link(node *x,node *y) {Evert(x),Splay(x),x->Fa=y;}
void Cut(node *x,node *y)
{
	Access(x),Splay(y);
	if (y->Fa==x) y->Fa=null;else Access(y),Splay(x),x->Fa=null;
}

int main()
{
	null=Nd;
	read(n),read(m);
	For(i,0,n+1) Nd[i]=(node){null,null,null,0};
	while (m--)
	{
		scanf("%s%d%d",s,&a,&b);
		if (s[0]=='Q') puts(Root(Nd+a)==Root(Nd+b)?"Yes":"No");
		if (s[0]=='C') Link(Nd+a,Nd+b);
		if (s[0]=='D') Cut(Nd+a,Nd+b);
	}
}
Problem2054
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1000000+19;
int Fa[N],C[N],n,m,p,q;

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}

int main()
{
	scanf("%d%d%d%d",&n,&m,&p,&q);
	For(i,1,n+2) Fa[i]=i;
	for (;m;m--)
	{
		int L=(m*p+q)%n+1,R=(m*q+p)%n+1;
		if (L>R) {int t=L;L=R;R=t;}
		for (int i=Getf(L);i<=R;i=Getf(i+1)) C[i]=m,Fa[i]=i+1;
	}
	For(i,1,n+1) printf("%d\n",C[i]);
}
Problem2055
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=100*2+19,M=N*N,oo=(1<<30)-1;
struct Edge {int y,f,c,nxt;} E[M];
int Last[N],pre[N],Dis[N],vis[N],Q[N*100];
int cnt,S,T,n,m,Cost,x;

void Add_Edge(int x,int y,int f,int c)
{
	E[cnt]=(Edge){y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,-c,Last[y]};Last[y]=cnt++;
}

bool SPFA()
{
	memset(Dis,64,sizeof(Dis));Dis[S]=0;
	int f=1,w=0;Q[1]=S;pre[S]=-1;
	while (f>w)
	{
		int x=Q[++w];vis[x]=0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]>Dis[x]+E[i].c)
			{
				Dis[E[i].y]=Dis[x]+E[i].c,pre[E[i].y]=i;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
	}
	return Dis[T]<oo;
}
void Update()
{
	int Min=oo;
	for (int i=pre[T];~i;i=pre[E[i^1].y]) Min=min(Min,E[i].f);
	for (int i=pre[T];~i;i=pre[E[i^1].y]) E[i].f-=Min,E[i^1].f+=Min;
	Cost+=Min*Dis[T];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	S=n+n+3,T=S+1;
	For(i,1,n+1) scanf("%d",&x),Add_Edge(S,i+n,x,0),Add_Edge(i,T,x,0);
	For(i,1,n) For(j,i+1,n+1) {scanf("%d",&x);if (~x) Add_Edge(i+n,j,oo,x);}
	For(i,1,n+1) Add_Edge(i+n,S-1,oo,0),Add_Edge(S-2,i,oo,0);
	Add_Edge(S-1,S-2,m,0);
	while (SPFA()) Update();
	printf("%d\n",Cost);
}
Problem2056
#include<cstdio>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int T,A[8];
unsigned long long b;

int main()
{
	for (scanf("%d",&T);T--;)
	{
		int f=1;
		For(i,0,8) {scanf("%d",&A[i]);if (A[i]!=60) f=0;}
		scanf("%llu",&b);
		if (f&&b==9223372036854775808ULL) {puts("18446744073709551616");continue;}
		For(i,0,8) b+=1ULL<<A[i];
		printf("%llu\n",b);
	}
}
Problem2096
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=3000000+19;
int Qb[N],Qs[N],A[N],bf,bw,sf,sw,n,Ans,x,L,k;

int main()
{
	read(k),read(n);
	For(i,1,n+1) read(A[i]);
	bw=sw=L=1;
	For(i,1,n+1)
	{
		while (bf>=bw&&A[Qb[bf]]>A[i]) bf--;Qb[++bf]=i;
		while (sf>=sw&&A[Qs[sf]]<A[i]) sf--;Qs[++sf]=i;
		while (A[Qs[sw]]-A[Qb[bw]]>k)
		{
			L++;
			while (Qb[bw]<L) bw++;
			while (Qs[sw]<L) sw++;
		}
		Ans=max(Ans,i-L+1);
	}
	printf("%d\n",Ans);
}
Problem2109
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=2000+19;
struct Edge {int y,nxt;} E[10000+19];
int Last[N],K[N],D[N],D2[N],Q[N],List[N];
int n,m,f,w,cnt,x,y;

int cmp(int i,int j) {return K[i]<K[j];}
void Add_Edge(int x,int y)
{
	D[y]++;
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
}
void work(int x)
{
	for (int i=1;i<=n;i++) D[i]=D2[i];
	f=0,w=0;
	for (int t=1,_=1,u;t<=n;t++)
	{
		for (;_<=n&&K[u=List[_]]<=t;_++) if (!D[u]&&u!=x) Q[++f]=u;
		if (f>w)
		{
			int u=Q[++w];
			for (int i=Last[u];~i;i=E[i].nxt)
				if (!(--D[E[i].y])&&K[E[i].y]<=t&&E[i].y!=x) Q[++f]=E[i].y;
		} else return;
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) scanf("%d",&K[i]),K[i]=n-K[i]+1,List[i]=i;
	for (int i=0;i<m;i++) scanf("%d%d",&x,&y),Add_Edge(y,x);
	sort(List+1,List+n+1,cmp);
	for (int i=1;i<=n;i++) D2[i]=D[i];
	for (int i=1;i<=n;i++) work(i),printf("%d ",n-f);puts("");
}
Problem2115
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;

const int M=100000+19,N=M/2;
typedef long long LL;
struct Edge {int y,nxt;LL z;} E[M*2];
int vis[N],Last[N];
int n,m,cnt,tot;
LL A[M*2],Base[65],Dis[N],x,y,z;

LL read()
{
	int c;LL x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10LL+c-'0';
	return x;
}
void Link(int x,int y,LL z)
{
	E[++cnt]=(Edge){y,Last[x],z};Last[x]=cnt;
	E[++cnt]=(Edge){x,Last[y],z};Last[y]=cnt;
}

void DFS(int x)
{
	vis[x]=1;
	for (int i=Last[x];i;i=E[i].nxt)
		if (!vis[E[i].y])
		{
			Dis[E[i].y]=Dis[x]^E[i].z;
			DFS(E[i].y);
		} else A[tot++]=Dis[x]^Dis[E[i].y]^E[i].z;
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=0;i<m;i++) x=read(),y=read(),z=read(),Link(x,y,z);
	DFS(1);
	for (int i=0;i<tot;i++)
		for (int j=63;j>=0;j--)
			if (A[i]>>j&1)
				if (!Base[j]) {Base[j]=A[i];break;}else A[i]^=Base[j];
	LL Ans=Dis[n];
	for (int i=63;i>=0;i--) if ((Ans^Base[i])>Ans) Ans^=Base[i];
	printf("%lld\n",Ans);
}
Problem2120
#include<cstdio>
#include<cctype>
using namespace std;

int cnt[11000+19],A[10000+19],D[1000000+19];
int n,Q,x,col,c,Ans,L,R;
char s[3];

void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	scanf("%d%d",&n,&Q);
	for (int i=1;i<=n;i++) 
	{
		scanf("%d",&x);
		if (!D[x]) D[x]=++col;
		A[i]=D[x];
	}
	for (int t=1;t<=Q;t++)
	{
		scanf("%s",s);
		read(L),read(R);
		if (s[0]=='R') {if (!D[R]) D[R]=++col;A[L]=D[R];continue;}
		Ans=0;
		for (int i=L;i<=R;i++) if (cnt[A[i]]!=t) cnt[A[i]]=t,Ans++;
		printf("%d\n",Ans);
	}
}
Problem2127
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<=y;i++)
using namespace std;

const int K=100+19,N=K*K,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[N*12];
int ID[K][K],C[K][K],D[K][K];
int Last[N],A[N],B[N],Q[N],Dis[N];
int n,m,tot,x,S,T,cnt,f,w,Flow;

void Link(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=0;
	f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(E[i].f,Flow));
			E[i].f-=tmp,E[i^1].f+=tmp,res+=tmp,Flow-=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	For(i,1,n) For(j,1,m) ID[i][j]=++tot;S=++tot,T=++tot;
	For(i,1,n) For(j,1,m) scanf("%d",&x),A[ID[i][j]]+=x*2,Flow+=x;
	For(i,1,n) For(j,1,m) scanf("%d",&x),B[ID[i][j]]+=x*2,Flow+=x;
	For(i,1,n-1) For(j,1,m)
		scanf("%d",&x),Flow+=x,A[ID[i][j]]+=x,A[ID[i+1][j]]+=x,C[i][j]+=x;
	For(i,1,n-1) For(j,1,m)
		scanf("%d",&x),Flow+=x,B[ID[i][j]]+=x,B[ID[i+1][j]]+=x,C[i][j]+=x;
	For(i,1,n) For(j,1,m-1)
		scanf("%d",&x),Flow+=x,A[ID[i][j]]+=x,A[ID[i][j+1]]+=x,D[i][j]+=x;
	For(i,1,n) For(j,1,m-1)
		scanf("%d",&x),Flow+=x,B[ID[i][j]]+=x,B[ID[i][j+1]]+=x,D[i][j]+=x;
	For(i,1,tot) if (A[i]) Link(S,i,A[i]);
	For(i,1,tot) if (B[i]) Link(i,T,B[i]);
	For(i,1,n) For(j,1,m)
	{
		if (C[i][j]) Link(ID[i][j],ID[i+1][j],C[i][j]),E[cnt-1].f=C[i][j];
		if (D[i][j]) Link(ID[i][j],ID[i][j+1],D[i][j]),E[cnt-1].f=D[i][j];
	}
	Flow*=2;while (BFS()) Flow-=Dinic(S,oo);
	printf("%d\n",Flow/2);
}
Problem2132
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int K=100+19,N=K*K,M=N*4+N*4,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[M];
int Last[N],Q[N],Dis[N];
int C[K][K],ID[K][K],n,m,tot,cnt,x,S,T,f,w,Ans,t;
int Dx[2]={1,0},Dy[2]={0,1};

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	f=1,w=0,Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			res+=tmp,Flow-=tmp,E[i].f-=tmp,E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	For(i,1,n+1) For(j,1,m+1) ID[i][j]=++tot;S=++tot,T=++tot;
	For(i,1,n+1) For(j,1,m+1)
		scanf("%d",&x),Ans+=x,
		i&1^j&1?Add_Edge(S,ID[i][j],x):Add_Edge(ID[i][j],T,x);
	For(i,1,n+1) For(j,1,m+1)
		scanf("%d",&x),Ans+=x,
		i&1^j&1?Add_Edge(ID[i][j],T,x):Add_Edge(S,ID[i][j],x);
	For(i,1,n+1) For(j,1,m+1) scanf("%d",&C[i][j]);
	For(i,1,n+1) For(j,1,m+1) For(k,0,2)
	{
		int nx=i+Dx[k],ny=j+Dy[k];
		if (nx>=1&&nx<=n&&ny>=1&&ny<=m)
			Ans+=(t=C[i][j]+C[nx][ny]),Add_Edge(ID[i][j],ID[nx][ny],t),E[cnt-1].f=t;
	}
	while (BFS()) Ans-=Dinic(S,oo);
	printf("%d\n",Ans);
}
Problem2134
#include<cstdio>
using namespace std;

const int Maxn=10000000+19;
int a[Maxn],A,B,C,n;
double Ans;

int main()
{
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1);
	for (int i=2;i<=n;i++) a[i]=(1LL*a[i-1]*A+B)%100000001;
	for (int i=1;i<=n;i++) a[i]=a[i]%C+1;
	a[0]=a[n];
	for (int i=1;i<=n;i++) Ans+=1./double(a[i]>a[i-1]?a[i]:a[i-1]);
	printf("%.3lf\n",Ans);
}
Problem2141
#include<cstdio>
#include<algorithm>
using namespace std;
 
const int Maxn=20000+19;
struct node {int ID,A;} A[Maxn];
int C[Maxn];
int n,m,Ans,Q,L,R,pre,cur;
 
int cmp1(node A,node B) {return A.A<B.A;}
int cmp2(node A,node B) {return A.ID<B.ID;}
 
int Query(int x) {int Ans=0;while (x) Ans+=C[x],x-=x&-x;return Ans;}
void Add(int x) {while (x<=n) C[x]++,x+=x&-x;}
 
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&A[i].A),A[i].ID=i;
    sort(A+1,A+n+1,cmp1);
    for (int i=1;i<=n;i++) {cur=A[i].A;A[i].A=A[i-1].A+(pre!=cur);pre=cur;}
    sort(A+1,A+n+1,cmp2);
    for (int i=n;i;i--) Ans+=Query(A[i].A-1),Add(A[i].A);
    printf("%d\n",Ans);
    scanf("%d",&Q);
    while (Q--)
    {
        scanf("%d%d",&L,&R);
        if (L>R) swap(L,R);
        Ans-=(A[L].A>A[R].A);Ans+=(A[L].A<A[R].A);
        for (int i=L+1;i<R;i++) Ans-=(A[L].A>A[i].A),Ans+=(A[R].A>A[i].A);
        for (int i=L+1;i<R;i++) Ans-=(A[i].A>A[R].A),Ans+=(A[i].A>A[L].A);
        swap(A[L].A,A[R].A);
        printf("%d\n",Ans);
    }
}
Problem2141
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
 
const int Maxn=20000+19;
struct node {int ID,A;} A[Maxn];
int C[Maxn];
int n,m,Ans,Q,L,R,pre,cur;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
 
int cmp1(node A,node B) {return A.A<B.A;}
int cmp2(node A,node B) {return A.ID<B.ID;}
 
int Query(int x) {int Ans=0;while (x) Ans+=C[x],x-=x&-x;return Ans;}
void Add(int x) {while (x<=n) C[x]++,x+=x&-x;}
 
int main()
{
    read(n);
    for (int i=1;i<=n;i++) read(A[i].A),A[i].ID=i;
    sort(A+1,A+n+1,cmp1);
    for (int i=1;i<=n;i++) {cur=A[i].A;A[i].A=A[i-1].A+(pre!=cur);pre=cur;}
    sort(A+1,A+n+1,cmp2);
    for (int i=n;i;i--) Ans+=Query(A[i].A-1),Add(A[i].A);
    printf("%d\n",Ans);
    read(Q);
    while (Q--)
    {
        read(L),read(R);
        if (L>R) swap(L,R);
        Ans-=(A[L].A>A[R].A);Ans+=(A[L].A<A[R].A);
        for (int i=L+1;i<R;i++) Ans-=(A[L].A>A[i].A),Ans+=(A[R].A>A[i].A);
        for (int i=L+1;i<R;i++) Ans-=(A[i].A>A[R].A),Ans+=(A[i].A>A[L].A);
        swap(A[L].A,A[R].A);
        printf("%d\n",Ans);
    }
}
Problem2142
#include<cstdio>
#include<algorithm>
using namespace std;
 
const int oo=2147483647;
typedef long long LL;
int Mod,n,m,Ans=1,cnt,tmp,sum;
int w[7],p[11],c[11],A[11];
 
int Pow(int a,int b,int p)
{
    int res=1;
    for (;b;b>>=1,a=1LL*a*a%p) if (b&1) res=1LL*res*a%p;
    return res;
}
void ExEuclid(int a,int b,int &x,int &y)
{
    if (!b) {x=1;y=0;return;}
    ExEuclid(b,a%b,x,y);
    int tmp=x;x=y;y=tmp-a/b*y;
}
int calc(int n,int p,int c,int &cnt)
{
    if (!n) return 1;
    int P=Pow(p,c,oo),Ans=1;
    for (int i=1;i<P;i++) if (i%p!=0) Ans=1LL*Ans*i%P;
    Ans=Pow(Ans,n/P,P);
    for (int i=1;i<=n%P;i++) if (i%p!=0) Ans=1LL*Ans*i%P;
    cnt+=n/p;
    return 1LL*Ans*calc(n/p,p,c,cnt)%P;
}
int Solve(int n,int m,int p,int c)
{
    int c1=0,c2=0,A1,A2,A3,x,y,P=Pow(p,c,oo);
    A1=calc(n,p,c,c1);
    A2=calc(m,p,c,c2);A3=calc(n-m,p,c,c2);
    c1-=c2;
    ExEuclid(A2,P,x,y);if (x<0) x+=P;A1=1LL*A1*x%P;
    ExEuclid(A3,P,x,y);if (x<0) x+=P;A1=1LL*A1*x%P;
    return 1LL*A1*Pow(p,c1,P)%P;
}
int C(int n,int m)
{
    int Ans=0;
    for (int i=0;i<cnt;i++) A[i]=Solve(n,m,p[i],c[i]);
    for (int i=0;i<cnt;i++)
    {
        int P=Pow(p[i],c[i],oo),D=Mod/P,x,y;
        ExEuclid(D,P,x,y);if (x<0) x+=P;
        Ans=(1LL*D*x%Mod*A[i]+Ans)%Mod;
    }
    return Ans;
}
 
int main()
{
    scanf("%d%d%d",&Mod,&n,&m);
    for (int i=1;i<=m;i++) scanf("%d",&w[i]),sum+=w[i];
    if (sum>n) return puts("Impossible"),0;
     
    tmp=Mod;
    for (int i=2;i*i<=tmp;i++)
        if (tmp%i==0) 
        {
            p[cnt]=i;
            while (tmp%i==0) c[cnt]++,tmp/=i;
            cnt++;
        }
    if (tmp>1) p[cnt]=tmp,c[cnt++]=1;
     
    for (int i=1;i<=m;i++) Ans=1LL*Ans*C(n,w[i])%Mod,n-=w[i];
    printf("%d\n",Ans);
}
Problem2144
#include<cstdio>
#include<algorithm>

using namespace std;

struct Sta
{
	int a,b,c;
	bool operator != (const Sta& B) const {return a!=B.a||b!=B.b||c!=B.c;}
	
	void In()
	{
		scanf("%d%d%d",&a,&b,&c);
		if (c<b) swap(c,b);
		if (b<a) swap(b,a);
		if (c<b) swap(c,b);
	}
	int Dep()
	{
		Sta C=*this;
		int s1,s2,res=1;
		while ((s1=b-a)!=(s2=c-b))
			if (s1>s2) {int t=(s1-1)/s2;res+=t,c-=t*s2,b-=t*s2;}
				else {int t=(s2-1)/s1;res+=t,a+=t*s1,b+=t*s1;}
		return *this=C,res;
	}
} A,B,fx,fy;

Sta Fa(Sta A,int k)
{
	k=1<<k;
	int s1,s2;
	while ((s1=A.b-A.a)!=(s2=A.c-A.b)&&k)
		if (s1>s2) {int t=min((s1-1)/s2,k);k-=t,A.c-=t*s2,A.b-=t*s2;}
			else {int t=min((s2-1)/s1,k);k-=t,A.a+=t*s1,A.b+=t*s1;}
	return A;
}
int Query()
{
	if (A.Dep()>B.Dep()) swap(A,B);
	Sta x=A,y=B;
	for (int i=B.Dep()-A.Dep(),k=0;i;k++,i>>=1) if (i&1) B=Fa(B,k);
	if (!(A!=B)) return y.Dep()-x.Dep();
	for (int i=30;~i;i--) if ((fx=Fa(A,i))!=(fy=Fa(B,i))) A=fx,B=fy;
	return A=Fa(A,0),x.Dep()+y.Dep()-2*A.Dep();
}

int main()
{
	A.In(),B.In();
	fx=Fa(A,30),fy=Fa(B,30);
	if (fx!=fy) return puts("NO"),0;
	puts("YES");
	printf("%d\n",Query());
}
Problem2150
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;

const int Maxn=52*52,oo=(1<<30)-1;
struct Edge {int y,nxt;} E[Maxn*4*2];
int Last[Maxn],vis[Maxn*2],Link[Maxn*2];
int n,m,r,c,tot,s,t,cnt,time,Ans,sum;
char Map[52][52];

int ID(int x,int y) {return x*m+y+1;}
int check(int x,int y) {return x>=0&&x<n&&y>=0&&y<m&&Map[x][y]=='.';}
void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
int Hungary(int x)
{
	for (int i=Last[x];i!=-1;i=E[i].nxt)
	{
		int y=E[i].y;
		if (vis[y]!=time)
		{
			vis[y]=time;
			if (!Link[y]||Hungary(Link[y])) {Link[y]=x;return 1;}
		}
	}
	return 0;
}

int main()
{
	scanf("%d%d%d%d",&n,&m,&r,&c);tot=n*m;
	memset(Last,-1,sizeof(Last));
	for (int i=0;i<n;i++) scanf("%s",Map[i]);
	for (int i=0;i<n;i++)
		for (int j=0;j<m;j++)
			if (Map[i][j]=='.')
			{
				if (check(i+r,j+c)) Add_Edge(ID(i,j),ID(i+r,j+c)+tot);
				if (check(i+r,j-c)) Add_Edge(ID(i,j),ID(i+r,j-c)+tot);
				if (check(i+c,j+r)) Add_Edge(ID(i,j),ID(i+c,j+r)+tot);
				if (check(i+c,j-r)) Add_Edge(ID(i,j),ID(i+c,j-r)+tot);
			} else sum++;
	for (int i=1;i<=tot;i++) time++,Ans+=Hungary(i);
	printf("%d\n",tot-Ans-sum);
}
Problem2152
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=20000+19,oo=(1<<30)-1;
struct Edge {int y,z,nxt;} E[N*2];
int Last[N],S[N],vis[N],A[3];
int n,x,y,z,cnt,X,Y,Min,Cen,Fcen;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

void Find_Cen(int x,int Fa,int n)
{
	S[x]=1;int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa&&!vis[E[i].y])
			Find_Cen(E[i].y,x,n),S[x]+=S[E[i].y],res=max(res,S[E[i].y]);
	res=max(res,n-S[x]);
	if (res<Min) Min=res,Cen=x,Fcen=Fa;
}
void DFS(int x,int Fa,int tmp)
{
	A[tmp%3]++;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa&&!vis[E[i].y]) DFS(E[i].y,x,tmp+E[i].z);
}
int Calc(int x,int tmp)
{
	A[0]=A[1]=A[2]=0;DFS(x,-1,tmp);
	return A[0]*A[0]+A[1]*A[2]*2;
}
void Solve(int x,int n)
{
	Min=oo,Find_Cen(x,-1,n),x=Cen;
	X+=Calc(x,0);vis[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (!vis[E[i].y])
		{
			X-=Calc(E[i].y,E[i].z);
			Solve(E[i].y,E[i].y==Fcen?n-S[x]:S[E[i].y]);
		}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);
	for (int i=1;i<n;i++) scanf("%d%d%d",&x,&y,&z),Link(x,y,z);
	Solve(1,n);
	Y=n*n;int t=gcd(X,Y);
	printf("%d/%d\n",X/t,Y/t);
}
Problem2152
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=20000+19,oo=(1<<30)-1;
struct Edge {int y,z,nxt;} E[N*2];
int Last[N],S[N],vis[N],A[3];
int n,x,y,z,cnt,X,Y,Min,Cen,Fcen;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

void Find_Cen(int x,int Fa,int n)
{
	S[x]=1;int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa&&!vis[E[i].y])
			Find_Cen(E[i].y,x,n),S[x]+=S[E[i].y],res=max(res,S[E[i].y]);
	res=max(res,n-S[x]);
	if (res<Min) Min=res,Cen=x,Fcen=Fa;
}
void DFS(int x,int Fa,int tmp)
{
	A[tmp%3]++;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa&&!vis[E[i].y]) DFS(E[i].y,x,tmp+E[i].z);
}
int Calc(int x,int tmp)
{
	A[0]=A[1]=A[2]=0;DFS(x,-1,tmp);
	return A[0]*A[0]+A[1]*A[2]*2;
}
void Solve(int x,int n)
{
	Min=oo,Find_Cen(x,-1,n),x=Cen;
	X+=Calc(x,0);vis[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (!vis[E[i].y])
		{
			X-=Calc(E[i].y,E[i].z);
			Solve(E[i].y,E[i].y==Fcen?n-S[x]:S[E[i].y]);
		}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n);
	for (int i=1;i<n;i++) read(x),read(y),read(z),Link(x,y,z);
	Solve(1,n);
	Y=n*n;int t=gcd(X,Y);
	printf("%d/%d\n",X/t,Y/t);
}
Problem2152
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
  
const int N=20000+19,oo=(1<<30)-1;
struct Edge {int y,z,nxt;} E[N*2];
int Last[N],S[N],vis[N],A[3];
int n,x,y,z,cnt,X,Y,Min,Cen,Fcen;
  
void read(int &x)
{
    int c;
    while (!isdigit(c=getchar()));x=c-'0';
    while (isdigit(c=getchar())) x=x*10+c-'0';
}
int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
void Link(int x,int y,int z)
{
    E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
    E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}
  
void Find_Cen(int x,int Fa,int n)
{
    S[x]=1;int res=0;
    for (int i=Last[x];~i;i=E[i].nxt)
        if (E[i].y!=Fa&&!vis[E[i].y])
            Find_Cen(E[i].y,x,n),S[x]+=S[E[i].y],res=max(res,S[E[i].y]);
    res=max(res,n-S[x]);
    if (res<Min) Min=res,Cen=x,Fcen=Fa;
}
void DFS(int x,int Fa,int tmp)
{
    A[tmp%3]++;
    for (int i=Last[x];~i;i=E[i].nxt)
        if (E[i].y!=Fa&&!vis[E[i].y]) DFS(E[i].y,x,tmp+E[i].z);
}
int Calc(int x,int tmp)
{
    A[0]=A[1]=A[2]=0;DFS(x,-1,tmp);
    return A[0]*A[0]+A[1]*A[2]*2;
}
void Solve(int x,int n)
{
    Min=oo,Find_Cen(x,-1,n),x=Cen;
    if (~Fcen) S[Fcen]=n-S[x];
    X+=Calc(x,0);vis[x]=1;
    for (int i=Last[x];~i;i=E[i].nxt)
        if (!vis[E[i].y])
        {
            X-=Calc(E[i].y,E[i].z);
            Solve(E[i].y,S[E[i].y]);
        }
}
  
int main()
{
    memset(Last,-1,sizeof(Last));
    read(n);
    for (int i=1;i<n;i++) read(x),read(y),read(z),Link(x,y,z);
    Solve(1,n);
    Y=n*n;int t=gcd(X,Y);
    printf("%d/%d\n",X/t,Y/t);
}
Problem2154
#include<cstdio>
#include<algorithm>
using namespace std;

const int top=10000000,Maxn=top+19,Mod=20101009;
int vis[Maxn],p[Maxn],g[Maxn],cnt,n,m,Ans;

int main()
{
    g[1]=1;
    for (int i=2;i<=top;i++)
	{
	    if (!vis[i]) p[cnt++]=i,g[i]=1-i+Mod;
	    for (int j=0,_=top/i;j<cnt&&p[j]<=_;j++)
		{
		    vis[p[j]*i]=1;
		    if (i%p[j]==0) {g[p[j]*i]=g[i];break;}
			    else g[p[j]*i]=1LL*g[p[j]]*g[i]%Mod;
		}
	}
    for (int i=2;i<=top;i++) g[i]=(g[i-1]+1LL*g[i]*i%Mod)%Mod;
	scanf("%d%d",&n,&m);
	for (int L=1,R;L<=n&&L<=m;L=R+1)
	{
		R=min(n/(n/L),m/(m/L));
		(Ans+=1LL*(g[R]-g[L-1]+Mod)%Mod*
			(1LL*(n/L)*(n/L+1)/2LL%Mod)%Mod*
			(1LL*(m/L)*(m/L+1)/2LL%Mod)%Mod)%=Mod;
	}
	printf("%d\n",Ans);
}
Problem2154
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=1e7+19,Mod=20101009;
int vis[Maxn],p[Maxn],g[Maxn],cnt,n,m,Ans;

int main()
{
	scanf("%d%d",&n,&m);if (n>m) swap(n,m);
	g[1]=1;
	for (int i=2;i<=n;i++)
	{
		if (!vis[i]) p[cnt++]=i,g[i]=1-i+Mod;
		for (int j=0,_=n/i;j<cnt&&p[j]<=_;j++)
		{
			vis[p[j]*i]=1;
			if (i%p[j]==0) {g[p[j]*i]=g[i];break;}
				else g[p[j]*i]=1LL*g[p[j]]*g[i]%Mod;
		}
	}
	for (int i=2;i<=n;i++) g[i]=(g[i-1]+1LL*g[i]*i%Mod)%Mod;
	for (int L=1,R;L<=n;L=R+1)
	{
		R=min(n/(n/L),m/(m/L));
		(Ans+=1LL*(g[R]-g[L-1]+Mod)%Mod*
			(1LL*(n/L)*(n/L+1)/2LL%Mod)%Mod*
			(1LL*(m/L)*(m/L+1)/2LL%Mod)%Mod)%=Mod;
	}
	printf("%d\n",Ans);
}
Problem2154
#include <cstdio>
#include <algorithm>
using namespace std;
#define RXD 20101009
#define maxn 10000000
long long g[maxn+10], Ans;
int n, m, Mn[maxn+10], Prime[maxn/10], Cnt;
inline void Init(int n){
	g[1]=1;
	for(int i=2; i<=n; i++)
	{
		if(!Mn[i]) Prime[Mn[i]=++Cnt]=i, g[i]=1-i;
		for(int j=1; j<=Cnt && i*Prime[j]<=n; j++)
		{
			Mn[i*Prime[j]]=j;
			if(Mn[i]==j){ g[i*Prime[j]]=g[i]; break; }
			else g[i*Prime[j]]=g[i]-Prime[j]*g[i];
		}
	}
	for(int i=2; i<=n; i++) g[i]=(g[i]*i+g[i-1])%RXD;
}
int main(){
	scanf("%d%d", &n, &m);
	if(n>m) swap(n, m); Init(m);
	for (int L=1,R;L<=n;L=R+1)
	{
        R=min(n/(n/L),m/(m/L));
		(Ans+=(g[R]-g[L-1]+RXD)%RXD
		*(1LL*(n/L)*(n/L+1)/2LL%RXD)%RXD
		*(1LL*(m/L)*(m/L+1)/2LL%RXD)%RXD+RXD)%=RXD;
	}
	printf("%lld\n", Ans);
}
Problem2157
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
#define Calc \
		if (opt==1) res+=tmp;\
		if (opt==2) res=max(res,tmp);\
		if (opt==3) res=min(res,tmp);
using namespace std;

void read(int &x)
{
	int c,f;
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}

const int N=20000+19,oo=(1<<30)-1;
typedef int one[N];
struct Edge {int y,z,nxt;} E[N*2];
one Last,Son,Fa,Deep,S,ID,Top,A,B,num;
int Sum[N*4],Max[N*4],Min[N*4],Rev[N*4];
int n,x,y,z,cnt,tot,Q,t,v,Ql,Qr,tmp;
char opt[5];

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

void DFS_Find(int x)
{
	S[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x])
		{
			Fa[E[i].y]=x;Deep[E[i].y]=Deep[x]+1,B[E[i].y]=E[i].z,num[(i>>1)+1]=E[i].y;
			DFS_Find(E[i].y);
			S[x]+=S[E[i].y];if (S[E[i].y]>S[Son[x]]) Son[x]=E[i].y;
		}
}
void DFS_Con(int x,int anc)
{
	ID[x]=++tot,A[tot]=B[x],Top[x]=anc;
	if (Son[x]) DFS_Con(Son[x],anc);
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Son[x]&&E[i].y!=Fa[x]) DFS_Con(E[i].y,E[i].y);
}

void Setrev(int x)
{
	Rev[x]^=1,Sum[x]=-Sum[x];
	int t=Max[x];Max[x]=-Min[x];Min[x]=-t;
}
void Push_down(int x) {if (Rev[x]) Setrev(Lsn),Setrev(Rsn),Rev[x]=0;}
void Update(int x)
{
	Max[x]=max(Max[Lsn],Max[Rsn]);
	Min[x]=min(Min[Lsn],Min[Rsn]);
	Sum[x]=Sum[Lsn]+Sum[Rsn];
}
void Build(int x,int L,int R)
{
	if (L==R) {Max[x]=Min[x]=Sum[x]=A[L];return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	Update(x);
}
void Modify(int x,int L,int R)
{
	if (L==R) {Max[x]=Min[x]=Sum[x]=v;return;}
	Push_down(x);
	t<=Mid?Modify(Lsn,L,Mid):Modify(Rsn,Mid+1,R);
	Update(x);
}
int Query(int x,int L,int R,int opt)
{
	if (Ql<=L&&R<=Qr) return opt==1?Sum[x]:(opt==2?Max[x]:Min[x]);
	Push_down(x);
	int res=opt==1?0:(opt==2?-oo:oo);
	if (Ql<=Mid) {int tmp=Query(Lsn,L,Mid,opt);Calc;}
	if (Qr>Mid) {int tmp=Query(Rsn,Mid+1,R,opt);Calc;}
	return res;
}
void Change(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {Setrev(x);return;}
	Push_down(x);
	if (Ql<=Mid) Change(Lsn,L,Mid);
	if (Qr>Mid) Change(Rsn,Mid+1,R);
	Update(x);
}

void Solve(int x,int y,int opt)
{
	int a=Top[x],b=Top[y],res=opt==1?0:(opt==2?-oo:oo);
	while (a!=b)
	{
		if (Deep[a]>Deep[b]) swap(a,b),swap(x,y);
		Ql=ID[b],Qr=ID[y];
		if (opt==0) Change(1,1,n);else {tmp=Query(1,1,n,opt);Calc;}
		y=Fa[b],b=Top[y];
	}
	Ql=min(ID[x],ID[y])+1,Qr=max(ID[x],ID[y]);
	if (opt==0) Change(1,1,n);else {tmp=Query(1,1,n,opt);Calc;}
	if (opt) printf("%d\n",res);
}

int main()
{
	memset(Max,128,sizeof(Max));
	memset(Min,60,sizeof(Min));
	memset(Last,-1,sizeof(Last));

	read(n);
	For(i,1,n) read(x),read(y),read(z),Link(++x,++y,z);
	DFS_Find(1);
	DFS_Con(1,1);
	Build(1,1,n);

	read(Q);
	while (Q--)
	{
		scanf("%s",opt),read(x),read(y);
		if (opt[0]=='C') t=ID[num[x]],v=y,Modify(1,1,n);
			else Solve(++x,++y,opt[0]=='N'?0:(opt[0]=='S'?1:(opt[1]=='A'?2:3)));

	}
}
Problem2179
#include<cstdio>
#include<cctype>
#include<cmath>
#include<algorithm>
using namespace std;

const int N=60000*4;
const double Pi=acos(-1.0);
struct Comp
{
	double re,im;
	Comp() {}
	Comp(double r,double i) {re=r,im=i;}
} A[N],B[N],w[2][N];
int n,c,C[N],rev[N];char s[N];

Comp operator + (Comp A,Comp B) {return Comp(A.re+B.re,A.im+B.im);}
Comp operator - (Comp A,Comp B) {return Comp(A.re-B.re,A.im-B.im);}
Comp operator * (Comp A,Comp B) {return Comp(A.re*B.re-A.im*B.im,A.re*B.im+A.im*B.re);}

void FFT(Comp *A,int f)
{
	for (int i=0;i<n;i++) if (i<rev[i]) swap(A[i],A[rev[i]]);
	Comp x,y;
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=0,l=0;k<i;k++,l+=t)
				x=A[j+k],y=w[f][l]*A[j+k+i],A[j+k]=x+y,A[j+k+i]=x-y;
	if (f) for (int i=0;i<n;i++) A[i].re/=n;
}

int main()
{
	scanf("%d",&n);
	scanf("%s",s);for (int i=0;i<n;i++) A[i].re=s[n-i-1]-'0';
	scanf("%s",s);for (int i=0;i<n;i++) B[i].re=s[n-i-1]-'0';
	for (c=1;c<n;c<<=1);n=c<<1;
	for (int i=0;i<n;i++)
	{
		w[0][i]=w[1][i]=Comp(cos(2.*Pi*i/n),sin(2.*Pi*i/n));
		w[1][i].im=-w[0][i].im;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|(x&1);
	}
	
	FFT(A,0),FFT(B,0);
	for (int i=0;i<n;i++) A[i]=A[i]*B[i];
	FFT(A,1);
	
	for (int i=0;i<n;i++) C[i]=A[i].re+0.5;
	for (int i=0;i<n;i++) C[i+1]+=C[i]/10,C[i]%=10;
	while (n>1&&!C[n-1]) n--;
	for (int i=n-1;i>=0;i--) printf("%d",C[i]);puts("");
}
Problem2179
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=60000*4+19,P=998244353;
int A[N],B[N],W[2][N],rev[N];
int n,m,c;
char a[N],b[N];

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}

void NTT(int *A,int f)
{
	For(i,0,n) if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=j,l=0,x,y;k<j+i;k++,l+=t)
				x=A[k],y=1LL*W[f][l]*A[k+i]%P,A[k]=(x+y)%P,A[k+i]=(x-y+P)%P;
	if (f)
	{
		int In=Pow(n,P-2);
		For(i,0,n) A[i]=1LL*A[i]*In%P;
	}
}

int main()
{
	n=IN();
	scanf("%s%s",a,b);
	For(i,0,n) A[n-1-i]=a[i]-'0',B[n-1-i]=b[i]-'0';
	for (c=1;c<n;c<<=1);n=c<<1;
	int W0=Pow(3,(P-1)/n),I0=Pow(W0,P-2),Pw=1,Pi=1;
	For(i,0,n)
	{
		W[0][i]=Pw,W[1][i]=Pi,Pw=1LL*Pw*W0%P,Pi=1LL*Pi*I0%P;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|x&1;
	}
	NTT(A,0),NTT(B,0);
	For(i,0,n) A[i]=1LL*A[i]*B[i]%P;
	NTT(A,1);
	For(i,0,n) A[i+1]+=A[i]/10,A[i]%=10;
	while (n&&!A[n-1]) n--;
	for (int i=n-1;~i;i--) printf("%d",A[i]);puts("");
}
Problem2186
#include<cstdio>
using namespace std;

const int top=10000000,Maxn=top+19;
int Ans[Maxn],Fac[Maxn],vis[Maxn];
int Inv[Maxn/10],Prime[Maxn/10];
int t,r,cnt,c,n,m,tmp;

void exEuclid(int a,int b,int &x,int &y)
{
	if (!b) {x=1;y=0;return;}
	exEuclid(b,a%b,x,y);
	int tmp=x;x=y;y=tmp-a/b*y;
}

int main()
{
	scanf("%d%d",&t,&r);
	Fac[0]=1;for (int i=1;i<=top;i++) Fac[i]=1LL*Fac[i-1]*i%r;
	for (int i=2;i<=top;i++)
	{
		if (!vis[i]) 
		{
			Prime[cnt]=i;
			exEuclid(i,r,Inv[cnt],tmp);
			if (Inv[cnt]<0) Inv[cnt]+=r;cnt++;
		}
		for (int j=0;j<cnt&&Prime[j]*i<=top;j++)
		{
			vis[Prime[j]*i]=1;
			if (i%Prime[j]==0) break;
		}
	}
	Ans[1]=1;
	for (int i=2;i<=top;i++) 
	{
		Ans[i]=Ans[i-1];
		if (!vis[i]) Ans[i]=1LL*Ans[i]*(i-1)%r*Inv[c++]%r;
	}
	while (t--)
	{
		scanf("%d%d",&n,&m);
		printf("%d\n",1LL*Fac[n]*Ans[m]%r);
	}
}
Problem2186
#include<cstdio>
//#include<cmath>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int top=1e7,N=top+19;
int p[N],Ans[N],T,Mod,cnt,n,m,Phi;
bool vis[N];

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%Mod) if (b&1) res=1LL*res*a%Mod;
	return res;
}

int main()
{
	scanf("%d%d",&T,&Mod);//Phi=Mod;
//	for (int i=2,_=sqrt(Mod)+1;i<=_;i++) if (Mod%i==0) Phi=Phi/i*(i-1);
	vis[1]=1;
	For(i,2,top+1)
	{
		if (!vis[i]) p[cnt++]=i;
		for (int j=0;j<cnt&&p[j]*i<=top;j++)
		{
			vis[p[j]*i]=1;
			if (i%p[j]==0) break;
		}
	}
	Ans[0]=1;
	For(i,1,top+1)
	{
		Ans[i]=Ans[i-1];
		if (!vis[i]) Ans[i]=1LL*Ans[i]*(i-1)%Mod*Pow(i,Mod-2)%Mod;
	}
	p[0]=1;For(i,1,top+1) p[i]=1LL*p[i-1]*i%Mod;
	while (T--) scanf("%d%d",&n,&m),printf("%d\n",1LL*p[n]*Ans[m]%Mod);
}
Problem2190
#include<cstdio>
#include<cmath>
using namespace std;

const int Maxn=40000+19;
int phi[Maxn],p[Maxn],n,Ans;

int main()
{
	scanf("%d",&n);n--;
	if (!n) {printf("0\n");return 0;}
	for (int i=1;i<=n;i++) p[i]=1,phi[i]=i;
	for (int i=2;i<=n;i++)
		if (p[i])
		{
			phi[i]=i-1;
			for (int j=2*i;j<=n;j+=i) 
			{
				p[j]=0;
				phi[j]=phi[j]/i*(i-1);
			}
		}
	for (int i=2;i<=n;i++) Ans+=phi[i];
	printf("%d\n",Ans*2+3);
}
Problem2194
#include<cstdio>
#include<cctype>
#include<cmath>
#include<algorithm>
using namespace std;

const int N=100000*4+19;
const double Pi=acos(-1.0);
struct Comp
{
	double re,im;
	Comp() {}
	Comp(double r,double i) {re=r,im=i;}
} A[N],B[N],w[2][N];
int rev[N],n,m,x,y,c;

Comp operator + (Comp A,Comp B) {return Comp(A.re+B.re,A.im+B.im);}
Comp operator - (Comp A,Comp B) {return Comp(A.re-B.re,A.im-B.im);}
Comp operator * (Comp A,Comp B) {return Comp(A.re*B.re-A.im*B.im,A.re*B.im+A.im*B.re);}

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void FFT(Comp *A,int f)
{
	Comp x,y;
	for (int i=0;i<n;i++) if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=0,l=0;k<i;k++,l+=t)
				x=A[j+k],y=w[f][l]*A[j+k+i],A[j+k]=x+y,A[j+k+i]=x-y;
	if (f) for (int i=0;i<n;i++) A[i].re/=n;
}

int main()
{
	read(n);
	for (int i=0;i<n;i++) read(x),read(y),A[i].re=x,B[n-i-1].re=y;
	for (m=n,n=1;n<m;n<<=1);n<<=1;
	for (int i=0;i<n;i++)
	{
		w[0][i]=w[1][i]=Comp(cos(2.*Pi*i/n),sin(2.*Pi*i/n));
		w[1][i].im=-w[0][i].im;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|(x&1);
	}
	
	FFT(A,0);FFT(B,0);
	for (int i=0;i<n;i++) A[i]=A[i]*B[i];
	FFT(A,1);
	
	for (int i=0;i<m;i++) printf("%d\n",int(A[i+m-1].re+0.5));
}
Problem2208
#include<cstdio>
#include<cstring>
using namespace std;

const int Maxn=2000+19;
struct Edge {int y,nxt;} E[Maxn*2];
int A[Maxn][Maxn],vis[Maxn],Last[Maxn],Ans,n,cnt;
char s[Maxn];

inline void Link(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
inline void DFS(int x)
{
	Ans++;vis[x]=1;
	for (int i=Last[x];i!=-1;i=E[i].nxt) if (!vis[E[i].y]) DFS(E[i].y);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);
	for (int i=1;i<=n;i++) 
	{
		scanf("%s",s);
		for (int j=1;j<=n;j++) if (s[j-1]=='1') Link(i,j);
	}
	for (int i=1;i<=n;i++) 
	{
		for (int j=1;j<=n;j++) vis[j]=0;
		DFS(i);
	}
	printf("%d\n",Ans);
}
Problem2209
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';return x;
}
int Max(int a,int b,int c) {return max(max(a,b),c);}
int Min(int a,int b,int c) {return min(min(a,b),c);}

const int N=1e5+19,oo=(1<<30)-1;
int t;
struct node *null;
struct node
{
	int S,Sum,key,lb,ls,rb,rs,Rev,Flp;
	node *L,*R,*Fa;

	void Setrev() {if (this!=null) Rev^=1,swap(L,R),swap(lb,rb),swap(ls,rs);}
	void Setflp()
	{
		if (this==null) return;
		Flp^=1,key=-key,Sum=-Sum;
		t=lb,lb=-ls,ls=-t,t=rb,rb=-rs,rs=-t;
	}
	void Down()
	{
		if (Rev) L->Setrev(),R->Setrev(),Rev=0;
		if (Flp) L->Setflp(),R->Setflp(),Flp=0;
	}
	void Update()
	{
		if (this==null) return;
		S=L->S+R->S+1,Sum=L->Sum+R->Sum+key;
		lb=Max(L->lb,L->Sum+key,L->Sum+key+R->lb);
		ls=Min(L->ls,L->Sum+key,L->Sum+key+R->ls);
		rb=Max(R->rb,R->Sum+key,R->Sum+key+L->rb);
		rs=Min(R->rs,R->Sum+key,R->Sum+key+L->rs);
	}
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (z!=null) if (y==z->L) z->L=this;else z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (z!=null) if (y==z->L) z->L=this;else z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N],*rt;

void Splay(node *x,node *Aim)
{
	static node *S[N];int k=0;
	node *tmp=x;
	while (tmp->Fa!=Aim) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (x->Fa!=Aim)
	{
		node *y=x->Fa,*z=y->Fa;
		if (y->Fa!=Aim)
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
	if (Aim==null) rt=x;
}

node *Findkth(node *x,int k)
{
	x->Down();
	if (k==x->L->S+1) return x;
	return k<x->L->S+1?Findkth(x->L,k):Findkth(x->R,k-x->L->S-1);
}

int n,Q,opt,Ql,Qr;
char s[N];

int main()
{
	n=IN(),Q=IN();
	null=Nd,rt=Nd+n+2;
	Nd[n+1]=*null=(node){0,0,0,-oo,oo,-oo,oo,0,0,null,null,Nd+n};
	Nd[n+2]=(node){0,0,0,-oo,oo,-oo,oo,0,0,null,Nd+1,null};
	scanf("%s",s+1);
	For(i,1,n+1) t=(s[i]=='('?1:-1),Nd[i]=(node){1,t,t,t,t,t,t,0,0,null,Nd+i+1,Nd+i-1};
	Nd[1].Fa=Nd+n+2;
	for (int i=n;i;i--) Nd[i].Update();Nd[n+2].Update();
	Splay(Nd+n+1,null);
	while (Q--)
	{
		opt=IN(),Ql=IN(),Qr=IN();
		Splay(Findkth(rt,Ql),null);
		Splay(Findkth(rt,Qr+2),rt);
		node *x=rt->R->L;
		if (opt==0) printf("%d\n",(-min(x->ls,0)+1)/2+(max(x->rb,0)+1)/2);
		if (opt==1) x->Setflp();
		if (opt==2) x->Setrev();
	}
}
Problem2221
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define mp make_pair
#define pb push_back
#define fir first
#define sec second
#define Mid (L+R>>1)
#define Lsn (x<<1)
#define Rsn (x<<1|1)

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int len=200000;
inline char nc(){
	static char buf[len],*b=buf+len;
	if (b==buf+len) fread(buf,1,len,stdin),b=buf;
	return *b++;
}
ll IN(){
	int c,f;ll x;
	while (!isdigit(c=nc())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=nc())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}
void output(ll x){
	if (x>=10) output(x/10);
	putchar(x%10+'0');
}

const int N=500000+19;
const ll oo=1ll<<60;

int bg[N][50],sm[N][50];
ll val[N],A[N],B[N];
int n,Qc,Qx;

//单调栈
void calcbig(int x,int y){
	if (y>n) return;
	bg[x][++*bg[x]]=y;
	For(i,1,*sm[y]+1)
		if (val[sm[y][i]]>val[x]){
			calcbig(x,sm[y][i]);
			return;
		}
}
void calcsml(int x,int y){
	if (y>n) return;
	sm[x][++*sm[x]]=y;
	For(i,1,*bg[y]+1)
		if (val[bg[y][i]]<val[x]){
			calcsml(x,bg[y][i]);
			return;
		}
}
void Init_stack(){
	static int b[N],s[N],stk[N],top;
	val[n+1]=oo;
	stk[top=1]=n+1;
	for (int i=n;i;i--){
		while (val[stk[top]]<=val[i]) top--;
		b[i]=stk[top];stk[++top]=i;
	}
	val[n+1]=-oo;
	stk[top=1]=n+1;
	for (int i=n;i;i--){
		while (val[stk[top]]>=val[i]) top--;
		s[i]=stk[top];stk[++top]=i;
	}
	for (int i=n;i;i--){
		calcbig(i,b[i]);
		calcsml(i,s[i]);
	}
}

//BIT
ll mn[N];

void Update(int x,ll v){
	for (;x<=Qc;x+=x&-x){
		if (v<mn[x]) mn[x]=v;else break;
	}
}
ll Query(int x){
	ll res=oo;
	for (;x;x-=x&-x) res=min(res,mn[x]);
	return res;
}

struct QType{
	int l,r,id;
} Q[N],T[N],tmp[N];
int l[N],r[N],low[N],num[N];
int t,c;
ll Ans[N];

void Upd(int x,int y,ll v){
	if (low[y]<=Qc) Update(low[y],v);
}
void work(int x){
	For(i,1,*bg[x]+1) Upd(x,bg[x][i],val[bg[x][i]]-val[x]);
	For(i,1,*sm[x]+1) Upd(x,sm[x][i],val[x]-val[sm[x][i]]);
}
void sortQ(){
	static int cnt[N];
	For(i,1,Qc+1) cnt[Q[i].r]++;
	For(i,1,n+1) cnt[i]+=cnt[i-1];
	For(i,1,Qc+1) tmp[cnt[Q[i].r]--]=Q[i];
	For(i,1,Qc+1) Q[i]=tmp[i];
}
void sortT(){
	static int cnt[N];
	For(i,1,Qc+1) cnt[T[i].l]++;
	For(i,1,n+1) cnt[i]+=cnt[i-1];
	For(i,1,Qc+1) tmp[cnt[T[i].l]--]=T[i];
	For(i,1,Qc+1) T[i]=tmp[i];
}
void Init(){
	For(i,0,N) mn[i]=oo;
	sort(B+1,B+n+1);
	*B=unique(B+1,B+n+1)-B-1;
	For(i,1,n+1){
		A[i]=lower_bound(B+1,B+n+1,A[i])-B;
	}
	sortQ();
	For(i,1,Qc+1) num[Q[i].id]=i;
	t=1;
	For(i,1,n+1){
		while (t<=Qc&&Q[t].r<i) t++;
		low[i]=t;
	}
	sortT();
	c=Qc;
}

int main(){
	n=IN(),Qc=IN();
	For(i,1,n+1){
		A[i]=B[i]=val[i]=IN();
	}
	For(i,1,Qc+1){
		Q[i]=T[i]=(QType){IN(),IN(),i};
		Ans[i]=oo;
	}
	Init();
	Init_stack();
	for (int i=n;i;i--){
		work(i);
		for (;c&&T[c].l>=i;c--){
			Qx=num[T[c].id];
			Ans[T[c].id]=Query(Qx);
		}
	}
	For(i,1,Qc+1){
		output(Ans[i]);
		puts("");
	}
}
Problem2223
#include<cstdio>
#include<cctype>

#define Mid (L+R>>1)
using namespace std;

const int Maxn=300000+19;
typedef int Seg[10000000+19];
int rt[Maxn];Seg sum,Lsn,Rsn;
int n,Q,t,cnt,Ql,Qr,L,R,Ans,top;

int read()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	return x;
}
void out(int x) {if (!x) return;out(x/10);putchar(x%10+'0');}

void Build(int &x,int y,int L,int R)
{
	sum[x=++cnt]=sum[y]+1;
	if (L==R) return;
	Lsn[x]=Lsn[y];Rsn[x]=Rsn[y];
	t<=Mid?Build(Lsn[x],Lsn[y],L,Mid):Build(Rsn[x],Rsn[y],Mid+1,R);
}

int main()
{
	n=read(),top=read();
	for (int i=1;i<=n;i++) t=read(),Build(rt[i],rt[i-1],1,top);
	Q=read();
	while (Q--)
	{
		Ql=read(),Qr=read();
		int Tr=rt[Qr],Tl=rt[Ql-1];
		L=1,R=top,Ans=0;
		while (L<=R)
		{
			if (L==R) {Ans=L;break;}
			if (sum[Lsn[Tr]]-sum[Lsn[Tl]]>(Qr-Ql+1)/2)  R=Mid,Tl=Lsn[Tl],Tr=Lsn[Tr];else 
				if (sum[Rsn[Tr]]-sum[Rsn[Tl]]>(Qr-Ql+1)/2) L=Mid+1,Tl=Rsn[Tl],Tr=Rsn[Tr];
					else break;
		}
		if (!Ans) puts("no");else printf("yes "),out(Ans),puts("");
	}
}
Problem2226
#include<cstdio>
#include<cctype>
using namespace std;

const int top=1000000,Maxn=top+19;
bool vis[Maxn];long long g[Maxn];
int f[Maxn],p[Maxn],phi[Maxn];
int n,cnt,T;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	g[1]=phi[1]=1;
	for (int i=2;i<=top;i++)
	{
		if (!vis[i]) {p[cnt++]=i,f[i]=1,g[i]=1LL*i*(i-1)+1,phi[i]=i-1;}
		for (int j=0;j<cnt&&p[j]*i<=top;j++)
		{
			int t=p[j]*i;vis[t]=1;
			if (i%p[j]==0)
			{
				f[t]=f[i];phi[t]=phi[i]*p[j];
				if (f[i]!=1) g[t]=g[f[t]]*g[t/f[t]];else g[t]=g[i]+1LL*phi[t/f[t]]*t/f[t];
				break;
			} else {f[t]=i,g[t]=g[i]*g[p[j]],phi[t]=phi[i]*phi[p[j]];}
		}
	}
	g[1]=0;
	read(T);
	while (T--) read(n),printf("%lld\n",1LL*n*(g[n]-1)/2LL+n);
}
Problem2227
#include<cstdio>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int MaxL=80,Base=1000000;
struct Bigint
{
	int Len,s[MaxL];
	void Clear() {while (Len>1&&!s[Len-1]) Len--;}
	void operator *= (int B)
	{
		Len+=2;s[Len-1]=s[Len-2]=0;
		For(i,0,Len) s[i]*=B;
		For(i,0,Len) s[i+1]+=s[i]/Base,s[i]%=Base;
		Clear();
	}
	Bigint operator - (const Bigint& B)
	{
		Bigint C=*this;
		For(i,0,C.Len)
		{
			int b=(i<B.Len?B.s[i]:0);
			if (C.s[i]<b) C.s[i+1]--,C.s[i]+=Base;C.s[i]-=b;
		}
		C.Clear();return C;
	}
	void Print()
	{
		printf("%d",s[Len-1]);
		for (int i=Len-2;~i;i--) printf("%06d",s[i]);
	}
} a,b;

const int S=50,top=200,N=top+19;
int T,n,m,cnt,t,s;
int A[S],B[S],p[S],vis[N];

int main()
{
	for (int i=2;i<=top;i++)
		if (!vis[i])
		{
			p[cnt++]=i;
			for (int j=i;j<=top;j+=i) vis[j]=1;
		}
	for (scanf("%d",&T);T--;)
	{
		scanf("%d%d",&n,&m);t=m+1-n,s=m;
		if (n>m) {puts("0 1");continue;}
		For(i,0,cnt) A[i]=B[i]=0;
		a.Len=a.s[0]=b.Len=b.s[0]=1;
		For(i,0,cnt) {int x=m+1;while (x%p[i]==0) x/=p[i],A[i]++;}
		For(i,0,cnt) A[i]*=n-1;
		For(i,0,cnt) while (t%p[i]==0) t/=p[i],A[i]++;
		For(i,0,cnt) while (s%p[i]==0) s/=p[i],B[i]++;
		For(i,0,cnt) B[i]=B[i]*n;
		For(i,0,cnt) t=min(A[i],B[i]),A[i]-=t,B[i]-=t;
		For(i,0,cnt) For(j,0,A[i]) a*=p[i];
		For(i,0,cnt) For(j,0,B[i]) b*=p[i];
		a.Print();putchar(' ');b.Print();puts("");
	}
}
Problem2241
#include<cstdio>
using namespace std;

const int Maxn=100+19;
int A[Maxn][Maxn],B[Maxn][Maxn];
int n,m,Ans=1<<30,sum;

inline int check(int a,int b)
{
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) B[i][j]=A[i][j];
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			if (B[i][j]<0) return 0;
			if (i+a-1<=n&&j+b-1<=m)
			{
				int x=B[i][j];
				B[i][j]-=x,B[i][j+b]+=x,B[i+a][j]+=x,B[i+a][j+b]-=x;
			}
			if (B[i][j]>0) return 0;
		}
	return 1;
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) scanf("%d",&A[i][j]),sum+=A[i][j];
	for (int i=n;i;i--) for (int j=m;j;j--) A[i][j]-=A[i][j-1];
	for (int i=n;i;i--) for (int j=m;j;j--) A[i][j]-=A[i-1][j];
	for (int x=1;x<=n;x++)
		if (sum%x==0)
			for (int y=1;y<=m;y++)
				if (sum%(x*y)==0&&sum/(x*y)<Ans&&check(x,y)) Ans=sum/(x*y);
	printf("%d\n",Ans);
}
Problem2242
#include<cstdio>
#include<cmath>
#include<cstring>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int Mo=100007;
struct Hash
{
	int A[2*Mo],key[2*Mo],Last[2*Mo],nxt[2*Mo],cnt;
	void Clear()
	{
		memset(A,-1,sizeof(A));
		memset(nxt,-1,sizeof(nxt));cnt=Mo;
	}
	void Ins(int x,int k)
	{
		int t=x%Mo;
		if (A[t]==-1) A[t]=x,key[t]=k,Last[t]=t;else
			nxt[Last[t]]=cnt,A[cnt]=x,key[cnt]=k,Last[t]=cnt++;
	}
	int Qry(int x)
	{
		for (int i=x%Mo;~i;i=nxt[i]) if (A[i]==x) return key[i];
		return -1;
	}
} H;
int T,S,k,x,y,z,Mod;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%Mod) if (b&1) res=1LL*res*a%Mod;
	return res;
}
void BSGS()
{
	if (y==0) {puts(!z?"1":"Orz, I cannot find x!");return;}
	H.Clear();
	int S=sqrt(Mod)+1,Inv=Pow(Pow(y,S),Mod-2),t=1;
	For(i,0,S) {if (H.Qry(t)==-1) H.Ins(t,i);t=1LL*t*y%Mod;}
	For(i,0,S)
		if (~(t=H.Qry(z))) {printf("%d\n",i*S+t);return;}
			else z=1LL*z*Inv%Mod;
	puts("Orz, I cannot find x!");
}

int main()
{
	for (scanf("%d%d",&T,&k);T--;)
	{
		scanf("%d%d%d",&y,&z,&Mod);
		if (k==1) printf("%d\n",Pow(y,z));
		if (k==2)
		{
			x=1LL*z*Pow(y,Mod-2)%Mod;
			if (1LL*x*y%Mod==z%Mod) printf("%d\n",x);
				else puts("Orz, I cannot find x!");
		}
		if (k==3) y%=Mod,z%=Mod,BSGS();
	}
}
Problem2243
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int Maxn=1e5+19;
typedef int one[Maxn];
struct Ans {int Ans,L,R;};
one Last,size,deep,Fa,top,son,ID,_ID,A;
int nxt[Maxn*2],to[Maxn*2];
int Lc[Maxn*4],Rc[Maxn*4],Cnt[Maxn*4],Col[Maxn*4];
int n,Q,x,y,v,cnt,tot,Ql,Qr;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Build(int x,int L,int R)
{
	if (L==R) {Lc[x]=Rc[x]=A[_ID[L]];Cnt[x]=1;return;}
	Build(Lsn,L,Mid);
	Build(Rsn,Mid+1,R);
	Lc[x]=Lc[Lsn],Rc[x]=Rc[Rsn],Cnt[x]=Cnt[Lsn]+Cnt[Rsn]-(Rc[Lsn]==Lc[Rsn]);
}
void Paint(int x,int v) {Lc[x]=Rc[x]=v;Cnt[x]=1;Col[x]=v;}
void Push_down(int x,int L,int R)
{
	if (L==R||Col[x]==-1) return;
	Paint(Lsn,Col[x]);Paint(Rsn,Col[x]);Col[x]=-1;
}
void Update(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {Paint(x,v);return;}
	Push_down(x,L,R);
	if (Ql<=Mid) Update(Lsn,L,Mid);
	if (Qr>Mid) Update(Rsn,Mid+1,R);
	Lc[x]=Lc[Lsn],Rc[x]=Rc[Rsn],Cnt[x]=Cnt[Lsn]+Cnt[Rsn]-(Rc[Lsn]==Lc[Rsn]);
}
Ans Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {return (Ans){Cnt[x],Lc[x],Rc[x]};}
	Push_down(x,L,R);
	Ans tmp={0,-1,-1};
	if (Ql<=Mid&&Mid<Qr) 
	{
		Ans tL=Query(Lsn,L,Mid),tR=Query(Rsn,Mid+1,R);
		return (Ans){tL.Ans+tR.Ans-(tL.R==tR.L),tL.L,tR.R};
	}
	if (Ql<=Mid) return Query(Lsn,L,Mid);else return Query(Rsn,Mid+1,R);
}

void DFS_find(int x)
{
	size[x]=1;
	for (int i=Last[x];i!=-1;i=nxt[i])
		if (to[i]!=Fa[x])
		{
			Fa[to[i]]=x;deep[to[i]]=deep[x]+1;
			DFS_find(to[i]);
			if (size[to[i]]>size[son[x]]) son[x]=to[i];size[x]+=size[to[i]];
		}
}
void DFS_con(int x,int anc)
{
	ID[x]=++tot;top[x]=anc;_ID[tot]=x;
	if (son[x]) DFS_con(son[x],anc);
	for (int i=Last[x];i!=-1;i=nxt[i])
		if (to[i]!=Fa[x]&&to[i]!=son[x]) DFS_con(to[i],to[i]);
}
void Change()
{
	int a=top[x],b=top[y];
	while (a!=b)
	{
		if (deep[a]>deep[b]) swap(a,b),swap(x,y);
		Ql=ID[b],Qr=ID[y];
		Update(1,1,n);
		y=Fa[b];b=top[y];
	}
	Ql=min(ID[x],ID[y]);Qr=max(ID[x],ID[y]);
	Update(1,1,n);
}
int Count()
{
	int a=top[x],b=top[y];
	Ans Ax={0,-1,-1},Ay={0,-1,-1},tmp;
	while (a!=b)
	{
		if (deep[a]>deep[b])
		{
			Ql=ID[a],Qr=ID[x];tmp=Query(1,1,n);
			Ax.Ans=Ax.Ans+tmp.Ans-(tmp.R==Ax.L);
			Ax.L=tmp.L;
			x=Fa[a];a=top[x];
		} else
		{
			Ql=ID[b],Qr=ID[y];tmp=Query(1,1,n);
			Ay.Ans=Ay.Ans+tmp.Ans-(tmp.R==Ay.L);
			Ay.L=tmp.L;
			y=Fa[b];b=top[y];
		}
	}
	if (ID[x]<ID[y]) 
	{
		Ql=ID[x],Qr=ID[y];tmp=Query(1,1,n);
		return Ax.Ans+tmp.Ans+Ay.Ans-(Ax.L==tmp.L)-(Ay.L==tmp.R);
	} else
	{
		Ql=ID[y],Qr=ID[x];tmp=Query(1,1,n);
		return Ay.Ans+tmp.Ans+Ax.Ans-(Ay.L==tmp.L)-(Ax.L==tmp.R);
	}
}

int main()
{
	read(n),read(Q);
	memset(Last,-1,sizeof(Last));
	memset(Col,-1,sizeof(Col));
	for (int i=1;i<=n;i++) read(A[i]);
	for (int i=1;i<n;i++)
	{
		read(x),read(y);
		nxt[cnt]=Last[x];to[cnt]=y;Last[x]=cnt++;
		nxt[cnt]=Last[y];to[cnt]=x;Last[y]=cnt++;
	}
	DFS_find(1);
	DFS_con(1,1);
	Build(1,1,n);
	while (Q--)
	{
		while (!isalpha(c=getchar()));
		if (c=='C')
		{
			read(x),read(y),read(v);
			Change();
		} else
		{
			read(x),read(y);
			printf("%d\n",Count());
		}
	}
}
Problem2257
#include<cstdio>
#include<algorithm>
using namespace std;

int A[30000000+19],tot,n,k,x,cnt;

int main()
{
	scanf("%d%d",&n,&k);
	while (n--)
	{
		scanf("%d",&x);
		for (int i=1;i*i<=x;i++)
			if (x%i==0)
			{
				A[tot++]=i;
				if (i*i!=x) A[tot++]=x/i;
			}
	}
	sort(A,A+tot);
	for (int i=tot-1;~i;i--)
	{
		if (i&&A[i]==A[i+1]) cnt++;else cnt=1;
		if (cnt>=k) return printf("%d\n",A[i]),0;
	}
}
Problem2282
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=300000+19;
struct Edge {int y,z,nxt;} E[N*2];
int Last[N],Dis[N],Fa[N],Q[N],vis[N],Dia[N],f[N],g[N],h[N];
int n,S,T,top,cnt,Time,Max,fr,we,tot,Ans=(1<<30)-1,x,y,z;

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

void BFS(int S,int Time)
{
	fr=1,we=0;
	Q[1]=S;Fa[S]=-1;Dis[S]=0;vis[S]=Time;
	while (fr>we)
	{
		int x=Q[++we];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (vis[E[i].y]!=Time)
				vis[E[i].y]=Time,Fa[E[i].y]=x,Dis[E[i].y]=Dis[x]+E[i].z,Q[++fr]=E[i].y;
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),top=IN();
	For(i,1,n) x=IN(),y=IN(),z=IN(),Link(x,y,z);
	Dis[0]=-1;
	BFS(1,++Time);For(i,1,n+1) if (Dis[i]>Dis[S]) S=i;
	BFS(S,++Time);For(i,1,n+1) if (Dis[i]>Dis[T]) T=i;
	Time++;
	for (int i=T;;i=Fa[i])
	{
		Dia[++tot]=i;
		f[i]=Dis[i],g[i]=f[T]-f[i],vis[i]=Time;
		if (i==S) break;
	}
	For(i,1,tot+1)
	{
		int x=Dia[i];
		BFS(x,Time);For(j,1,fr+1) h[x]=max(h[x],Dis[Q[j]]);
	}
	for (int L=1,R=1,tmp=0;L<=tot;L++,R=max(L,R))
	{
		int x=Dia[L];
		while (R<tot&&f[x]-f[Dia[R+1]]<=top) tmp=max(tmp,h[Dia[R++]]);
		if (g[x]>=Ans) break;
		Ans=min(Ans,max(max(g[x],f[Dia[R]]),tmp));
	}
	printf("%d\n",Ans);
}
Problem2286
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=250000+19,oo=(1<<30)-1;
typedef long long LL;
struct Edge {int y,z,nxt;} E[N*2];
struct Edge2 {int y,nxt;} E2[N];
int Last[N],h[N*2],Deep[N],ID[N],Last2[N],is_h[N];
int Min[N][20],Fa[N][20];
int n,x,y,z,cnt,Q,m,tot,cnt2;

bool cmp(int a,int b) {return ID[a]<ID[b];}
void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}
void Add_Edge(int x,int y) {E2[cnt2]=(Edge2){y,Last2[x]};Last2[x]=cnt2++;}

void DFS(int x)
{
	ID[x]=++tot;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x][0])
			Fa[E[i].y][0]=x,
			Min[E[i].y][0]=E[i].z,
			Deep[E[i].y]=Deep[x]+1,DFS(E[i].y);
}
int LCA(int x,int y)
{
	if (Deep[x]>Deep[y]) swap(x,y);
	for (int i=Deep[y]-Deep[x],k=0;i;i>>=1,k++) if (i&1) y=Fa[y][k];
	if (x==y) return x;
	for (int i=17;i>=0;i--) if (Fa[x][i]!=Fa[y][i]) x=Fa[x][i],y=Fa[y][i];
	return Fa[x][0];
}
int Dis(int x,int y)
{
	int res=oo;
	if (Deep[x]>Deep[y]) swap(x,y);
	for (int i=Deep[y]-Deep[x],k=0;i;i>>=1,k++)
		if (i&1) res=min(res,Min[y][k]),y=Fa[y][k];
	return res;
}
LL DP(int x)
{
	LL Ans=0;
	for (int i=Last2[x];~i;i=E2[i].nxt)
		Ans+=min(is_h[E2[i].y]?oo:DP(E2[i].y),1LL*Dis(x,E2[i].y));
	return Ans;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	memset(Last2,-1,sizeof(Last2));
	n=IN();
	For(i,1,n) x=IN(),y=IN(),z=IN(),Link(x,y,z);

	DFS(1);
	For(x,1,18) For(i,1,n+1)
	{
		int t=Fa[i][x-1];
		Fa[i][x]=Fa[t][x-1],Min[i][x]=min(Min[i][x-1],Min[t][x-1]);
	}

	for (Q=IN();Q--;)
	{
		m=IN();
		For(i,1,m+1) h[i]=IN(),is_h[h[i]]=1;
		sort(h+1,h+m+1,cmp);
		For(i,1,m) h[m+i]=LCA(h[i],h[i+1]);h[m=2*m]=1;
		sort(h+1,h+m+1,cmp);
		m=unique(h+1,h+m+1)-h-1;
		cnt2=0;
		For(i,2,m+1) Add_Edge(LCA(h[i-1],h[i]),h[i]);
		printf("%lld\n",DP(1));
		For(i,1,m+1) Last2[h[i]]=-1,is_h[h[i]]=0;
	}
}
Problem2287
#include<cstdio>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=2000+19;
int f[N],g[N],A[N];
int n,m;

int main()
{
	scanf("%d%d",&n,&m);
	For(i,0,n) scanf("%d",&A[i]);
	f[0]=1;
	For(i,0,n) for (int j=m;j>=A[i];j--) (f[j]+=f[j-A[i]])%=10;
	For(i,0,n)
	{
		For(j,0,A[i]) g[j]=f[j];
		For(j,A[i],m+1) g[j]=(f[j]-g[j-A[i]]+10)%10;
		For(j,1,m+1) printf("%d",g[j]);puts("");
	}
}
Problem2292
#include<cstdio>
#include<cctype>
#include<cstring>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1e5+1e6+19;
struct Edge {int y,nxt;} E[N];
int Dis[N],Q[N],Last[N],n,m,t,cnt,x,y,z;

void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}

void BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[1]=0;
	int f=1,w=0;Q[1]=1;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	t=n=IN(),m=IN();
	For(i,0,m)
	{
		x=IN(),y=IN(),z=IN();
		if (z==1) Add_Edge(x,y);else t++,Add_Edge(x,t),Add_Edge(t,y);
	}
	BFS();
	printf("%d\n",Dis[n]);
}
Problem2295
#include<cstdio>
#include<cstring>

char s[100000+19],S[]="luvletter";
int T,Ans,n,c;

int main()
{
	for (scanf("%d\n",&T);T--;)
	{
		gets(s);
		n=strlen(s),Ans=0,c=0;
		for (int i=0;i<n;i++) if (s[i]==S[c]) {c++;if (c==9) Ans++,c=0;}
		printf("%d\n",Ans);
	}
}
Problem2299
#include<cstdio>
#include<cctype>
using namespace std;

int t,a,b,x,y,p,q;

int read()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	return x;
}

int exgcd(int a,int b,int &x,int &y)
{
	if (!b) return x=1,y=0,a;
	int Ans=exgcd(b,a%b,x,y);
	int tmp=x;x=y;y=tmp-a/b*y;
	return Ans;
}

int main()
{
	t=read();
	while (t--)
	{
		a=read(),b=read(),x=read(),y=read();
		if (!a&&!b) {puts(!x&&!y?"Y":"N");continue;}
		if (!a) {puts(x%b==0&&y%b==0?"Y":"N");continue;}
		if (!b) {puts(x%a==0&&y%a==0?"Y":"N");continue;}
		int gcd=exgcd(a,b,p,q);
		if (x%gcd||y%gcd) {puts("N");continue;}
		bool X=x/gcd&1,Y=y/gcd&1,P=p&1,Q=q&1,A=(a/gcd)&1,B=(b/gcd)&1;
		bool px=p&X,qx=q&X,py=p&Y,qy=q&Y;
		if (px==qy&&py==qx||
			(px^B)==qy&&(py^A)==qx||
			(px^B)==(qy^A)&&(py^A)==(qx^B)||
			px==(qy^A)&&py==(qx^B)) puts("Y");else puts("N");
	}
}
Problem2300
#include<set>
#include<cstdio>
#include<cmath>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Be begin()
#define Ed end()
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19;
struct Point
{
	int x,y;
	Point() {}
	Point(int _x,int _y) {x=_x,y=_y;}
	bool operator < (const Point& B) const {return x<B.x||x==B.x&&y<B.y;}
} A[N],B,C,D;
int Del[N],L,x,y,m,Q,tot;
typedef Point Vector;
set<Point> U;
double Ans,Out[N*2];
struct Event {int opt,x;} E[N*2];

Vector operator - (Point A,Point B) {return Vector(A.x-B.x,A.y-B.y);}
int Cross(Vector A,Vector B) {return A.x*B.y-A.y*B.x;}
int Cross(Point A,Point B,Point C) {return Cross(B-A,C-B);}
double Dis(Point A,Point B) {return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));}

void Ins(Point A)
{
	set<Point>::iterator It=U.lower_bound(A),x,y,L,R;R=It,L=--It;
	if (Cross(A,*R,*L)>0) return;
	Ans=Ans-Dis(*L,*R)+Dis(*L,A)+Dis(A,*R);
	for (x=L,y=--L;x!=U.Be&&Cross(*y,*x,A)>0;x=y--) Ans=Ans-Dis(*x,*y)-Dis(*x,A)+Dis(*y,A),U.erase(x);
	for (x=R,y=++R;y!=U.Ed&&Cross(A,*x,*y)>0;x=y++) Ans=Ans-Dis(*x,*y)-Dis(*x,A)+Dis(*y,A),U.erase(x);
	U.insert(A);
}

int main()
{
	L=IN(),x=IN(),y=IN();
	B=Point(0,0),C=Point(L,0),D=Point(x,y);
	U.insert(B),U.insert(C),U.insert(D),Ans=Dis(B,D)+Dis(C,D);
	m=IN();For(i,1,m+1) A[i].x=IN(),A[i].y=IN();
	Q=IN();For(i,1,Q+1) {E[i].opt=IN();if (E[i].opt==1) Del[E[i].x=IN()]=1;}
	For(i,1,m+1) if (!Del[i]) Ins(A[i]);
	for (int i=Q;i;i--) if (E[i].opt==1) Ins(A[E[i].x]);else Out[++tot]=Ans;
	for (int i=tot;i;i--) printf("%.2lf\n",Out[i]);
}
Problem2301
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int top=50000,N=top+19;
typedef long long LL;
int vis[N],p[N],mu[N],cnt;
int a,b,c,d,k,n;

LL Calc(int n,int m)
{
	LL res=0;
	n/=k,m/=k;
	if (n>m) swap(n,m);
	for (int L=1,R;L<=n;L=R+1)
	{
		R=min(n/(n/L),m/(m/L));
		res+=1LL*(mu[R]-mu[L-1])*(n/L)*(m/L);
	}
	return res;
}

int main()
{
	mu[1]=1;
	for (int i=2;i<=top;i++)
	{
		if (!vis[i]) {p[cnt++]=i,mu[i]=-1;}
		for (int j=0;j<cnt&&p[j]*i<=top;j++)
		{
			vis[p[j]*i]=1;
			if (i%p[j]==0) {mu[p[j]*i]=0;break;} else mu[p[j]*i]=-mu[i];
		}
	}
	For(i,1,top+1) mu[i]+=mu[i-1];
	for (n=IN();n--;)
	{
		a=IN(),b=IN(),c=IN(),d=IN(),k=IN();
		printf("%lld\n",Calc(b,d)-Calc(a-1,d)-Calc(b,c-1)+Calc(a-1,c-1));
	}
}
Problem2324
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=150*2+19,M=N*N*2,oo=(1<<30)-1;
struct Edge {int y,f,c,nxt;} E[M];
int Last[N],Dis[N],vis[N],Q[N*100],pre[N],A[151][151];
int cnt,n,m,Cost,k,S,T,x,y,z;

void Add_Edge(int x,int y,int f,int c)
{
	E[cnt]=(Edge){y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,-c,Last[y]};Last[y]=cnt++;
}

bool SPFA()
{
	memset(Dis,64,sizeof(Dis));Dis[S]=0;
	int f=1,w=0;Q[1]=S;pre[S]=-1;
	while (f>w)
	{
		int x=Q[++w];vis[x]=0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]>Dis[x]+E[i].c)
			{
				Dis[E[i].y]=Dis[x]+E[i].c;
				pre[E[i].y]=i;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
	}
	return Dis[T]<oo;
}
void Update()
{
	int Min=oo;
	for (int i=pre[T];~i;i=pre[E[i^1].y]) Min=min(Min,E[i].f);
	for (int i=pre[T];~i;i=pre[E[i^1].y]) E[i].f-=Min,E[i^1].f+=Min;
	Cost+=Min*Dis[T];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d%d",&n,&m,&k);
	S=n+n+1,T=S+1;
	Add_Edge(S,0,k,0);
	memset(A,60,sizeof(A));
	For(i,0,m) scanf("%d%d%d",&x,&y,&z),A[x][y]=A[y][x]=min(A[x][y],z);
	For(k,0,n+1) For(i,0,n+1) For(j,0,n+1)
		if (i>=k||j>=k) A[i][j]=min(A[i][j],A[i][k]+A[k][j]);
	For(i,1,n+1) Add_Edge(0,i+n,1,A[0][i]),Add_Edge(S,i,1,0),Add_Edge(i+n,T,1,0);
	For(i,1,n+1) For(j,i+1,n+1) Add_Edge(i,j+n,1,A[i][j]);
	while (SPFA()) Update();
	printf("%d\n",Cost);
}
Problem2325
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define U(x) if (x<0) x=-oo;
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=30000+19,oo=(1<<30)-1;
struct Edge {int y,nxt;} E[N*2];
typedef int one[N];
one Last,Sz,Fa,Top,Deep,son,ID,_ID;
struct node {int D0,D1,D2,D3,L0,L1,R0,R1;} S[N*4],Ans,t;
int n,m,cnt,tot,Qx,Ql,Qr,x,y;
char s[N][3],sn[3],opt[3];

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}

void DFS_Find(int x)
{
	Sz[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x])
		{
			Fa[E[i].y]=x,Deep[E[i].y]=Deep[x]+1,
			DFS_Find(E[i].y),
			Sz[x]+=Sz[E[i].y];if (Sz[E[i].y]>Sz[son[x]]) son[x]=E[i].y;
		}
}
void DFS_Con(int x,int anc)
{
	ID[x]=++tot;Top[x]=anc;_ID[tot]=x;
	if (son[x]) DFS_Con(son[x],anc);
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x]&&E[i].y!=son[x]) DFS_Con(E[i].y,E[i].y);
}
node operator + (node A,node B)
{
	node C;
	C.D0=max(A.D0+B.D0,A.D1+B.D2);U(C.D0);
	C.D1=max(A.D0+B.D1,A.D1+B.D3);U(C.D1);
	C.D2=max(A.D2+B.D0,A.D3+B.D2);U(C.D2);
	C.D3=max(A.D3+B.D3,A.D2+B.D1);U(C.D3);
	C.L0=max(A.L0,max(A.D0+B.L0,A.D1+B.L1));U(C.L0);
	C.L1=max(A.L1,max(A.D2+B.L0,A.D3+B.L1));U(C.L1);
	C.R0=max(B.R0,max(B.D0+A.R0,B.D2+A.R1));U(C.R0);
	C.R1=max(B.R1,max(B.D1+A.R0,B.D3+A.R1));U(C.R1);
	return C;
}
inline void New(int x,char *s)
{
	S[x].D0=(s[0]=='.'?1:-oo);
	S[x].D3=(s[1]=='.'?1:-oo);
	S[x].L0=S[x].R0=(s[0]=='.'?(s[1]=='.'?2:1):-oo);
	S[x].L1=S[x].R1=(s[1]=='.'?(s[0]=='.'?2:1):-oo);
	S[x].D1=S[x].D2=(s[0]=='.'&&s[1]=='.'?2:-oo);
}
void Build(int x,int L,int R)
{
	if (L==R) {New(x,s[_ID[L]]);return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
void Update(int x,int L,int R)
{
	if (L==R) {New(x,s[_ID[L]]);return;}
	Qx<=Mid?Update(Lsn,L,Mid):Update(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
node Count(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return S[x];
	if (Qr<=Mid) return Count(Lsn,L,Mid);
	if (Ql>Mid) return Count(Rsn,Mid+1,R);
	return Count(Lsn,L,Mid)+Count(Rsn,Mid+1,R);
}
int Query(int x,int y)
{
	if (s[x][0]=='#'&&s[x][1]=='#') return 0;
	int a=Top[x],b=Top[y],fx=0,fy=0;
	node Ax,Ay;
	while (a!=b)
		if (Deep[a]<Deep[b])
			Ql=ID[b],Qr=ID[y],t=Count(1,1,n),Ay=fy?t+Ay:t,y=Fa[b],b=Top[y],fy=1;else
			Ql=ID[a],Qr=ID[x],t=Count(1,1,n),Ax=fx?t+Ax:t,x=Fa[a],a=Top[x],fx=1;
	if (Deep[x]<Deep[y])
	{
		if (fx) swap(Ax.D1,Ax.D2),swap(Ax.L0,Ax.R0),swap(Ax.L1,Ax.R1);
		Ql=ID[x],Qr=ID[y],t=Count(1,1,n);
		if (fx&&fy) Ans=Ax+t+Ay;else
		if (fx) Ans=Ax+t;else if (fy) Ans=t+Ay;else Ans=t;
		return max(Ans.L0,Ans.L1);
	} else
	{
		if (fy) swap(Ay.D1,Ay.D2),swap(Ay.L0,Ay.R0),swap(Ay.L1,Ay.R1);
		Ql=ID[y],Qr=ID[x],t=Count(1,1,n);
		if (fx&&fy) Ans=Ay+t+Ax;else
		if (fx) Ans=t+Ax;else if (fy) Ans=Ay+t;else Ans=t;
		return max(Ans.R0,Ans.R1);
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,n) Link(IN(),IN());
	For(i,1,n+1) scanf("%s",s[i]);
	DFS_Find(1),DFS_Con(1,1);
	Build(1,1,n);
	while (m--)
	{
		scanf("%s",opt);
		if (opt[0]=='C') x=IN(),Qx=ID[x],scanf("%s",s[x]),Update(1,1,n);
			else x=IN(),y=IN(),printf("%d\n",Query(x,y));
	}
}
Problem2325
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define U(x) if (x<0) x=-oo;
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=30000+19,oo=(1<<30)-1;
struct Edge {int y,nxt;} E[N*2];
typedef int one[N];
one Last,Sz,Fa,Top,Deep,son,ID,_ID;
struct node {int D0,D1,D2,D3,L0,L1,R0,R1;} S[N*4],Ans,t;
int n,m,cnt,tot,Qx,Ql,Qr,x,y;
char s[N][3],sn[3],opt[3];

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}

void DFS_Find(int x)
{
	Sz[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x])
		{
			Fa[E[i].y]=x,Deep[E[i].y]=Deep[x]+1,
			DFS_Find(E[i].y),
			Sz[x]+=Sz[E[i].y];if (Sz[E[i].y]>Sz[son[x]]) son[x]=E[i].y;
		}
}
void DFS_Con(int x,int anc)
{
	ID[x]=++tot;Top[x]=anc;_ID[tot]=x;
	if (son[x]) DFS_Con(son[x],anc);
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x]&&E[i].y!=son[x]) DFS_Con(E[i].y,E[i].y);
}
node operator + (node A,node B)
{
	node C;
	C.D0=max(A.D0+B.D0,A.D1+B.D2);U(C.D0);
	C.D1=max(A.D0+B.D1,A.D1+B.D3);U(C.D1);
	C.D2=max(A.D2+B.D0,A.D3+B.D2);U(C.D2);
	C.D3=max(A.D3+B.D3,A.D2+B.D1);U(C.D3);
	C.L0=max(A.L0,max(A.D0+B.L0,A.D1+B.L1));U(C.L0);
	C.L1=max(A.L1,max(A.D2+B.L0,A.D3+B.L1));U(C.L1);
	C.R0=max(B.R0,max(B.D0+A.R0,B.D2+A.R1));U(C.R0);
	C.R1=max(B.R1,max(B.D1+A.R0,B.D3+A.R1));U(C.R1);
	return C;
}
inline void New(int x,char *s)
{
	S[x].D0=(s[0]=='.'?1:-oo);
	S[x].D3=(s[1]=='.'?1:-oo);
	S[x].L0=S[x].R0=(s[0]=='.'?(s[1]=='.'?2:1):-oo);
	S[x].L1=S[x].R1=(s[1]=='.'?(s[0]=='.'?2:1):-oo);
	S[x].D1=S[x].D2=(s[0]=='.'&&s[1]=='.'?2:-oo);
}
void Build(int x,int L,int R)
{
	if (L==R) {New(x,s[_ID[L]]);return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
void Update(int x,int L,int R)
{
	if (L==R) {New(x,s[_ID[L]]);return;}
	Qx<=Mid?Update(Lsn,L,Mid):Update(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
node Count(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return S[x];
	if (Qr<=Mid) return Count(Lsn,L,Mid);
	if (Ql>Mid) return Count(Rsn,Mid+1,R);
	return Count(Lsn,L,Mid)+Count(Rsn,Mid+1,R);
}
int Query(int x,int y)
{
	if (s[x][0]=='#'&&s[x][1]=='#') return 0;
	int a=Top[x],b=Top[y],fx=0,fy=0,f=0;
	node Ax,Ay;
	while (a!=b)
		if (Deep[a]<Deep[b])
			Ql=ID[b],Qr=ID[y],t=Count(1,1,n),Ay=fy?t+Ay:t,y=Fa[b],b=Top[y],fy=1;else
			Ql=ID[a],Qr=ID[x],t=Count(1,1,n),Ax=fx?t+Ax:t,x=Fa[a],a=Top[x],fx=1;
	if (Deep[x]>Deep[y]) swap(Ax,Ay),swap(fx,fy),swap(x,y),f=1;
	if (fx) swap(Ax.D1,Ax.D2),swap(Ax.L0,Ax.R0),swap(Ax.L1,Ax.R1);
	Ql=ID[x],Qr=ID[y],t=Count(1,1,n);
	if (fx&&fy) Ans=Ax+t+Ay;else
	if (fx) Ans=Ax+t;else if (fy) Ans=t+Ay;else Ans=t;
	return f?max(Ans.R0,Ans.R1):max(Ans.L0,Ans.L1);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,n) Link(IN(),IN());
	For(i,1,n+1) scanf("%s",s[i]);
	DFS_Find(1),DFS_Con(1,1);
	Build(1,1,n);
	while (m--)
	{
		scanf("%s",opt);
		if (opt[0]=='C') x=IN(),Qx=ID[x],scanf("%s",s[x]),Update(1,1,n);
			else x=IN(),y=IN(),printf("%d\n",Query(x,y));
	}
}
Problem2326
#include<cstdio>
using namespace std;

typedef long long LL;
struct Matrix {int n,m,s[3][3];} A,B;
LL n;int Mod;

Matrix operator * (Matrix A,Matrix B)
{
	Matrix C;C.n=A.n,C.m=B.m;
	for (int i=0;i<C.n;i++)
		for (int j=0;j<C.m;j++)
		{
			C.s[i][j]=0;
			for (int k=0;k<A.m;k++) (C.s[i][j]+=1LL*A.s[i][k]*B.s[k][j]%Mod)%=Mod;
		}
	return C;
}
Matrix Pow(Matrix A,LL b)
{
	Matrix res;
	res.n=res.m=3;
	for (int i=0;i<3;i++) for (int j=0;j<3;j++) res.s[i][j]=(i==j);
	for (;b;b>>=1,A=A*A) if (b&1) res=res*A;
	return res;
}

int main()
{
	scanf("%lld%d",&n,&Mod);
	A.n=1,A.m=3;
	A.s[0][0]=0,A.s[0][1]=A.s[0][2]=1;
	B.n=B.m=3;
	B.s[0][1]=B.s[0][2]=B.s[1][2]=B.s[2][0]=0;
	B.s[1][0]=B.s[1][1]=B.s[2][1]=B.s[2][2]=1;
	for (LL x=9;;x=x*10+9)
	{
		B.s[0][0]=(x+1)%Mod;
		if (x<=n) A=A*Pow(B,x-(x/10LL));
		if (x>(n-9)/10.) {B.s[0][0]=(x*10+10)%Mod,A=A*Pow(B,n-x);break;}
	}
	printf("%d\n",A.s[0][0]);
}
Problem2329
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19,oo=(1<<30)-1;

int n,Q,t,Ql,Qr;
char s[N],opt[10],tar[3];

struct node *null;
struct node
{
	int S,Sum,key,lb,ls,rb,rs,Rev,Flp,Set;
	node *L,*R,*Fa;

	void Setrev() {if (this!=null) Rev^=1,swap(L,R),swap(lb,rb),swap(ls,rs);}
	void Setset(int v)
	{
		if (this==null) return;
		key=Set=v,Sum=v*S,Rev=Flp=0;
		lb=rb=v>0?S:-1,ls=rs=v<0?-S:1;
	}
	void Setflp()
	{
		if (this==null) return;
		Flp^=1,key=-key,Sum=-Sum,
		t=lb,lb=-ls,ls=-t,t=rb,rb=-rs,rs=-t;
	}
	void Down()
	{
		if (Set) L->Setset(Set),R->Setset(Set),Set=0;
		if (Rev) L->Setrev(),R->Setrev(),Rev=0;
		if (Flp) L->Setflp(),R->Setflp(),Flp=0;
	}
	void Update()
	{
		if (this==null) return;
		S=L->S+R->S+1,Sum=L->Sum+R->Sum+key;
		lb=max(L->lb,L->Sum+max(key,key+R->lb));
		ls=min(L->ls,L->Sum+min(key,key+R->ls));
		rb=max(R->rb,R->Sum+max(key,key+L->rb));
		rs=min(R->rs,R->Sum+min(key,key+L->rs));
	}
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (z->L==y) z->L=this;else z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (z->L==y) z->L=this;else z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N],*rt;

void Splay(node *x,node *Aim)
{
	static node *S[N];
	node *tmp=x;int k=0;
	while (tmp->Fa!=Aim) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (x->Fa!=Aim)
	{
		node *y=x->Fa,*z=y->Fa;
		if (y->Fa!=Aim)
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
	if (Aim==null) rt=x;
}

node *Findkth(node *x,int k)
{
	x->Down();
	if (x->L->S+1==k) return x;
	return k<x->L->S+1?Findkth(x->L,k):Findkth(x->R,k-x->L->S-1);
}
node *Build(int L,int R)
{
	if (L>R) return null;
	node *x=Nd+Mid;t=s[Mid]=='('?1:s[Mid]==')'?-1:0;
	*x=(node){1,t,t,t,t,t,t,0,0,0,null,null,null};
	x->L=Build(L,Mid-1),x->R=Build(Mid+1,R);
	if (x->L!=null) x->L->Fa=x;
	if (x->R!=null) x->R->Fa=x;
	return x->Update(),x;
}

int main()
{
	n=IN(),Q=IN();
	scanf("%s",s+1);
	null=Nd+n+2;
	rt=Build(0,n+1);
	while (Q--)
	{
		scanf("%s",opt);
		Ql=IN(),Qr=IN();
		Splay(Findkth(rt,Ql),null);
		Splay(Findkth(rt,Qr+2),rt);
		node *x=rt->R->L;
		if (opt[0]=='R') scanf("%s",tar),x->Setset(tar[0]=='('?1:-1);
		if (opt[0]=='Q') printf("%d\n",(-min(x->ls,0)+1)/2+(max(x->rb,0)+1)/2);
		if (opt[0]=='S') x->Setrev();
		if (opt[0]=='I') x->Setflp();
	}
}
Problem2330
#include<queue>
#include<cstdio>
#include<cstring>
#include<cctype>
using namespace std;
 
const int Maxn=100000+19;
typedef long long LL;
struct Edge {int x,y;LL Dis;int nxt;} E[Maxn<<2];
int n,k,c,x,y,ch,E_cnt,cnt[Maxn],inQ[Maxn],Last[Maxn];
LL Dis[Maxn];
queue<int> Q;
 
inline void Read(int &x)
{
	while (!isdigit(ch=getchar()));
	x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
}
inline void Add_Edge(int x,int y,LL Dis)
{
    E[E_cnt]=(Edge){x,y,Dis,Last[x]};
    Last[x]=E_cnt++;
}
inline LL SPFA()
{
    while (!Q.empty())
    {
        int x=Q.front();Q.pop();
        inQ[x]=0;
        for (int i=Last[x];i^-1;i=E[i].nxt)
        {
            int y=E[i].y;
            if (Dis[x]+E[i].Dis>Dis[y])
            {
                Dis[y]=Dis[x]+E[i].Dis;
                if (!inQ[y]) 
                {
                    inQ[y]=1;Q.push(y);
                    if (++cnt[y]>=n) return -1;
                }
            }
        }
    }
    LL Min=(1LL<<60)-1,Ans=0LL;
    for (int i=1;i<=n;i++) Min=min(Min,Dis[i]);
    for (int i=1;i<=n;i++) Dis[i]+=1-Min;
    for (int i=1;i<=n;i++) Ans+=Dis[i];
	return Ans;
}
 
int main()
{
    memset(Last,-1,sizeof(Last));
    scanf("%d%d",&n,&k);
    for (int i=0;i<k;i++)
    {
        Read(c);Read(x);Read(y);
        switch (c)
        {
            case 1:{Add_Edge(x,y,0),Add_Edge(y,x,0);break;}
            case 2:
			{
				if (x==y) {printf("-1\n");return 0;}
				Add_Edge(x,y,1);break;
			}
            case 3:{Add_Edge(y,x,0);break;}
            case 4:
			{
				if (x==y) {printf("-1\n");return 0;}
				Add_Edge(y,x,1);break;
			}
            case 5:Add_Edge(x,y,0);
        }
    }
    for (int i=1;i<=n;i++) Q.push(i),Dis[i]=0,inQ[i]=1;
    printf("%lld\n",SPFA());
}
Problem2333
//拆掉一个点再合并的时候应该跟rt[x]而不是Fa[x]合并 
#include<set>
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c,f;
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}

const int N=300000+19;
int Fa[N],n,D,w,x,y,Q;
multiset<int> S;
char s,t,opt[5];

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}
inline void Erase(int v) {S.erase(S.find(v));}

struct node *null;
struct node
{
	node *Fa,*L,*R;
	int key,Add,npl;
	
	void SetAdd(int v) {Add+=v,key+=v;}
	void Down() {if (Add) L->SetAdd(Add),R->SetAdd(Add),Add=0;}
	void Update() {if (this!=null) npl=R->npl+1;}
} Nd[N],*rt[N];

node *Merge(node *A,node *B)
{
	if (A==null) return B;
	if (B==null) return A;
	if (A->key<B->key) swap(A,B);
	A->Down();
	A->R=Merge(A->R,B),A->R->Fa=A;
	if (A->R->npl>A->L->npl) swap(A->L,A->R);
	return A->Update(),A;
}
void All_Down(node *x)
{
	static node *St[N];int k=0;
	while (x!=null) St[++k]=x,x=x->Fa;
	while (k) St[k--]->Down();
}

void U(int x,int y)
{
	x=Getf(x),y=Getf(y);
	if (x!=y)
	{
		Fa[x]=y;
		node *k=Merge(rt[x],rt[y]);
		if (k==rt[x]) Erase(rt[y]->key);else Erase(rt[x]->key);
		rt[y]=k;
	}
}
void A1(node *x,int w)
{
	int Fx=Getf(x-Nd);
	Erase(rt[Fx]->key);

	All_Down(x);x->key+=w;
	if (x->Fa->L==x) x->Fa->L=null;else x->Fa->R=null;
	node *t=Merge(x->L,x->R);
	x->L=x->R=null;
	rt[Fx]=Merge(t,rt[Fx]==x?x:Merge(x,rt[Fx]));
	rt[Fx]->Fa=null;

	S.insert(rt[Fx]->key);
}
void A2(int x,int w)
{
	Erase(rt[x=Getf(x)]->key),rt[x]->SetAdd(w),S.insert(rt[x]->key);
}

int main()
{
	null=Nd;
	read(n);
	For(i,0,n+1) Nd[i]=(node){null,null,null,0,0,0};
	null->npl=-1;
	For(i,1,n+1) Fa[i]=i,read(Nd[i].key),S.insert(Nd[i].key),rt[i]=Nd+i;
	read(Q);
	while (Q--)
	{
		scanf("%s",opt);
		s=opt[0],t=opt[1];
		if (s=='U') read(x),read(y),U(x,y);
		if (s=='A')
		{
			if (t!='3') read(x);read(w);
			if (t=='1') A1(Nd+x,w);else if (t=='2') A2(x,w);else D+=w;
		}
		if (s=='F')
		{
			if (t!='3') read(x);
			if (t=='1') All_Down(Nd+x),printf("%d\n",(Nd+x)->key+D);
			if (t=='2') printf("%d\n",rt[Getf(x)]->key+D);
			if (t=='3') printf("%d\n",*(--S.end())+D);
		}
	}
}
Problem2337
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=100+19,M=10000+19;
struct Edge {int y,z,nxt;} E[M*2];
int Last[N],Out[N];
int n,m,cnt,x,y,z;
double Ans,A[N][N];

void Add_Edge(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;Out[x]++;
}

double Calc(int a)
{
	For(i,1,n+1) For(j,1,n+2) A[i][j]=0.0;
	For(x,1,n)
	{
		A[x][x]=1.0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].z>>a&1) A[x][E[i].y]+=1.0/Out[x],A[x][n+1]+=1.0/Out[x];
				else A[x][E[i].y]-=1.0/Out[x];
	}
	A[n][n]=1.0;
	For(i,1,n+1)
	{
		int r=i;
		For(j,i+1,n+1) if (fabs(A[j][i])>fabs(A[r][i])) r=j;
		if (r!=i) For(j,i,n+2) swap(A[i][j],A[r][j]);
		double x=A[i][i];For(j,i,n+2) A[i][j]/=x;
		For(j,1,n+1) if (i!=j)
		{
			double x=A[j][i];
			For(k,i,n+2) A[j][k]-=x*A[i][k];
		}
	}
	return A[1][n+1];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	For(i,0,m)
	{
		scanf("%d%d%d",&x,&y,&z);
		Add_Edge(x,y,z);
		if (x!=y) Add_Edge(y,x,z);
	}
	For(i,0,31) Ans+=Calc(i)*(1<<i);
	printf("%.3lf\n",Ans);
}
Problem2338
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=1500+19;
typedef long long LL;
struct Point 
{
	int x,y;
	Point() {}
	Point(int _x,int _y):x(_x),y(_y){}
	bool operator == (const Point& B) const {return x==B.x&&y==B.y;}
} P[Maxn];
struct Line
{
	Point *A,*B;
	Point Mid;LL Len;
	bool operator < (const Line& B) const 
	{
		if (Len!=B.Len) return Len<B.Len;
		return Mid.x!=B.Mid.x?Mid.x<B.Mid.x:Mid.y<B.Mid.y;
	}
} L[Maxn*Maxn];
typedef Point Vector;
int n,tot;LL Ans;

LL sqr(LL x) {return 1LL*x*x;}
LL Abs(LL x) {return x>0?x:-x;}
Vector operator - (Point A,Point B) {return Vector(A.x-B.x,A.y-B.y);}
LL operator * (Vector A,Vector B) {return 1LL*A.x*B.y-1LL*A.y*B.x;}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d%d",&P[i].x,&P[i].y);
	for (int i=0;i<n;i++)
		for (int j=0;j<i;j++)
		{
			L[tot].A=&P[i];L[tot].B=&P[j];
			L[tot].Mid=Point(P[i].x+P[j].x,P[i].y+P[j].y);
			L[tot].Len=1LL*sqr(P[i].x-P[j].x)+1LL*sqr(P[i].y-P[j].y);
			tot++;
		}
	sort(L,L+tot);
	for (int i=0;i<tot;i++)
		for (int j=i-1;j>=0&&L[i].Len==L[j].Len&&L[i].Mid==L[j].Mid;j--)
			Ans=max(Ans,Abs((*(L[i].A)-*(L[j].A))*(*(L[i].B)-*(L[j].A))));
	printf("%lld\n",Ans);
}
Problem2342
#include<set>
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=500000+19;
struct node
{
	int x,P;
	bool operator < (const node& B) const {return x-P<B.x-B.P;}
} A[N];
set<int> S;
int P[N],n,c,Ans;
char s[N];

void Manacher()
{
	s[0]='#';
	int Max=0,ID=0;
	For(i,1,n+1)
	{
		if (Max>i) P[i]=min(Max-i,P[2*ID-i]);else P[i]=0;
		while (s[i+P[i]+1]==s[i-P[i]]) P[i]++;
		if (i+P[i]>Max) Max=i+P[i],ID=i;
	}
}

int main()
{
	scanf("%d%s",&n,s+1);
	Manacher();
	For(i,1,n+1) A[i]=(node){i,P[i]};
	sort(A+1,A+n+1);
	For(x,1,n+1)
	{
		while (c<=n&&A[c].x-A[c].P<=x) S.insert(A[c++].x);
		set<int>::iterator it=S.upper_bound(x+P[x]/2);
		if (it!=S.begin()) Ans=max(Ans,(*--it-x)*4);
	}
	printf("%d\n",Ans);
}
Problem2375
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1000000+19;
int Fa[N],C[N],n,m,p,q;

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}

int main()
{
	scanf("%d%d%d%d",&n,&m,&p,&q);
	For(i,1,n+2) Fa[i]=i;
	for (;m;m--)
	{
		int L=(m*p+q)%n+1,R=(m*q+p)%n+1;
		if (L>R) {int t=L;L=R;R=t;}
		for (int i=Getf(L);i<=R;i=Getf(i+1)) C[i]=m,Fa[i]=i+1;
	}
	For(i,1,n+1) printf("%d\n",C[i]);
}
Problem2393
#include<cstdio>
#include<algorithm>
#include<functional>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

typedef unsigned long long LL;
LL L,R,A[1<<15],B[1<<15],Ans;
int v[1<<15],cnt,n;

void Getnum(LL x)
{
	if (x) A[cnt++]=x;
	if (x*10+2<=R) Getnum(x*10+2);
	if (x*10+9<=R) Getnum(x*10+9);
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
void Calc(int x,LL Lcm,int c)
{
	if (Lcm>R) return;
	if (x==n) {if (Lcm!=1) Ans+=(c?1:-1)*(R/Lcm-(L-1)/Lcm);return;}
	Calc(x+1,Lcm,c);
	Calc(x+1,Lcm/gcd(Lcm,B[x])*B[x],c^1);
}

int main()
{
	scanf("%lld%lld",&L,&R);
	Getnum(0);
	sort(A,A+cnt);
	For(i,0,cnt)
		if (!v[i])
		{
			B[n++]=A[i];
			For(j,i+1,cnt) if (A[j]%A[i]==0) v[j]=1;
		}
	sort(B,B+n,greater<int>());
	Calc(0,1,0);
	printf("%lld\n",Ans);
}
Problem2395
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=200+19,M=10000+19,oo=(1<<30)-1;

struct Edge{
	int x,y,z,a,b;
	bool operator < (const Edge &B) const {return z<B.z;}
} E[M];

int fa[N];
int n,m;

struct Point{
	int x,y;
	bool operator < (const Point &B) const {return 1ll*x*y<1ll*B.x*B.y;}
} A,B,res;
typedef Point Vector;

Vector operator - (Point A,Point B) {return (Vector){A.x-B.x,A.y-B.y};}
ll cross(Vector A,Vector B){
	return 1ll*A.x*B.y-1ll*A.y*B.x;
}

int getf(int x) {return fa[x]==x?x:fa[x]=getf(fa[x]);}
Point Kruskal(){
	Point A;
	A.x=A.y=0;
	sort(E,E+m);
	For(i,1,n+1) fa[i]=i;
	For(i,0,m){
		int fx=getf(E[i].x),fy=getf(E[i].y);
		if (fx!=fy){
			fa[fx]=fy;
			A.x+=E[i].a;
			A.y+=E[i].b;
		}
	}
	if (A<res) res=A;
	return A;
}
void work(Point A,Point B){
	For(i,0,m) E[i].z=-E[i].a*(B.y-A.y)-E[i].b*(A.x-B.x);
	Point C=Kruskal();
	if (cross(C-A,B-A)<=0) return;
	work(A,C);
	work(C,B);
}

int main(){
	res=(Point){oo,oo};
	n=IN(),m=IN();
	For(i,0,m) E[i]=(Edge){IN()+1,IN()+1,0,IN(),IN()};	
	For(i,0,m) E[i].z=E[i].a;
	A=Kruskal();
	For(i,0,m) E[i].z=E[i].b;
	B=Kruskal();
	work(A,B);
	printf("%d %d\n",res.x,res.y);
}
Problem2423
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=5000+19,Mod=100000000;
int f[2][N],g[2][N],n,m,c=1,p;
char A[N],B[N];

int main()
{
	scanf("%s%s",A+1,B+1);
	n=strlen(A+1)-1,m=strlen(B+1)-1;
	For(i,0,m+1) g[c][i]=1;
	For(i,1,n+1)
	{
		c^=1,p^=1;
		g[c][0]=1;
		For(j,1,m+1)
			if (A[i]==B[j])
			{
				f[c][j]=f[p][j-1]+1;
				g[c][j]=g[p][j-1];
				if (f[p][j]==f[c][j]) (g[c][j]+=g[p][j])%=Mod;
				if (f[c][j-1]==f[c][j]) (g[c][j]+=g[c][j-1])%=Mod;
			} else
			{
				f[c][j]=max(f[p][j],f[c][j-1]);
				if (f[p][j]>f[c][j-1]) g[c][j]=g[p][j];
				if (f[p][j]<f[c][j-1]) g[c][j]=g[c][j-1];
				if (f[p][j]==f[c][j-1])
					g[c][j]=(g[p][j]+g[c][j-1]-(f[p][j-1]==f[c][j]?g[p][j-1]:0)+Mod)%Mod;
			}
	}
	printf("%d\n%d\n",f[c][m],g[c][m]);
}
Problem2424
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=2000+19,M=N*6,oo=(1<<30)-1;
typedef int one[N];
one Last,Dis,pre,vis,Q;
struct Edge {int y,f,c,nxt;} E[M];
int n,m,s,S,T,x,cnt,Cost,f,w;

void Add_Edge(int x,int y,int f,int c)
{
	E[cnt]=(Edge){y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,-c,Last[y]};Last[y]=cnt++;
}

bool SPFA()
{
	memset(Dis,64,sizeof(Dis));Dis[S]=0;
	Q[w=0,f=1]=S,pre[S]=-1;
	while (f>w)
	{
		int x=Q[++w];vis[x]=0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[x]+E[i].c<Dis[E[i].y])
			{
				Dis[E[i].y]=Dis[x]+E[i].c,pre[E[i].y]=i;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
	}
	return Dis[T]<oo;
}
void Update()
{
	int Min=oo;
	for (int i=pre[T];~i;i=pre[E[i^1].y]) Min=min(Min,E[i].f);
	for (int i=pre[T];~i;i=pre[E[i^1].y]) E[i].f-=Min,E[i^1].f+=Min;
	Cost+=Min*Dis[T];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d%d",&n,&m,&s);
	S=n+1,T=S+1;
	For(i,1,n+1) scanf("%d",&x),Add_Edge(i,T,x,0);
	For(i,1,n+1) scanf("%d",&x),Add_Edge(S,i,oo,x);
	For(i,1,n) Add_Edge(i,i+1,s,m);
	while (SPFA()) Update();
	printf("%d\n",Cost);	
}
Problem2424
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=200+19,M=N*6,oo=(1<<30)-1;
typedef int one[N];
one Last,Dis,pre,vis,Q;
struct Edge {int y,f,c,nxt;} E[M];
int n,m,s,S,T,x,cnt,Cost,f,w;

void Add_Edge(int x,int y,int f,int c)
{
	E[cnt]=(Edge){y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,-c,Last[y]};Last[y]=cnt++;
}

bool SPFA()
{
	memset(Dis,64,sizeof(Dis));Dis[S]=0;
	Q[w=0,f=1]=S,pre[S]=-1;
	while (f>w)
	{
		int x=Q[++w];vis[x]=0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[x]+E[i].c<Dis[E[i].y])
			{
				Dis[E[i].y]=Dis[x]+E[i].c,pre[E[i].y]=i;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
	}
	return Dis[T]<oo;
}
void Update()
{
	int Min=oo;
	for (int i=pre[T];~i;i=pre[E[i^1].y]) Min=min(Min,E[i].f);
	for (int i=pre[T];~i;i=pre[E[i^1].y]) E[i].f-=Min,E[i^1].f+=Min;
	Cost+=Min*Dis[T];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d%d",&n,&m,&s);
	S=n+1,T=S+1;
	For(i,1,n+1) scanf("%d",&x),Add_Edge(i,T,x,0);
	For(i,1,n+1) scanf("%d",&x),Add_Edge(S,i,oo,x);
	For(i,1,n) Add_Edge(i,i+1,s,m);
	while (SPFA()) Update();
	printf("%d\n",Cost);	
}
Problem2427
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=100+19,M=500+19;
typedef int one[N];
one w,v,W,V,DFN,Low,SCC,In,nxt,S,vis,reID;
int f[N][M],n,m,cnt;

void Upd(int &x,int y) {x=x>y?x:y;}

struct Graph
{
	struct Edge {int y,nxt;} E[N*2];
	int Last[N];
	int tot,Time,cnt;
	Graph() {memset(Last,-1,sizeof(Last));}
	void Add_Edge(int x,int y)
	{
		E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	}
	void DFS(int x)
	{
		Low[x]=DFN[x]=++Time;S[++*S]=x;
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if (!DFN[y=E[i].y]) DFS(y),Low[x]=min(Low[x],Low[y]);
				else if (!SCC[y]) Low[x]=min(Low[x],DFN[y]);
		if (Low[x]==DFN[x])
		{
			int u;tot++;
			do
			{
				u=S[(*S)--],SCC[u]=tot;
				W[tot]+=w[u],V[tot]+=v[u];
			} while (u!=x);
		}
	}
	void Tarjan() {For(i,0,n+1) if (!DFN[i]) DFS(i);}
	void DFS(int x,int Fa)
	{
		reID[++Time]=x;int pre=Time;
		for (int i=Last[x],y;~i;i=E[i].nxt) if ((y=E[i].y)!=Fa) DFS(y,x);
		nxt[pre]=Time+1;
	}
} P,G;

int main()
{
	n=IN(),m=IN();
	For(i,1,n+1) w[i]=IN();
	For(i,1,n+1) v[i]=IN();
	For(i,1,n+1) P.Add_Edge(i,IN());
	P.Tarjan();
	For(x,1,n+1) for (int i=P.Last[x],y;~i;i=P.E[i].nxt)
		if (SCC[y=P.E[i].y]!=SCC[x]&&y) G.Add_Edge(SCC[y],SCC[x]),vis[SCC[x]]=1;
	For(i,2,P.tot+1) if (!vis[i]) G.Add_Edge(1,i);
	G.DFS(1,-1);
	memset(f,200,sizeof(f));
	memset(f[1],0,sizeof(f[1]));
	For(i,1,G.Time+1)
	{
		For(j,W[reID[i]],m+1) Upd(f[i+1][j],f[i][j-W[reID[i]]]+V[reID[i]]);
		For(j,0,m+1) Upd(f[nxt[i]][j],f[i][j]);
	}
	printf("%d\n",f[G.Time+1][m]);
}
Problem2429
#include<cstdio>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define sqr(x) ((x)*(x))
using namespace std;

const int N=1000+19;
struct Edge
{
	int x,y,z;
	bool operator < (const Edge& B) const {return z<B.z;}
} E[N*N];
struct node {int x,y;} P[N];
int A[N],Fa[N],n,t,m,Ans,Max;

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}

int main()
{
	scanf("%d",&n);
	For(i,1,n+1) scanf("%d",&A[i]);
	scanf("%d",&t);
	For(i,1,t+1) scanf("%d%d",&P[i].x,&P[i].y),Fa[i]=i;
	For(i,1,t+1) For(j,i+1,t+1) E[m++]=(Edge){i,j,sqr(P[i].x-P[j].x)+sqr(P[i].y-P[j].y)};
	sort(E,E+m);
	For(i,0,m)
	{
		int fx=Getf(E[i].x),fy=Getf(E[i].y);
		if (fx!=fy) Fa[fx]=fy,Max=E[i].z;
	}
	For(i,1,n+1) Ans+=(sqr(A[i])>=Max);
	printf("%d\n",Ans);
}
Problem2430
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=20000+19;
struct node
{
	int x,y;
	bool operator < (const node& B) const {return x>B.x;}
} A[Maxn];
int n,m,Ans,f[2];

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	read(n),read(m);n--;m--;
	for (int i=1;i<=n;i++) read(A[i].x),A[i].y=0;
	for (int i=n+1;i<=n+m;i++) read(A[i].x),A[i].y=1;
	sort(A+1,A+n+m+1);
	f[0]=f[1]=1;
	for (int i=1;i<=n+m;i++)
	{
		Ans+=f[A[i].y^1]*A[i].x;
		f[A[i].y]++;
	}
	printf("%d\n",Ans);
}
Problem2431
#include<cstdio>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1000+19,Mod=10000;
int f[N][N],s[N][N],n,K;

int main()
{
	scanf("%d%d",&n,&K);
	For(i,1,K+2) s[0][i]=1;
	For(i,1,n+1) For(k,0,K+1)
		f[i][k]=(s[i-1][k+1]-s[i-1][max(k-i+1,0)]+Mod)%Mod,
		s[i][k+1]=(s[i][k]+f[i][k])%Mod;
	printf("%d\n",f[n][K]);
}
Problem2434
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;

const int Maxn=100000+19;
struct Edge {int y,nxt;} E[Maxn];
struct Query {int x,ID,nxt;} Qu[Maxn];
typedef int one[Maxn];
typedef int Node[Maxn*10];
one Fa,nxt,ID,to,QL,Ans;
Node head,Last,Q,C,In,Out,Fail;
int t[Maxn][26];
int x,y,T,Time,top,tot,f,w,cnt,m,cQ;
char s[Maxn];

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
void Add_Query(int x,int y,int ID) {Qu[cQ]=(Query){y,ID,QL[x]};QL[x]=cQ++;}
void Update(int x,int v) {for (;x<=Time;x+=x&-x) C[x]+=v;}
int Query(int x) {int Ans=0;for (;x;x-=x&-x) Ans+=C[x];return Ans;}
void DFS(int x)
{
	In[x]=++Time;
	for (int i=Last[x];~i;i=E[i].nxt) DFS(E[i].y);
	Out[x]=Time;
}
void GetAns(int x)
{
	Update(In[x],1);
	for (int i=head[x];i;i=nxt[i])
		for (int j=QL[to[i]];~j;j=Qu[j].nxt)
			Ans[Qu[j].ID]=Query(Out[ID[Qu[j].x]])-Query(In[ID[Qu[j].x]]-1);
	for (int i=0;i<26;i++) if (t[x][i]) GetAns(t[x][i]);
	Update(In[x],-1);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	memset(QL,-1,sizeof(QL));
	scanf("%s",s);
	Fa[++top]=0;
	for (int i=0,_=strlen(s);i<_;i++)
		if (s[i]=='P') ID[++T]=x,to[T]=T,nxt[T]=head[x],head[x]=T;
			else if (s[i]=='B') {if (top) x=Fa[--top];} else
			{
				int& u=t[x][s[i]-'a'];
				if (!u) u=++tot;Fa[++top]=x=u;
			}
	for (Q[w=0,f=1]=0;f>w;)
	{
		int x=Q[++w];if (x) Add_Edge(Fail[x],x);
		for (int i=0;i<26;i++)
		{
			int& u=t[x][i];
			if (u)
			{
				Q[++f]=u;int v=Fail[x];
				while (v&&!t[v][i]) v=Fail[v];
				Fail[u]=(t[v][i]!=u?t[v][i]:0);
			}
		}
	}
	read(m);
	for (int i=0;i<m;i++) read(x),read(y),Add_Query(y,x,i);
	DFS(0);
	GetAns(0);
	for (int i=0;i<m;i++) printf("%d\n",Ans[i]);
}
Problem2435
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=1000000+5;
typedef long long LL;
struct Edge {int y,z,nxt;} E[N*2];
int Fa[N],S[N],Last[N],n,x,y,z,cnt;
LL Ans;

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}
void DFS(int x)
{
	S[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x])
			Fa[E[i].y]=x,
			DFS(E[i].y),
			S[x]+=S[E[i].y],Ans+=1LL*E[i].z*abs(n-S[E[i].y]-S[E[i].y]);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n);
	For(i,1,n) read(x),read(y),read(z),Link(x,y,z);
	DFS(1);
	printf("%lld\n",Ans);
}
Problem2440
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

const int Top=45000,N=Top+19;
int p[N],vis[N],mu[N];

int T,t,cnt,k,res;
long long L,R;

int Calc(int x)
{
	int res=0;
	for (int i=1;i*i<=x;i++) res+=mu[i]*(x/i/i);
	return res;
}

int main()
{
	mu[1]=1;
	for (int i=2;i<=Top;i++)
	{
		if (!vis[i]) p[cnt++]=i,mu[i]=-1;
		for (int j=0;j<cnt&&p[j]*i<=Top;j++)
		{
			vis[t=p[j]*i]=1;
			if (i%p[j]==0) {mu[t]=0;break;}
			mu[t]=-mu[i];
		}
	}
	for (scanf("%d",&T);T--;)
	{
		scanf("%d",&k);
		L=1,R=2e9+1;
		while (L<=R) if (Calc(Mid)>=k) res=Mid,R=Mid-1;else L=Mid+1;
		printf("%d\n",res);
	}
}
Problem2440
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+(R-L>>1))
using namespace std;

const int Top=45000,N=Top+19;
int p[N],vis[N],mu[N];

int T,t,cnt,k,res,L,R;

int Calc(int x)
{
	int res=0;
	for (int i=1;i*i<=x;i++) res+=mu[i]*(x/i/i);
	return res;
}

int main()
{
	mu[1]=1;
	for (int i=2;i<=Top;i++)
	{
		if (!vis[i]) p[cnt++]=i,mu[i]=-1;
		for (int j=0;j<cnt&&p[j]*i<=Top;j++)
		{
			vis[t=p[j]*i]=1;
			if (i%p[j]==0) {mu[t]=0;break;}
			mu[t]=-mu[i];
		}
	}
	for (scanf("%d",&T);T--;)
	{
		scanf("%d",&k);
		L=1,R=2*k;
		while (L<=R) if (Calc(Mid)>=k) res=Mid,R=Mid-1;else L=Mid+1;
		printf("%d\n",res);
	}
}
Problem2453
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=10000+19,Col=1000000+19;
int A[Maxn],cnt[Col];
int n,Q,Ql,Qr,Ans,x,v,L,R;
char s[3];

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Update(int x,int v)
{
	if (!x) return;
	cnt[A[x]]+=v;
	if (v==-1&&cnt[A[x]]==0) Ans--;
	if (v==1&&cnt[A[x]]==1) Ans++;
}

int main()
{
	read(n),read(Q);
	for (int i=1;i<=n;i++) scanf("%d",&A[i]);
	while (Q--)
	{
		scanf("%s",s);
		if (s[0]=='Q')
		{
			read(Ql),read(Qr);
			while (L<Ql) Update(L++,-1);
			while (L>Ql) Update(--L,1);
			while (R<Qr) Update(++R,1);
			while (R>Qr) Update(R--,-1);
			printf("%d\n",Ans);
		} else
		{
			read(x),read(v);
			if (Ql<=x&&x<=Qr) Update(x,-1);A[x]=v;
			if (Ql<=x&&x<=Qr) Update(x,1);
		}
	}
}
Problem2456
#include<cstdio>
using namespace std;

int n,cnt,pre,x;

int main()
{
	scanf("%d",&n);
	while (n--)
	{
		scanf("%d",&x);
		if (cnt==0) pre=x,cnt=1;
			else 
				if (pre==x) cnt++;else cnt--;
	}
	printf("%d\n",pre);
}
Problem2462
#include<string>
#include<iostream>
using namespace std;

int a,b,c,d,Q;
string s;

int main()
{
	int a,b,Q;
	cin>>a>>b>>c>>d;
	for (int i=0;i<a;i++) cin>>s;
	cin>>Q;
	for (int i=0;i<Q;i++) cout<<"1\n";
}
Problem2463
#include<cstdio>
using namespace std;

int main()
{
	int n;
	while (scanf("%d",&n)&&n) printf("%s\n",n&1?"Bob":"Alice");
	return 0;
}
Problem2466
#include<cstdio>
#include<bitset>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=100+19;
typedef bitset<Maxn> Matrix[Maxn];
int n,x,y,Ans,tmp;
Matrix A;

void Gauss()
{
	for (int i=1;i<=n;i++)
	{
		int r=0;
		for (int j=i;j<=n;j++) if (A[j][i]) {r=j;break;}
		if (r) 
		{
			swap(A[i],A[r]);
			for (int j=1;j<=n;j++) if (j!=i&&A[j][i]) A[j]^=A[i];
		}
	}
}
void DFS(int x)
{
	if (x==n+1) 
	{
		tmp=0;
		for (int i=1;i<=n;i++) tmp+=A[i][n+1];
		Ans=min(Ans,tmp);return;
	}
	if (A[x][x]) {DFS(x+1);return;}
	A[x][n+1]=1;for (int i=1;i<=n;i++) if (x!=i&&A[i][x]) A[i]^=A[x];
	DFS(x+1);for (int i=1;i<=n;i++) if (x!=i&&A[i][x]) A[i]^=A[x];
	A[x][n+1]=0;for (int i=1;i<=n;i++) if (x!=i&&A[i][x]) A[i]^=A[x];
	DFS(x+1);for (int i=1;i<=n;i++) if (x!=i&&A[i][x]) A[i]^=A[x];
}

int main()
{
	while (~scanf("%d",&n)&&n)
	{
		Ans=(1<<30)-1;
		for (int i=1;i<=n;i++) A[i].reset(),A[i][i]=A[i][n+1]=1;
		for (int i=1;i<n;i++) scanf("%d%d",&x,&y),A[x][y]=A[y][x]=1;
		Gauss();
		DFS(1);
		printf("%d\n",Ans);
	}
}
Problem2480
#include<cmath>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int Mo=100007;
struct Hash
{
	int A[Mo*2],key[Mo*2],Last[Mo],nxt[Mo*2],cnt;
	void Clear()
	{
		memset(A,-1,sizeof(A));
		memset(nxt,-1,sizeof(nxt)),cnt=Mo;
	}
	void Ins(int x,int k)
	{
		int t=x%Mo;
		if (A[t]==-1) A[t]=x,key[t]=k,Last[t]=t;else
			nxt[Last[t]]=cnt,A[cnt]=x,key[cnt]=k,Last[t]=cnt++;
	}
	int Qry(int x)
	{
		for (int i=x%Mo;~i;i=nxt[i]) if (A[i]==x) return key[i];
		return -1;
	}
} H;
int y,z,P;

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
void Exgcd(int a,int b,int &x,int &y)
{
	if (!b) {x=1,y=0;return;}
	Exgcd(b,a%b,x,y);
	int t=x;x=y;y=t-a/b*y;
}
int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
int Inv(int a)
{
	int x,y;Exgcd(a,P,x,y);return (x+P)%P;
}
int ExBSGS()
{
	//y^x=z (mod P)
	int t=1,k=0,w=1;
	For(i,0,50) {if (t==z) return i;t=1LL*t*y%P;}
	for (t=gcd(y,P);t!=1;t=gcd(y,P))
	{
		if (z%t) return -1;
		z/=t,P/=t,k++,w=1LL*w*(y/t)%P;
	}
	int S=sqrt(P)+1,I=Inv(Pow(y,S));
	t=w;H.Clear();
	For(i,0,S) {if (H.Qry(t)==-1) H.Ins(t,i);t=1LL*t*y%P;}
	For(i,0,S)
		if (~(t=H.Qry(z))) return i*S+t+k;else z=1LL*z*I%P;
	return -1;
}

int main()
{
	while (y=IN(),P=IN(),z=IN(),y||P||z)
	{
		int Ans=ExBSGS();
		~Ans?printf("%d\n",Ans):puts("No Solution");
	}
}
Problem2482
#include<map>
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x,f;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=100000+19;
typedef long long LL;
const LL oo=1LL<<60;
map<int,int> M;
struct Event
{
	int L,R,ID;
	bool operator < (const Event& B) const {return R<B.R;}
} E[N];
int A[N],pre[N],n,Ql,Qr,Qv,c,Q;LL Ans[N],v;

//SegTree
struct node
{
	LL M,A,Hm,Ha;
	node() {}
	node(LL _M,LL _Hm) {M=_M,Hm=_Hm;A=Ha=0;}
	void SetA(LL v) {Ha=max(Ha,A+=v),Hm=max(Hm,M+=v);}
	void SetHa(LL v) {Ha=max(Ha,A+v),Hm=max(Hm,M+v);}
} S[N*4];

void Push_down(int x)
{
	if (v=S[x].Ha) S[Lsn].SetHa(v),S[Rsn].SetHa(v),S[x].Ha=0;
	if (v=S[x].A) S[Lsn].SetA(v),S[Rsn].SetA(v),S[x].A=0;
}
void Update(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {S[x].SetA(Qv);return;}
	Push_down(x);
	if (Ql<=Mid) Update(Lsn,L,Mid);
	if (Qr>Mid) Update(Rsn,Mid+1,R);
	S[x]=node(max(S[Lsn].M,S[Rsn].M),max(S[Lsn].Hm,S[Rsn].Hm));
}
LL Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return S[x].Hm;
	Push_down(x);
	LL res=-oo;
	if (Ql<=Mid) res=max(res,Query(Lsn,L,Mid));
	if (Qr>Mid) res=max(res,Query(Rsn,Mid+1,R));
	return res;
}

int main()
{
	n=IN();
	For(i,1,n+1) A[i]=IN();
	Q=IN();For(i,0,Q) E[i]=(Event){IN(),IN(),i};
	sort(E,E+Q);
	For(i,1,n+1) pre[i]=M[A[i]],M[A[i]]=i;
	For(R,1,n+1)
	{
		Ql=pre[R]+1,Qr=R,Qv=A[R],Update(1,1,n);
		while (c<Q&&E[c].R==R) Ql=E[c].L,Qr=R,Ans[E[c].ID]=Query(1,1,n),c++;
	}
	For(i,0,Q) printf("%lld\n",Ans[i]);
}
Problem2502
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=100+19,M=N*N,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[M];
int Last[N],Q[N],Dis[N],In[N],Out[N];
int n,cnt,C,x,S,T,Ans;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	int f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			res+=tmp,Flow-=tmp,E[i].f-=tmp,E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);S=n+1,T=S+1;
	For(i,1,n+1)
	{
		scanf("%d",&C);
		while (C--) scanf("%d",&x),Add_Edge(i,x,oo),In[x]++,Out[i]++;
	}
	For(i,1,n+1) Add_Edge(S,i,oo),Add_Edge(i,T,oo);
	S=T+1,T=S+1;
	For(i,1,S) Add_Edge(S,i,In[i]),Add_Edge(i,T,Out[i]);
	Add_Edge(S-1,S-2,oo);
	while (BFS()) Dinic(S,oo);
	T=S-1,S=T-1;
	Ans=E[Last[T]^1].f;
	Last[T]=E[Last[T]].nxt,Last[S]=E[Last[S]].nxt;
	swap(T,S);
	while (BFS()) Ans-=Dinic(S,oo);
	printf("%d\n",Ans);
}
Problem2527
#include<set>
#include<map>
#include<cmath>
#include<string>
#include<cstdio>
#include<vector>
#include<cctype>
#include<cstdlib>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define Mid (L+R>>1)

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;

const int N=3e5+19,top=1e9;
typedef int one[N];
struct Edge {int y,nxt;} E[N];
struct QType {int L,R,v;} Q[N];
one Last,O,P,id,__id,Ans,vis;
int n,m,Qc,cnt,Ql,Qr,v;

void Add_Edge(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
}

int Time;
ll C[N],T[N];
void Add(int x,int v)
{
	for (;x<=m;x+=x&-x)
	{
		if (T[x]!=Time) T[x]=Time,C[x]=0;
		C[x]+=v;
	}
}
ll Query(int x)
{
	ll Ans=0;
	for (;x;x-=x&-x) Ans+=(T[x]==Time?C[x]:0);
	return Ans;
}
void Update(int L,int R,int v) {Add(L,v),Add(R+1,-v);}

void Work(int l,int r,int L,int R)
{
	if (L==R)
	{
		For(i,l,r+1) Ans[id[i]]=L;
		return;
	}
	Time++;
	For(i,L,Mid+1)
	{
		int Ql=Q[i].L,Qr=Q[i].R,v=Q[i].v;
		if (Ql<=Qr) Update(Ql,Qr,v);
			else Update(Ql,m,v),Update(1,Qr,v);
	}
	For(t,l,r+1)
	{
		int tmp=0,x=id[t];
		for (int i=Last[x];~i;i=E[i].nxt)
			tmp=min(tmp+Query(E[i].y),1ll*top);
		if (tmp>=P[x]) vis[x]=1;else vis[x]=0,P[x]-=tmp;
	}
	int c=l-1,p;
	For(i,l,r+1) if (vis[id[i]]) __id[++c]=id[i];
	p=c;
	For(i,l,r+1) if (!vis[id[i]]) __id[++c]=id[i];
	memcpy(id+l,__id+l,sizeof(int)*(r-l+1));
	if (l<=p) Work(l,p,L,Mid);
	if (p+1<=r) Work(p+1,r,Mid+1,R);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,m+1) Add_Edge(IN(),i);
	For(i,1,n+1) P[i]=IN(),id[i]=i;
	Qc=IN();
	For(i,1,Qc+1) Q[i]=(QType){IN(),IN(),IN()};
	Q[++Qc]=(QType){1,m,top};
	Work(1,n,1,Qc);
	For(i,1,n+1) Ans[i]==Qc?puts("NIE"):printf("%d\n",Ans[i]);
}
Problem2535
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=2000+19;
struct Edge {int y,nxt;} E[10000+19];
int Last[N],K[N],D[N],D2[N],Q[N],List[N];
int n,m,f,w,cnt,x,y;

int cmp(int i,int j) {return K[i]<K[j];}
void Add_Edge(int x,int y)
{
	D[y]++;
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
}
void work(int x)
{
	for (int i=1;i<=n;i++) D[i]=D2[i];
	f=0,w=0;
	for (int t=1,_=1,u;t<=n;t++)
	{
		for (;_<=n&&K[u=List[_]]<=t;_++) if (!D[u]&&u!=x) Q[++f]=u;
		if (f>w)
		{
			int u=Q[++w];
			for (int i=Last[u];~i;i=E[i].nxt)
				if (!(--D[E[i].y])&&K[E[i].y]<=t&&E[i].y!=x) Q[++f]=E[i].y;
		} else return;
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) scanf("%d",&K[i]),K[i]=n-K[i]+1,List[i]=i;
	for (int i=0;i<m;i++) scanf("%d%d",&x,&y),Add_Edge(y,x);
	sort(List+1,List+n+1,cmp);
	for (int i=1;i<=n;i++) D2[i]=D[i];
	work(0);
	for (int i=n;i;i--) printf("%d ",Q[i]);puts("");
	for (int i=1;i<=n;i++) work(i),printf("%d ",n-f);puts("");
}
Problem2555
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=2*600000+19;
//LCT
struct node *null;
struct node
{
	node *L,*R,*Fa;
	int rev,Add,key;

	bool Top() {return Fa==null||Fa->L!=this&&Fa->R!=this;}
	void Setrev() {rev^=1,swap(L,R);}
	void Setadd(int x) {Add+=x,key+=x;}
	void Down()
	{
		if (rev) L->Setrev(),R->Setrev(),rev=0;
		if (Add) L->Setadd(Add),R->Setadd(Add),Add=0;
	}

	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;
	}
} Nd[N],*cur=Nd;

node *New(int v) {return *cur=(node){null,null,null,0,0,v},cur++;}
void Splay(node *x)
{
	static node *S[N];int k=0;node *tmp=x;
	while (!tmp->Top()) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (!x->Top())
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top())
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
}
node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa) Splay(x),x->R=y;
	return y;
}
void Evert(node *x) {Access(x)->Setrev();}
void Link(node *x,node *y) {Evert(x),Splay(x),x->Fa=y;}
void Cut(node *x,node *y)
{
	Access(x),Splay(y);
	if (y->Fa==x) y->Fa=null;else Access(y),Splay(x),x->Fa=null;
}

//SAM
struct State
{
	State *Par,*go[26];
	int val;node *rt;	
} Ns[N],*Cur=Ns,*Last,*rt;

State *New(int v,int R) {return Cur->val=v,Cur->rt=New(R),Cur++;}
void Extend(int x)
{
	State *p=Last,*np=New(p->val+1,0);
	for (;p&&!p->go[x];p=p->Par) p->go[x]=np;
	if (!p) np->Par=rt,Link(np->rt,rt->rt);else
	{
		State *t=p->go[x];
		if (t->val==p->val+1) np->Par=t,Link(np->rt,t->rt);else
		{
			Splay(t->rt);
			State *nt=New(p->val+1,t->rt->key);
			Cut(t->Par->rt,t->rt),
			nt->Par=t->Par,t->Par=np->Par=nt;
			Link(nt->Par->rt,nt->rt),Link(t->rt,nt->rt),Link(np->rt,nt->rt);
			memcpy(nt->go,t->go,sizeof(t->go));
			for (;p&&p->go[x]==t;p=p->Par) p->go[x]=nt;
		}
	}
	Last=np;Evert(rt->rt),Access(np->rt)->Setadd(1);
}

int Mask,Len,Ans,Q;
char opt[10],s[N];

void Decode(int x) {For(i,0,Len) x=(x*131+i)%Len,swap(s[i],s[x]);}

int main()
{
	null=New(0);null->L=null->R=null->Fa=null;
	rt=Last=New(0,0);
	scanf("%d",&Q);
	scanf("%s",s),Len=strlen(s);
	For(i,0,Len) Extend(s[i]-'A');
	while (Q--)
	{
		scanf("%s%s",opt,s),Len=strlen(s);
		Decode(Mask);
		if (opt[0]=='A') For(i,0,Len) Extend(s[i]-'A');
			else
			{
				State *x=rt;Ans=0;
				For(i,0,Len)
				{
					if (!x->go[s[i]-'A']) {Ans=-1;break;}
					x=x->go[s[i]-'A'];
				}
				if (Ans==-1) puts("0");else
					Splay(x->rt),printf("%d\n",Ans=x->rt->key),Mask^=Ans;
			}
	}
}
Problem2558
#include<map>
#include<cstdio>
#include<cctype>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=6000+19;
struct node
{
	int C,A1,A2,A3;
	bool operator < (const node& B) const
	{
		if (C!=B.C) return C<B.C;
		if (A1!=B.A1) return A1<B.A1;
		if (A2!=B.A2) return A2<B.A2;
		return A3<B.A3;
	}
} A[N];
map<node,int> M;
int To[N],n,Ans;
char s[5];

int main()
{
	n=IN()-1;
	For(i,1,n+1)
	{
		scanf("%s",s);
		A[i]=(node){s[0]=='C'?1:s[0]=='Z'?2:3,IN(),IN(),IN()};
	}
	for (int i=n;i;i--)
	{
		node tmp=(node){A[i].C,To[A[i].A1],To[A[i].A2],To[A[i].A3]};
		if (M.count(tmp)) To[i]=M[tmp];else To[i]=M[tmp]=i,Ans++;
	}
	printf("%d\n",Ans+1);
}
Problem2561
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=20000+19,M=200000+19,oo=(1<<30)-1;
struct Link
{
	int x,y,z;
	bool operator < (const Link& B) const {return z<B.z;}
} L[M];
struct Edge {int y,f,nxt;} E[M*2];
int Q[N],Dis[N],Last[N];
int Flow,f,w,S,T,cnt,n,m,A;

void Add_Edge(int x,int y)
{
	E[cnt]=(Edge){y,1,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,1,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	f=1,w=0;Q[1]=S;
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			E[i].f-=tmp,E[i^1].f+=tmp,res+=tmp,Flow-=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	n=IN(),m=IN();
	For(i,0,m) L[i].x=IN(),L[i].y=IN(),L[i].z=IN();
	sort(L,L+m);
	memset(Last,-1,sizeof(Last));cnt=0;
	
	S=IN(),T=IN(),A=IN();
	For(i,0,m) if (L[i].z<A) Add_Edge(L[i].x,L[i].y);
	while (BFS()) Flow+=Dinic(S,oo);
	
	memset(Last,-1,sizeof(Last));cnt=0;
	For(i,0,m) if (L[i].z>A) Add_Edge(L[i].x,L[i].y);
	while (BFS()) Flow+=Dinic(S,oo);
	printf("%d\n",Flow);
}
Problem2563
#include<cstdio>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=10000+19;
double A[N],Ans;
int n,m,x,y,z;

int main()
{
	scanf("%d%d",&n,&m);
	For(i,1,n+1) scanf("%lf",&A[i]);
	For(i,0,m) scanf("%d%d%d",&x,&y,&z),A[x]+=z/2.0,A[y]+=z/2.0;
	sort(A+1,A+n+1);
	For(i,1,n+1) Ans+=((i&1)?-1:1)*A[i];
	printf("%.0lf\n",Ans);
}
Problem2588
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>

#define Mid (L+R>>1)
using namespace std;

const int Maxn=100000+19;
typedef int one[Maxn];
typedef int Seg[Maxn*20];
struct Edge {int y,nxt;} E[Maxn*2];
Seg Lsn,Rsn,sum;
one A,b,d,Last,rt,Deep;
int Fa[18][Maxn];
int n,Q,cnt,tcnt,t,top,x,y,Lans,k;

int cmp(int a,int b) {return A[a]<A[b];}

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void out(int x) {if (!x) return;out(x/10);putchar(x%10+'0');}
void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}

void build(int &x,int y,int L,int R)
{
	sum[x=++tcnt]=sum[y]+1;
	if (L==R) return;
	Lsn[x]=Lsn[y];Rsn[x]=Rsn[y];
	(t<=Mid)?build(Lsn[x],Lsn[y],L,Mid):build(Rsn[x],Rsn[y],Mid+1,R);
}
void DFS(int x)
{
	t=A[x],build(rt[x],rt[Fa[0][x]],1,top);
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].y!=Fa[0][x]) Fa[0][E[i].y]=x,Deep[E[i].y]=Deep[x]+1,DFS(E[i].y);
}
int LCA(int x,int y)
{
	if (x==y) return x;
	if (Deep[x]>Deep[y]) swap(x,y);
	for (int i=17;i>=0;i--) if (Deep[Fa[i][y]]>Deep[x]) y=Fa[i][y];
	if (Deep[y]>Deep[x]) y=Fa[0][y];
	if (x==y) return x;
	for (int i=17;i>=0;i--) if (Fa[i][x]!=Fa[i][y]) x=Fa[i][x],y=Fa[i][y];
	return Fa[0][x];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n),read(Q);
	for (int i=1;i<=n;i++) read(A[i]),b[i]=i;
	sort(b+1,b+n+1,cmp);
	for (int L=1,R=1;L<=n;L=R+1,R=L)
	{
		while (b[R]==b[R+1]) R++;
		d[++top]=A[b[R]];for (int i=L;i<=R;i++) A[b[i]]=top;
	}
	for (int i=1;i<n;i++) read(x),read(y),Link(x,y);
	DFS(1);
	for (int i=1;i<=17;i++)
		for (int x=1;x<=n;x++) Fa[i][x]=Fa[i-1][Fa[i-1][x]];
	while (Q--)
	{
		read(x),read(y),read(k);x^=Lans;
		int z=LCA(x,y),u=Fa[0][z],L=1,R=top;
		x=rt[x],y=rt[y],z=rt[z],u=rt[u];
		while (L!=R)
		{
			int tmp=sum[Lsn[x]]+sum[Lsn[y]]-sum[Lsn[z]]-sum[Lsn[u]];
			if (tmp>=k) x=Lsn[x],y=Lsn[y],z=Lsn[z],u=Lsn[u],R=Mid;
				else x=Rsn[x],y=Rsn[y],z=Rsn[z],u=Rsn[u],k-=tmp,L=Mid+1;
		}
		out(Lans=d[L]);
		if (Q) puts("");
	}
}
Problem2594
//(x,y)去重什么的要判断x是否>y 
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';
	return x;
}

const int N=100000+19,M=10*N;
struct Event {int opt,x,y,ID;} Q[N];
struct Edge
{
	int x,y,z,ID,f;
	void Input(int i) {x=IN(),y=IN(),z=IN(),ID=i;if (x>y) swap(x,y);}
	bool operator < (const Edge& B) const {return z<B.z;}
} E[M];
int w[M],Fa[N],Ans[N],n,m,Qt,x,y,tot,p;

bool cmpxy(const Edge& A,const Edge& B) {return A.x<B.x||A.x==B.x&&A.y<B.y;}
bool cmpID(const Edge& A,const Edge& B) {return A.ID<B.ID;}

struct node *null;
struct node
{
	node *L,*R,*Fa;
	int rev,pos,ID;
	
	bool Top() {return Fa==null||Fa->L!=this&&Fa->R!=this;}
	void Setrev() {swap(L,R),rev^=1;}
	void Down() {if (rev) L->Setrev(),R->Setrev(),rev^=1;}
	void Update()
	{
		pos=ID;
		if (w[L->pos]>w[pos]) pos=L->pos;
		if (w[R->pos]>w[pos]) pos=R->pos;
	}

	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N+M];

void Splay(node *x)
{
	static node *S[N+M];
	node *tmp=x;int k=0;
	while (!tmp->Top()) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (!x->Top())
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top())
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}
node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa) Splay(x),x->R=y,x->Update();
	return y;
}
node *Root(node *x)
{
	Access(x),Splay(x);
	while (x->L!=null) x=x->L,x->Down();
	return x;
}
void Evert(node *x) {Access(x)->Setrev();}
void Link(node *x,node *y) {Evert(x),Splay(x),x->Fa=y;}
void Cut(node *x,node *y)
{
	Access(x),Splay(y);
	if (y->Fa==x) y->Fa=null;else Access(y),Splay(x),x->Fa=null;
}

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}
int Find(int x,int y)
{
	int L=1,R=m,res;
	while (L<=R) if (E[Mid].x<x||E[Mid].x==x&&E[Mid].y<=y) res=Mid,L=Mid+1;else R=Mid-1;
	return res;
}

int main()
{
	null=Nd;
	n=IN(),m=IN(),Qt=IN();
	For(i,0,n+1) Nd[i]=(node){null,null,null,0,0,0},Fa[i]=i;
	For(i,n+1,n+m+1) Nd[i]=(node){null,null,null,0,i-n,i-n};
	For(i,1,m+1) E[i].Input(i),w[i]=E[i].z;
	sort(E+1,E+m+1,cmpxy);
	For(i,0,Qt)
	{
		Q[i].opt=IN(),x=IN(),y=IN();
		if (x>y) swap(x,y);
		if (Q[i].opt==2) E[p=Find(x,y)].f=1,Q[i].ID=E[p].ID;
		Q[i].x=x,Q[i].y=y;
	}
	sort(E+1,E+m+1);
	For(i,1,m+1) if (!E[i].f)
	{
		int fx=Getf(x=E[i].x),fy=Getf(y=E[i].y);
		if (fx!=fy) Fa[fx]=fy,Link(Nd+x,Nd+E[i].ID+n),Link(Nd+y,Nd+E[i].ID+n);
	}
	sort(E+1,E+m+1,cmpID);
	for (int i=Qt-1;i>=0;i--)
	{
		int x=Q[i].x,y=Q[i].y,t=Q[i].ID;
		if (Q[i].opt==1) Evert(Nd+x),Ans[tot++]=w[Access(Nd+y)->pos];else
			if (Getf(x)!=Getf(y)) Fa[Getf(x)]=Getf(y),Link(Nd+x,Nd+t+n),Link(Nd+y,Nd+t+n);
				else
				{
					Evert(Nd+x),p=Access(Nd+y)->pos;
					if (w[t]<w[p])
						Cut(Nd+E[p].x,Nd+p+n),Cut(Nd+E[p].y,Nd+p+n),
						Link(Nd+x,Nd+t+n),Link(Nd+y,Nd+t+n);
				}
	}
	for (int i=tot-1;i>=0;i--) printf("%d\n",Ans[i]);
}
Problem2599
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(x) for (int i=Last[x];~i;i=E[i].nxt) if (!vis[E[i].y])
using namespace std;

const int N=200000+19;
struct Edge {int y,z,nxt;} E[N*2];
int Last[N],S[N],vis[N],t[1000000+19];
int n,k,x,y,z,Cen,Fcen,Min,cnt,Ans;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

void Find_cen(int x,int Fa,int n)
{
	S[x]=1;int res=0;
	For(x)
		if (E[i].y!=Fa) Find_cen(E[i].y,x,n),S[x]+=S[E[i].y],res=max(res,S[E[i].y]);
	res=max(res,n-S[x]);
	if (res<Min) Min=res,Cen=x,Fcen=Fa;
}
void DFS(int x,int Fa,int d,int v,int f)
{
	if (v<=k)
	{
		if (f==2) Ans=min(Ans,d+t[k-v]);
		if (f==1) t[v]=min(t[v],d);
		if (f==0) t[v]=(1<<30)-1;
	}
	For(x) if (E[i].y!=Fa) DFS(E[i].y,x,d+1,v+E[i].z,f);
}
void Solve(int x,int n)
{
	Min=(1<<30)-1,Find_cen(x,-1,n),vis[x=Cen]=1;
	For(x) DFS(E[i].y,-1,1,E[i].z,2),DFS(E[i].y,-1,1,E[i].z,1);
	Ans=min(Ans,t[k]);
	For(x) DFS(E[i].y,-1,1,E[i].z,0);
	For(x) Solve(E[i].y,E[i].y==Fcen?n-S[x]:S[E[i].y]);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	memset(t,60,sizeof(t));
	read(n),read(k);Ans=n;
	for (int i=1;i<n;i++) read(x),read(y),read(z),Link(++x,++y,z);
	Solve(1,n);
	printf("%d\n",Ans==n?-1:Ans);
}
Problem2599
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Rep(x) for (int i=Last[x],y;~i;i=E[i].nxt) if (!vis[y=E[i].y])
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=200000+19,oo=(1<<30)-1;
struct Edge {int y,z,nxt;} E[N*2];
int Last[N],S[N],vis[N],C[N*10],T[N*10];
int n,k,cnt,Ans=oo,cen,Min,Fcen,Time,x,y,z;

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}
void Findcen(int x,int Fa,int n)
{
	int tmp=0;S[x]=1;
	Rep(x) if (y!=Fa) Findcen(y,x,n),S[x]+=S[y],tmp=max(tmp,S[y]);
	tmp=max(tmp,n-S[x]);
	if (tmp<Min) Min=tmp,cen=x,Fcen=Fa;
}
void DFS(int x,int Fa,int Dis,int Len,int f)
{
	if (Dis>k) return;
	if (f)
	{
		if (T[Dis]!=Time) T[Dis]=Time,C[Dis]=oo;
		C[Dis]=min(C[Dis],Len);
	} else if (T[k-Dis]==Time) Ans=min(Ans,Len+C[k-Dis]);
	Rep(x) if (y!=Fa) DFS(y,x,Dis+E[i].z,Len+1,f);
}
void Solve(int x,int n)
{
	Min=oo,Findcen(x,-1,n),vis[x=cen]=1;
	if (~Fcen) S[Fcen]=n-S[x];
	Time++;T[0]=Time,C[0]=0;
	Rep(x) DFS(y,x,E[i].z,1,0),DFS(y,x,E[i].z,1,1);
	Rep(x) Solve(y,S[y]);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),k=IN();
	For(i,1,n) x=IN(),y=IN(),z=IN(),Link(x+1,y+1,z);
	Solve(1,n);
	printf("%d\n",Ans==oo?-1:Ans);
}
Problem2610
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=200000+19,oo=1<<30;
struct node;typedef node* nd;
struct node {int ID;nd nxt;} b[Maxn];nd Last[Maxn];
typedef int one[Maxn];
struct Event {int ID,f;} A[Maxn*2];
one L,R,Fa,Ans,vis,gL,gR;
int n,m,cnt;

int c,f;
void read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}

int getf(int x) {return Fa[x]==x?x:Fa[x]=getf(Fa[x]);}
void Union(int x,int y,int time)
{
	int fx=getf(x),fy=getf(y);
	if (fx!=fy)
	{
		if (fy==1) swap(fx,fy);
		if (fx==1) for (nd j=&b[fy];j;j=j->nxt) Ans[j->ID]=time;
		Fa[fy]=fx,Last[fx]->nxt=&b[fy],Last[fx]=Last[fy];
	}
}

int main()
{
	memset(Ans,60,sizeof(Ans));
	read(n),read(m);
	for (int i=1;i<=n;i++) read(L[i]),read(R[i]);
	for (int i=0;i<m;i++) 
	{
		read(A[i].ID),read(A[i].f);
		if (A[i].f==1) gL[A[i].ID]=1;else gR[A[i].ID]=1;
	}
	for (int i=1;i<=n;i++) Fa[i]=i,b[i].ID=i,b[i].nxt=0,Last[i]=&b[i];
	for (int i=1;i<=n;i++)
	{
		if (L[i]!=-1&&!gL[i]) Union(i,L[i],oo);
		if (R[i]!=-1&&!gR[i]) Union(i,R[i],oo);
	}
	for (int i=m-1;i>=0;i--) Union(A[i].ID,(A[i].f==1?L[A[i].ID]:R[A[i].ID]),i);
	for (int i=1;i<=n;i++) printf("%d\n",Ans[i]>=m?-1:Ans[i]);
}
Problem2631
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=100000+19,Mod=51061;
int n,Q,x,y,c,s,t;char S[3];

struct node;node *null;
struct node
{
	node *L,*R,*Fa;
	unsigned int Sz,Sum,Rev,Add,Mul,key;
	
	bool Top() {return Fa==null||Fa->L!=this&&Fa->R!=this;}
	void Setrev() {Rev^=1,swap(L,R);}
	void Change(int Qm,int Qa)
	{
		if (this==null) return;
		key=(key*Qm+Qa)%Mod;
		Sum=(Sum*Qm+Sz*Qa)%Mod;
		Mul=(Mul*Qm)%Mod;
		Add=(Add*Qm+Qa)%Mod;
	}
	void Down()
	{
		if (Rev) L->Setrev(),R->Setrev(),Rev=0;
		L->Change(Mul,Add),R->Change(Mul,Add),Mul=1,Add=0;
	}
	void Update() {if (this!=null) Sz=(L->Sz+R->Sz+1)%Mod,Sum=(key+L->Sum+R->Sum)%Mod;}
	
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N];

void Splay(node *x)
{
	static node *S[N];
	node *tmp=x;int k=0;
	while (!tmp->Top()) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (!x->Top())
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top())
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}
node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa) Splay(x),x->R=y,x->Update();
	return y;
}
void Evert(node *x) {Access(x)->Setrev();}
void Link(node *x,node *y) {Evert(x),Splay(x),x->Fa=y;}
void Cut(node *x,node *y)
{
	Access(x),Splay(y);
	if (y->Fa==x) y->Fa=null;else Access(y),Splay(x),x->Fa=null;
}

int main()
{
	null=Nd;
	read(n),read(Q);
	For(i,1,n+1) Nd[i]=(node){null,null,null,1,1,0,0,1,1};
	Nd[0]=(node){null,null,null,0,0,0,0,1,0};
	For(i,1,n) read(x),read(y),Link(Nd+x,Nd+y);
	while (Q--)
	{
		scanf("%s",S);read(x),read(y);
		if (S[0]=='+') read(c),Evert(Nd+x),Access(Nd+y)->Change(1,c);
		if (S[0]=='-') read(s),read(t),Cut(Nd+x,Nd+y),Link(Nd+s,Nd+t);
		if (S[0]=='*') read(c),Evert(Nd+x),Access(Nd+y)->Change(c,0);
		if (S[0]=='/') Evert(Nd+x),printf("%d\n",Access(Nd+y)->Sum);
	}
}
Problem2648
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (T[x].L)
#define Rsn (T[x].R)
using namespace std;

int IN()
{
	int c,x,f;
	while (!isdigit(c=getchar())&&c!='-');(c=='-')?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=500000+19,oo=(1<<30)-1;
int n,m;

//KD-Tree
struct Node
{
	int A[2],S[2],B[2],L,R;
} T[2*N];
int P[2],d,rt,Ans;

bool cmp(Node A,Node B) {return A.A[d]<B.A[d];}
void Update(int x)
{
	For(i,0,2)
	{
		T[x].B[i]=T[x].S[i]=T[x].A[i];
		if (Lsn)
			T[x].B[i]=max(T[x].B[i],T[Lsn].B[i]),
			T[x].S[i]=min(T[x].S[i],T[Lsn].S[i]);
		if (Rsn)
			T[x].B[i]=max(T[x].B[i],T[Rsn].B[i]),
			T[x].S[i]=min(T[x].S[i],T[Rsn].S[i]);
	}
}
int Build(int L,int R,int D)
{
	int x=L+R>>1;
	d=D,nth_element(T+L,T+x,T+R+1,cmp);
	if (L<x) Lsn=Build(L,x-1,(D+1)%2);
	if (x<R) Rsn=Build(x+1,R,(D+1)%2);
	return Update(x),x;
}
void Insert(int &x,int D)
{
	if (!x)
	{
		x=++n;
		For(i,0,2) T[x].B[i]=T[x].S[i]=T[x].A[i]=P[i];
		return;
	}
	For(i,0,2)
		T[x].S[i]=min(T[x].S[i],P[i]),
		T[x].B[i]=max(T[x].B[i],P[i]);
	Insert(P[D]<T[x].A[D]?Lsn:Rsn,(D+1)%2);
}
int TDis(int x,int *A)
{
	int Ans=0;
	For(i,0,2)
	{
		if (A[i]<T[x].S[i]) Ans+=T[x].S[i]-A[i];
		if (A[i]>T[x].B[i]) Ans+=A[i]-T[x].B[i];
	}
	return Ans;
}
int QDis(int *A,int *B)
{
	int Ans=0;
	For(i,0,2) Ans+=abs(A[i]-B[i]);
	return Ans;
}
void Query(int x)
{
	Ans=min(Ans,QDis(T[x].A,P));
	int Tl=Lsn?TDis(Lsn,P):oo,Tr=Rsn?TDis(Rsn,P):oo;
	if (Tl<Tr)
	{
		if (Tl<Ans) Query(Lsn);
		if (Tr<Ans) Query(Rsn);
	} else
	{
		if (Tr<Ans) Query(Rsn);
		if (Tl<Ans) Query(Lsn);
	}
}

int main()
{
	n=IN(),m=IN();
	For(i,1,n+1) For(j,0,2) T[i].A[j]=IN();
	rt=Build(1,n,0);
	while (m--)
		if (IN()==1)
		{
			For(i,0,2) P[i]=IN();Insert(rt,0);
		} else
		{
			Ans=oo;For(i,0,2) P[i]=IN();Query(rt);
			printf("%d\n",Ans);
		}
}
Problem2648
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (T[x].L)
#define Rsn (T[x].R)
using namespace std;

const int N=500000+19,oo=(1<<30)-1,Len=20000000;
int n,m;char Buf[Len],*B=Buf;

int IN()
{
	int c,x,f;
	while (!isdigit(c=*B++)&&c!='-');(c=='-')?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=*B++)) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}
void Print(int x)
{
	if (!x) return;
	Print(x/10),putchar(x%10+'0');
}
void OUT(int x)
{
	if (!x) puts("0");else Print(x),puts("");
}

//KD-Tree
struct Node
{
	int A[2],S[2],B[2],L,R;
} T[2*N];
int P[2],d,rt,Ans;

bool cmp(Node A,Node B) {return A.A[d]<B.A[d];}
void Update(int x)
{
	For(i,0,2)
	{
		T[x].B[i]=T[x].S[i]=T[x].A[i];
		if (Lsn)
			T[x].B[i]=max(T[x].B[i],T[Lsn].B[i]),
			T[x].S[i]=min(T[x].S[i],T[Lsn].S[i]);
		if (Rsn)
			T[x].B[i]=max(T[x].B[i],T[Rsn].B[i]),
			T[x].S[i]=min(T[x].S[i],T[Rsn].S[i]);
	}
}
int Build(int L,int R,int D)
{
	int x=L+R>>1;
	d=D,nth_element(T+L,T+x,T+R+1,cmp);
	if (L<x) Lsn=Build(L,x-1,(D+1)%2);
	if (x<R) Rsn=Build(x+1,R,(D+1)%2);
	return Update(x),x;
}
void Insert(int &x,int D)
{
	if (!x)
	{
		x=++n;
		For(i,0,2) T[x].B[i]=T[x].S[i]=T[x].A[i]=P[i];
		return;
	}
	For(i,0,2)
		T[x].S[i]=min(T[x].S[i],P[i]),
		T[x].B[i]=max(T[x].B[i],P[i]);
	Insert(P[D]<T[x].A[D]?Lsn:Rsn,(D+1)%2);
}
int TDis(int x,int *A)
{
	int Ans=0;
	For(i,0,2)
	{
		if (A[i]<T[x].S[i]) Ans+=T[x].S[i]-A[i];
		if (A[i]>T[x].B[i]) Ans+=A[i]-T[x].B[i];
	}
	return Ans;
}
int QDis(int *A,int *B)
{
	int Ans=0;
	For(i,0,2) Ans+=abs(A[i]-B[i]);
	return Ans;
}
void Query(int x)
{
	Ans=min(Ans,QDis(T[x].A,P));
	int Tl=Lsn?TDis(Lsn,P):oo,Tr=Rsn?TDis(Rsn,P):oo;
	if (Tl<Tr)
	{
		if (Tl<Ans) Query(Lsn);
		if (Tr<Ans) Query(Rsn);
	} else
	{
		if (Tr<Ans) Query(Rsn);
		if (Tl<Ans) Query(Lsn);
	}
}

int main()
{
	fread(Buf,1,Len,stdin);
	n=IN(),m=IN();
	For(i,1,n+1) For(j,0,2) T[i].A[j]=IN();
	rt=Build(1,n,0);
	while (m--)
		if (IN()==1)
		{
			For(i,0,2) P[i]=IN();Insert(rt,0);
		} else
		{
			Ans=oo;For(i,0,2) P[i]=IN();Query(rt);
			OUT(Ans);
		}
}
Problem2654
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=50000+19,M=N*2;
struct Edge
{
	int x,y,z;
	bool operator < (const Edge& B) const {return z<B.z;}
} E[2][M];
int C[2],Fa[N],x,y,z,c,n,m,Need,L,R,res,Sum,cur,cnt;

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}
bool Check(int Delta)
{
	Sum=cur=cnt=0;
	For(i,1,n+1) Fa[i]=i;
	For(i,0,C[1])
	{
		while (cur<C[0]&&E[0][cur].z+Delta<=E[1][i].z)
		{
			int fx=Getf(E[0][cur].x),fy=Getf(E[0][cur].y);
			if (fx!=fy) Fa[fx]=fy,Sum+=E[0][cur].z+Delta,cnt++;cur++;
		}
		int fx=Getf(E[1][i].x),fy=Getf(E[1][i].y);
		if (fx!=fy) Fa[fx]=fy,Sum+=E[1][i].z;
	}
	while (cur<C[0])
	{
		int fx=Getf(E[0][cur].x),fy=Getf(E[0][cur].y);
		if (fx!=fy) Fa[fx]=fy,Sum+=E[0][cur].z+Delta,cnt++;cur++;
	}
	return cnt>=Need;
}

int main()
{
	n=IN(),m=IN(),Need=IN();
	For(i,0,m) x=IN()+1,y=IN()+1,z=IN(),c=IN(),E[c][C[c]++]=(Edge){x,y,z};
	sort(E[0],E[0]+C[0]);
	sort(E[1],E[1]+C[1]);
	L=-101,R=101;
	while (L<=R)
		if (Check(Mid)) res=Sum-Need*Mid,L=Mid+1;else R=Mid-1;
	printf("%d\n",res);
}
Problem2656
#include<cstdio>
#include<cstring>
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;

const int Maxn=14,Base=100000000;
char c[100+1];
struct Bign
{
	int Len,s[Maxn];
	void clear() {while (Len>1&&!s[Len-1]) Len--;}
	void reset() {memset(s,0,sizeof(s));Len=1;}
	void read()
	{
		reset();
		scanf("%s",c);int L=strlen(c);
		Len=L/8+(L%8!=0);
		for (int i=0;i<Len;i++)
			for (int j=max(L-i*8-8,0);j<L-i*8;j++) s[i]=s[i]*10+c[j]-'0';
	}
	void print()
	{
		printf("%d",s[Len-1]);
		for (int i=Len-2;i>=0;i--) printf("%08d",s[i]);puts("");
	}
	void shr()
	{
		for (int i=Len-1;i;i--) s[i-1]+=(s[i]&1)*Base,s[i]>>=1;
		s[0]>>=1;clear();
	}
} f,g,n;
int t;

Bign operator + (Bign A,Bign B)
{
	A.Len=max(A.Len,B.Len)+1;
	for (int i=0;i<A.Len;i++) A.s[i]+=B.s[i];
	for (int i=0;i<A.Len;i++) A.s[i+1]+=A.s[i]/Base,A.s[i]%=Base;
	A.clear();return A;
}
void calc()
{
	if (n.Len==1&&n.s[0]==1) {f.reset();g.reset();f.s[0]=g.s[0]=1;return;}
	int Flag=(n.s[0]&1);
	n.shr();calc();
	Flag?f=f+g:g=g+f;
}

int main()
{
	scanf("%d",&t);
	while (t--) n.read(),calc(),f.print();
}
Problem2656
#include<cstdio>
#include<cstring>
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;
const int Maxn=14,Base=100000000;char c[100+1];
struct Bign{int Len,s[Maxn];void clear() {while(Len>1&&!s[Len-1]) Len--;}
void reset() {memset(s,0,sizeof(s));Len=1;}
void rd(){reset();scanf("%s",c);int L=strlen(c);
Len=L/8+(L%8!=0);for (int i=0;i<Len;i++)for(int j=max(L-i*8-8,0);j<L-i*8;j++) s[i]=s[i]*10+c[j]-'0';
}void pt(){printf("%d",s[Len-1]);for(int i=Len-2;i>=0;i--) printf("%08d",s[i]);puts("");}
void shr(){for (int i=Len-1;i;i--) s[i-1]+=(s[i]&1)*Base,s[i]>>=1;s[0]>>=1;clear();}
}f,g,n;int t;Bign operator + (Bign A,Bign B){A.Len=max(A.Len,B.Len)+1;for (int i=0;i<A.Len;i++) A.s[i]+=B.s[i];
for (int i=0;i<A.Len;i++) A.s[i+1]+=A.s[i]/Base,A.s[i]%=Base;A.clear();return A;}
void C(){if (n.Len==1&&n.s[0]==1) {f.reset();g.reset();f.s[0]=g.s[0]=1;return;}int F=(n.s[0]&1);n.shr();C();F?f=f+g:g=g+f;
}int main(){scanf("%d",&t);while(t--)n.rd(),C(),f.pt();}
Problem2656
#include<cstdio>
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;
 
const int Base=100000000;
char c[100+1];
struct Bign
{
    int Len,s[14];
    void clear() {while (Len>1&&!s[Len-1]) Len--;}
    void reset() {for (int i=0;i<14;i++) s[i]=0;Len=1;}
    void read()
    {
		reset();
		scanf("%s",c);
		char *t=c;while(*t) t++;
		int w=1;
		while(t-->c)
		{
			s[Len-1]+=(*t-'0')*w;w*=10;
			if(w==Base)	s[++Len]=0,w=1;
		}
		clear();
    }
    void print()
    {
        printf("%d",s[Len-1]);
        for (int i=Len-2;i>=0;i--) printf("%08d",s[i]);puts("");
    }
    void shr()
    {
        for (int i=Len-1;i;i--) s[i-1]+=(s[i]&1)*Base,s[i]>>=1;
        s[0]>>=1;clear();
    }
    void operator += (Bign B)
    {
    	Len=max(Len,B.Len)+1;
    	for (int i=0;i<Len;i++) s[i]+=B.s[i];
    	for (int i=0;i<Len;i++) s[i+1]+=s[i]/Base,s[i]%=Base;
    	clear();
    }
} f,g,n;
int t;

void calc()
{
    if (n.Len==1&&n.s[0]==1) {f.reset();g.reset();f.s[0]=g.s[0]=1;return;}
    int Flag=(n.s[0]&1);
    n.shr();calc();
    Flag?f+=g:g+=f;
}
 
int main()
{
    scanf("%d",&t);
    while (t--) n.read(),calc(),f.print();
}
Problem2657
#include<map>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=200000+19;
struct Edge {int y,nxt;} E[N*2];
typedef pair<int,int> PII;
map<PII,int> Map;
int n,x,y,z,Max,ID,cnt;
int Dis[N],Last[N];

void Link(int i,int x,int y)
{
	PII A=make_pair(x,y);int j;
	if (j=Map[A])
	{
		E[cnt]=(Edge){j,Last[i]};Last[i]=cnt++;
		E[cnt]=(Edge){i,Last[j]};Last[j]=cnt++;
	} else Map[A]=i;
}

void DFS(int x,int Fa,int D)
{
	Dis[x]=D;
	for (int i=Last[x];~i;i=E[i].nxt) if (E[i].y!=Fa) DFS(E[i].y,x,D+1);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n),n-=2;
	For(i,1,n+1)
	{
		read(x),read(y),read(z);
		if (x>y) swap(x,y);
		if (y>z) swap(y,z);
		if (x>y) swap(x,y);
		Link(i,x,y),Link(i,x,z),Link(i,y,z);
	}
	DFS(1,-1,1);
	Max=0;For(i,1,n+1) if (Dis[i]>Max) Max=Dis[i],ID=i;
	DFS(ID,-1,1);
	Max=0;For(i,1,n+1) if (Dis[i]>Max) Max=Dis[i];
	printf("%d\n",Max);
}
Problem2658
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Fir first
#define Sec second
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=40000+19;
typedef long long LL;
struct Point
{
	int x,y;
	bool operator < (const Point& B) const {return x<B.x;}
} A[100000+19];
int R,C,n,cur;LL Ans;

struct node *null;
struct node
{
	node *L,*R;
	int S,Add,H;LL Ans;

	void SetAdd(int v) {if (this!=null) Add+=v,H+=v;}
	void Down() {if (Add) L->SetAdd(Add),R->SetAdd(Add),Add=0;}
	void Update()
	{
		if (this==null) return;Down();
		S=L->S+R->S+1;
		Ans=L->Ans+R->Ans+1LL*(L->S)*(L->S+1)/2LL*(L->H-H)+1LL*(R->S)*(R->S+1)/2LL*(R->H-H);
	}
} Nd[N],*Rt;
typedef node* rt;
typedef pair<rt,rt> Drt;

rt Merge(rt A,rt B)
{
	if (A==null) return B;
	if (B==null) return A;
	A->Down(),B->Down();
	if (A->H<B->H) return A->R=Merge(A->R,B),A->Update(),A;
		else return B->L=Merge(A,B->L),B->Update(),B;
}
Drt Split(rt A,int k)
{
	if (A==null) return Drt(null,null);
	A->Down();Drt x;
	if (A->L->S>=k) x=Split(A->L,k),A->L=x.Sec,A->Update(),x.Sec=A;
		else x=Split(A->R,k-A->L->S-1),A->R=x.Fir,A->Update(),x.Fir=A;
	return x;
}

rt Build(int L,int R)
{
	if (L>R) return null;
	rt A=Nd+Mid;
	A->L=Build(L,Mid-1),A->R=Build(Mid+1,R);
	return A->H=A->Add=0,A->Update(),A;
}

int main()
{
	null=Nd;
	R=IN(),C=IN(),n=IN();
	For(i,0,n) A[i].x=IN(),A[i].y=IN();
	sort(A,A+n);
	Rt=Build(1,C);
	Ans=1LL*R*(R+1)/2LL*C*(C+1)/2LL;
	For(i,1,R+1)
	{
		Rt->SetAdd(1);
		while (cur<n&&A[cur].x==i)
		{
			Drt x=Split(Rt,A[cur].y-1),y=Split(x.Sec,1);
			Nd[A[cur].y]=(node){null,null,0,0,0,0};
			Rt=Merge(Merge(x.Fir,y.Fir),y.Sec);cur++;
		}
		Ans-=Rt->Ans+1LL*C*(C+1)/2LL*Rt->H;
	}
	printf("%lld\n",Ans);
}
Problem2659
#include<cstdio>
using namespace std;

long long p,q;

int main()
{
	scanf("%lld%lld",&p,&q);
	if (p==q) printf("%lld\n",(p-1)*(p+1)/4);
		else printf("%lld\n",(p-1)*(q-1)/4);
}
Problem2661
#include <cstdio>
#include <cmath>
#include <algorithm>
 
using namespace std;
const int N = 2005;
const int M = N * 100;
const int inf = (int) 1e9;
 
struct edges {
    int next, to, f, cost;
    edges() {}
    edges(int _n, int _t, int _f, int _c) : next(_n), to(_t), f(_f), cost(_c) {}
} e[M];
  
int n, S, T;
int first[N], tot = 1;
int d[N], g[N], q[N];
bool v[N];
 
   
inline void Add_Edges(int x, int y, int f, int c) {
    e[++tot] = edges(first[x], y, f, c), first[x] = tot;
    e[++tot] = edges(first[y], x, 0, -c), first[y] = tot;
}
  
inline int calc() {
    int flow = inf, x;
    for (x = g[T]; x; x = g[e[x ^ 1].to])
        flow = min(flow, e[x].f);
    for (x = g[T]; x; x = g[e[x ^ 1].to])
        e[x].f -= flow, e[x ^ 1].f += flow;
    return flow;
}
  
bool spfa() {
    int x, y, l, r;
    for (x = 1; x <= T; ++x)
        d[x] = inf;
    d[S] = 0, v[S] = 1, q[0] = S;
    for(l = r = 0; l != (r + 1) % N; ++l %= N) {
        for (x = first[q[l]]; x; x = e[x].next)
            if (d[q[l]] + e[x].cost < d[y = e[x].to] && e[x].f) {
                d[y] = d[q[l]] + e[x].cost, g[y] = x;
                if (!v[y])
                    q[++r %= N] = y, v[y] = 1;
            }
        v[q[l]] = 0;
    }
    return d[T] != inf;
}
 
inline void work() {
    int ans1 = 0, ans2 = 0, del;
    while (spfa()) {
        del = calc();
        ans1 += del, ans2 += del * d[T];
    }
    printf("%d %d\n", ans1 >> 1, -ans2 >> 1);
}
 
inline int sqr(int x) {
    return x * x;
}
 
inline int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
 
inline bool check(int a, int b) {
    int t = sqr(b) - sqr(a);
    if (sqr((int) sqrt(t)) != t) return 0;
    return gcd(a, (int) sqrt(t)) == 1;
}
 
int main() {
    int a, b, i, j;
    scanf("%d%d", &a, &b);
    S = (b - a + 1) << 1 | 1, T = S + 1;
    for (i = a; i <= b; ++i)
        for (j = a; j < i; ++j) if (check(j, i))
            Add_Edges(i - a + 1, j + b - a * 2 + 2, 1, - i - j),
            Add_Edges(j - a + 1, i + b - a * 2 + 2, 1, - i - j);
    for (i = a; i <= b; ++i)
        Add_Edges(S, i - a + 1, 1, 0), Add_Edges(i + b - a * 2 + 2, T, 1, 0);
    work();
    return 0;
}
Problem2662
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=50+19,Len=50*50;
struct Edge {int y,z,nxt;} E[1000*2+19];
int Last[N],Dis[N][N],Q[N*N+19][2],vis[N][N];
int n,m,k,cnt,x,y,z,f,w,Ans=(1<<30)-1;

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

inline void Update(int x,int y,int D)
{
	if (D<Dis[x][y])
	{
		Dis[x][y]=D;
		if (!vis[x][y])
		{
			vis[x][y]=1;
			if (Dis[x][y]<Dis[Q[w+1][0]][Q[w+1][1]]) Q[w][0]=x,Q[w][1]=y,w--;
				else f=f%Len+1,Q[f][0]=x,Q[f][1]=y;
		}
	}
}
void SPFA()
{
	f=1,w=0;Q[1][0]=1,Q[1][1]=0;
	memset(Dis,60,sizeof(Dis));Dis[1][0]=0;
	while (f!=w)
	{
		w=w%Len+1,x=Q[w][0],y=Q[w][1];vis[x][y]=0;
		for (int i=Last[x];~i;i=E[i].nxt)
		{
			Update(E[i].y,y,Dis[x][y]+E[i].z);
			if (y<k) Update(E[i].y,y+1,Dis[x][y]+E[i].z/2);
		}
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d%d",&n,&m,&k);
	For(i,0,m) scanf("%d%d%d",&x,&y,&z),Link(x,y,z);
	SPFA();
	For(i,0,k+1) Ans=min(Ans,Dis[n][i]);
	printf("%d\n",Ans);
}
Problem2668
//若一个点既是入又是出 相当于从In往Out免费流1 
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int P=20+3,N=P*P*2,oo=(1<<30)-1;
struct Edge {int x,y,f,c,nxt;} E[N*(8+4)];
int All[2],cnt[P][P],ID[P][P];
int Last[N],vis[N],Dis[N],Q[10*N],pre[N];
int n,m,Ecnt,S,T,tot,Flow,Cost;
int Dx[8]={1,1,1,0,0,-1,-1,-1},Dy[8]={-1,0,1,-1,1,-1,0,1};
char s[P][P];

void Add_Edge(int x,int y,int f,int c)
{
	E[Ecnt]=(Edge){x,y,f,c,Last[x]};Last[x]=Ecnt++;
	E[Ecnt]=(Edge){y,x,0,-c,Last[y]};Last[y]=Ecnt++;
}

bool SPFA()
{
	memset(Dis,64,sizeof(Dis));Dis[S]=0,pre[S]=-1;
	int f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];vis[x]=0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[x]+E[i].c<Dis[E[i].y])
			{
				pre[E[i].y]=i;
				Dis[E[i].y]=Dis[x]+E[i].c;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
	}
	return Dis[T]<oo;
}
void Update()
{
	int Min=oo;
	for (int i=pre[T];~i;i=pre[E[i].x]) Min=min(Min,E[i].f);
	for (int i=pre[T];~i;i=pre[E[i].x]) E[i].f-=Min,E[i^1].f+=Min;
	Flow+=Min,Cost+=Min*Dis[T];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	For(i,1,n+1) For(j,1,m+1) ID[i][j]=++tot;
	S=n*m*2+1,T=S+1;

	For(t,0,2)
	{
		For(i,1,n+1) scanf("%s",s[i]+1);
		For(i,1,n+1) For(j,1,m+1)
		{
			cnt[i][j]+=s[i][j]-'0';
			if (s[i][j]=='1')
				All[t]++,!t?Add_Edge(S,ID[i][j],1,0):Add_Edge(ID[i][j]+n*m,T,1,0);
		}
	}
	if (All[0]!=All[1]) return puts("-1"),0;
	For(i,1,n+1) scanf("%s",s[i]+1);
	For(i,1,n+1) For(j,1,m+1)
	{
		Add_Edge(ID[i][j],ID[i][j]+n*m,(s[i][j]-'0'+cnt[i][j])/2,0);
		For(k,0,8)
		{
			int tx=i+Dx[k],ty=j+Dy[k];
			if (tx<1||tx>n||ty<1||ty>m) continue;
			Add_Edge(ID[i][j]+n*m,ID[tx][ty],oo,1);
		}
	}
	while (SPFA()) Update();
	if (Flow!=All[0]) return puts("-1"),0;
	printf("%d\n",Cost);
}
Problem2679
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=20+19;

map<int,Vi> M;
int A[N],vis[1<<21];
int n,m,res;

void DFS_1(int x,int s,int b){
	if (x==m){
		M[s].pb(b);
		return;
	}
	DFS_1(x+1,s,b);
	DFS_1(x+1,s+A[x],b|1<<x);
	DFS_1(x+1,s-A[x],b|1<<x);
}
void DFS_2(int x,int s,int b){
	if (x==n){
		if (M.count(s)){
			For(i,0,M[s].size()){
				vis[b|M[s][i]]=1;
			}
		}
		return;
	}
	DFS_2(x+1,s,b);
	DFS_2(x+1,s+A[x],b|1<<x);
	DFS_2(x+1,s-A[x],b|1<<x);
}

int main(){
	n=IN();
	For(i,0,n) A[i]=IN();
	m=n/2;
	DFS_1(0,0,0);
	DFS_2(m,0,0);
	For(i,1,1<<n) res+=vis[i];
	printf("%d\n",res);
}
Problem2679
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=20+19;

map<int,int> M;
Vi V[60000];
int A[N],vis[1<<21];
int n,m,res,tot;

void DFS_1(int x,int s,int b){
	if (x==m){
		if (!M.count(s)) M[s]=++tot;
		V[M[s]].pb(b);
		return;
	}
	DFS_1(x+1,s,b);
	DFS_1(x+1,s+A[x],b|1<<x);
	DFS_1(x+1,s-A[x],b|1<<x);
}
void DFS_2(int x,int s,int b){
	if (x==n){
		if (M.count(s)){
			int id=M[s];
			For(i,0,V[id].size()){
				vis[b|V[id][i]]=1;
			}
		}
		return;
	}
	DFS_2(x+1,s,b);
	DFS_2(x+1,s+A[x],b|1<<x);
	DFS_2(x+1,s-A[x],b|1<<x);
}

int main(){
	n=IN();
	For(i,0,n) A[i]=IN();
	m=n/2;
	DFS_1(0,0,0);
	DFS_2(m,0,0);
	For(i,1,1<<n) res+=vis[i];
	printf("%d\n",res);
}
Problem2683
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int W=500000+19,N=400000+19;
struct Event
{
	int opt,x,a,L,R,pos,ID;
	bool operator < (const Event& B) const {return x<B.x||x==B.x&&pos<B.pos;}
} E[N],tmp[N];
int Ans[N],C[W],T[W];
int n,w,opt,x,y,A,x1,y1,x2,y2,Time,cnt;

void Update(int x,int v)
{
	for (int i=x;i<=w;i+=i&-i)
	{
		if (T[i]!=Time) T[i]=Time,C[i]=0;
		C[i]+=v;
	}
}
int Query(int x)
{
	int Ans=0;
	for (int i=x;i;i-=i&-i) Ans+=(T[i]==Time?C[i]:0);
	return Ans;
}

void CDQ(int L,int R)
{
	if (L==R) return;
	Time++;
	For(i,L,R+1)
	{
		if (E[i].pos<=Mid&&E[i].opt==1) Update(E[i].L,E[i].a);
		if (E[i].pos>Mid&&E[i].opt==2) Ans[E[i].ID]+=E[i].a*(Query(E[i].R)-Query(E[i].L-1));
	}
	int Tl=L,Tr=Mid+1;
	For(i,L,R+1) if (E[i].pos<=Mid) tmp[Tl++]=E[i];else tmp[Tr++]=E[i];
	For(i,L,R+1) E[i]=tmp[i];
	CDQ(L,Mid);CDQ(Mid+1,R);
}

int main()
{
	read(w);
	while ((read(opt),opt)!=3)
		if (opt==1)
		{
			read(x),read(y),read(A);
			n++;E[n]=(Event){1,x,A,y,0,n,0};
		} else
		{
			read(x1),read(y1),read(x2),read(y2);cnt++;
			n++;E[n]=(Event){2,x1-1,-1,y1,y2,n,cnt};
			n++;E[n]=(Event){2,x2,1,y1,y2,n,cnt};
		}
	sort(E+1,E+n+1);
	CDQ(1,n);
	For(i,1,cnt+1) printf("%d\n",Ans[i]);
}
Problem2693
#include<cstdio>
#include<algorithm>
using namespace std;

const int top=10000000,Maxn=top+19,Mod=100000009;
long long g[Maxn];
int vis[Maxn],p[Maxn],cnt,n,m,T,Ans;

int main()
{
    g[1]=1;
    for (int i=2;i<=top;i++)
	{
	    if (!vis[i]) p[cnt++]=i,g[i]=1-i+Mod;
	    for (int j=0;j<cnt&&p[j]*i<=top;j++)
		{
		    vis[p[j]*i]=1;
		    if (i%p[j]==0) {g[p[j]*i]=g[i];break;}
			    else g[p[j]*i]=g[p[j]]*g[i]%Mod;
		}
	}
    for (int i=2;i<=top;i++) g[i]=(g[i-1]+g[i]*i%Mod)%Mod;
    scanf("%d",&T);
    while (T--)
	{
	    scanf("%d%d",&n,&m);Ans=0;
	    for (int L=1,R;L<=n&&L<=m;L=R+1)
		{
		    R=min(n/(n/L),m/(m/L));
			(Ans+=1LL*(g[R]-g[L-1]+Mod)%Mod*
				(1LL*(n/L)*(n/L+1)/2LL%Mod)%Mod*
				(1LL*(m/L)*(m/L+1)/2LL%Mod)%Mod)%=Mod;
		}
	    printf("%d\n",Ans);
	}
}
Problem2693
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int top=10000000,Maxn=top+19,Mod=100000009;
int vis[Maxn],p[Maxn],g[Maxn],cnt,n,m,T,Ans;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
    g[1]=1;
    for (int i=2;i<=top;i++)
	{
	    if (!vis[i]) p[cnt++]=i,g[i]=1-i+Mod;
	    for (int j=0,_=top/i;j<cnt&&p[j]<=_;j++)
		{
		    vis[p[j]*i]=1;
		    if (i%p[j]==0) {g[p[j]*i]=g[i];break;}
			    else g[p[j]*i]=1LL*g[p[j]]*g[i]%Mod;
		}
	}
    for (int i=2;i<=top;i++) g[i]=(g[i-1]+1LL*g[i]*i%Mod)%Mod;
    read(T);
    while (T--)
	{
	    read(n),read(m),Ans=0;
	    for (int L=1,R;L<=n&&L<=m;L=R+1)
		{
		    R=min(n/(n/L),m/(m/L));
			(Ans+=1LL*(g[R]-g[L-1]+Mod)%Mod*
				(1LL*(n/L)*(n/L+1)/2LL%Mod)%Mod*
				(1LL*(m/L)*(m/L+1)/2LL%Mod)%Mod)%=Mod;
		}
	    printf("%d\n",Ans);
	}
}
Problem2697
#include<cstdio>
#include<algorithm>
using namespace std;

int A[1000+19],n,k,Ans;

int main()
{
	scanf("%d%d",&n,&k);n--;
	for (int i=1;i<=k;i++) scanf("%d",&A[i]);
	sort(A+1,A+k+1);
	for (int i=k;i>=1&&n>=1;i--,n-=2) Ans+=A[i]*n;
	printf("%d\n",Ans);
}
Problem2705
#include<cstdio>
using namespace std;

typedef long long LL;

LL phi(LL n)
{
	LL Ans=n;
	for (LL i=2;i*i<=n;i++)
		if (!(n%i))
		{
			Ans=Ans/i*(i-1);
			while (!(n%i)) n/=i;
		}
	if (n>1) Ans=Ans/n*(n-1);
	return Ans;
}

int main()
{
	LL n,Ans=0;
	scanf("%lld",&n);
	for (LL i=1;i*i<=n;i++)
		if (!(n%i))
		{
			Ans+=i*phi(n/i);
			if (i*i!=n) Ans+=(n/i)*phi(n/(n/i));
		}
	printf("%lld\n",Ans);
	//for(;;);
	return 0;
}
Problem2716
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (T[x].L)
#define Rsn (T[x].R)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1000000+19,oo=(1<<30)-1;

//KD-Tree
struct Node
{
	int A[2],B[2],S[2],L,R;
} T[N];
int P[2],n,m,d,Ans,rt;

bool cmp(Node A,Node B) {return A.A[d]<B.A[d];}
void Update(int x)
{
	For(i,0,2)
	{
		T[x].B[i]=T[x].S[i]=T[x].A[i];
		if (Lsn)
			T[x].B[i]=max(T[x].B[i],T[Lsn].B[i]),
			T[x].S[i]=min(T[x].S[i],T[Lsn].S[i]);
		if (Rsn)
			T[x].B[i]=max(T[x].B[i],T[Rsn].B[i]),
			T[x].S[i]=min(T[x].S[i],T[Rsn].S[i]);
	}
}
int Build(int L,int R,int D)
{
	int x=(L+R>>1);
	d=D,nth_element(T+L,T+x,T+R+1,cmp);
	if (L<x) Lsn=Build(L,x-1,(D+1)%2);
	if (x<R) Rsn=Build(x+1,R,(D+1)%2);
	return Update(x),x;
}
void Insert(int &x,int D)
{
	if (!x)
	{
		x=++n;For(i,0,2) T[x].B[i]=T[x].S[i]=T[x].A[i]=P[i];
		return;
	}
	For(i,0,2) T[x].B[i]=max(T[x].B[i],P[i]),T[x].S[i]=min(T[x].S[i],P[i]);
	Insert(P[D]<T[x].A[D]?Lsn:Rsn,(D+1)%2);
}
int QDis(int x,int *A)
{
	int Ans=0;
	For(i,0,2) Ans+=abs(A[i]-T[x].A[i]);
	return Ans;
}
int TDis(int x,int *A)
{
	int Ans=0;
	For(i,0,2)
	{
		if (A[i]<T[x].S[i]) Ans+=T[x].S[i]-A[i];
		if (A[i]>T[x].B[i]) Ans+=A[i]-T[x].B[i];
	}
	return Ans;
}
void Query(int x)
{
	Ans=min(Ans,QDis(x,P));
	int Tl=Lsn?TDis(Lsn,P):oo,Tr=Rsn?TDis(Rsn,P):oo;
	if (Tl<Tr)
	{
		if (Tl<Ans) Query(Lsn);
		if (Tr<Ans) Query(Rsn);
	} else
	{
		if (Tr<Ans) Query(Rsn);
		if (Tl<Ans) Query(Lsn);
	}
}

int main()
{
	n=IN(),m=IN();
	For(i,1,n+1) For(j,0,2) T[i].A[j]=IN();
	rt=Build(1,n,0);
	while (m--)
		if (IN()==1)
		{
			For(i,0,2) P[i]=IN();
			Insert(rt,0);
		} else
		{
			For(i,0,2) P[i]=IN();
			Ans=oo;Query(rt);printf("%d\n",Ans);
		}
}
Problem2716
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<climits>
using namespace std;
#define For(i,a,b) for(int i=(a);i<=(b);i++)
#define Forn(i,a,b) for(int i=(a);i>=(b);i--)
#define NC getchar
inline int read(){
	int x=0,f=1;char c=NC();for(;c<'0'||c>'9';c=NC())if(c=='-')f=-1;
	for(;c>='0'&&c<='9';c=NC())x=x*10+c-'0';return x*f;
}
int n,m;
#define N 2000010
struct node{
	int x,y,k,id;
	inline void Read(){
		x=read()+1,y=read()+1;
	}
}g[N],Tmp[N];
int maxx,ans[N],c[N];
inline int lowbit(int x){return x&-x;}
inline int ask(int x){
	int nowans=0;for(;x;x-=lowbit(x))nowans=max(nowans,c[x]);
	return nowans;
}
inline void add(int x,int d){
	for(;x<=maxx;x+=lowbit(x))c[x]=max(c[x],d);
}
inline void clear(int x){
	for(;x<=maxx;x+=lowbit(x))c[x]=0;
}
inline int cmp(const node &a,const node &b){
	return (a.x!=b.x)?a.x<b.x:a.id<b.id;
}
inline void CDQ(int l,int r){
	if(l>=r)return;
	int mid=(l+r)>>1;
	int l1=l-1,l2=mid;
	For(i,l,r)if(g[i].id<=mid)Tmp[++l1]=g[i];else Tmp[++l2]=g[i];
	For(i,l,r)g[i]=Tmp[i];CDQ(l,mid);
	int j=l;
	For(i,mid+1,r)if(g[i].k==2){
		for(;j<=mid&&g[j].x<=g[i].x;j++)if(g[j].k==1){
			add(g[j].y,g[j].y+g[j].x);
		}int tmp=ask(g[i].y);
		if(tmp)ans[g[i].id]=min(ans[g[i].id],g[i].x+g[i].y-tmp);
	}
	For(i,l,j-1)if(g[i].k==1)clear(g[i].y);
	CDQ(mid+1,r);
	l1=l,l2=mid+1;
	For(i,l,r)if(cmp(g[l1],g[l2])&&l1<=mid)Tmp[i]=g[l1++];
	else if(l2<=r)Tmp[i]=g[l2++];else Tmp[i]=g[l1++];
	For(i,l,r)g[i]=Tmp[i];
}
int main(){
	n=read();m=read();For(i,1,n){
		g[i].Read(),g[i].k=1,g[i].id=i;
		maxx=max(maxx,max(g[i].x,g[i].y));
	}
	For(i,n+1,m+n){
		g[i].k=read();g[i].Read();g[i].id=i;
		maxx=max(maxx,max(g[i].x,g[i].y));
	}maxx++;
	memset(ans,60,sizeof(ans));
	sort(g+1,g+n+m+1,cmp);CDQ(1,n+m);
	For(i,1,n+m)g[i].x=maxx-g[i].x;
	sort(g+1,g+n+m+1,cmp);CDQ(1,n+m);
	For(i,1,n+m)g[i].y=maxx-g[i].y;
	sort(g+1,g+n+m+1,cmp);CDQ(1,n+m);
	For(i,1,n+m)g[i].x=maxx-g[i].x;
	sort(g+1,g+n+m+1,cmp);CDQ(1,n+m);
	For(i,1,n+m)if(ans[i]<1e9)printf("%d\n",ans[i]);
}
Problem2716
#include<stdio.h>
#include<algorithm>
#define lowbit(o) o&-o
#define inf 1000000000
#define N 1000006
#define M 1000005
using namespace std;
int f[N],i,j,k,l,s,n,m,x,y,id,p,tot;
struct node {
	int x,y,b,v,c,t;
}a[M],b[M],c[M];
int ans[M];
inline int max(int o,int p) {
	if (o>p) return o;
	return p;
}

inline void add(int o,int p,int w,int u,int e) {
	a[++tot].b=o; a[tot].x=p; a[tot].y=w; a[tot].v=u;
	a[tot].c=e; a[tot].t=tot;
}
inline bool cmp(const node &x,const node &y) {
	return x.x<y.x;
}
inline bool cmp1(const node &x,const node &y) {
	return x.x>y.x;
}
inline void add(int o,int p) {
	for (;o<=N-5;o+=lowbit(o)) f[o]=max(f[o],p);
}
inline int ask(int o) {
	int s=-inf;
	for (;o;o-=lowbit(o)) s=max(s,f[o]);
	return s;
}
inline int fg(int o) {
	for (;o<=N-5;o+=lowbit(o)) f[o]=-inf;
}
inline void Add(int o,int p) {
	for (;o;o-=lowbit(o)) f[o]=max(f[o],p);
}
inline int Ask(int o) {
	int s=-inf;
	for (;o<=N-5;o+=lowbit(o)) s=max(s,f[o]);
	return s;
}
inline int Fg(int o) {
	for (;o;o-=lowbit(o)) f[o]=-inf;
}
inline void work(int l,int r) {
	//x>x1 y>y1
	if (l>=r) return ;
	int mid=(l+r)>>1;
	work(l,mid); work(mid+1,r);
	int gt=0,GT=0;
	for (int i=l;i<=mid;i++) if (a[i].b==1) b[++gt]=a[i];
	for (int i=mid+1;i<=r;i++) if (a[i].b==2) c[++GT]=a[i];
	sort(b+1,b+1+gt,cmp); sort(c+1,c+1+GT,cmp);
	int j=1;
	for (int i=1;i<=GT;i++) {
		while (b[j].x<=c[i].x&&j<=gt) {
			add(b[j].y,b[j].x+b[j].y);
			j++;
		}
		ans[c[i].c]=min(ans[c[i].c],c[i].x+c[i].y-ask(c[i].y));
	}
	for (int i=1;i<j;i++) fg(b[i].y);
}	
inline void work1(int l,int r) {
	//x<x1 y<y1
	if (l>=r) return ;
	int mid=(l+r)>>1;
	work1(l,mid); work1(mid+1,r);
	int gt=0,GT=0;
	for (int i=l;i<=mid;i++) if (a[i].b==1) b[++gt]=a[i];
	for (int i=mid+1;i<=r;i++) if (a[i].b==2) c[++GT]=a[i];
	sort(b+1,b+1+gt,cmp1); sort(c+1,c+1+GT,cmp1);
	int j=1;
	for (int i=1;i<=GT;i++) {
		while (b[j].x>=c[i].x&&j<=gt) {
			Add(b[j].y,-b[j].x-b[j].y);
			j++;
		}
		ans[c[i].c]=min(ans[c[i].c],-c[i].x-c[i].y-Ask(c[i].y));
	}
	for (int i=1;i<j;i++) Fg(b[i].y);
}	
inline void work2(int l,int r) {
	//x>x1 y<y1
	if (l>=r) return ;
	int mid=(l+r)>>1;
	work2(l,mid); work2(mid+1,r);
	int gt=0,GT=0;
	for (int i=l;i<=mid;i++) if (a[i].b==1) b[++gt]=a[i];
	for (int i=mid+1;i<=r;i++) if (a[i].b==2) c[++GT]=a[i];
	sort(b+1,b+1+gt,cmp); sort(c+1,c+1+GT,cmp);
	int j=1;
	for (int i=1;i<=GT;i++) {
		while (b[j].x<=c[i].x&&j<=gt) {
			Add(b[j].y,b[j].x-b[j].y);
			j++;
		}
		ans[c[i].c]=min(ans[c[i].c],c[i].x-c[i].y-Ask(c[i].y));
	}
	for (int i=1;i<j;i++) Fg(b[i].y);
}	
inline void work3(int l,int r) {
	//x<x1 y>y1
	if (l>=r) return ;
	int mid=(l+r)>>1;
	work3(l,mid); work3(mid+1,r);
	int gt=0,GT=0;
	for (int i=l;i<=mid;i++) if (a[i].b==1) b[++gt]=a[i];
	for (int i=mid+1;i<=r;i++) if (a[i].b==2) c[++GT]=a[i];
	sort(b+1,b+1+gt,cmp1); sort(c+1,c+1+GT,cmp1);
	int j=1;
	for (int i=1;i<=GT;i++) {
		while (b[j].x>=c[i].x&&j<=gt) {
			add(b[j].y,-b[j].x+b[j].y);
			j++;
		}
		ans[c[i].c]=min(ans[c[i].c],-c[i].x+c[i].y-ask(c[i].y));
	}
	for (int i=1;i<j;i++) fg(b[i].y);
}	
inline int in() {
	char c=getchar();
	int s=0;
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') s=s*10+c-48,c=getchar();
	return s;
}
int main() {
	scanf("%d%d",&n,&m);
	for (i=1;i<=n;i++) {
		x=in()+1,y=in()+1,add(1,x,y,1,p);
	}
	for (i=1;i<=m;i++) {
		scanf("%d",&id);
		if (id==1) {
			x=in()+1,y=in()+1,add(1,x,y,1,p);
		}
		else {
			x=in()+1,y=in()+1,add(2,x,y,1,++p),ans[p]=inf;
		}
	}
	for (i=1;i<=N-5;i++) f[i]=-inf;
	work(1,tot);
	work1(1,tot);
	work2(1,tot);
	work3(1,tot);
	for (i=1;i<=p;i++) printf("%d\n",ans[i]);
}
	
Problem2724
#include<cstdio>
#include<cstring>
#include<cctype>
#include<cmath>
#include<vector>
#include<algorithm>

#define ID(x) ((x-1)/S+1)
#define L(x) ((x-1)*S+1)
#define R(x) (x==tot?n:x*S)
#define all(V) V.begin(),V.end()
using namespace std;

const int Maxn=40000+19,Tot=1000+19;
typedef int one[Maxn];
one A,cnt,B,C;
vector<int> V[Maxn];
int Ans[Tot][Tot];
int n,Q,S,Ql,Qr,tot,pos,Lans,cur;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int calc(int x,int L,int R)
{
	return upper_bound(all(V[x]),R)-lower_bound(all(V[x]),L);
}
int cmp(int a,int b) {return A[a]<A[b];}

int main()
{
	read(n),read(Q);
	S=sqrt(n/(log(n)/log(2)));if (!S) S++;tot=n/S+(n%S!=0);
	for (int i=1;i<=n;i++) read(A[i]),B[i]=i;
	sort(B+1,B+n+1,cmp);
	for (int L=1,R=1;L<=n;L=R+1,R=L)
	{
		while (A[B[R]]==A[B[R+1]]) R++;
		C[++cur]=A[B[L]];for (int i=L;i<=R;i++) A[B[i]]=cur;
	}
	for (int i=1;i<=n;i++) V[A[i]].push_back(i);
	for (int i=1;i<=n;i++) sort(V[i].begin(),V[i].end());
	for (int i=1;i<=tot;i++)
	{
		memset(cnt,0,sizeof(cnt));pos=0;
		for (int j=i;j<=tot;j++)
		{
			for (int k=L(j);k<=R(j);k++) 
			{
				cnt[A[k]]++;
				if (cnt[A[k]]>cnt[pos]||cnt[A[k]]==cnt[pos]&&A[k]<pos) pos=A[k];
			}
			Ans[i][j]=pos;
		}
	}
	while (Q--)
	{
		read(Ql),read(Qr);
		Ql=(Ql+Lans-1)%n+1;
		Qr=(Qr+Lans-1)%n+1;if (Ql>Qr) swap(Ql,Qr);
		Lans=0;
		if (ID(Ql)+1>=ID(Qr))
		{
			for (int i=Ql;i<=Qr;i++) cnt[A[i]]=0;
			for (int i=Ql;i<=Qr;i++)
			{
				cnt[A[i]]++;
				if (cnt[A[i]]>cnt[Lans]||
					cnt[A[i]]==cnt[Lans]&&A[i]<Lans) Lans=A[i];
			}
		} else
		{
			Lans=Ans[ID(Ql)+1][ID(Qr)-1];
			int Max=calc(Lans,Ql,Qr);
			for (int i=Ql;i<=R(ID(Ql));i++) cnt[A[i]]=0;
			for (int i=L(ID(Qr));i<=Qr;i++) cnt[A[i]]=0;
			for (int i=Ql;i<=R(ID(Ql));i++) 
				if (!cnt[A[i]])
				{
					cnt[A[i]]=1;
					int tmp=calc(A[i],Ql,Qr);
					if (tmp>Max||tmp==Max&&A[i]<Lans) Lans=A[i],Max=tmp;
				}
			for (int i=L(ID(Qr));i<=Qr;i++) 
				if (!cnt[A[i]])
				{
					cnt[A[i]]=1;
					int tmp=calc(A[i],Ql,Qr);
					if (tmp>Max||tmp==Max&&A[i]<Lans) Lans=A[i],Max=tmp;
				}
		}
		Lans=C[Lans];
		printf("%d\n",Lans);
	}
}
Problem2725
#include<set>
#include<map>
#include<queue>
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define mp make_pair
#define Pb push_back
using namespace std;

typedef long long LL;
typedef double Db;

const int N=200000+19,Len=20000000;
const LL oo=1LL<<60;
typedef int one[N];
typedef pair<int,int> Pii;
struct Edge {int y,z,nxt;} E[N*2];
one Last,vis,pre,PtS,PtT,Deg,Q,P;
int n,m,cnt,x,y,z,S,T,f,w;
LL DisS[N],DisT[N];
map<Pii,int> inP;
map<Pii,LL> Ans;
vector<LL> Vi[N],Vo[N];
multiset<LL> Ms;
char Buf[Len],*b=Buf;

int IN()
{
	int c,f,x;
	while (!isdigit(c=*b++)&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=*b++)) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

struct node
{
	int x;LL v;
	bool operator < (const node& B) const {return v>B.v;}
};priority_queue<node> H;
void Dijkstra(int S,int T,LL *Dis)
{
	memset(vis,0,sizeof(vis));
	For(i,1,n+1) Dis[i]=oo;Dis[S]=0;
	H.push((node){S,0});
	while (!H.empty())
	{
		int x=H.top().x;LL D=H.top().v;H.pop();
		if (vis[x]) continue;vis[x]=1;
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if (Dis[x]+E[i].z<Dis[y=E[i].y])
			{
				Dis[y]=Dis[x]+E[i].z,pre[y]=i;
				H.push((node){y,Dis[y]});
			}
	}
}

int main()
{
	fread(Buf,1,Len,stdin);
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,m+1) x=IN(),y=IN(),z=IN(),Link(x,y,z);
	S=IN(),T=IN();

	Dijkstra(S,T,DisS);
	if (DisS[T]==oo)
	{
		for (int Qc=IN();Qc--;) puts("Infinity");
		return 0;
	}
	memset(vis,0,sizeof(vis));
	for (int i=T;i!=S;i=E[pre[i]^1].y) P[++*P]=i;P[++*P]=S;
	reverse(P+1,P+*P+1);
	For(i,1,*P) inP[mp(P[i],P[i+1])]=inP[mp(P[i+1],P[i])]=1;
	For(i,1,n+1) PtS[i]=n+1;
	f=w=0;
	For(i,1,*P+1) PtS[P[i]]=i,Q[++f]=P[i],vis[P[i]]=1;
	For(x,1,n+1) for (int i=Last[x],y;~i;i=E[i].nxt)
		if (DisS[x]+E[i].z==DisS[y=E[i].y]) Deg[y]++;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if (!vis[y=E[i].y]&&DisS[x]+E[i].z==DisS[y])
			{
				PtS[y]=min(PtS[y],PtS[x]);
				if (--Deg[y]==0) Q[++f]=y;
			}
	}
	Dijkstra(T,S,DisT);
	memset(Deg,0,sizeof(Deg));
	memset(vis,0,sizeof(vis));
	For(i,1,n+1) PtT[i]=0;
	f=w=0;
	For(i,1,*P+1) PtT[P[i]]=i,Q[++f]=P[i],vis[P[i]]=1;
	For(x,1,n+1) for (int i=Last[x],y;~i;i=E[i].nxt)
		if (DisT[x]+E[i].z==DisT[y=E[i].y]) Deg[y]++;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if (!vis[y=E[i].y]&&DisT[x]+E[i].z==DisT[y])
			{
				PtT[y]=max(PtT[y],PtT[x]);
				if (--Deg[y]==0) Q[++f]=y;
			}
	}
	
	For(x,1,n+1) for (int i=Last[x],y;~i;i=E[i].nxt)
	{
		y=E[i].y;
		if (inP.count(mp(x,y))) continue;
		if (PtS[x]<PtT[y])
		{
			LL key=DisS[x]+E[i].z+DisT[y];
			Vi[PtT[y]].Pb(key),Vo[PtS[x]].Pb(key);
		}
	}
	Ms.insert(oo);
	For(i,1,*P)
	{
		For(j,0,Vi[i].size()) Ms.erase(Ms.find(Vi[i][j]));
		For(j,0,Vo[i].size()) Ms.insert(Vo[i][j]);
		Ans[mp(P[i],P[i+1])]=Ans[mp(P[i+1],P[i])]=*Ms.begin();
	}

	for (int Qc=IN();Qc--;)
	{
		x=IN(),y=IN();
		if (!inP.count(mp(x,y))) printf("%lld\n",DisS[T]);
			else Ans[mp(x,y)]==oo?puts("Infinity"):printf("%lld\n",Ans[mp(x,y)]);
	}
}
Problem2729
#include<cstdio>
#include<cstring>
using namespace std;

const int Base=1000000,MaxL=2000+19;
struct Bigint
{
	int Len,s[MaxL];
	Bigint() {Len=1;memset(s,0,sizeof(s));}
	void clear() {while (Len>1&&!s[Len-1]) Len--;}
	void operator *= (int A)
	{
		for (int i=0;i<Len;i++) s[i]*=A;
		for (int i=0;i<Len;i++) s[i+1]+=s[i]/Base,s[i]%=Base;
		Len++;clear();
	}
	void operator -= (Bigint A)
	{
		for (int i=0;i<Len;i++) 
		{
			if (s[i]<A.s[i]) s[i+1]--,s[i]+=Base;
			s[i]-=A.s[i];
		}
		clear();
	}
	void print()
	{
		printf("%d",s[Len-1]);
		for (int i=Len-2;i>=0;i--) printf("%06d",s[i]);puts("");
	}
} Ans,tmp;
int n,m;

int main()
{
	scanf("%d%d",&n,&m);
	Ans.s[0]=1;tmp.s[0]=2;
	for (int i=2;i<=n+2;i++) Ans*=i;
	for (int i=n+3-m+1;i<=n+3;i++) Ans*=i;
	for (int i=2;i<=n+1;i++) tmp*=i;
	for (int i=n+2-m+1;i<=n+2;i++) tmp*=i;
	Ans-=tmp;
	Ans.print();
}
Problem2730
#include<set>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define mp make_pair
#define fir first
#define sec second
using namespace std;

typedef unsigned long long LL;
typedef double Db;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=500*2+19,M=500+19;
typedef int one[N];
typedef pair<int,int> Pii;
struct Edge {int y,nxt;} E[M*2];
one Last,DFN,Low,Cut,vis;
Pii Stk[M];
set<int> S[M];
int cnt,x,y,tot,top,BCC,Ans1,Rt,Deg,n,m;
LL Ans2;

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void Tarjan(int x)
{
	Low[x]=DFN[x]=++tot;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (!DFN[y=E[i].y])
		{
			Stk[++top]=mp(x,y);
			Tarjan(y),Low[x]=min(Low[x],Low[y]);
			if (Low[y]>=DFN[x])
			{
				x==Rt?Deg++:Cut[x]=1;BCC++;
				Pii u;
				do
				{
					u=Stk[top--];
					S[BCC].insert(u.fir),S[BCC].insert(u.sec);
				} while (u!=mp(x,y));
			}
		} else Low[x]=min(Low[x],DFN[y]);
}

int main()
{
	for (int Case=1;m=IN();Case++)
	{
		For(i,1,BCC+1) S[i].clear();
		memset(Last,-1,sizeof(Last));
		memset(DFN,0,sizeof(DFN));
		memset(vis,0,sizeof(vis));
		memset(Cut,0,sizeof(Cut));
		cnt=n=tot=BCC=Ans1=0;Ans2=1;

		For(i,1,m+1) x=IN(),y=IN(),Link(x,y),n=max(n,max(x,y));
		For(i,1,n+1) if (!DFN[i])
		{
			Deg=0,Tarjan(Rt=i);
			if (Deg>=2) Cut[i]=1;
		}
		For(i,1,BCC+1)
		{
			int tmp=0;
			for (set<int>::iterator it=S[i].begin();it!=S[i].end();it++) tmp+=Cut[*it];
			if (tmp==1) Ans1++,Ans2*=S[i].size()-tmp;
			if (tmp==0) Ans1=2,Ans2=n*(n-1)/2;
		}
		printf("Case %d: %d %llu\n",Case,Ans1,Ans2);
	}
}
Problem2732
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define Mid (L+R>>1)

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef long double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=200000+19;
const db oo=1e15;
int n,L,R,res,f,w,m;
db X,Y0,Y1;

struct Point{
	db x,y;
	Point() {}
	Point(db __x,db __y) {x=__x,y=__y;}
} P[N];
typedef Point Vector;

Vector operator - (Point A,Point B) {return Vector(A.x-B.x,A.y-B.y);}
Vector operator * (db k,Vector A) {return Vector(A.x*k,A.y*k);}
Point operator + (Point A,Vector B) {return Point(A.x+B.x,A.y+B.y);}
db cross(Vector A,Vector B) {return A.x*B.y-A.y*B.x;}

struct Line{
	Point P;
	Vector V;
	db Ang;
	int id;
	Line() {}
	Line(Point __P,Vector __V,int __id){
		P=__P;V=__V;
		Ang=atan2(V.y,V.x);id=__id;
	}
	bool operator < (const Line &b) const{
		if (Ang!=b.Ang) return Ang<b.Ang;
		return cross(V,b.P-P)<0;
	}
} l[N],Q[N];

bool onleft(Point A,Line B){
	return cross(B.V,A-B.P)>=0;
}
Point intersection(Line A,Line B){
	assert(fabs(cross(A.V,B.V))>1e-9);
	db k=cross(B.P-A.P,B.V)/cross(A.V,B.V);
	return A.P+k*A.V;
}
bool halfplane(int T){
	db pre=oo;
	f=-1,w=0;
	For(i,1,m+1)
		if (l[i].id<=T&&l[i].Ang!=pre){
			while (f>w&&!onleft(P[f-1],l[i])) f--;
			while (f>w&&!onleft(P[w],l[i])) w++;
			Q[++f]=l[i];
			if (f>w) P[f-1]=intersection(Q[f-1],Q[f]);
			pre=l[i].Ang;
		}
	while (f>w&&!onleft(P[f-1],Q[w])) f--;
	return f-w>1;
}

int main(){
	l[++m]=Line(Point(-oo,oo),Vector(0,-1),0);
	l[++m]=Line(Point(-oo,-oo),Vector(1,0),0);
	l[++m]=Line(Point(oo,-oo),Vector(0,1),0);
	l[++m]=Line(Point(oo,oo),Vector(-1,0),0);
	n=IN();
	For(i,1,n+1){
		X=IN(),Y0=IN(),Y1=IN();
		l[++m]=Line(Point(0,Y1/X),Vector(-1,X),i);
		l[++m]=Line(Point(0,Y0/X),Vector(1,-X),i);
	}
	sort(l+1,l+m+1);
	L=1,R=n;
	while (L<=R){
		if (halfplane(Mid)) res=Mid,L=Mid+1;else R=Mid-1;
	}
	printf("%d\n",res);
}
Problem2733
#include<cstdio>
#include<cctype>
#include<algorithm>

#define Mid (L+R>>1)
using namespace std;

const int Maxn=100000+19;
typedef int one[5000000+19];
one Lsn,Rsn,sum;
int Fa[Maxn],root[Maxn],ID[Maxn],A[Maxn];
int n,m,x,y,tot,t,Q;
char s[3];

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}
void Update(int &x,int L,int R)
{
	if (!x) x=++tot;sum[x]++;
	if (L==R) return;
	if (t<=Mid) Update(Lsn[x],L,Mid);else Update(Rsn[x],Mid+1,R);
}
int Query(int x,int L,int R,int k)
{
	if (L==R) return L;
	if (k<=sum[Lsn[x]]) return Query(Lsn[x],L,Mid,k);
	else return Query(Rsn[x],Mid+1,R,k-sum[Lsn[x]]);
}
int Merge(int x,int y)
{
	if (!x) return y;
	if (!y) return x;
	Lsn[x]=Merge(Lsn[x],Lsn[y]);
	Rsn[x]=Merge(Rsn[x],Rsn[y]);
	sum[x]=sum[Lsn[x]]+sum[Rsn[x]];
	return x;
}

int main()
{
	read(n),read(m);
	for (int i=1;i<=n;i++) read(A[i]),ID[A[i]]=i;
	for (int i=1;i<=n;i++) Fa[i]=i;
	for (int i=0;i<m;i++)
	{
		read(x),read(y);
		int Fx=Getf(x),Fy=Getf(y);
		if (Fx!=Fy) Fa[Fy]=Fx;
	}
	for (int i=1;i<=n;i++) t=A[i],Update(root[Getf(i)],1,n);
	read(Q);
	for (int i=0;i<Q;i++)
	{
		scanf("%s",s);
		read(x),read(y);
		if (s[0]=='B')
		{
			int Fx=Getf(x),Fy=Getf(y);
			if (Fx!=Fy) Fa[Fy]=Fx,root[Fx]=Merge(root[Fx],root[Fy]);
		} else x=root[Getf(x)],printf("%d\n",sum[x]<y?-1:ID[Query(x,1,n,y)]);
	}
}
Problem2738
#include<stdio.h>
#include<algorithm>
#define N 505*505
#define M 60005
#define lowbit(o) o&-o
using namespace std;
struct node {
	int x,y,v;
}a[N],c[N];
struct node1 {
	int x,y,id,k,xx,yy,v;
}b[M],d[M];
int i,j,k,l,s[M],n,m,tot,f[505][505],ans[M];
inline bool cmp(const node &x,const node &y) {
	return x.v<y.v;
}
inline bool Cmp(const node1 &x,const node1 &y) {
	return x.v>y.v;
}
inline bool cmp1(const node &x,const node &y) {
	return x.x<y.x;
}
inline bool Cmp1(const node1 &x,const node1 &y) {
	return x.x<y.x;
}
inline void change(int o,int w,int p) {
	int oo=o;
	for (;w<=n;w+=lowbit(w)) 
	for (o=oo;o<=n;o+=lowbit(o)) f[w][o]+=p;
}
inline int ask(int o,int p) {
	int s=0;
	int oo=o;
	for (;p;p-=lowbit(p))
	for (o=oo;o;o-=lowbit(o)) s+=f[p][o];
	return s;
}
inline void work(int l,int r,int L,int R) {
	if (L>R) return ;
	if (l==r) {
		for (int i=L;i<=R;i++) ans[b[i].id]=a[l].v;
		return ;
	}
	int mid=(l+r)>>1;
	int gt=0,gtw=0;
	for (int i=l;i<=mid;i++) change(a[i].x,a[i].y,1);
	for (int i=L;i<=R;i++) {
		s[b[i].id]=ask(b[i].xx,b[i].yy)-ask(b[i].x-1,b[i].yy)-ask(b[i].xx,b[i].y-1)+ask(b[i].x-1,b[i].y-1);
		if (s[b[i].id]>=b[i].k) b[i].v=1;
		else b[i].v=-1;
	}
	int i;
	sort(b+L,b+R+1,Cmp);
	for (i=L;i<=R;i++) if (b[i].v==-1) break;
	work(mid+1,r,i,R);
	for (int i=l;i<=mid;i++) change(a[i].x,a[i].y,-1);
	work(l,mid,L,i-1);
}
inline int in() {
	char c=getchar();
	int s=0;
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') s=s*10+c-48,c=getchar();
	return s;
}
int main() {
	scanf("%d%d",&n,&m);
	for (i=1;i<=n;i++) 
	for (j=1;j<=n;j++) a[++tot].v=in(),a[tot].x=i,a[tot].y=j;
	sort(a+1,a+1+tot,cmp);
	for (i=1;i<=m;i++) b[i].x=in(),b[i].y=in(),b[i].xx=in(),b[i].yy=in(),b[b[i].id=i].k=in();
	work(1,tot,1,m);
	for (i=1;i<=m;i++) printf("%d\n",ans[i]);
}
Problem2738
#include<set>
#include<map>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define mp make_pair
#define pb push_back
#define fir first
#define sec second
#define Mid (L+R>>1)

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=500*500+60000*2+19;

struct Point
{
	int x,y,z;
	bool operator < (const Point &B) const {return x<B.x;}
} P[N],__P[N];
struct QType
{
	int f,id,x,l,r;
	bool operator < (const QType& B) const {return x<B.x;}
} Q[N],__Q[N];
int n,Qc,cnt,tot,x1,y1,x2,y2;
int Ans[N],k[N],id[N],vis[N],tmp[N];

int C[N],T[N],Time;
void Add(int x)
{
	for (;x<=n;x+=x&-x)
	{
		if (T[x]!=Time) T[x]=Time,C[x]=0;
		C[x]++;
	}
}
int Query(int x)
{
	int res=0;
	for (;x;x-=x&-x) res+=(T[x]==Time?C[x]:0);
	return res;
}

void Work(int Ql,int Qr,int l,int r,int L,int R)
{
	if (L==R)
	{
		For(i,l,r+1) Ans[Q[i].id]=L;
		return;
	}
	int c=Ql,t,p,Qt,Qp;
	Qt=Ql-1;	For(i,Ql,Qr+1) if (P[i].z<=Mid) __P[++Qt]=P[i];
	Qp=Qt;		For(i,Ql,Qr+1) if (P[i].z>Mid) __P[++Qt]=P[i];
	For(i,Ql,Qr+1) P[i]=__P[i];
	Time++;
	For(i,l,r+1) tmp[Q[i].id]=0,vis[Q[i].id]=-1;
	For(i,l,r+1)
	{
		while (c<=Qp&&P[c].x<=Q[i].x&&P[c].z<=Mid) Add(P[c++].y);
		tmp[Q[i].id]+=Q[i].f*(Query(Q[i].r)-Query(Q[i].l-1));
	}
	For(i,l,r+1) if (vis[t=Q[i].id]==-1)
	{
		if (k[t]<=tmp[t]) vis[t]=1;else k[t]-=tmp[t],vis[t]=0;
	}
	t=l-1;		For(i,l,r+1) if (vis[Q[i].id]) __Q[++t]=Q[i];
	p=t;		For(i,l,r+1) if (!vis[Q[i].id]) __Q[++t]=Q[i];
	For(i,l,r+1) Q[i]=__Q[i];
	if (Ql<=Qp&&l<=p) Work(Ql,Qp,l,p,L,Mid);
	if (Qp+1<=Qr&&p+1<=r) Work(Qp+1,Qr,p+1,r,Mid+1,R);
}

int main()
{
	n=IN(),Qc=IN();
	For(i,1,n+1) For(j,1,n+1) P[++tot]=(Point){i,j,IN()};
	For(i,1,Qc+1)
	{
		x1=IN(),y1=IN(),x2=IN(),y2=IN();
		k[i]=IN();
		Q[++cnt]=(QType){-1,i,x1-1,y1,y2};
		Q[++cnt]=(QType){1,i,x2,y1,y2};
	}
	sort(P+1,P+tot+1);
	sort(Q+1,Q+cnt+1);
	Work(1,tot,1,cnt,0,int(1e9));
	For(i,1,Qc+1) printf("%d\n",Ans[i]);
}
Problem2741
#include<cstdio>
#include<cctype>
#include<cmath>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<=y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=12000+19,M=120,Top=1e7;
int B[M][N],A[N],rt[N],son[Top][2],Sum[Top];
int n,m,tot,v,Ans,Ql,Qr,S,cnt,x,y;

void Insert(int &x,int y,int a)
{
	Sum[x=++tot]=Sum[y]+1;
	if (a==-1) return;
	son[x][0]=son[y][0],son[x][1]=son[y][1];
	Insert(son[x][v>>a&1],son[y][v>>a&1],a-1);
}
int Query(int L,int R,int a)
{
	int res=0;L=rt[L-1],R=rt[R];
	for (int i=30;i>=0;i--)
	{
		int t=a>>i&1^1;
		if (Sum[son[R][t]]-Sum[son[L][t]]) res|=1<<i;else t^=1;
		R=son[R][t],L=son[L][t];
	}
	return res;
}

int main()
{
	n=IN(),m=IN();
	For(i,2,n+1) A[i]=A[i-1]^IN();
	Insert(rt[1],0,30);
	For(i,2,n+1) v=A[i],Insert(rt[i],rt[i-1],30);
	S=sqrt(n)+1,cnt=((n+1)/S)+((n+1)%S!=0);
	For(i,0,cnt) For(j,i*S+1,n+1)
		B[i][j]=max(B[i][j-1],Query(i*S+1,j,A[j]));
	while (m--)
	{
		Ql=(1LL*IN()+Ans)%n+1,Qr=(1LL*IN()+Ans)%n+1;Ql++,Qr++;
		if (Ql>Qr) swap(Ql,Qr);Ql--;
		int x=(Ql==1)?0:(Ql-2)/S+1;
		Ans=B[x][Qr];
		For(i,Ql,min(x*S,Qr)) Ans=max(Ans,Query(Ql,Qr,A[i]));
		printf("%d\n",Ans);
	}
}
Problem2743
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;

const int Maxn=1000000+19;
typedef int one[Maxn];
one A,nxt,pre,Last,Ans,L,C;
int n,c,Q,x;

int ch;
void read(int &x)
{
	while (!isdigit(ch=getchar()));x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
}

void Add(int x,int v) {if (!x) return;for (;x<=n+1;x+=x&-x) C[x]+=v;}
int Query(int x) {int Ans=0;for (;x;x-=x&-x) Ans+=C[x];return Ans;}

int main()
{
	read(n),read(c),read(Q);
	for (int i=1;i<=n;i++) read(A[i]),pre[i]=Last[A[i]],Last[A[i]]=i;
	for (int i=1;i<=n;i++) if (pre[i]) Add(pre[i]+1,-1),Add(pre[pre[i]]+1,1);
	memset(Last,0,sizeof(Last));
	for (int i=1;i<=Q;i++) read(L[i]),read(x),nxt[i]=Last[x],Last[x]=i;
	for (int R=n;R>=1;R--)
	{
		for (int i=Last[R];i;i=nxt[i]) Ans[i]=Query(L[i]);
		Add(pre[pre[R]]+1,-1);Add(pre[R]+1,1);
	}
	for (int i=1;i<=Q;i++) printf("%d\n",Ans[i]);
}
Problem2745
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=3000+19,M=200+19;

int C[M][M],f[M];
int n,m,p,a,b,res,S;

int Pow(int a,int b){
	int res=1;
	for (;b;b>>=1,a=1ll*a*a%p) if (b&1) res=1ll*res*a%p;
	return res;
}

void work(){
	static int f[N*N],s[N*N],vis[N][N];
	int t=(1ll*(m-1)*(m-2)%p+1)%p,sum;
	s[1]=f[1]=1ll*m*(m-1)%p;
	vis[f[1]][1]=1;
	For(i,2,n+1){
		f[i]=1ll*f[i-1]*t%p;
		if (vis[f[i]][i%p]){
			int t=i-vis[f[i]][i%p];
			sum=s[i-1];
			sum=(0ll+sum+1ll*(s[i-1]-s[i-t-1]+p)*((n-i+1)/t)%p)%p;
			sum=(0ll+sum+s[i-t+(n-i+1)%t-1]-s[i-t-1]+p)%p;
			printf("%d\n",1ll*sum*Pow(2,m)%p);
			return;
		}
		s[i]=(s[i-1]+1ll*f[i]*Pow(i,m)%p)%p;
		vis[f[i]][i%p]=i;
	}
	sum=s[n];
	printf("%d\n",1ll*sum*Pow(2,m)%p);
}

int main(){
	n=IN(),m=IN(),p=IN();
	a=1ll*m*(m-1)%p;
	b=(1ll*(m-1)*(m-2)+1)%p;
	if (p<=3000) return work(),0;
	S=int(sqrt(n))+1;
	For(i,0,m+1){
		C[i][0]=1;
		For(j,1,i+1) C[i][j]=(C[i-1][j-1]+C[i-1][j])%p;
	}
	For(i,0,S){
		int pro=Pow(b,i),tmp=1;
		for (int j=m;~j;j--){
			(f[j]+=1ll*pro*tmp%p)%=p;
			tmp=1ll*tmp*(i+1)%p;
		}
	}
	For(i,0,n/S){
		int sum=0,tmp=1;
		For(k,0,m+1){
			(sum+=1ll*C[m][k]*tmp%p*f[k]%p)%=p;
			tmp=1ll*tmp*(i*S)%p;
		}
		(res+=1ll*Pow(b,i*S)*sum%p)%=p;
	}
	For(i,0,n%S){
		int x=n/S*S+i;
		(res+=1ll*Pow(b,x)*Pow(x+1,m)%p)%=p;
	}
	printf("%d\n",1ll*a*Pow(2,m)%p*res%p);
}
Problem2746
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=1000000+19,Mod=1000000007;
typedef int one[Maxn];
one Fir,Fail,Deep,Q,Last,Num;
int ID[Maxn*2],t[Maxn][26],Fa[Maxn][20];
int n,m,x,cur,f,w,cnt,a,b,c,d,tot;
char s[Maxn];

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int LCA(int x,int y)
{
	if (Deep[x]>Deep[y]) swap(x,y);
	for (int k=Deep[y]-Deep[x],i=0;k;k>>=1,i++) if (k&1) y=Fa[y][i];
	if (x==y) return x;
	for (int i=19;i>=0;i--) if (Fa[x][i]!=Fa[y][i]) x=Fa[x][i],y=Fa[y][i];
	return Fa[x][0];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n);
	for (int T=1;T<=n;T++)
	{
		scanf("%s",s);Fir[T]=cur,x=0;
		for (int i=0,_=strlen(s);i<_;i++)
		{
			int& u=t[x][s[i]-'a'];
			if (!u) u=++tot,Num[u]=(26LL*Num[x]+s[i]-'a')%Mod;
			x=ID[++cur]=u;
		}
	}
	for (Q[w=0,f=1]=0;f>w;)
	{
		int x=Q[++w];
		if (x) Fa[x][0]=Fail[x],Deep[x]=Deep[Fail[x]]+1;
		for (int i=0;i<26;i++)
		{
			int& u=t[x][i];
			if (u) {Q[++f]=u;if (x) Fail[u]=t[Fail[x]][i];}
				else u=t[Fail[x]][i];
		}
	}
	for (int x=1;x<20;x++)
		for (int i=1;i<=tot;i++) Fa[i][x]=Fa[Fa[i][x-1]][x-1];
	read(m);
	while (m--)
	{
		read(a),read(b),read(c),read(d);
		int x=ID[Fir[a]+b],y=ID[Fir[c]+d],Ans=LCA(x,y);
		printf("%d\n",Num[Ans]);
	}
}
Problem2748
#include<cstdio>
using namespace std;

const int Maxn=1000+19;
int f[50+19][Maxn];
int main()
{
	int n,B,Max,tmp,flag=0;
	scanf("%d%d%d",&n,&B,&Max);
	f[0][B]=1;
	for (int i=0;i<n;i++)
	{
		scanf("%d",&tmp);
		for (int j=0;j<=Max;j++)
			if (f[i][j])
			{
				if (j+tmp<=Max) f[i+1][j+tmp]=1;
				if (j-tmp>=0) f[i+1][j-tmp]=1;
			}
	}
	for (int Ans=Max;Ans>=0;Ans--)
		if (f[n][Ans]) 
		{
			printf("%d\n",Ans);
			flag=1;break;
		}
	if (!flag) printf("-1\n");
	//for(;;);
	return 0;
}
Problem2750
#include<cstdio>
#include<vector>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
using namespace std;

typedef long long LL;
typedef double Db;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=5000+19,P=1e9+7;
struct Edge {int y,z,ID,nxt;} E[5000+19];
typedef int one[N];
one Last,__A,__B,Dis,Ans,vis;
vector<int> V[N];
int n,m,x,y,z,cnt;

void Add_Edge(int x,int y,int z,int ID)
{
	E[cnt]=(Edge){y,z,ID,Last[x]};Last[x]=cnt++;
}
void SPFA(int S)
{
	static int Q[N*100+19];int f=1,w=0;Q[1]=S;
	For(i,1,n+1) V[i].clear();
	memset(__B,0,sizeof(__B));
	memset(__A,0,sizeof(__A));
	memset(Dis,60,sizeof(Dis));Dis[S]=0,__A[S]=1;
	while (f>w)
	{
		int x=Q[++w];vis[x]=0;
		for (int i=Last[x],y;~i;i=E[i].nxt)
		{
			if (Dis[x]+E[i].z<Dis[y=E[i].y])
			{
				Dis[y]=Dis[x]+E[i].z,V[y].clear();
				if (!vis[y]) vis[y]=1,Q[++f]=y;
			}
			if (Dis[x]+E[i].z==Dis[y]) V[y].Pb(x);
		}
	}
}
int A(int x)
{
	if (__A[x]) return __A[x];__A[x]=0;
	For(i,0,V[x].size()) __A[x]+=A(V[x][i]);
	return __A[x];
}
int B(int x)
{
	if (__B[x]) return __B[x];__B[x]=1;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (Dis[x]+E[i].z==Dis[y=E[i].y]) (__B[x]+=B(y))%=P;
	return __B[x];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,m+1) x=IN(),y=IN(),z=IN(),Add_Edge(x,y,z,i);
	For(i,1,n+1)
	{
		SPFA(i);
		For(x,1,n+1) for (int i=Last[x],y;~i;i=E[i].nxt)
			if (Dis[x]+E[i].z==Dis[y=E[i].y]) (Ans[E[i].ID]+=1LL*A(x)*B(y)%P)%=P;
	}
	For(i,1,m+1) printf("%d\n",Ans[i]);
}
Problem2751
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=1e5+19,Mod=1000000007;
struct node
{
	int x,y;
	bool operator == (const node& B) const {return x==B.x&&y==B.y;}
	bool operator < (const node& B) const {return x<B.x||x==B.x&&y<B.y;}
} A[N];
int n,m,k,Ans=1,top;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%Mod) if (b&1) res=1LL*res*a%Mod;
	return res;
}

int main()
{
	read(n),read(m),read(k),top=1LL*(n+1)*n/2LL%Mod;
	For(i,0,k) read(A[i].x),read(A[i].y);
	sort(A,A+k);
	k=unique(A,A+k)-A;
	for (int L=0,R=0;L<k;L=R+1,R=L)
	{
		while (R+1<k&&A[R].x==A[R+1].x) R++;
		int a=top;For(i,L,R+1) a=(a-A[i].y+Mod)%Mod;
		m--,Ans=1LL*Ans*a%Mod;
	}
	Ans=1LL*Ans*Pow(top,m)%Mod;
	printf("%d\n",Ans);
}
Problem2752
#include<cstdio>
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid ((L+R)>>1)
using namespace std;

const int Maxn=1e5+19;
typedef long long LL;
typedef LL one[Maxn*4];
char s[9];
int n,m,Ql,Qr,v;
LL A0,A1,A2,tmp1[Maxn],tmp2[Maxn];
one s0,s1,s2,Add;

inline LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}

inline void Change(int x,int L,int R,int v)
{
	s0[x]+=1LL*v*(R-L+1);
	s1[x]+=1LL*v*(tmp1[R]-tmp1[L-1]);
	s2[x]+=1LL*v*(tmp2[R]-tmp2[L-1]);
}
inline void Push_down(int x,int L,int R)
{
	if (L==R||!Add[x]) return;
	Add[Lsn]+=Add[x];Change(Lsn,L,Mid,Add[x]);
	Add[Rsn]+=Add[x];Change(Rsn,Mid+1,R,Add[x]);
	Add[x]=0;
}
inline void Update(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) 
	{
		Add[x]+=v;Change(x,L,R,v);
		return;
	}
	Push_down(x,L,R);
	if (Ql<=Mid) Update(Lsn,L,Mid);
	if (Qr>Mid) Update(Rsn,Mid+1,R);
	s0[x]=s0[Lsn]+s0[Rsn];
	s1[x]=s1[Lsn]+s1[Rsn];
	s2[x]=s2[Lsn]+s2[Rsn];
}
inline void Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {A0+=s0[x],A1+=s1[x],A2+=s2[x];return;}
	Push_down(x,L,R);
	if (Ql<=Mid) Query(Lsn,L,Mid);
	if (Qr>Mid) Query(Rsn,Mid+1,R);
}

int main()
{
	scanf("%d%d",&n,&m);n--;
	for (int i=1;i<=n;i++) tmp1[i]=tmp1[i-1]+i;
	for (int i=1;i<=n;i++) tmp2[i]=tmp2[i-1]+1LL*i*i;
	while (m--)
	{
		scanf("%s%d%d",s,&Ql,&Qr);Qr--;
		if (s[0]=='C') scanf("%d",&v),Update(1,1,n);
		if (s[0]=='Q')
		{
			int Vl=-Ql+1,Vr=Qr+1;
			A0=A1=A2=0;
			Query(1,1,n);
			LL tmp1=A0*1LL*Vl*Vr+A1*1LL*(Vr-Vl)-A2;
			LL tmp2=1LL*(Qr-Ql+1)*(Qr-Ql+2)/2LL;
			LL t=gcd(tmp1,tmp2);tmp1/=t;tmp2/=t;
			printf("%lld/%lld\n",tmp1,tmp2);
		}
	}
}
Problem2752
#include<cstdio>
#include<cctype>
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid ((L+R)>>1)
using namespace std;

const int Maxn=1e5+19;
typedef long long LL;
typedef LL one[Maxn*4];
char s[9];
int n,m,Ql,Qr,v;
LL A0,A1,A2,tmp1[Maxn],tmp2[Maxn];
one s0,s1,s2,Add;

int f,c;
inline void read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}
inline LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}

inline void Change(int x,int L,int R,int v)
{
	s0[x]+=1LL*v*(R-L+1);
	s1[x]+=1LL*v*(tmp1[R]-tmp1[L-1]);
	s2[x]+=1LL*v*(tmp2[R]-tmp2[L-1]);
}
inline void Push_down(int x,int L,int R)
{
	if (L==R||!Add[x]) return;
	Add[Lsn]+=Add[x];Change(Lsn,L,Mid,Add[x]);
	Add[Rsn]+=Add[x];Change(Rsn,Mid+1,R,Add[x]);
	Add[x]=0;
}
inline void Update(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) 
	{
		Add[x]+=v;Change(x,L,R,v);
		return;
	}
	Push_down(x,L,R);
	if (Ql<=Mid) Update(Lsn,L,Mid);
	if (Qr>Mid) Update(Rsn,Mid+1,R);
	s0[x]=s0[Lsn]+s0[Rsn];
	s1[x]=s1[Lsn]+s1[Rsn];
	s2[x]=s2[Lsn]+s2[Rsn];
}
inline void Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {A0+=s0[x],A1+=s1[x],A2+=s2[x];return;}
	Push_down(x,L,R);
	if (Ql<=Mid) Query(Lsn,L,Mid);
	if (Qr>Mid) Query(Rsn,Mid+1,R);
}

int main()
{
	read(n),read(m),n--;
	for (int i=1;i<=n;i++) tmp1[i]=tmp1[i-1]+i;
	for (int i=1;i<=n;i++) tmp2[i]=tmp2[i-1]+1LL*i*i;
	while (m--)
	{
		scanf("%s",s),read(Ql),read(Qr);Qr--;
		if (s[0]=='C') read(v),Update(1,1,n);
		if (s[0]=='Q')
		{
			int Vl=-Ql+1,Vr=Qr+1;
			A0=A1=A2=0;
			Query(1,1,n);
			LL tmp1=A0*1LL*Vl*Vr+A1*1LL*(Vr-Vl)-A2;
			LL tmp2=1LL*(Qr-Ql+1)*(Qr-Ql+2)/2LL;
			LL t=gcd(tmp1,tmp2);tmp1/=t;tmp2/=t;
			printf("%lld/%lld\n",tmp1,tmp2);
		}
	}
}
Problem2754
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Rep(i,x,y) for (int i=x;i<=y;i++)
#define Dep(i,x,y) for (int i=x;i>=y;i--)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int M=50000+19,Cnt=20000+19,N=200000+M+Cnt*2+19;
int s[N],t[N],SA[N],rk[2*N],h[N],trk[N],tmp[N],cnt[N],Bel[N],p,n;
int Len[M],St[M],Ans[Cnt],vis[Cnt],C,c,m,tot=10000;

void Build_SA()
{
	Rep(i,1,n) p=max(p,s[i]),cnt[s[i]]++;
	Rep(i,1,p) cnt[i]+=cnt[i-1];
	Dep(i,n,1) SA[cnt[s[i]]--]=i;
	rk[SA[1]]=p=1;
	Rep(i,2,n) rk[SA[i]]=(s[SA[i]]==s[SA[i-1]])?p:++p;
	for (int k=1;k<=n;k<<=1)
	{
		memset(cnt,0,sizeof(cnt));
		Rep(i,1,n) cnt[rk[i+k]]++;
		Rep(i,1,p) cnt[i]+=cnt[i-1];
		Dep(i,n,1) tmp[cnt[rk[i+k]]--]=i;
		memset(cnt,0,sizeof(cnt));
		Rep(i,1,n) cnt[rk[i]]++;
		Rep(i,1,p) cnt[i]+=cnt[i-1];
		Dep(i,n,1) SA[cnt[rk[tmp[i]]]--]=tmp[i];
		trk[SA[1]]=p=1;
		Rep(i,2,n) trk[SA[i]]=(rk[SA[i]]==rk[SA[i-1]]&&rk[SA[i]+k]==rk[SA[i-1]+k])?p:++p;
		Rep(i,1,n) rk[i]=trk[i];
	}
	for (int i=1,j=0;i<=n;i++)
	{
		if (rk[i]==1) continue;
		while (s[i+j]==s[SA[rk[i]-1]+j]) j++;
		h[rk[i]]=j;if (j) j--;
	}
}

int main()
{
	C=IN(),m=IN();
	Rep(i,1,C)
	{
		c=IN();Rep(j,1,c) s[++n]=IN(),Bel[n]=i;s[++n]=++tot;
		c=IN();Rep(j,1,c) s[++n]=IN(),Bel[n]=i;s[++n]=++tot;
	}
	Rep(i,1,m)
	{
		Len[i]=c=IN();St[i]=n+1;Rep(j,1,c) s[++n]=IN();s[++n]=++tot;
	}
	Build_SA();
	Rep(i,1,m)
	{
		int tmp=0,t;
		for (int j=rk[St[i]];h[j]>=Len[i];j--) if ((t=Bel[SA[j-1]])&&vis[t]!=i) vis[t]=i,tmp++,Ans[t]++;
		for (int j=rk[St[i]]+1;h[j]>=Len[i];j++) if ((t=Bel[SA[j]])&&vis[t]!=i) vis[t]=i,tmp++,Ans[t]++;
		printf("%d\n",tmp);
	}
	For(i,1,C) printf("%d ",Ans[i]);printf("%d\n",Ans[C]);
}
Problem2756
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,j) for (int i=1;i<=n;i++) for (int j=1;j<=m;j++)
using namespace std;

typedef long long LL;
const int D=40+19,N=D*D;
const LL oo=1LL<<50;
struct Edge {int y,nxt;LL f;} E[N*5];
int Last[N],Q[N],Dis[N];
int A[D][D],ID[D][D],tot,Te,n,m,S,T,cnt;
LL sum[2],Flow,x;
int Dx[4]={1,0,-1,0},Dy[4]={0,1,0,-1};

void Add_Edge(int x,int y,LL f)
{
	E[cnt]=(Edge){y,Last[x],f};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y],0};Last[y]=cnt++;
}

bool BFS()
{
	int f=1,w=0;Q[1]=S;
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
LL Dinic(int x,LL Flow)
{
	if (x==T||!Flow) return Flow;
	LL res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			LL tmp=Dinic(E[i].y,min(Flow,E[i].f));
			res+=tmp,Flow-=tmp,E[i].f-=tmp,E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

LL GetAns(LL x) {return (1LL*n*m*x-sum[0]-sum[1])/2LL;}
bool Check(LL x)
{
	memset(Last,-1,sizeof(Last));cnt=0;
	For(i,j) if (x<A[i][j]) return 0;
	For(i,j)
		if ((i&1)==(j&1))
		{
			Add_Edge(S,ID[i][j],x-A[i][j]);
			for (int k=0;k<4;k++)
			{
				int tx=i+Dx[k],ty=j+Dy[k];
				if (tx>=1&&tx<=n&&ty>=1&&ty<=m) Add_Edge(ID[i][j],ID[tx][ty],oo);
			}
		} else Add_Edge(ID[i][j],T,x-A[i][j]);
	Flow=0;while (BFS()) Flow+=Dinic(S,oo);
	return Flow==GetAns(x);
}
LL Calc()
{
	tot=0;
	scanf("%d%d",&n,&m);
	sum[0]=sum[1]=0;
	For(i,j) scanf("%d",&A[i][j]),ID[i][j]=++tot,sum[(i&1)^(j&1)]+=A[i][j];
	S=++tot,T=++tot;
	if ((n*m)&1)
	{
		x=sum[0]-sum[1];
		return Check(x)?GetAns(x):-1;
	} else
	{
		if (sum[0]!=sum[1]) return -1;
		LL L=1,R=oo,res=0;
		while (L<=R)
		{
			LL Mid=(L+R)>>1;
			if (Check(Mid)) res=Mid,R=Mid-1;else L=Mid+1;
		}
		return res?GetAns(res):-1;
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&Te);
	while (Te--) printf("%lld\n",Calc());
}
Problem2757
#include<cstdio>
#include<algorithm>

#define Mid (L+R>>1)
using namespace std;

typedef long long LL;
const LL Top=70000+19,Mod=20120427,Lim=1e18;
typedef int DP[20][Top];
int Pre[Top][10],T,cnt,d[20],P[4]={2,3,5,7},Pow[20];
LL A[Top],L,R,K;
DP f,g,w,h;

void DFS(LL x,int t)
{
	A[++cnt]=x;
	for (int i=t;i<4;i++) if (x<=Lim/P[i]) DFS(x*P[i],i);
}
int Find(LL x)
{
	int L=1,R=cnt,res=0;
	while (L<=R) if (A[Mid]>=x) res=Mid,R=Mid-1;else L=Mid+1;
	return A[res]==x?res:0;
}

int calc_0(LL n)
{
	int res=0,Flag=0,tmp=0,t=0;
	for (LL i=++n;i;i/=10) d[t++]=i%10;reverse(d,d+t);
	for (int i=1;i<t;i++)
		for (int j=1;j<10;j++)
			(res+=1LL*j*Pow[t-i-1]%Mod*w[t-i-1][0]%Mod+h[t-i-1][0])%=Mod;
	for (int i=0;i<t;i++)
	{
		for (int j=!i;j<d[i];j++)
		{
			int pre=(1LL*tmp*Pow[t-i]%Mod+j*Pow[t-i-1]%Mod)%Mod;
			(res+=1LL*w[t-i-1][0]*pre%Mod+h[t-i-1][0])%=Mod;
			if (Flag||!j) (res+=1LL*w[t-i-1][1]*pre%Mod+h[t-i-1][1])%=Mod;
		}
		Flag|=!d[i],tmp=(tmp*10+d[i])%Mod;
	}
	return res;
}
int calc_1(LL n)
{
	LL k=K;int Fk=Find(K),t=0,res=0,tmp=0;
	if (!Fk) return 0;
	for (LL i=++n;i;i/=10) d[t++]=i%10;reverse(d,d+t);
	for (int i=1;i<t;i++) (res+=f[i][Fk])%=Mod;
	for (int i=0;i<t;i++)
	{
		for (int j=1;j<d[i];j++)
			if (k%j==0)
			{
				int pre=(1LL*tmp*Pow[t-i]%Mod+j*Pow[t-i-1]%Mod)%Mod;
				(res+=1LL*g[t-i-1][Pre[Fk][j]]*pre%Mod+f[t-i-1][Pre[Fk][j]])%=Mod;
			}
		if (!d[i]) break;
		Fk=Pre[Fk][d[i]],k/=d[i],tmp=(tmp*10+d[i])%Mod;
		if (!Fk) break;
	}
	return res;
}

int main()
{
	DFS(1,0);sort(A+1,A+cnt+1);
	Pow[0]=1;for (int i=1;i<20;i++) Pow[i]=10*Pow[i-1]%Mod;
	g[0][1]=1;
	for (int k=1;k<=cnt;k++)
		for (int j=1;j<10;j++) if (A[k]%j==0) Pre[k][j]=Find(A[k]/j);
	for (int i=1;i<20;i++)
		for (int k=1;k<=cnt;k++)
			for (int j=1;j<10;j++)
				if (A[k]%j==0)
					(g[i][k]+=g[i-1][Pre[k][j]])%=Mod,
					(f[i][k]+=10LL*f[i-1][Pre[k][j]]+1LL*j*g[i-1][Pre[k][j]])%=Mod;
	w[0][1]=1;
	for (int i=1;i<20;i++)
		w[i][0]=(10*w[i-1][0]+w[i-1][1])%Mod,
		w[i][1]=9*w[i-1][1]%Mod,
		h[i][0]=(100*h[i-1][0]%Mod+45*w[i-1][0]%Mod+10*h[i-1][1])%Mod,
		h[i][1]=(90*h[i-1][1]+45*w[i-1][1])%Mod;
	scanf("%d",&T);
	while (T--)
	{
		scanf("%lld%lld%lld",&L,&R,&K);
		if (!K) printf("%d\n",(calc_0(R)-calc_0(L-1)+Mod)%Mod);
			else printf("%d\n",(calc_1(R)-calc_1(L-1)+Mod)%Mod);
	}
}
Problem2761
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=50000+19;
struct node {int A,ID,can;} A[Maxn];
int t,n,fir;

int f,c;char buf[15];
void read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}
void print(int x)
{
	if (x==0) {putchar('0');return;}
	if (x<0) putchar('-'),x=-x;
	c=0;while (x) buf[c++]=x%10+'0',x/=10;
	while (--c>=0) putchar(buf[c]);
}

int cmp1(node A,node B) {return A.A<B.A||A.A==B.A&&A.ID<B.ID;}
int cmp2(node A,node B) {return A.can!=B.can?A.can>B.can:A.ID<B.ID;}

int main()
{
	read(t);
	while (t--)
	{
		fir=1;
		scanf("%d",&n);
		for (int i=0;i<n;i++) read(A[i].A),A[i].ID=i;
		sort(A,A+n,cmp1);
		for (int i=0;i<n;i++) A[i].can=(!i||A[i].A!=A[i-1].A);
		sort(A,A+n,cmp2);
		for (int i=0;i<n&&A[i].can;i++) 
		{
			if (fir) fir=0;else putchar(' ');
			print(A[i].A);
		}
		puts("");
	}
}
Problem2762
#include<cmath>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mp make_pair
#define Empty Mp(1,0)
using namespace std;

int IN()
{
	int c,x,f;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int oo=1000000,N=oo+19;
typedef pair<int,int> Pii;
struct Ine
{
	int a,b,c,v;
} I[N/10];
int n,a,b,c;
char s[10];

int C[2*N];
void Add(int x,int v) {for (x+=oo+1;x<=2*oo;x+=x&-x) C[x]+=v;}
int Query(int x) {int Ans=0;for (x+=oo+1;x;x-=x&-x) Ans+=C[x];return Ans;}

Pii Seg(int a,int b,int c)
{
	if (a==0) return b>c?Mp(-oo,oo):Empty;
	if (a>0)
	{
		int x=floor(1.0*(c-b)/a)+1;
		return x>oo?Empty:x<-oo?Mp(-oo,oo):Mp(x,oo);
	}
	if (a<0)
	{
		int x=ceil(1.0*(c-b)/a)-1;
		return x<-oo?Empty:x>oo?Mp(-oo,oo):Mp(-oo,x);
	}
}
void Add(int a,int b,int c)
{
	I[++n]=(Ine){a,b,c,0};
	Pii A=Seg(a,b,c);
	Add(A.first,1),Add(A.second+1,-1);
}
void Del(int x)
{
	if (I[x].v) return;I[x].v=1;
	Pii A=Seg(I[x].a,I[x].b,I[x].c);
	Add(A.first,-1),Add(A.second+1,1);
}

int main()
{
	for (int Q=IN();Q--;)
	{
		scanf("%s",s);
		if (s[0]=='A') a=IN(),b=IN(),c=IN(),Add(a,b,c);
		if (s[0]=='D') Del(IN());
		if (s[0]=='Q') printf("%d\n",Query(IN()));
	}
}
Problem2763
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=10000+19,Len=N*10;
struct Edge {int y,z,nxt;} E[N*5*2];
int Q[Len+19][2],Dis[N][12],vis[N][12],Last[N];
int f,w,n,m,k,S,T,Ans=(1<<30)-1,cnt,a,b,c,x,y;

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

inline void Update(int x,int y,int D)
{
	if (D<Dis[x][y])
	{
		Dis[x][y]=D;
		if (!vis[x][y])
		{
			vis[x][y]=1;
			if (Dis[x][y]<Dis[Q[w+1][0]][Q[w+1][1]]) Q[w][0]=x,Q[w][1]=y,w--;
				else f=f%Len+1,Q[f][0]=x,Q[f][1]=y;
		}
	}
}

void SPFA()
{
	memset(Dis,60,sizeof(Dis));Dis[S][0]=0;
	f=1,w=0,Q[1][0]=S,Q[1][1]=0;
	while (f!=w)
	{
		w=w%Len+1,x=Q[w][0],y=Q[w][1];vis[x][y]=0;
		for (int i=Last[x];~i;i=E[i].nxt)
		{
			Update(E[i].y,y,Dis[x][y]+E[i].z);
			if (y<k) Update(E[i].y,y+1,Dis[x][y]);
		}
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d%d%d%d",&n,&m,&k,&S,&T);
	For(i,0,m) read(a),read(b),read(c),Link(a,b,c);
	SPFA();
	For(i,0,k+1) Ans=min(Ans,Dis[T][i]);
	printf("%d\n",Ans);
}
Problem2766
#include<cstdio>
#include<cstring>
using namespace std;

const int Maxn=100+19,oo=(1<<30)-1;
int F[Maxn][27],pre[Maxn][27],Ans[Maxn][Maxn],Out[Maxn];
char s[Maxn][27];
int m,n,st,ed,Case,L;

int main()
{
	while (scanf("%d%d",&m,&n)==2&&m&&n)
	{
		for (int i=1;i<=m;i++) scanf("%s",s[i]);
		scanf("%d%d",&st,&ed);ed--;
		for (int i=st;i<ed;i++) 
			for (int j=0;j<n;j++) F[i][j]=-oo;
		for (int j=0;j<n;j++) F[ed][j]=(s[ed][j]=='O'?1:-oo),pre[ed][j]=0;
		for (int i=ed-1;i>=st;i--)
			for (int j=0;j<n;j++)
				if (s[i][j]=='O')
				{
					F[i][j]=oo;
					for (int k=0;k<n;k++)
						if (s[i+1][k]=='O'&&F[i+1][k]+(k!=j)<F[i][j])
							F[i][j]=F[i+1][k]+(k!=j),pre[i][j]=k;
				}
		printf("Case %d:\n\n",++Case);
		int Min=oo,pos;
		for (int i=0;i<n;i++) if (F[st][i]>0&&F[st][i]<Min) Min=F[st][i],pos=i;
		if (Min==oo) {puts("Not available\n");continue;}
		for (int j=st;j<=ed;j++) Out[j]=pos,pos=pre[j][pos];
		int L=st;Out[ed+1]=-1;
		for (int i=st+1;i<=ed+1;i++)
			if (Out[i]!=Out[i-1]) printf("%c: %d-%d\n",Out[L]+'A',L,i),L=i;
		puts("");
	}
}
Problem2768
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=300+19,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[N*N*2];
int A[N],Last[N],Q[N],Dis[N];
int S,T,n,m,x,y,cnt,Flow;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	int f=1,w=0;Q[1]=S;
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			res+=tmp,Flow-=tmp,E[i].f-=tmp,E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	S=n+1,T=S+1;
	For(i,1,n+1) scanf("%d",&A[i]),A[i]?Add_Edge(S,i,1):Add_Edge(i,T,1);
	For(i,0,m)
	{
		scanf("%d%d",&x,&y);
		if (A[x]^A[y]) A[x]?Add_Edge(x,y,1):Add_Edge(y,x,1);
	}
	while (BFS()) Flow+=Dinic(S,oo);
	printf("%d\n",Flow);
}
Problem2789
#include<cstdio>
#include<vector>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1000000+19;
vector<int> V[27];
int C[N],x,n;
char s[N];
long long Ans;

void Add(int x) {for (;x<n;x+=x&-x) C[x]++;}
int Query(int x) {int Ans=0;for (;x;x-=x&-x) Ans+=C[x];return Ans;}

int main()
{
	scanf("%d%s",&n,s);For(i,0,n) V[s[i]-'A'].push_back(i+1);
	scanf("%s",s);
	for (int i=n-1;~i;i--)
	{
		x=V[s[i]-'A'].back(),V[s[i]-'A'].pop_back();
		Ans+=Query(x-1),Add(x);
	}
	printf("%lld\n",Ans);
}
Problem2793
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=1000000+19,top=1000000;
bool lucky[Maxn],vis[Maxn];
int nxt[Maxn],n,m,x;
long long Ans[Maxn],tot;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void print(long long x) {if (!x) return;print(x/10);putchar(x%10+'0');}

int main()
{
	read(m);while (m--) read(x),lucky[x]=1;
	for (int i=1;i<=top;i++) nxt[i]=i;
	read(n);
	while (n--)
	{
		read(x);
		int& y=nxt[x];
		for (int i=1;i<=x;i++)
		{
			while (y<=top&&vis[y]) y+=x;
			if (y>top) break;
			vis[y]=1;
			if (lucky[y]) Ans[++Ans[0]]=tot+i,lucky[y]=0;
		}
		tot+=x;
	}
	if (!Ans[0]) puts("0");else print(Ans[0]),puts("");
	for (int i=1;i<=Ans[0];i++,puts("")) print(Ans[i]);
}
Problem2793
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=1000000+19,top=1000000;
bool lucky[Maxn],vis[Maxn];
int nxt[Maxn],n,m,x;
long long Ans[Maxn],tot;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	read(m);while (m--) read(x),lucky[x]=1;
	for (int i=1;i<=top;i++) nxt[i]=i;
	read(n);
	while (n--)
	{
		read(x);
		int& y=nxt[x];
		for (int i=1;i<=x;i++)
		{
			while (y<=top&&vis[y]) y+=x;
			if (y>top) break;
			vis[y]=1;
			if (lucky[y]) Ans[++Ans[0]]=tot+i,lucky[y]=0;
		}
		tot+=x;
	}
	for (int i=0;i<=Ans[0];i++) printf("%lld\n",Ans[i]);
}
Problem2793
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=1000000+19,top=1000000;
bool lucky[Maxn],vis[Maxn];
int nxt[Maxn],n,m,x;
long long Ans[Maxn],tot;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	read(m);while (m--) read(x),lucky[x]=1;
	for (int i=1;i<=top;i++) nxt[i]=1;
	read(n);
	while (n--)
	{
		read(x);
		int y=nxt[x];
		for (int i=1;i<=x;i++)
		{
			while (1LL*x*y<=top&&vis[x*y]) y++;
			if (1LL*x*y>top) break;
			int t=x*y;vis[t]=1;
			if (lucky[t]) Ans[++Ans[0]]=tot+i,lucky[t]=0;
		}
		tot+=x;nxt[x]=y;
	}
	for (int i=0;i<=Ans[0];i++) printf("%lld\n",Ans[i]);
}
Problem2793
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=1000000+19,top=1000000;
bool lucky[Maxn],vis[Maxn];
int nxt[Maxn],n,m,x;
long long Ans[Maxn],tot;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	read(m);while (m--) read(x),lucky[x]=1;
	for (int i=1;i<=top;i++) nxt[i]=1;
	read(n);
	while (n--)
	{
		read(x);
		int y=nxt[x];
		for (int i=1;i<=x;i++)
		{
			while (x*y<=top&&vis[x*y]) y++;if (x*y>top) break;
			int t=x*y;vis[t]=1;
			if (lucky[t]) Ans[++Ans[0]]=tot+i,lucky[t]=0;
		}
		tot+=x;nxt[x]=y;
	}
	for (int i=0;i<=Ans[0];i++) printf("%lld\n",Ans[i]);
}
Problem2793
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=1000000+19,top=1000000;
bool lucky[Maxn],vis[Maxn];
int nxt[Maxn],n,m,x;
long long Ans[Maxn],tot;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	read(m);while (m--) read(x),lucky[x]=1;
	for (int i=1;i<=top;i++) nxt[i]=1;
	read(n);
	while (n--)
	{
		read(x);
		for (int i=1;i<=x;i++)
		{
			while (x*nxt[x]<=top&&vis[x*nxt[x]]) nxt[x]++;
			if (x*nxt[x]>top) break;
			int t=x*nxt[x];vis[t]=1;
			if (lucky[t]) Ans[++Ans[0]]=tot+i,lucky[t]=0;
		}
		tot+=x;
	}
	for (int i=0;i<=Ans[0];i++) printf("%lld\n",Ans[i]);
}
Problem2802
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=250000+19;
typedef long long LL;
struct node
{
	int ID,v;
	bool operator < (const node& B) const {return v<B.v;}
};priority_queue<node> Q;
int A[N],B[N],vis[N],n,Ans;
LL cur;

int main()
{
	n=IN();
	For(i,1,n+1) A[i]=IN();
	For(i,1,n+1) B[i]=IN();
	For(i,1,n+1)
	{
		cur+=A[i];
		if (cur>=B[i]) cur-=B[i],Q.push((node){i,B[i]}),Ans++;else
			if (!Q.empty()&&B[i]<Q.top().v)
			{
				cur+=Q.top().v-B[i];Q.pop(),Q.push((node){i,B[i]});
			}
	}
	printf("%d\n",Ans);
	while (!Q.empty()) vis[Q.top().ID]=1,Q.pop();
	For(i,1,n+1) if (vis[i]) printf("%d ",i);puts("");
}
Problem2809
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=100000+19;
typedef long long LL;
struct Edge {int y,nxt;} E[N];
int B[N],Last[N],x,n,m,cnt;
LL Ans;

void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}

struct node *null;
struct node
{
	node *L,*R;
	int S,key,npl;LL sum;
} Nd[N],*rt[N];

node *Merge(node *A,node *B)
{
	if (A==null) return B;
	if (B==null) return A;
	if (A->key<B->key) swap(A,B);
	A->R=Merge(A->R,B);
	if (A->R->npl>A->L->npl) swap(A->L,A->R);
	A->npl=A->R->npl+1;
	A->sum=A->L->sum+A->R->sum+A->key;
	A->S=A->L->S+A->R->S+1;return A;
}

void DFS(int x)
{
	for (int i=Last[x];~i;i=E[i].nxt) DFS(E[i].y),rt[x]=Merge(rt[x],rt[E[i].y]);
	while (rt[x]->sum>m) rt[x]=Merge(rt[x]->L,rt[x]->R);
	Ans=max(Ans,1LL*rt[x]->S*B[x]);
}

int main()
{
	null=Nd;
	memset(Last,-1,sizeof(Last));
	read(n),read(m);
	For(i,0,n+1) Nd[i]=(node){null,null,1,0,0,0};
	null->npl=-1;null->S=0;
	For(i,1,n+1)
		read(x),read(Nd[i].key),read(B[i]),
		Add_Edge(x,i),Nd[i].sum=Nd[i].key,rt[i]=Nd+i;
	DFS(1);
	printf("%lld\n",Ans);
}
Problem2818
#include<cstdio>
using namespace std;

const int Maxn=1e7+19;
typedef long long LL;
int List[Maxn],p[Maxn];
LL A[Maxn],phi[Maxn],Ans;
int n,cnt;

int main()
{
	scanf("%d",&n);
	phi[1]=1;
	for (int i=2;i<=n;i++)
	{
		if (!p[i]) List[cnt++]=i,phi[i]=i-1;
		for (int j=0;j<cnt&&i*List[j]<=n;j++)
		{
			p[i*List[j]]=1;
			if (i%List[j]==0) {phi[i*List[j]]=phi[i]*List[j];break;}
				else phi[i*List[j]]=phi[i]*phi[List[j]];
		}
	}
	for (int i=2;i<=n;i++) phi[i]=phi[i-1]+2LL*phi[i];
	for (int i=0;i<cnt;i++) Ans+=phi[n/List[i]];
	printf("%lld\n",Ans);
}
Problem2819
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=500000+19;
struct Edge {int y,nxt;} E[N*2];
int Last[N],Fa[N][20],Deep[N],In[N],Out[N],C[N],A[N];
int n,Q,cnt,x,y,tot,pre;
char s[3];

void Update(int x,int v) {for (int i=x;i<=n;i+=i&-i) C[i]^=v;}
int Query(int x) {int Ans=0;for (int i=x;i;i-=i&-i) Ans^=C[i];return Ans;}
int Ask(int x) {return Query(In[x]);}

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x,int cur)
{
	In[x]=++tot,cur^=A[x];
	Update(tot,cur^pre);pre=cur;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x][0]) Fa[E[i].y][0]=x,Deep[E[i].y]=Deep[x]+1,DFS(E[i].y,cur);
	Out[x]=tot;
}
int Lca(int x,int y)
{
	if (Deep[x]>Deep[y]) swap(x,y);
	for (int k=Deep[y]-Deep[x],i=0;k;k>>=1,i++) if (k&1) y=Fa[y][i];
	if (x==y) return x;
	for (int i=19;i>=0;i--) if (Fa[x][i]!=Fa[y][i]) x=Fa[x][i],y=Fa[y][i];
	return Fa[x][0];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n);
	For(i,1,n+1) read(A[i]);
	For(i,1,n) read(x),read(y),Link(x,y);
	DFS(1,0);
	For(x,1,20) For(i,1,n+1) Fa[i][x]=Fa[Fa[i][x-1]][x-1];
	read(Q);
	while (Q--)
	{
		scanf("%s",s),read(x),read(y);
		if (s[0]=='Q') puts(Ask(x)^Ask(y)^A[Lca(x,y)]?"Yes":"No");
			else Update(In[x],A[x]^y),Update(Out[x]+1,A[x]^y),A[x]=y;
	}
}
Problem2819
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=500000+19;
struct Edge {int y,nxt;} E[N*2];
typedef int one[N];
one Last,D,A,__A,In,Out;
int Fa[20][N],n,cnt,tot,x,y,z;
char s[5];

one C;
void Upd(int x,int v) {for (;x<=n;x+=x&-x) C[x]^=v;}
int Qry(int x) {int Ans=0;for (x=In[x];x;x-=x&-x) Ans^=C[x];return Ans;}
void Modify(int L,int R,int v) {Upd(L,v),Upd(R+1,v);}

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x)
{
	In[x]=++tot;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if ((y=E[i].y)!=Fa[0][x])
		{
			Fa[0][y]=x,D[y]=D[x]+1,A[y]=A[y]^A[x];
			DFS(y);
		}
	Out[x]=tot;
}
int LCA(int x,int y)
{
	if (D[x]>D[y]) swap(x,y);
	for (int i=D[y]-D[x],k=0;i;i>>=1,k++) if (i&1) y=Fa[k][y];
	if (x==y) return x;
	for (int i=19;~i;i--) if (Fa[i][x]!=Fa[i][y]) x=Fa[i][x],y=Fa[i][y];
	return Fa[0][x];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN();
	For(i,1,n+1) __A[i]=A[i]=IN();
	For(i,1,n) Link(IN(),IN());
	DFS(1);
	For(i,1,20) For(x,1,n+1) Fa[i][x]=Fa[i-1][Fa[i-1][x]];
	For(i,1,n+1) Modify(In[i],In[i],A[i]);
	for (int Q=IN();Q--;)
	{
		scanf("%s",s);
		if (s[0]=='Q')
		{
			z=LCA(x=IN(),y=IN());
			puts(Qry(x)^Qry(y)^Qry(z)^Qry(Fa[0][z])?"Yes":"No");
		} else
		{
			x=IN(),y=IN();
			Modify(In[x],Out[x],__A[x]^y);__A[x]=y;
		}
	}
}
Problem2820
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int top=10000000,Maxn=top+19;
int vis[Maxn],g[Maxn],mu[Maxn],p[Maxn];
int T,n,m,cnt;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	g[1]=0;
	for (int i=2;i<=top;i++)
	{
		if (!vis[i]) p[cnt++]=i,mu[i]=-1,g[i]=1;
		for (int j=0;j<cnt&&1LL*p[j]*i<=top;j++)
		{
			vis[p[j]*i]=1;
			if (i%p[j]==0) {mu[p[j]*i]=0,g[p[j]*i]=mu[i];break;}
				else mu[p[j]*i]=-mu[i],g[p[j]*i]=-g[i]+mu[i];
		}
	}
	for (int i=2;i<=top;i++) g[i]+=g[i-1];
	read(T);
	while (T--)
	{
		long long Ans=0;
		read(n),read(m);
		for (int L=1,R;L<=n&&L<=m;L=R+1)
		{
			R=min(n/(n/L),m/(m/L));
			Ans+=1LL*(g[R]-g[L-1])*(n/L)*(m/L);
		}
		printf("%lld\n",Ans);
	}
}
Problem2821
#include<cmath>
#include<cstdio>
#include<cctype>
#include<algorithm>
 
#define Mid (L+R>>1)
using namespace std;
 
const int Maxn=100000+19;
typedef int one[Maxn];
one A,L,R,tot,vis,LL,RR,Cl,Cr;
struct node 
{
    int x,y;
    bool operator < (const node& B) const {return x<B.x||x==B.x&&y<B.y;}
    bool operator == (const node& B) const {return x==B.x&&y==B.y;}
} B[Maxn];
int Ans[1500][1500];
int n,c,Q,S,cnt,Ql,Qr,Lans,tmp,Bl,Br;
 
int ch;
void read(int &x)
{
    while (!isdigit(ch=getchar()));x=ch-'0';
    while (isdigit(ch=getchar())) x=x*10+ch-'0';
}
int low(node x)
{
    int L=Cl[x.x],R=Cr[x.x]+1,res;
    while (L<=R) if (x<B[Mid]||x==B[Mid]) res=Mid,R=Mid-1;else L=Mid+1;
    return res;
}
int upp(node x) {return low((node){x.x,x.y+1});}
void Calc(int x,int Flag)
{
    if (Flag) 
    {
        tmp=upp((node){x,R[Br]})-low((node){x,L[Bl]});
        if (tmp&&!(tmp&1)) Lans--;
    }
    tmp=upp((node){x,Qr})-low((node){x,Ql});
    if (tmp&&!(tmp&1)) Lans++;
}
 
int main()
{
    read(n),read(c),read(Q);
    for (int i=1;i<=n;i++) read(A[i]);
    S=sqrt(1.0*n/(log(n)/log(2)))+1;cnt=n/S+(n%S!=0);
    for (int i=1;i<=cnt;i++) L[i]=(i-1)*S+1,R[i]=i*S;R[cnt]=n;
    for (int i=1;i<=cnt;i++) 
    {
        for (int j=L[i-1];j<L[i];j++) LL[j]=i;
        for (int j=R[i+1];j>R[i];j--) RR[j]=i;
    }
    for (int i=1;i<=cnt;i++)
    {
        for (int j=L[i];j<=n;j++) tot[A[j]]=0;tmp=0;
        for (int j=i;j<=cnt;j++)
        {
            for (int k=L[j];k<=R[j];k++) 
            {
                if (tot[A[k]]) if (!(tot[A[k]]&1)) tmp--;
                tot[A[k]]++;
                if (tot[A[k]]) if (!(tot[A[k]]&1)) tmp++;
            }
            Ans[i][j]=tmp;
        }
    }
    for (int i=1;i<=n;i++) B[i]=(node){A[i],i};
    sort(B+1,B+n+1);B[n+1]=(node){1<<30,1<<30};
    for (int i=1;i<=n+1;i++)
        if (B[i].x!=B[i-1].x) Cl[B[i].x]=i,Cr[B[i-1].x]=i-1;
    while (Q--)
    {
        read(Ql),read(Qr);
        Ql=(Ql+Lans)%n+1;Qr=(Qr+Lans)%n+1;
        if (Ql>Qr) swap(Ql,Qr);
        Bl=LL[Ql];Br=RR[Qr];
        Lans=Ans[Bl][Br];
        if (Bl<=Br)
        {
            for (int i=Ql;i<L[Bl];i++) if (vis[A[i]]!=Q) vis[A[i]]=Q,Calc(A[i],1);
            for (int i=R[Br]+1;i<=Qr;i++) if (vis[A[i]]!=Q) vis[A[i]]=Q,Calc(A[i],1);
        } else for (int i=Ql;i<=Qr;i++) if (vis[A[i]]!=Q) vis[A[i]]=Q,Calc(A[i],0);
        printf("%d\n",Lans);
    }
}
Problem2822
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int Maxl=50+9,Base=100000000;
typedef long long LL;
struct Bigint
{
	LL s[Maxl];int Len;
	Bigint() {memset(s,0,sizeof(s));Len=1;}
	Bigint(int x) {memset(s,0,sizeof(s));Len=1;s[0]=x;}

	void clear() {while (Len>1&&!s[Len-1]) Len--;}
	void Output()
	{
		printf("%lld",s[Len-1]);
		for (int i=Len-2;i>=0;i--) printf("%08lld",s[i]);puts("");
	}
} C[500+19];

Bigint operator * (Bigint A,int B)
{
	A.Len+=2;
	For(i,0,A.Len) A.s[i]*=B;
	For(i,0,A.Len) A.s[i+1]+=A.s[i]/Base,A.s[i]%=Base;
	return A.clear(),A;
}
Bigint operator / (Bigint A,int B)
{
	for (int i=A.Len-1;i>=0;i--)
	{
		if (i) A.s[i-1]+=1LL*(A.s[i]%B)*Base;
		A.s[i]/=B;
	}
	return A.clear(),A;
}

int n;

int main()
{
	scanf("%d",&n);
	C[1]=Bigint(1);
	For(i,2,n+1) C[i]=C[i-1]*(4*i-2)/(i+1);
	C[n].Output();
}
Problem2824
#include<cstdio>
#include<algorithm>
using namespace std;

int A[50+19],B[100+19];
int n,Ans,tmp;

int cmp(int a,int b) {return A[a]<A[b];}

void DFS(int g,int h)
{
	if (!h&&!A[0]) {Ans=min(Ans,g);return;}
	for (int i=1;i<n;i++)
	{
		int t=h-(i<n-1?(abs(A[i]-A[i+1])>1)-(abs(A[0]-A[i+1])>1):0);
		if (g+t<Ans)
		{
			for (int j=0;j+j<i;j++) swap(A[j],A[i-j]);
			DFS(g+1,t);
			for (int j=0;j+j<i;j++) swap(A[j],A[i-j]);
		}
	}
}

int main()
{
	scanf("%d",&n);Ans=2*n;
	for (int i=0;i<n;i++) scanf("%d",&A[i]),B[i]=i;
	sort(B,B+n,cmp);
	for (int i=0;i<n;i++) A[B[i]]=i;
	for (int i=1;i<n;i++) tmp+=abs(A[i]-A[i-1])>1;
	DFS(0,tmp);
	printf("%d\n",Ans);
}
Problem2841
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
#define mp make_pair
#define fir first
#define sec second
using namespace std;

typedef long long LL;
typedef double Db;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=200000+19,M=600000+19;
struct Edge {int y,nxt;} E[M*2];
typedef int one[N];
typedef pair<int,int> Pii;
one Last,DFN,Low,vis,res;
Pii Stk[2*M];
vector<Pii> V[M];
vector<Pii>::iterator it;
int cnt,n,m,top,tot,BCC,Ans,x,y;

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void Tarjan(int x,int pre)
{
	Low[x]=DFN[x]=++tot;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (i!=pre)
		{
			Stk[++top]=mp(x,y=E[i].y);
			if (!DFN[y])
			{
				Tarjan(y,i^1),Low[x]=min(Low[x],Low[y]);
				if (Low[y]>=DFN[x])
				{
					Pii u;BCC++;
					do
					{
						u=Stk[top--];V[BCC].Pb(u);
					} while (u!=mp(x,y));
				}
			} else Low[x]=min(Low[x],DFN[y]);
		}
}
int DFS(int x,int col)
{
	vis[x]=col;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (!vis[y=E[i].y])
		{
			if (DFS(y,col^3)) return 1;
		} else if (vis[y]!=(col^3)) return 1;
	return 0;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,m+1) Link(IN(),IN());
	For(i,1,n+1) if (!DFN[i]) Tarjan(i,-1);
	memset(Last,-1,sizeof(Last));cnt=0;
	For(i,1,BCC+1)
	{
		for (it=V[i].begin();it!=V[i].end();it++) Link(it->fir,it->sec);
		if (DFS(V[i][0].fir,1))
			for (it=V[i].begin();it!=V[i].end();it++) res[it->fir]=res[it->sec]=1;
		for (it=V[i].begin();it!=V[i].end();it++)
		{
			x=it->fir,y=it->sec;
			Last[x]=Last[y]=-1,vis[x]=vis[y]=0;
		}
		cnt=0;
	}
	For(i,1,n+1) Ans+=!res[i];
	printf("%d\n",Ans);
}
Problem2841
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
#define mp make_pair
#define fir first
#define sec second
using namespace std;

typedef long long LL;
typedef double Db;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=100000+19,M=600000+19;
struct Edge {int y,nxt;} E[M*2];
typedef int one[N];
typedef pair<int,int> Pii;
one Last,DFN,Low,vis,res;
Pii Stk[2*M];
vector<Pii> V[M];
vector<Pii>::iterator it;
int cnt,n,m,top,tot,BCC,Ans,x,y;

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void Tarjan(int x,int pre)
{
	Low[x]=DFN[x]=++tot;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (i!=pre)
		{
			Stk[++top]=mp(x,y=E[i].y);
			if (!DFN[y])
			{
				Tarjan(y,i^1),Low[x]=min(Low[x],Low[y]);
				if (Low[y]>=DFN[x])
				{
					Pii u;BCC++;
					do
					{
						u=Stk[top--];V[BCC].Pb(u);
					} while (u!=mp(x,y));
				}
			} else Low[x]=min(Low[x],DFN[y]);
		}
}
int DFS(int x,int col)
{
	vis[x]=col;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (!vis[y=E[i].y])
		{
			if (DFS(y,col^3)) return 1;
		} else if (vis[y]!=(col^3)) return 1;
	return 0;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,m+1) Link(IN(),IN());
	For(i,1,n+1) if (!DFN[i]) Tarjan(i,-1);
	memset(Last,-1,sizeof(Last));cnt=0;
	For(i,1,BCC+1)
	{
		for (it=V[i].begin();it!=V[i].end();it++) Link(it->fir,it->sec);
		if (DFS(V[i][0].fir,1))
			for (it=V[i].begin();it!=V[i].end();it++) res[it->fir]=res[it->sec]=1;
		for (it=V[i].begin();it!=V[i].end();it++)
		{
			x=it->fir,y=it->sec;
			Last[x]=Last[y]=-1,vis[x]=vis[y]=0;
		}
		cnt=0;
	}
	For(i,1,n+1) Ans+=!res[i];
	printf("%d\n",Ans);
}
Problem2841
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
#define mp make_pair
#define fir first
#define sec second
using namespace std;

typedef long long LL;
typedef double Db;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=100000+19,M=300000+19;
struct Edge {int y,nxt;} E[M*4];
typedef int one[N];
typedef pair<int,int> Pii;
one Last,DFN,Low,vis,res;
Pii Stk[2*M];
vector<Pii> V[M];
vector<Pii>::iterator it;
int cnt,n,m,top,tot,BCC,Ans,x,y;

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void Tarjan(int x,int pre)
{
	Low[x]=DFN[x]=++tot;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (i!=pre)
		{
			Stk[++top]=mp(x,y=E[i].y);
			if (!DFN[y])
			{
				Tarjan(y,i^1),Low[x]=min(Low[x],Low[y]);
				if (Low[y]>=DFN[x])
				{
					Pii u;BCC++;
					do
					{
						u=Stk[top--];V[BCC].Pb(u);
					} while (u!=mp(x,y));
				}
			} else Low[x]=min(Low[x],DFN[y]);
		}
}
int DFS(int x,int col)
{
	vis[x]=col;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (!vis[y=E[i].y])
		{
			if (DFS(y,col^3)) return 1;
		} else if (vis[y]!=(col^3)) return 1;
	return 0;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,m+1) Link(IN(),IN());
	For(i,1,n+1) if (!DFN[i]) Tarjan(i,-1);
	memset(Last,-1,sizeof(Last));cnt=0;
	For(i,1,BCC+1)
	{
		for (it=V[i].begin();it!=V[i].end();it++) Link(it->fir,it->sec);
		if (DFS(V[i][0].fir,1))
			for (it=V[i].begin();it!=V[i].end();it++) res[it->fir]=res[it->sec]=1;
		for (it=V[i].begin();it!=V[i].end();it++)
		{
			x=it->fir,y=it->sec;
			Last[x]=Last[y]=-1,vis[x]=vis[y]=0;
		}
		cnt=0;
	}
	For(i,1,n+1) Ans+=!res[i];
	printf("%d\n",Ans);
}
Problem2841
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
#define mp make_pair
#define fir first
#define sec second
using namespace std;

typedef long long LL;
typedef double Db;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=100000+19,M=300000+19;
struct Edge {int y,nxt;} E[M*2];
typedef int one[N];
typedef pair<int,int> Pii;
one Last,DFN,Low,vis,res;
Pii Stk[2*M];
vector<Pii> V[M];
vector<Pii>::iterator it;
int cnt,n,m,top,tot,BCC,Ans,x,y;

void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
void Tarjan(int x,int pre)
{
	Low[x]=DFN[x]=++tot;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (i!=pre)
		{
			Stk[++top]=mp(x,y=E[i].y);
			if (!DFN[y])
			{
				Tarjan(y,i^1),Low[x]=min(Low[x],Low[y]);
				if (Low[y]>=DFN[x])
				{
					Pii u;BCC++;
					do
					{
						u=Stk[top--];V[BCC].Pb(u);
					} while (u!=mp(x,y));
				}
			} else Low[x]=min(Low[x],DFN[y]);
		}
}
int DFS(int x,int col)
{
	vis[x]=col;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (!vis[y=E[i].y])
		{
			if (DFS(y,col^3)) return 1;
		} else if (vis[y]!=(col^3)) return 1;
	return 0;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,m+1) x=IN(),y=IN(),Add_Edge(x,y),Add_Edge(y,x);
	For(i,1,n+1) if (!DFN[i]) Tarjan(i,-1);
	memset(Last,-1,sizeof(Last));cnt=0;
	For(i,1,BCC+1)
	{
		for (it=V[i].begin();it!=V[i].end();it++) Add_Edge(it->fir,it->sec);
		if (DFS(V[i][0].fir,1))
			for (it=V[i].begin();it!=V[i].end();it++) res[it->fir]=res[it->sec]=1;
		for (it=V[i].begin();it!=V[i].end();it++)
		{
			x=it->fir,y=it->sec;
			Last[x]=Last[y]=-1,vis[x]=vis[y]=0;
		}
		cnt=0;
	}
	For(i,1,n+1) Ans+=!res[i];
	printf("%d\n",Ans);
}
Problem2841
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
#define mp make_pair
#define fir first
#define sec second
using namespace std;

typedef long long LL;
typedef double Db;

const int N=100000+19,M=300000+19,Len=8000000;
struct Edge {int y,nxt;} E[M*2];
typedef int one[N];
typedef pair<int,int> Pii;
one Last,DFN,Low,vis,res;
Pii Stk[2*M];
vector<Pii> V[M];
vector<Pii>::iterator it;
int cnt,n,m,top,tot,BCC,Ans,x,y;
char Buf[Len],*b=Buf;

int IN()
{
	int c,f,x;
	while (!isdigit(c=*b++)&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=*b++)) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
void Tarjan(int x,int pre)
{
	Low[x]=DFN[x]=++tot;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (i!=pre)
		{
			Stk[++top]=mp(x,y=E[i].y);
			if (!DFN[y])
			{
				Tarjan(y,i^1),Low[x]=min(Low[x],Low[y]);
				if (Low[y]>=DFN[x])
				{
					Pii u;BCC++;
					do
					{
						u=Stk[top--];V[BCC].Pb(u);
					} while (u!=mp(x,y));
				}
			} else Low[x]=min(Low[x],DFN[y]);
		}
}
int DFS(int x,int col)
{
	vis[x]=col;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if (!vis[y=E[i].y])
		{
			if (DFS(y,col^3)) return 1;
		} else if (vis[y]!=(col^3)) return 1;
	return 0;
}

int main()
{
	fread(Buf,1,Len,stdin);
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,m+1) x=IN(),y=IN(),Add_Edge(x,y),Add_Edge(y,x);
	For(i,1,n+1) if (!DFN[i]) Tarjan(i,-1);
	memset(Last,-1,sizeof(Last));cnt=0;
	For(i,1,BCC+1)
	{
		for (it=V[i].begin();it!=V[i].end();it++) Add_Edge(it->fir,it->sec);
		if (DFS(V[i][0].fir,1))
			for (it=V[i].begin();it!=V[i].end();it++) res[it->fir]=res[it->sec]=1;
		for (it=V[i].begin();it!=V[i].end();it++)
		{
			x=it->fir,y=it->sec;
			Last[x]=Last[y]=-1,vis[x]=vis[y]=0;
		}
		cnt=0;
	}
	For(i,1,n+1) Ans+=!res[i];
	printf("%d\n",Ans);
}
Problem2843
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=30000+19;
struct node *null;
struct node
{
	node *L,*R,*Fa;
	int key,Sum,rev;

	bool Top() {return Fa==null||Fa->L!=this&&Fa->R!=this;}
	void Update() {Sum=L->Sum+R->Sum+key;}
	void Setrev() {rev^=1,swap(L,R);}
	void Down() {if (rev) L->Setrev(),R->Setrev(),rev=0;}

	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N];

void Splay(node *x)
{
	static node *S[N];
	node *tmp=x;int k=0;
	while (!tmp->Top()) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (!x->Top())
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top())
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}
node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa) Splay(x),x->R=y,x->Update();
	return y;
}
node *Root(node *x)
{
	Access(x),Splay(x);
	while (x->L!=null) x=x->L,x->Down();
	return x;
}
void Evert(node *x) {Access(x)->Setrev();}
void Link(node *x,node *y)
{
	if (Root(x)==Root(y)) {puts("no");return;}
	puts("yes"),Evert(x),Splay(x),x->Fa=y;
}

int A[N],n,Q,x,y;
char s[15];

int main()
{
	null=Nd;
	n=IN();
	For(i,1,n+1) A[i]=IN();
	For(i,0,n+1) Nd[i]=(node){null,null,null,A[i],A[i],0};
	Q=IN();
	while (Q--)
	{
		scanf("%s",s);
		if (s[0]=='b') Link(Nd+IN(),Nd+IN());
		if (s[0]=='p') x=IN(),y=IN(),Splay(Nd+x),(Nd+x)->key=y,(Nd+x)->Update();
		if (s[0]=='e')
		{
			x=IN(),y=IN();
			if (Root(Nd+x)!=Root(Nd+y)) puts("impossible");else
				Evert(Nd+x),printf("%d\n",Access(Nd+y)->Sum);
		}
	}
}
Problem2843
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=30000+19;
int n,x,a,b;
char s[20];

struct node *null;
struct node
{
	node *L,*R,*Fa;
	int rev,Sum,key;
	
	bool Top() {return Fa==null||Fa->L!=this&&Fa->R!=this;}
	void Setrev() {rev^=1,swap(L,R);}
	void Update() {if (this!=null) Sum=L->Sum+R->Sum+key;}
	void Down() {if (rev) L->Setrev(),R->Setrev(),rev=0;}
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y,y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y,y->Fa=this;y->Update();
	}
} Nd[N],*A,*B;

void Splay(node *x)
{
	static node *S[N];node *tmp=x;int k=0;
	while (!tmp->Top()) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (!x->Top())
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top())
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}
node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa) Splay(x),x->R=y,x->Update();
	return y;
}
void Evert(node *x) {Access(x)->Setrev();}
node *Root(node *x)
{
	Access(x),Splay(x);
	while (x->L!=null) x=x->L,x->Down();
	return x;
}
void Link(node *x,node *y) {Evert(x),Splay(x),x->Fa=y;}

int main()
{
	null=Nd;*null=(node){null,null,null,0,0,0};
	n=IN();
	For(i,1,n+1) x=IN(),Nd[i]=(node){null,null,null,0,x,x};
	for (int Qc=IN();Qc--;)
	{
		scanf("%s",s);
		if (s[0]=='b')
		{
			A=Nd+IN(),B=Nd+IN();
			if (Root(A)==Root(B)) {puts("no");continue;}
			puts("yes");Link(A,B);
		}
		if (s[0]=='p') A=Nd+IN(),Splay(A),A->key=IN(),A->Update();
		if (s[0]=='e')
		{
			A=Nd+IN(),B=Nd+IN();
			if (Root(A)!=Root(B)) {puts("impossible");continue;}
			Evert(A),printf("%d\n",Access(B)->Sum);
		}
	}
}
Problem2843
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=100000+19;
int n,x,v;
char s[20];

struct node *null;
struct node
{
	node *L,*R,*Fa;
	int key,Sum,rev;
	bool Top() {return Fa==null||Fa->L!=this&&Fa->R!=this;}
	void Setrev() {rev^=1,swap(L,R);}
	void Down() {if (rev) L->Setrev(),R->Setrev(),rev=0;}
	void Update() {Sum=L->Sum+R->Sum+key;}
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y,y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y,y->Fa=this;y->Update();
	}
} Nd[N];

void Splay(node *x)
{
	static node *S[N];node *tmp=x;int k=0;
	while (!tmp->Top()) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (!x->Top())
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top()) 
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}
node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa) Splay(x),x->R=y,x->Update();
	return y;
}
void Evert(node *x) {Access(x)->Setrev();}
node *Root(node *x)
{
	Access(x),Splay(x);
	while (x->L!=null) x=x->L,x->Down();
	return x;
}
void Link(node *x,node *y)
{
	if (Root(x)==Root(y)) {puts("no");return;}
	puts("yes");Evert(x),Splay(x),x->Fa=y;
}
void Query(node *x,node *y)
{
	if (Root(x)!=Root(y)) {puts("impossible");return;}
	Evert(x),printf("%d\n",Access(y)->Sum);
}

int main()
{
	null=Nd;*null=(node){null,null,null,0,0,0};
	n=IN();
	For(i,1,n+1)
	{
		v=IN();
		Nd[i]=(node){null,null,null,v,v,0};
	}
	for (int Qc=IN();Qc--;)
	{
		scanf("%s",s);
		if (s[0]=='b') Link(Nd+IN(),Nd+IN());
		if (s[0]=='p')
		{
			node *x=Nd+IN();v=IN();
			Splay(x),x->key=v,x->Update();
		}
		if (s[0]=='e') Query(Nd+IN(),Nd+IN());
	}
}
Problem2870
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=50000+19;
struct Edge {int y,nxt;} E[N*2];
struct node
{
	int v,ID;
	bool operator < (const node& B) const {return v<B.v;}
} A[N];
int Fa[N][16],Pa[N],Last[N],Deep[N],C[N][2],vis[N];
int cnt,n,Ans;

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
int Getf(int x) {return Pa[x]==x?x:Pa[x]=Getf(Pa[x]);}
void DFS(int x)
{
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x][0])
			Fa[E[i].y][0]=x,Deep[E[i].y]=Deep[x]+1,DFS(E[i].y);
}
int Query(int x,int y)
{
	if (Deep[x]>Deep[y]) swap(x,y);
	int a=x,b=y;
	for (int i=Deep[y]-Deep[x],k=0;i;i>>=1,k++) if (i&1) y=Fa[y][k];
	if (x==y) return Deep[b]-Deep[a]+1;
	for (int i=15;~i;i--) if (Fa[x][i]!=Fa[y][i]) x=Fa[x][i],y=Fa[y][i];
	return x=Fa[x][0],Deep[a]+Deep[b]-Deep[x]-Deep[Fa[x][0]];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN();
	For(i,1,n+1) A[i]=(node){IN(),i},Pa[i]=i;
	For(i,1,n) Link(IN(),IN());
	Deep[1]=1,DFS(1);
	For(x,1,16) For(i,1,n+1) Fa[i][x]=Fa[Fa[i][x-1]][x-1];
	sort(A+1,A+n+1);
	for (int t=n;t;t--)
	{
		int x=A[t].ID,ax=x,ay=x,fx=Getf(x),Max=1,tmp,cx,cy;vis[x]=1;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (vis[E[i].y])
			{
				int fy=Getf(E[i].y),bx=C[fy][0],by=C[fy][1],cx=ax,cy=ay;
				Pa[fy]=fx;
				if ((tmp=Query(ax,bx))>Max) Max=tmp,cx=ax,cy=bx;
				if ((tmp=Query(ax,by))>Max) Max=tmp,cx=ax,cy=by;
				if ((tmp=Query(ay,bx))>Max) Max=tmp,cx=ay,cy=bx;
				if ((tmp=Query(ay,by))>Max) Max=tmp,cx=ay,cy=by;
				if ((tmp=Query(bx,by))>Max) Max=tmp,cx=bx,cy=by;
				ax=cx,ay=cy;
			}
		C[fx][0]=ax,C[fx][1]=ay;
		Ans=max(Ans,A[t].v*Max);
	}
	printf("%d\n",Ans);
}
Problem2875
#include<cstdio>
using namespace std;

typedef long long LL;
struct Matrix {int n,m;LL s[2][2];} A,B;
LL m,a,c,x0,n;int g;

LL Mult(LL A,LL b)
{
	LL res=0;
	for (;b;b>>=1,A=(A+A)%m) if (b&1) res=(res+A)%m;
	return res;
}
Matrix operator * (Matrix A,Matrix B)
{
	Matrix C;C.n=A.n,C.m=B.m;
	for (int i=0;i<C.n;i++)
		for (int j=0;j<C.m;j++)
		{
			C.s[i][j]=0;
			for (int k=0;k<A.m;k++) (C.s[i][j]+=Mult(A.s[i][k],B.s[k][j]))%=m;
		}
	return C;
}
Matrix Pow(Matrix A,LL b)
{
	Matrix res=A;
	for (--b;b;b>>=1,A=A*A) if (b&1) res=res*A;
	return res;
}

int main()
{
	scanf("%lld%lld%lld%lld%lld%d",&m,&a,&c,&x0,&n,&g);
	A.n=1,A.m=2;
	A.s[0][0]=x0,A.s[0][1]=c;
	B.n=B.m=2;
	B.s[0][0]=a,B.s[0][1]=0,B.s[1][0]=B.s[1][1]=1;
	A=A*Pow(B,n);
	printf("%d\n",A.s[0][0]%g);
}
Problem2879
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=40+100*800+19,M=10000000,oo=(1<<30)-1;
struct Edge {int y,f,c,nxt;} E[M];
int Last[N],Q[N],Dis[N],pre[N],vis[N],Ti[41][101];
int cnt,n,p,S,T,Ans,x,Sum,m;

int ID(int i,int j) {return (i-1)*Sum+(j-1)+n+1;}

void Add_Edge(int x,int y,int f,int c)
{
	E[cnt]=(Edge){y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,-c,Last[y]};Last[y]=cnt++;
}
bool SPFA()
{
	int f=1,w=0;Q[1]=S;pre[S]=-1;
	memset(Dis,64,sizeof(Dis));Dis[S]=0;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[x]+E[i].c<Dis[E[i].y])
			{
				pre[E[i].y]=i;
				Dis[E[i].y]=Dis[x]+E[i].c;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
		vis[x]=0;
	}
	return Dis[T]<oo;
}
void Update()
{
	for (int i=pre[T];~i;i=pre[E[i^1].y]) E[i].f--,E[i^1].f++;
	Ans+=Dis[T];
	int t=E[pre[T]^1].y-n-1,x=t/Sum+1,y=t%Sum+1;
	For(i,1,n+1) Add_Edge(i,ID(x,y+1),1,Ti[i][x]*(y+1));
	Add_Edge(ID(x,y+1),T,1,0);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();S=N-1,T=S-1;
	For(i,1,n+1) Add_Edge(S,i,x=IN(),0),Sum+=x;
	For(i,1,n+1) For(j,1,m+1) Add_Edge(i,ID(j,1),1,Ti[i][j]=IN());
	For(i,1,m+1) Add_Edge(ID(i,1),T,1,0);
	while (SPFA()) Update();
	printf("%d\n",Ans);
}
Problem2929
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=200+19,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[N*N];
int Last[N],Q[N],Dis[N];
int S,T,cnt,n,m,x,y,Ans,C;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	int f=1,w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(E[i].f,Flow));
			res+=tmp,Flow-=tmp,E[i].f-=tmp,E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);
	For(i,1,n)
	{
		scanf("%d",&C);
		while (C--) scanf("%d",&x),Add_Edge(i,x,i==1||x==n?1:oo);
	}
	S=1,T=n;
	while (BFS()) Ans+=Dinic(S,oo);
	printf("%d\n",Ans);
}
Problem2937
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=10000*3+19;
typedef long long LL;
LL Sa[N],Sb[N],tmp,Ans=1LL<<60;
int A[N],B[N],x,n;

LL Dis(int i,int j) {return Sb[j-1]-Sb[i-1];}

int main()
{
	n=IN();
	For(i,1,n+1) A[i]=A[i+n]=A[i+n+n]=IN(),B[i]=B[i+n]=B[i+n+n]=IN();
	For(i,1,3*n+1) Sa[i]=Sa[i-1]+A[i],Sb[i]=Sb[i-1]+B[i];
	For(i,1,n+1) tmp+=1LL*Dis(i,n+1)*A[i];x=1;
	For(i,n+1,n+n+1)
	{
		while (Dis(x,i)>Dis(i,x+n)) tmp=tmp+1LL*(Dis(i,x+n)-Dis(x,i))*A[x++];
		Ans=min(Ans,tmp);
		tmp=tmp+1LL*((Sa[i]-Sa[x-1])-(Sa[x+n-1]-Sa[i]))*B[i];
	}
	printf("%lld\n",Ans);
}
Problem2938
#include<cstdio>
#include<cstring>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=30000+19;
struct Edge {int y,nxt;} E[N*2];
int son[N][2],vis[N],Q[N],Fail[N],Last[N],In[N],n,tot,f,w,cnt;
char s[N];

void Add_Edge(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;In[y]++;
}
bool Toposort()
{
	f=w=0;int tmp=0;
	For(i,0,tot+1)
		if (!vis[i])
		{
			tmp++;if (!In[i]) Q[++f]=i;
		}
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if ((--In[E[i].y])==0) Q[++f]=E[i].y;
	}
	return f!=tmp;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	for (scanf("%d",&n);n--;)
	{
		scanf("%s",s);int L=strlen(s),x=0;
		For(i,0,L)
		{
			int &u=son[x][s[i]-'0'];
			if (!u) u=++tot;x=u;
		}
		vis[x]=1;
	}
	f=1,w=0;
	while (f>w)
	{
		int x=Q[++w];vis[x]|=vis[Fail[x]];
		For(i,0,2)
		{
			int &u=son[x][i];
			if (u) {Q[++f]=u;if (x) Fail[u]=son[Fail[x]][i];}
				else u=son[Fail[x]][i];
		}
	}
	For(x,0,tot+1) if (!vis[x])
		For(i,0,2) if (!vis[son[x][i]]) Add_Edge(x,son[x][i]);
	puts(Toposort()?"TAK":"NIE");
}
Problem2939
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=5000*2+19,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[2000000];
int Last[N],Dis[N],Q[N],f,w,cnt,Ans,n,S,T;

void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	f=1,w=0;Q[1]=S;
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			E[i].f-=tmp,E[i^1].f+=tmp,Flow-=tmp,res+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN();
	Add_Edge(1,2,oo),Add_Edge(2*n-1,2*n,oo);
	For(i,2,n) Add_Edge(2*i-1,2*i,1);
	For(i,1,n) for (int k=IN();k--;) Add_Edge(2*i,2*IN()-1,1);
	S=1,T=2*n;
	while (BFS()) Ans+=Dinic(S,oo);
	printf("%d\n",Ans);
}
Problem2940
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1000+19;
int SG[N],vis[N],Time,c,z,n,x,m;

void Prepare()
{
	For(i,1,1001)
	{
		Time++;
		for (int j=0;i-c-j>=0;j++) vis[SG[j]^SG[i-c-j]]=Time;
		for (int j=0;i-z-j>=0;j++) vis[SG[j]^SG[i-z-j]]=Time;
		for (int j=0;i-n-j>=0;j++) vis[SG[j]^SG[i-n-j]]=Time;
		while (vis[SG[i]]==Time) SG[i]++;
	}
}

int main()
{
	scanf("%d%d%d",&c,&z,&n);
	Prepare();
	for (scanf("%d",&m);m--;) scanf("%d",&x),puts(SG[x]?"1":"2");
}
Problem2941
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=500+19;
struct Edge {int y,nxt;} E[N*N];
int SPY[N],Q[N],Last[N],is_C[N],vis[N],f,w,Time,cnt,n,b;

void Add(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
void BFS(int S)
{
	f=w=0;Time++;
	For(i,1,n+1) if (is_C[i]&&i!=S) Q[++f]=i;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (vis[E[i].y]!=Time) vis[E[i].y]=Time,Q[++f]=E[i].y;
	}
	For(i,1,n+1) if (!is_C[i]&&vis[i]!=Time) SPY[i]=1;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN();
	For(i,1,n+1)
	{
		int k=IN();is_C[i]=!k;
		while (k--) Add(IN(),i);
	}
	For(i,1,n+1) if (is_C[i]) BFS(i);
	For(i,1,n+1) if (SPY[i]) printf("%d\n",i),b=1;
	if (!b) puts("BRAK");
}
Problem2942
#include<cstdio>
#include<cctype>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=10000+19,P=1000;
int A[N],B[N],vis[N],x[N],n,Ans=1,tmp;

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=a*a%P) if (b&1) res=res*a%P;
	return res;
}

int main()
{
	n=IN();
	For(i,1,n+1) B[i]=IN();
	For(i,1,n+1) if (!vis[i])
	{
		int cnt=1;vis[i]=1;
		for (int j=B[i];j!=i;j=B[j]) vis[j]=1,cnt++;
		A[++*A]=cnt;
	}
	For(i,1,*A+1) if (A[i]%2==0) return puts("0"),0;
	For(i,1,*A+1) (Ans*=Pow(2,(A[i]-1)/2))%=P;
	For(i,1,*A+1) x[A[i]]++;
	For(i,1,n+1) for (int j=2*i;j<=n;j+=i) x[i]+=x[j];
	For(i,1,n+1) x[i]=x[i]*(x[i]-1)/2;
	for (int i=n;i;i--) for (int j=2*i;j<=n;j+=i) x[i]-=x[j];
	For(i,1,n+1) tmp+=x[i]*i;
	(Ans*=Pow(2,tmp))%=P;
	printf("%d\n",Ans);
}
Problem2944
#include<cstdio>
#include<string>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=25;
string S;
int C[N],k,n;

string Solve(string S,int k)
{
	int m=S.length();
	if (!m) return "";
	For(i,0,m)
		if (C[i]*C[m-1-i]<=k) k-=C[i]*C[m-1-i];
			else return S[i]+Solve(S.substr(0,i),k/C[m-1-i])+Solve(S.substr(i+1,m),k%C[m-1-i]);
}

int main()
{
	scanf("%d%d",&k,&n);
	For(i,0,n) S+=i+'a';
	C[0]=1;
	For(i,1,n+1) For(j,0,i) C[i]+=C[j]*C[i-1-j];
	puts(Solve(S,k-1).c_str());
}
Problem2946
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=2000+19,oo=(1<<30)-1;
char s[6][Maxn];
int n,Len,Ans,F[Maxn];

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%s",s[i]);
	Len=strlen(s[0]);
	for (int i=0;i<Len;i++)
	{
		F[i]=F[i+1]=i;
		for (int j=i+1;j<Len;j++)
		{
			int k=F[j];
			while (k!=i&&s[0][k]!=s[0][j]) k=F[k];
			F[j+1]=(s[0][k]==s[0][j]?k+1:i);
		}
		int Min=oo;
		for (int x=1;x<n;x++)
		{
			int j=i,Max=0;
			for (int k=0,_=strlen(s[x]);k<_;k++)
			{
				while (j!=i&&s[0][j]!=s[x][k]) j=F[j];
				if (s[0][j]==s[x][k]) j++;
				Max=max(Max,j-i);
			}
			Min=min(Min,Max);
		}
		Ans=max(Ans,Min);
	}
	printf("%d\n",n==1?Len:Ans);
}
Problem2947
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int N=1e6+19,Top=1e6,Len=20000000;
char Buf[Len],*B=Buf;
int S[N*4],n,Qx,Qv;
long long Ans;

int IN()
{
	int c,x;
	while (!isdigit(c=*B++));x=c-'0';
	while (isdigit(c=*B++)) x=(x<<1)+(x<<3)+c-'0';return x;
}

void Add(int x,int L,int R)
{
	S[x]+=Qv;
	if (L==R) return;
	Qx<=Mid?Add(Lsn,L,Mid):Add(Rsn,Mid+1,R);
}
int Qmax(int x,int L,int R)
{
	if (L==R) return S[x]?L:0;
	int t=Qmax(Rsn,Mid+1,R);
	return t?t:Qmax(Lsn,L,Mid);
}
int Qmin(int x,int L,int R)
{
	if (L==R) return S[x]?L:0;
	int t=Qmin(Lsn,L,Mid);
	return t?t:Qmin(Rsn,Mid+1,R);
}

int main()
{
	fread(Buf,1,Len,stdin);
	for (n=IN();n--;)
	{
		Qv=1;
		for (int k=IN();k--;) Qx=IN(),Add(1,1,Top);
		Ans+=(Qx=Qmax(1,1,Top)),Qv=-1,Add(1,1,Top);
		Ans-=(Qx=Qmin(1,1,Top)),Qv=-1,Add(1,1,Top);
	}
	printf("%lld\n",Ans);
}
Problem2947
#include<set>
#include<cstdio>
#include<cctype>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1e6+19,Len=20000000;
multiset<int> S;
char Buf[Len],*B=Buf;
long long Ans;int n,k;

int IN()
{
	int c,x;
	while (!isdigit(c=*B++));x=c-'0';
	while (isdigit(c=*B++)) x=(x<<1)+(x<<3)+c-'0';return x;
}

int main()
{
	fread(Buf,1,Len,stdin);
	for (n=IN();n--;)
	{
		for (k=IN();k--;) S.insert(IN());
		Ans+=(*--S.end())-(*S.begin());
		S.erase(S.begin());
		S.erase(--S.end());
	}
	printf("%lld\n",Ans);
}
Problem2947
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1e6+19,Len=30000000;
char Buf[Len],*B=Buf;
long long Ans;int n,k,x,a,b;

int IN()
{
	int c,x;
	while (!isdigit(c=*B++));x=c-'0';
	while (isdigit(c=*B++)) x=(x<<1)+(x<<3)+c-'0';return x;
}

struct Heap
{
	bool f;
	int S[N],Pos[N],Cnt[N],n;

	void Up(int x)
	{
		while (x>1&&(S[x]<S[x>>1])==f)
			swap(S[x],S[x>>1]),swap(Pos[S[x]],Pos[S[x>>1]]),x>>=1;
	}
	void Down(int x)
	{
		for (;;)
		{
			int t=x;
			if ((x<<1)<=n&&(S[x<<1]<S[t])==f) t=x<<1;
			if ((x<<1|1)<=n&&(S[x<<1|1]<S[t])==f) t=x<<1|1;
			if (t==x) break;swap(S[x],S[t]);swap(Pos[S[x]],Pos[S[t]]),x=t;
		}
	}
	void Ins(int x) {if (++Cnt[x]==1) S[++n]=x,Pos[x]=n,Up(n);}
	void Del(int v)
	{
		if (--Cnt[v]==0) Pos[S[n]]=Pos[v],S[Pos[v]]=S[n--],Up(Pos[v]),Down(Pos[v]);
	}
} Hs,Hb;

int main()
{
	fread(Buf,1,Len,stdin);
	Hs.f=1;
	for (n=IN();n--;)
	{
		for (k=IN();k--;) x=IN(),Hb.Ins(x),Hs.Ins(x);
		a=Hb.S[1],b=Hs.S[1],Ans+=a-b;
		Hb.Del(a),Hb.Del(b);
		Hs.Del(a),Hs.Del(b);
	}
	printf("%lld\n",Ans);
}
Problem2956
#include<cstdio>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int Mod=19940417,P6=3323403;
int n,m,Ans;

int Calc(int x) {return 1LL*x*(x+1)%Mod*(x*2+1)%Mod*P6%Mod;}
int Query(int n)
{
	int res=1LL*n*n%Mod;
	for (int L=1,R;L<=n;L=R+1)
	{
		R=n/(n/L);
		res=(res-1LL*(L+R)*(R-L+1)/2LL%Mod*(n/L)%Mod+Mod)%Mod;
	}
	return res;
}

int main()
{
	scanf("%d%d",&n,&m);
	Ans=1LL*Query(n)*Query(m)%Mod;
	for (int L=1,R;L<=n&&L<=m;L=R+1)
	{
		R=min(n/(n/L),m/(m/L));
		Ans=(Ans-1LL*(R-L+1)*n%Mod*m%Mod+Mod)%Mod;
		Ans=(Ans-1LL*(n/L)*(m/L)%Mod*(Calc(R)-Calc(L-1)+Mod)%Mod+Mod)%Mod;
		Ans=(Ans+1LL*(1LL*m*(n/L)+1LL*n*(m/L))%Mod*(1LL*(L+R)*(R-L+1)/2LL%Mod)%Mod)%Mod;
	}
	printf("%d\n",Ans);
}
Problem2962
#include<cstdio>
#include<cctype>
#include<cassert>

#define For(i,x,y) for (int i=x;i<y;i++)
#define CH isdigit(c=getchar())
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x,f;
	while (!CH&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (CH) x=x*10+c-'0';return !f?x:-x;
}

const int N=100000+19,Mod=19940417;
int C[N][21],A[N],n,Q,Ql,Qr,v,t,c;
char s[3];

inline void U(int &a,int b) {a+=b;if (a<0) a+=Mod;else if (a>=Mod) a-=Mod;}

struct node
{
	int rev,Add,A[21];
	node() {rev=Add=0;For(i,0,21) A[i]=0;}

	node operator + (const node& B) const
	{
		node res;
		For(i,0,21) For(j,0,21-i) U(res.A[i+j],1LL*A[i]*B.A[j]%Mod);
		For(k,0,21) assert(res.A[k]>=0&&res.A[k]<Mod);
		return res;
	}
	void Setadd(int t,int n)
	{
		U(Add,t);
		static int tmp[21];
		For(k,0,21)
		{
			tmp[k]=0;int T=1;
			if (k>n) continue;
			for (int i=k;~i;i--)
				U(tmp[k],1LL*C[n-i][k-i]*A[i]%Mod*T%Mod),T=1LL*T*t%Mod;
		}
		For(k,0,21) A[k]=tmp[k],assert(A[k]>=0&&A[k]<Mod);
	}
	void Setrev()
	{
		rev^=1,Add=(-Add+Mod)%Mod;
		for (int i=1;i<21;i+=2) A[i]=(-A[i]+Mod)%Mod,assert(A[i]>=0&&A[i]<Mod);
	}
} S[N*4];

void Down(int x,int L,int R)
{
	if (L==R) return;
	if (S[x].rev) S[Lsn].Setrev(),S[Rsn].Setrev(),S[x].rev=0;
	if (t=S[x].Add)
		S[Lsn].Setadd(t,Mid-L+1),
		S[Rsn].Setadd(t,R-Mid),S[x].Add=0;
}
void Build(int x,int L,int R)
{
	if (L==R) {S[x].A[0]=1,S[x].A[1]=(IN()%Mod+Mod)%Mod;return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
void Update(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {S[x].Setadd(v,R-L+1);return;}
	Down(x,L,R);
	if (Ql<=Mid) Update(Lsn,L,Mid);
	if (Qr>Mid) Update(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
void Reverse(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {S[x].Setrev();return;}
	Down(x,L,R);
	if (Ql<=Mid) Reverse(Lsn,L,Mid);
	if (Qr>Mid) Reverse(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
node Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return S[x];
	Down(x,L,R);
	if (Ql<=Mid&&Qr<=Mid) return Query(Lsn,L,Mid);
	if (Ql>Mid&&Qr>Mid) return Query(Rsn,Mid+1,R);
	return Query(Lsn,L,Mid)+Query(Rsn,Mid+1,R);
}

int main()
{
	n=IN(),Q=IN();
	For(i,0,n+1)
	{
		C[i][0]=1;
		for (int j=1;j<=i&&j<21;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%Mod;
	}
	Build(1,1,n);
	while (Q--)
	{
		scanf("%s",s),Ql=IN(),Qr=IN();
		if (s[0]=='I') v=(IN()%Mod+Mod)%Mod,Update(1,1,n);
		if (s[0]=='R') Reverse(1,1,n);
		if (s[0]=='Q') c=IN(),printf("%d\n",Query(1,1,n).A[c]);
	}
}
Problem2982
#include<cstdio>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int Mod=10007;
int Fac[Mod],Inv[Mod];
int T,n,m;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=a*a%Mod) if (b&1) res=res*a%Mod;
	return res;
}
int C(int n,int m)
{
	if (n<m) return 0;
	if (n<Mod&&m<Mod) return Fac[n]*Inv[m]%Mod*Inv[n-m]%Mod;
	return C(n/Mod,m/Mod)*C(n%Mod,m%Mod)%Mod;
}

int main()
{
	Fac[0]=1;For(i,1,Mod) Fac[i]=Fac[i-1]*i%Mod;
	Inv[Mod-1]=Pow(Mod-1,Mod-2);
	for (int i=Mod-2;i>=0;i--) Inv[i]=Inv[i+1]*(i+1)%Mod;
	for (scanf("%d",&T);T--;) scanf("%d%d",&n,&m),printf("%d\n",C(n,m));
}
Problem3027
#include<cstdio>
using namespace std;

const int Mod=2004;
int A[15],n,L,R;

int C(int n,int m)
{
	if (n<m) return 0;
	int p[4]={2,3,5,7},c[4]={0},Ans=1;
	if (m>n-m) m=n-m;
	for (int i=1;i<=m;i++)
		for (int j=0;j<4;j++)
			for (int k=i;k%p[j]==0;c[j]++,k/=p[j]);
	for (int i=n;i>n-m;i--)
	{
		int k=i;
		for (int j=0;j<4;j++)
			for (;c[j]&&k%p[j]==0;c[j]--,k/=p[j]);
		Ans=1LL*Ans*k%Mod;
	}
	return Ans;
}
inline int calc(int tot)
{
	int Ans=0;
	for (int i=0;i<(1<<n);i++)
	{
		int cnt=0,t=tot;
		for (int j=0;j<n;j++) if (i>>j&1) cnt++,t-=A[j]+1;
		if (t>=0) Ans=(Ans+((cnt&1)?-1:1)*C(t+n,n)+Mod)%Mod;
	}
	return Ans;
}

int main()
{
	scanf("%d%d%d",&n,&L,&R);
	for (int i=0;i<n;i++) scanf("%d",&A[i]);
	printf("%d\n",(calc(R)-calc(L-1)+Mod)%Mod);
}
Problem3032
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=100000+19;
typedef long long LL;
LL X[N],Y[N],Ans;
int n,m,T,x,y;

LL Solve(LL *A,int n)
{
	For(i,1,n+1) A[i]+=A[i-1]-T/n;
	sort(A+1,A+n+1);
	LL x=A[(n+1)/2],res=0;
	For(i,1,n+1) res+=abs(x-A[i]);
	return res;
}

int main()
{
	read(n),read(m),read(T);
	if (T%n&&T%m) return puts("impossible"),0;
	For(i,0,T) read(x),read(y),X[x]++,Y[y]++;
	if (T%n==0) Ans+=Solve(X,n);
	if (T%m==0) Ans+=Solve(Y,m);
	printf("%s %lld\n",T%n?"column":(T%m?"row":"both"),Ans);
}
Problem3036
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;

const int M=2e5+19,Eps=1e-8;
struct Edge {int b,c,nxt;} E[M];
int n,m,a,b,c,Last[M>>1],K[M>>1],cnt;
double F[M>>1];

inline void Add_Edge(int a,int b,int c)
{
	E[cnt]=(Edge){b,c,Last[a]};
	Last[a]=cnt++;
}
inline double Exp(int x,int Dis)
{
	if (x==n) return 0.;
	if (fabs(F[x])>Eps) return F[x];
	double Ans=0.;
	for (int i=Last[x];i^-1;i=E[i].nxt) 
		Ans+=1./double(K[x])*(E[i].c+Exp(E[i].b,Dis));
	return F[x]=Ans;
}

int main()
{
	scanf("%d%d",&n,&m);
	memset(Last,-1,sizeof(Last));
	for (int i=0;i<m;i++) 
	{
		scanf("%d%d%d",&a,&b,&c);
		Add_Edge(a,b,c);K[a]++;
	}
	printf("%.2lf\n",Exp(1,0));
}
Problem3036
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;

const int M=2e5+19,Eps=1e-8;
struct Edge {int b,c,nxt;} E[M];
int n,m,a,b,c,Last[M>>1],K[M>>1],cnt,ch;
double F[M>>1];

inline void Read(int &x)
{
	while (!isdigit(ch=getchar()));
	x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
}
inline void Add_Edge(int a,int b,int c)
{
	E[cnt]=(Edge){b,c,Last[a]};
	Last[a]=cnt++;
}
inline double Exp(int x,int Dis)
{
	if (x==n) return 0.;
	if (F[x]!=0) return F[x];
	double Ans=0.;
	for (int i=Last[x];i^-1;i=E[i].nxt) 
		Ans+=1./double(K[x])*(E[i].c+Exp(E[i].b,Dis));
	return F[x]=Ans;
}

int main()
{
	scanf("%d%d",&n,&m);
	memset(Last,-1,sizeof(Last));
	for (int i=0;i<m;i++) 
	{
		Read(a);Read(b);Read(c);
		Add_Edge(a,b,c);K[a]++;
	}
	printf("%.2lf\n",Exp(1,0));
}
Problem3038
#include<cstdio>
#include<cctype>
#include<cmath>
#include<algorithm>
using namespace std;

const int Maxn=100000+19;
typedef long long LL;
int Fa[Maxn],n,Q,k,L,R;
LL C[Maxn],A[Maxn];

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int getf(int x) {return Fa[x]==x?x:Fa[x]=getf(Fa[x]);}
void Update(int x,LL v) {for(;x<=n;x+=x&-x) C[x]+=v;}
LL Query(int x) {LL Ans=0;for(;x;x-=x&-x) Ans+=C[x];return Ans;}

int main()
{
	read(n);
	for (int i=1;i<=n;i++) scanf("%lld",&A[i]),Update(i,A[i]),Fa[i]=i;
	Fa[n+1]=n+1;
	read(Q);
	while (Q--)
	{
		read(k),read(L),read(R);
		if (L>R) swap(L,R);
		if (!k)
			for (int i=getf(L);i<=R;i=getf(i+1))
			{
				LL x=sqrt(A[i]);
				Update(i,x-A[i]);
				if ((A[i]=x)==1) Fa[i]=i+1;
			}
		else printf("%lld\n",Query(R)-Query(L-1));
	}
}
Problem3039
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=1000+19;
typedef int two[Maxn][Maxn];
two U,L,R,A;
int n,m,Ans,c;

int Getchar() {while ((c=getchar())!='F'&&c!='R');return c;}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) A[i][j]=Getchar()=='F';
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++) L[i][j]=A[i][j]?L[i][j-1]+1:0;
		for (int j=m;j;j--) R[i][j]=A[i][j]?R[i][j+1]+1:0;
	}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) 
			if (A[i][j])
			{
				U[i][j]=U[i-1][j]+1;
				if (A[i-1][j]) 
					L[i][j]=min(L[i-1][j],L[i][j]),
					R[i][j]=min(R[i-1][j],R[i][j]);
			}
	for (int i=1;i<=n;i++) 
		for (int j=1;j<=m;j++) Ans=max(Ans,(L[i][j]+R[i][j]-1)*U[i][j]);
	printf("%d\n",Ans*3);
}
Problem3040
#include<cstdio>
#include<cctype>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;

const int N=1000000+19;
typedef long long LL;
int n,m,t,vis[N],c;
LL Dis[N],x,y,z,rxa,rxc,rya,ryc,rp;
struct Note
{
	int ID,Dis;
	bool operator < (const Note& A) const {return Dis>A.Dis;}
};
struct Edge	{int to;LL Len;};
priority_queue<Note> Q;
vector<Edge> E[N];

inline void Read(LL &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void Dijkstra_Heap()
{
	memset(vis,0,sizeof(vis));
	for (int i=1;i<=n;i++) Dis[i]=1LL<<60;
	Dis[1]=0;
	Q.push((Note){1,0});
	while (!Q.empty())
	{
		int x=Q.top().ID,D=Q.top().Dis;Q.pop();
		if (x==n) return;
		if (vis[x]) continue;
		vis[x]=1;
		for (int i=0;i<E[x].size();i++)
		{
			int to=E[x][i].to;
			if (!vis[to]&&D+E[x][i].Len<Dis[to])
			{
				Dis[to]=D+E[x][i].Len;
				Q.push((Note){to,Dis[to]});
			}
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	scanf("%d%lld%lld%lld%lld%lld",&t,&rxa,&rxc,&rya,&ryc,&rp);
	x=y=0;
	for (int i=0;i<n;i++)
	{
		x=(x*rxa+rxc)%rp;
		y=(y*rya+ryc)%rp;
		int a=min(x%n+1,y%n+1),b=max(y%n+1,y%n+1);
		E[a].push_back((Edge){b,1e8-100*a});
	}
	for (int i=t;i<m;i++)
	{
		Read(x);Read(y);Read(z);
		E[x].push_back((Edge){y,z});
	}
	Dijkstra_Heap();
	printf("%lld\n",Dis[n]);
	return 0;
}
Problem3043
#include<cstdio>
#include<cctype>
#define LL long long
using namespace std;

const int Maxn=100000+19;
int A[Maxn],x,n,c;
LL Z=0,F=0;

LL max(LL a,LL b) {return a>b?a:b;}
LL abs(LL a) {return a>0?a:-a;}
void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) Read(A[i]);
	for (int i=1;i<n;i++)
	{
		x=A[i]-A[i-1];
		if (x>0) Z+=x;else F+=x;
	}
	F=-F;
	printf("%lld\n%lld\n",max(F,Z),abs(F-Z)+1);
	return 0;
}
Problem3052
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

const int len=200000;
inline char nc(){
	static char buf[len],*b=buf+len;
	if (b==buf+len) fread(buf,1,len,stdin),b=buf;
	return *b++;
}
int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=100000+19;

struct Edge{
	int y,nxt;
} E[N*2];
typedef int one[N];
one Last,v,w,dep,top,fa,sz,son,S,blo,pre,col,vis,c,A;
int n,m,Qc,Mc,cnt,Top,B,num,x,y,T,tot,id;
ll Ans[N],res;

struct QType{
	int o,T,x,y;
	bool operator < (const QType &B) const{
		if (blo[x]!=blo[B.x]) return blo[x]<blo[B.x];
		if (blo[y]!=blo[B.y]) return blo[y]<blo[B.y];
		return T<B.T;
	}
} Q[N],q[N],tmp;

void Link(int x,int y){
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void dfs(int x){
	int pre=Top;
	sz[x]=1;
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if ((y=E[i].y)!=fa[x]){
			dep[y]=dep[x]+1;
			fa[y]=x;
			dfs(y);
			sz[x]+=sz[y];
			if (sz[y]>sz[son[x]]) son[x]=y;
			if (Top-pre>B){
				num++;
				while (Top!=pre) blo[S[Top--]]=num;
			}
		}
	S[++Top]=x;
}
void dfs(int x,int Anc){
	top[x]=Anc;
	if (son[x]) dfs(son[x],Anc);
	for (int i=Last[x],y;~i;i=E[i].nxt){
		if ((y=E[i].y)!=fa[x]&&y!=son[x]) dfs(y,y);
	}
}
int LCA(int x,int y){
	int a=top[x],b=top[y];
	while (a!=b){
		if (dep[a]>dep[b]) swap(a,b),swap(x,y);
		y=fa[b],b=top[y];
	}
	return dep[x]<dep[y]?x:y;
}
void Reverse(int x){
	if (!vis[x]){
		res+=1ll*v[A[x]]*w[++c[A[x]]];
		vis[x]=1;
	} else{
		res-=1ll*v[A[x]]*w[c[A[x]]--];
		vis[x]=0;
	}
}
void work(int x,int y){
	while (x!=y){
		if (dep[x]>dep[y]) swap(x,y);
		Reverse(y),y=fa[y];
	}
}
void Modify(int x,int y){
	if (!vis[x]) A[x]=y;else{
		res-=1ll*v[A[x]]*w[c[A[x]]--];
		A[x]=y;
		res+=1ll*v[A[x]]*w[++c[A[x]]];
	}
}

int main(){
	memset(Ans,-1,sizeof(Ans));
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN(),Qc=IN();
	B=int(pow(n,2.0/3.0));
	For(i,1,m+1) v[i]=IN();
	For(i,1,n+1) w[i]=IN();
	For(i,1,n) Link(IN(),IN());
	For(i,1,n+1) A[i]=col[i]=IN();
	dfs(1);
	dfs(1,1);
	num++;
	while (Top) blo[S[Top--]]=num;
	For(i,1,Qc+1){
		tmp=(QType){IN(),i,IN(),IN()};
		if (tmp.o==1){
			if (blo[tmp.x]>blo[tmp.y]) swap(tmp.x,tmp.y);
			Q[++id]=tmp;
		}
		if (tmp.o==0){
			tot++;
			pre[tot]=col[tmp.x];
			col[tmp.x]=tmp.y;
			q[tot]=tmp;
		}
	}
	q[0].T=0;
	q[tot+1].T=Qc+1;
	sort(Q+1,Q+id+1);
	x=1,y=1;T=0;
	For(i,1,id+1){
		work(x,Q[i].x);
		work(y,Q[i].y);
		x=Q[i].x;
		y=Q[i].y;
		while (q[T+1].T<=Q[i].T) T++,Modify(q[T].x,q[T].y);
		while (q[T].T>Q[i].T) Modify(q[T].x,pre[T]),T--;
		int z=LCA(x,y);
		res+=1ll*v[A[z]]*w[++c[A[z]]];
		Ans[Q[i].T]=res;
		res-=1ll*v[A[z]]*w[c[A[z]]--];
	}
	For(i,1,Qc+1){
		if (~Ans[i]) printf("%lld\n",Ans[i]);
	}
}
Problem3053
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (T[x].L)
#define Rsn (T[x].R)
using namespace std;

int IN()
{
	int c,x,f;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=50000+19,oo=2147483647;

struct Sol
{
	int A[5],Ans;
	Sol() {}
	Sol(int x) {Ans=x;}
	bool operator < (const Sol& B) const {return Ans<B.Ans;}
};priority_queue<Sol> Q;
int Res[20][5];

//KD-Tree
struct node
{
	int A[5],S[5],B[5],L,R;
} T[N];
int P[5],n,K,d,Ans,m,rt;

bool cmp(node A,node B) {return A.A[d]<B.A[d];}
void Update(int x)
{
	For(i,0,K)
	{
		T[x].S[i]=T[x].B[i]=T[x].A[i];
		if (Lsn)
			T[x].S[i]=min(T[x].S[i],T[Lsn].S[i]),
			T[x].B[i]=max(T[x].B[i],T[Lsn].B[i]);
		if (Rsn)
			T[x].S[i]=min(T[x].S[i],T[Rsn].S[i]),
			T[x].B[i]=max(T[x].B[i],T[Rsn].B[i]);
	}
}
int Build(int L,int R,int D)
{
	int x=L+R>>1;
	d=D,nth_element(T+L,T+x,T+R+1,cmp);
	Lsn=(L<x?Build(L,x-1,(D+1)%K):0);
	Rsn=(x<R?Build(x+1,R,(D+1)%K):0);
	return Update(x),x;
}
int QDis(int *A,int *B)
{
	int Ans=0;
	For(i,0,K) Ans+=(A[i]-B[i])*(A[i]-B[i]);
	return Ans;
}
int TDis(int x,int *A)
{
	int Ans=0;
	For(i,0,K)
	{
		if (A[i]>T[x].B[i]) Ans+=(A[i]-T[x].B[i])*(A[i]-T[x].B[i]);
		if (A[i]<T[x].S[i]) Ans+=(A[i]-T[x].S[i])*(A[i]-T[x].S[i]);
	}
	return Ans;
}
void Query(int x)
{
	int tmp=QDis(T[x].A,P);
	if (tmp<Q.top().Ans)
	{
		Sol S;
		For(i,0,K) S.A[i]=T[x].A[i];S.Ans=tmp;
		Q.push(S),Q.pop();
	}
	int Tl=Lsn?TDis(Lsn,P):oo,Tr=Rsn?TDis(Rsn,P):oo;
	if (Tl<Tr)
	{
		if (Tl<Q.top().Ans) Query(Lsn);
		if (Tr<Q.top().Ans) Query(Rsn);
	} else
	{
		if (Tr<Q.top().Ans) Query(Rsn);
		if (Tl<Q.top().Ans) Query(Lsn);
	}
}

int main()
{
	while (~scanf("%d%d",&n,&K))
	{
		For(i,1,n+1) For(j,0,K) T[i].A[j]=IN();
		rt=Build(1,n,0);
		for (int t=IN();t--;)
		{
			Ans=oo;For(i,0,K) P[i]=IN();m=IN();
			For(i,0,m) Q.push(Sol(oo));
			printf("the closest %d points are:\n",m);
			Query(rt);
			for (int j=m;j;j--)
			{
				For(i,0,K) Res[j][i]=Q.top().A[i];Q.pop();
			}
			for (int i=1;i<=m;i++,puts(""))
				For(j,0,K)
				{
					if (j) putchar(' ');
					printf("%d",Res[i][j]);
				}
		}
	}
}
Problem3053
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=50000+19,oo=(1<<30)-1;
int k,D,n,m;

struct Point {int s[5];} A[N],Ans[N],P;
struct node
{
	node *L,*R;
	Point A,B,S;
	void Update()
	{
		B=S=A;
		if (L) For(i,0,k) B.s[i]=max(B.s[i],L->B.s[i]),S.s[i]=min(S.s[i],L->S.s[i]);
		if (R) For(i,0,k) B.s[i]=max(B.s[i],R->B.s[i]),S.s[i]=min(S.s[i],R->S.s[i]);
	}
} Nd[N],*rt;
struct Sol
{
	Point S;int v;
	Sol() {}
	Sol(int __v) {v=__v;}
	Sol(Point __S,int __v) {S=__S,v=__v;}
	bool operator < (const Sol& B) const {return v<B.v;}
};priority_queue<Sol> Q;

bool cmp(Point A,Point B) {return A.s[D]<B.s[D];}
int Dis(Point A,Point B)
{
	int tmp=0;
	For(i,0,k) tmp+=(A.s[i]-B.s[i])*(A.s[i]-B.s[i]);
	return tmp;
}
int Calc(node *x)
{
	int tmp=0;
	For(i,0,k)
	{
		if (P.s[i]>x->B.s[i]) tmp+=(P.s[i]-x->B.s[i])*(P.s[i]-x->B.s[i]);
		if (P.s[i]<x->S.s[i]) tmp+=(P.s[i]-x->S.s[i])*(P.s[i]-x->S.s[i]);
	}
	return tmp;
}
node *Build(int L,int R)
{
	if (L>R) return 0;
	node *x=Nd+Mid;
	nth_element(A+L,A+Mid,A+R+1,cmp);
	x->A=A[Mid];
	x->L=Build(L,Mid-1);
	x->R=Build(Mid+1,R);
	return x->Update(),x;
}
void Query(node *x)
{
	int tmp,Tl,Tr;
	if ((tmp=Dis(x->A,P))<Q.top().v) Q.pop(),Q.push(Sol(x->A,tmp));
	Tl=x->L?Calc(x->L):oo,Tr=x->R?Calc(x->R):oo;
	if (Tl<Tr)
	{
		if (Tl<Q.top().v) Query(x->L);
		if (Tr<Q.top().v) Query(x->R);
	} else
	{
		if (Tr<Q.top().v) Query(x->R);
		if (Tl<Q.top().v) Query(x->L);
	}
}

int main()
{
	while (~scanf("%d%d",&n,&k))
	{
		For(i,1,n+1) For(j,0,k) A[i].s[j]=IN();
		rt=Build(1,n);
		for (int Qc=IN();Qc--;)
		{
			For(i,0,k) P.s[i]=IN();
			m=IN();
			while (!Q.empty()) Q.pop();
			For(i,0,m) Q.push(Sol(oo));
			printf("the closest %d points are:\n",m);
			Query(rt);
			For(i,0,m) Ans[m-1-i]=Q.top().S,Q.pop();
			for (int i=0;i<m;i++,puts(""))
			{
				printf("%d",Ans[i].s[0]);
				For(j,1,k) printf(" %d",Ans[i].s[j]);
			}
		}
	}
}
Problem3053
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=50000+19,oo=(1<<30)-1;
int k,D,n,m;

struct Point {int s[5];} A[N],Ans[N],P;
struct node
{
	node *L,*R;
	Point A,B,S;
	void Update()
	{
		B=S=A;
		if (L) For(i,0,k) B.s[i]=max(B.s[i],L->B.s[i]),S.s[i]=min(S.s[i],L->S.s[i]);
		if (R) For(i,0,k) B.s[i]=max(B.s[i],R->B.s[i]),S.s[i]=min(S.s[i],R->S.s[i]);
	}
} Nd[N],*rt;
struct Sol
{
	Point S;int v;
	Sol() {}
	Sol(int __v) {v=__v;}
	Sol(Point __S,int __v) {S=__S,v=__v;}
	bool operator < (const Sol& B) const {return v<B.v;}
};priority_queue<Sol> Q;

bool cmp(Point A,Point B) {return A.s[D]<B.s[D];}
int Dis(Point A,Point B)
{
	int tmp=0;
	For(i,0,k) tmp+=(A.s[i]-B.s[i])*(A.s[i]-B.s[i]);
	return tmp;
}
int Calc(node *x)
{
	int tmp=0;
	For(i,0,k)
	{
		if (P.s[i]>x->B.s[i]) tmp+=(P.s[i]-x->B.s[i])*(P.s[i]-x->B.s[i]);
		if (P.s[i]<x->S.s[i]) tmp+=(P.s[i]-x->S.s[i])*(P.s[i]-x->S.s[i]);
	}
	return tmp;
}
node *Build(int L,int R,int d)
{
	if (L>R) return 0;
	node *x=Nd+Mid;
	D=d,nth_element(A+L,A+Mid,A+R+1,cmp);
	x->A=A[Mid];
	x->L=Build(L,Mid-1,(d+1)%k);
	x->R=Build(Mid+1,R,(d+1)%k);
	return x->Update(),x;
}
void Query(node *x)
{
	int tmp,Tl,Tr;
	if ((tmp=Dis(x->A,P))<Q.top().v) Q.pop(),Q.push(Sol(x->A,tmp));
	Tl=x->L?Calc(x->L):oo,Tr=x->R?Calc(x->R):oo;
	if (Tl<Tr)
	{
		if (Tl<Q.top().v) Query(x->L);
		if (Tr<Q.top().v) Query(x->R);
	} else
	{
		if (Tr<Q.top().v) Query(x->R);
		if (Tl<Q.top().v) Query(x->L);
	}
}

int main()
{
	while (~scanf("%d%d",&n,&k))
	{
		For(i,1,n+1) For(j,0,k) A[i].s[j]=IN();
		rt=Build(1,n,0);
		for (int Qc=IN();Qc--;)
		{
			For(i,0,k) P.s[i]=IN();
			m=IN();
			while (!Q.empty()) Q.pop();
			For(i,0,m) Q.push(Sol(oo));
			printf("the closest %d points are:\n",m);
			Query(rt);
			For(i,0,m) Ans[m-1-i]=Q.top().S,Q.pop();
			for (int i=0;i<m;i++,puts(""))
			{
				printf("%d",Ans[i].s[0]);
				For(j,1,k) printf(" %d",Ans[i].s[j]);
			}
		}
	}
}
Problem3064
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int N=100000+19,oo=(1<<30)-1,Len=5000000;
char Buf[Len],*B=Buf,c;

void U(int &x,int y) {x=x>y?x:y;}
int IN()
{
	int c,x,f;
	while (!isdigit(c=*B++)&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=*B++)) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

//SegTree
struct node
{
	int M,A,S,Hm,Ha,Hs;
	node() {}
	node(int _M,int _Hm) {M=_M,Hm=_Hm;A=Ha=0;S=Hs=-oo;}
	void SetA(int v)
	{
		U(Hm,M+=v);
		if (S==-oo) U(Ha,A+=v);else U(Hs,S+=v);
	}
	void SetHa(int v)
	{
		U(Hm,M+v);
		if (S==-oo) U(Ha,A+v);else U(Hs,S+v);
	}
	void SetS(int v) {U(Hm,M=v),U(Hs,S=v),A=0;}
	void SetHs(int v) {U(Hm,v),U(Hs,v);}
} S[N*4];
int n,v,Ql,Qr,Qv;

node operator + (node A,node B) {return node(max(A.M,B.M),max(A.Hm,B.Hm));}
void Push_down(int x)
{
	if (v=S[x].Ha) S[Lsn].SetHa(v),S[Rsn].SetHa(v),S[x].Ha=0;
	if ((v=S[x].Hs)>-oo) S[Lsn].SetHs(v),S[Rsn].SetHs(v),S[x].Hs=-oo;
	if (v=S[x].A) S[Lsn].SetA(v),S[Rsn].SetA(v),S[x].A=0;
	if ((v=S[x].S)>-oo) S[Lsn].SetS(v),S[Rsn].SetS(v),S[x].S=-oo;
}
void Build(int x,int L,int R)
{
	if (L==R) {v=IN(),S[x]=node(v,v);return;}
	Build(Lsn,L,Mid);Build(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
void Update(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {c=='P'?S[x].SetA(Qv):S[x].SetS(Qv);return;}
	Push_down(x);
	if (Ql<=Mid) Update(Lsn,L,Mid);
	if (Qr>Mid) Update(Rsn,Mid+1,R);
	S[x]=S[Lsn]+S[Rsn];
}
int Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return c=='Q'?S[x].M:S[x].Hm;
	Push_down(x);
	int res=-oo;
	if (Ql<=Mid) res=max(res,Query(Lsn,L,Mid));
	if (Qr>Mid) res=max(res,Query(Rsn,Mid+1,R));
	return res;
}

int main()
{
	fread(Buf,1,Len,stdin);
	n=IN(),Build(1,1,n);
	for (int Q=IN();Q--;)
	{
		while (!isalpha(c=*B++));Ql=IN(),Qr=IN();
		if (c=='Q'||c=='A') printf("%d\n",Query(1,1,n));
		if (c=='P'||c=='C') Qv=IN(),Update(1,1,n);
	}
}
Problem3065
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}


//Seg
const int Top=20000000;
struct Seg *Null;
struct Seg
{
	Seg *L,*R;
	int S;
	void Update() {S=L->S+R->S;}
} ND[Top],*Pool[Top];
int top,Qx;

Seg *New() {Seg *x=Pool[top--];return x->L=x->R=Null,x->S=0,x;}
void Insert(Seg *&x,int L,int R,int v)
{
	if (x==Null) x=New();x->S+=v;
	if (L==R) return;
	Qx<=Mid?Insert(x->L,L,Mid,v):Insert(x->R,Mid+1,R,v);
}
void Delete(Seg *&x)
{
	if (x==Null) return;
	Delete(x->L),Delete(x->R);
	Pool[++top]=x;x=Null;
}


//SGT
const int N=70000+19;
const double Alpha=0.75;
struct SGT *null,*RT;
struct SGT
{
	SGT *L,*R;Seg *rt;
	int key,S;
	void Update() {if (this!=null) S=L->S+R->S+1;}
	bool Balance() {return L->S<=S*Alpha&&R->S<=S*Alpha;}
} Nd[N],*S[N],*tmp[N];
int k,kt,tcnt,f,Qt,Val;

SGT *Build(int L,int R)
{
	if (L>R) return null;
	SGT *x=tmp[Mid];
	x->L=Build(L,Mid-1),x->R=Build(Mid+1,R);
	For(i,L,R+1) Qx=tmp[i]->key,Insert(x->rt,0,70000,1);
	return x->Update(),x;
}
void Getseq(SGT *&x)
{
	if (x==null) return;
	Delete(x->rt),Getseq(x->L),tmp[++kt]=x,Getseq(x->R);
	x=null;
}
void Ins(SGT *&x,int ID,int v)
{
	if (x==null)
	{
		x=Nd+(++tcnt),*x=(SGT){null,null,Null,v,1};
		Qx=v,Insert(x->rt,0,70000,1);return;
	}
	x->S++;S[++k]=x,Qx=v,Insert(x->rt,0,70000,1);
	ID<=x->L->S+1?Ins(x->L,ID,v):Ins(x->R,ID-x->L->S-1,v);
}
void Insert(int ID,int v)
{
	k=0,Ins(RT,ID,v);
	For(i,1,k+1)
		if (!S[i]->Balance())
		{
			f=i>1&&S[i]==S[i-1]->L,kt=0,Getseq(S[i]);
			SGT *T=Build(1,kt);
			if (i==1) RT=T;else f?S[i-1]->L=T:S[i-1]->R=T;
		}
}
void Modify(SGT *x)
{
	Insert(x->rt,0,70000,1);
	if (Qt==x->L->S+1) {swap(Qx,x->key);Insert(x->rt,0,70000,-1);return;}
	if (Qt<x->L->S+1) Modify(x->L);else Qt-=x->L->S+1,Modify(x->R);
	Insert(x->rt,0,70000,-1);
}


//Query
int ka,kb,n,Q,Ql,Qr,K,Ans;
Seg *B[N];int A[N];
char opt[3];

void Findseq(SGT *x,int Delta)
{
	if (x==null) return;
	int L=Delta+1,R=Delta+x->S,T=Delta+x->L->S+1;
	if (Ql<=L&&R<=Qr) {B[++kb]=x->rt;return;}
	if (Ql<T) Findseq(x->L,Delta);
	if (T<Qr) Findseq(x->R,T);
	if (Ql<=T&&T<=Qr) A[++ka]=x->key;
}
void Query()
{
	ka=kb=0,Findseq(RT,0);
	int L=0,R=70000;
	while (L!=R)
	{
		int tmp=0;
		For(i,1,ka+1) tmp+=(L<=A[i]&&A[i]<=Mid);
		For(i,1,kb+1) tmp+=B[i]->L->S;
		if (K<=tmp) {R=Mid;For(i,1,kb+1) B[i]=B[i]->L;}
			else {L=Mid+1;For(i,1,kb+1) B[i]=B[i]->R;K-=tmp;}
	}
	printf("%d\n",Ans=L);
}

int main()
{
	Null=ND;null=Nd;
	null->L=null->R=null;null->rt=Null;
	Null->L=Null->R=Null;
	For(i,1,Top) Pool[++top]=ND+i;
	For(i,1,N) (Nd+i)->L=(Nd+i)->R=null,(Nd+i)->rt=Null;
	
	n=IN();
	For(i,1,n+1) (Nd+i)->key=IN(),tmp[i]=Nd+i;tcnt=n;
	RT=Build(1,n);
	Q=IN();
	while (Q--)
	{
		scanf("%s",opt);
		if (opt[0]=='Q') Ql=IN()^Ans,Qr=IN()^Ans,K=IN()^Ans,Query();
		if (opt[0]=='M') Qt=IN()^Ans,Qx=IN()^Ans,Modify(RT);
		if (opt[0]=='I') Qt=IN()^Ans,Val=IN()^Ans,Insert(Qt,Val);
	}
}
Problem3070
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x,_=y;i<_;i++)
#define Mid (L+R>>1)
using namespace std;

const int top=1e6+10000,N=top+19;
typedef long long LL;
int f[N],p[N],Top[N],t[70],k,cur,x,tmp;
LL n;

LL List[]=
	{980041252300368241LL,980081572226620249LL,980123330478839089LL,980164036225940281LL,980204604210903241LL,
	980244915616336969LL,980284400132638129LL,980326004287254769LL,980367054849107689LL,980408011215491401LL,
	980448148571617489LL,980490037416786961LL,980531622169613089LL,980572883005917601LL,980613506983231969LL,
	980655375593885209LL,980694804996730321LL,980735340389963929LL,980776696623673849LL,980818945055863369LL,
	980860077244742809LL,980901970926932209LL,980941785610052809LL,980983914782435041LL,981023295323372401LL,
	981064931002353961LL,981106004956250209LL,981148545752948329LL,981187462058963041LL,981229533110074249LL,
	981270170687090761LL,981311993877101041LL,981353001676921129LL,981393055343982649LL,981435019847004529LL,
	981476684075892601LL,981515313637415209LL,981554415548586961LL,981595999088241289LL,981637956040626481LL,
	981679525497061561LL,981719851366137361LL,981761323472657809LL,981802847979841801LL,981843120892480729LL,
	981883331213469169LL,981924109164463921LL,981965906650241041LL,982007605929294961LL,982048493486992801LL,
	982088545488493249LL,982129942135744249LL,982169861015997889LL,982211655803314561LL,982251473271204049LL,
	982291798992535201LL,982334119689545401LL,982374415390584841LL,982414850681654329LL,982454291651552329LL,
	982495545342611689LL,982536696811871881LL,982576818242516641LL,982618570141473721LL,982658197598045329LL,
	982699364369187481LL,982739980821710329LL,982779678138297601LL,982821993481711681LL,982863175580382721LL,
	982903743864430441LL,982944424026478369LL,982984894841666809LL,983023324049756929LL,983063185727894041LL,
	983104043696057089LL,983146675381575961LL,983189589594207241LL,983231548859748241LL,983271934358080249LL,
	983313772419560521LL,983355916797155521LL,983398196944223449LL,983438109856239361LL,983479166022242761LL,
	983521774105115569LL,983562316308892609LL,983603343330877369LL,983646235771726921LL,983686260832348921LL,
	983727905374119889LL,983768404217298001LL,983810621816142961LL,983852165833327729LL,983892631525331641LL,
	983935046208870001LL,983975787384958369LL,984017223787874929LL,984058744391017201LL,984101198367525001LL,
	984142038219084889LL,984183454312882849LL,984224418889207609LL,984266003389479721LL,984306493464995089LL,
	984346524019196881LL,984385944215334049LL,984427067786046361LL,984468656567115721LL,984509920776921289LL,
	984551094564921361LL,984592900295303209LL,984632781876209449LL,984673922510161129LL,984714933016273369LL,
	984756285744370129LL,984797623462829401LL,984839124800953321LL,984880253866836889LL,984921352033697521LL,
	984960930621016441LL,985001919314171641LL,985045378184997529LL,985086444066374521LL,985128165877540441LL,
	985167446882904289LL,985208134159239169LL,985249953836661241LL,985291123243912489LL,985331642340180529LL,
	985373047721733889LL,985416077999100049LL,985457068219821409LL,985498619188654561LL,985538070388775401LL,
	985579349062507081LL,985620501524303089LL,985661289493048081LL,985701712946063689LL,985741148354130529LL,
	985783884836517001LL,985824870791605321LL,985864789230232081LL,985905443243410369LL,985946384063892241LL,
	985987730865784201LL,986030329702378801LL,986069163961083409LL,986111836055026321LL,986153405603297147LL,
	986193822451180561LL,986233525906082281LL,986275712943994201LL,986316089406063529LL,986357006970875929LL,
	986398171691991601LL,986437334988897289LL,986479109234603209LL,986521106850060721LL,986561528065093369LL,
	986601302490807481LL,986643604670218609LL,986685272031386929LL,986726078052311689LL,986767548482551081LL,
	986808554881229161LL,986849633656945249LL,986890653682232209LL,986932270626733201LL,986974114958872681LL,
	987015769428608929LL,987056840594919649LL,987098349768102289LL,987139231891123249LL,987181024970485921LL,
	987221666369464681LL,987262221167268601LL,987303297460814161LL,987345352362705961LL,987387026589597001LL,
	987427771598164009LL,987468370377653761LL,987509868328266721LL,987551430751225729LL,987592572687347929LL,
	987633775108308409LL,987675189078243121LL,987717347308410601LL,987758138886168841LL,987800294911082041LL,
	987841358542955569LL,987883234069461409LL,987922331417438041LL,987962208805820161LL,988003808578213249LL,
	988047071203013761LL,988087901397575449LL,988129153911578449LL,988170176663035081LL,988211128691671921LL,
	988252709845654009LL,988293011435508529LL,988336006005904609LL,988375895718979681LL,988417834271586601LL,
	988458334093831561LL,988499900563622329LL,988540931010157849LL,988580582255566609LL,988621149046724209LL,
	988661939396706481LL,988703359008195769LL,988743319772544361LL,988784760976211761LL,988826926969768441LL,
	988868194907827441LL,988909543262154721LL,988951461312189769LL,988992119248527241LL,989032754152585081LL,
	989074145728040761LL,989113982705157409LL,989154882677150281LL,989195409531479089LL,989237122783624009LL,
	989279015947753969LL,989319656745213049LL,989362076840911489LL,989402719344439009LL,989443541730126289LL,
	989486107722680569LL,989527337686512769LL,989567613529757161LL,989609338607956609LL,989650797956187481LL,
	989691907991755609LL,989732776136978449LL,989774055013984321LL,989814733835514889LL,989856671065637281LL,
	989897924667971881LL,989938502559380089LL,989980518029656609LL,990021853812499561LL,990064328760576169LL,
	990104245375712041LL,990144341906280961LL,990184104901842601LL,990223976166600289LL,990265086163768321LL,
	990305273523370561LL,990346206078991609LL,990386741407788169LL,990428965429662529LL,990471484937986921LL,
	990513209162580601LL,990555001944092209LL,990595310639183209LL,990636754804472689LL,990677184602216329LL,
	990719128154470009LL,990760240465621201LL,990802225591659121LL,990842419867241041LL,990885577362575449LL,
	990926577654608401LL,990967933183480729LL,991008835629867289LL,991050774256039561LL,991090977554883529LL,
	991131834753817849LL,991173298105535689LL,991216188020937649LL,991256920361412769LL,991298589439964521LL,
	991339753598732521LL,991381870483555321LL,991422673935814201LL,991462952486294929LL,991504522337726401LL,
	991545479670030289LL,991586119197293929LL,991626309453748609LL,991667703481068769LL,991708879286247721LL,
	991750721185178761LL,991791062168507329LL,991832029402184881LL,991874479423676209LL,991917017997195481LL,
	991957517733950881LL,991998548164755121LL,992040408126136009LL,992079133460446249LL,992120305853674321LL,
	992161307776681249LL,992202557578135201LL,992244274418638921LL,992284641376792201LL,992325009156042769LL,
	992366067109869841LL,992407588148226721LL,992450899262453401LL,992491449746299801LL,992533467552348121LL,
	992573218713936721LL,992615158546743169LL,992656130841047401LL,992697223541970241LL,992738257311675169LL,
	992779319828168161LL,992819251279566649LL,992861232181153729LL,992904254259447721LL,992944096548434809LL,
	992984585359682161LL,993027119828666521LL,993067124027066089LL,993108619867012609LL,993149219661850729LL,
	993191406857032321LL,993233240154709129LL,993273507628704241LL,993314888182081921LL,993356771920468201LL,
	993397651874702881LL,993438716065453681LL,993478401624773689LL,993519810368020321LL,993560621909062321LL,
	993602797905135289LL,993643120716819049LL,993684508968586009LL,993724279185554401LL,993768145373915209LL,
	993810002778638809LL,993852319648659241LL,993893066238608449LL,993934112752528249LL,993975363498563161LL,
	994015534348738729LL,994057169641560649LL,994098534610099801LL,994139417859552409LL,994180457495076289LL,
	994222909881067441LL,994264633275445249LL,994305934754103409LL,994346295762677881LL,994388109498671449LL,
	994428863081512681LL,994470403317614161LL,994511892564213241LL,994554136614769201LL,994596644848283569LL,
	994636888089595921LL,994677199963832401LL,994719196191346609LL,994760961913915681LL,994802736492468289LL,
	994843761889265401LL,994883299953380161LL,994925918956431289LL,994967166338807281LL,995008378666138489LL,
	995049795341417929LL,995089261686308881LL,995130548366663809LL,995171189469824929LL,995213196124290529LL,
	995255267513284969LL,995295923134845721LL,995337585233912761LL,995378565787172449LL,995420081955152569LL,
	995461255770434209LL,995502693842908969LL,995543801518364569LL,995584151722274689LL,995624299190682001LL,
	995666459094589129LL,995707889463579769LL,995747125376462209LL,995788489567032529LL,995829235910928721LL,
	995869975104988201LL,995910862829435569LL,995952501869691601LL,995994117828512401LL,996035243633016409LL,
	996077915247294961LL,996119709484404961LL,996161584444628809LL,996202749637985761LL,996244550486419081LL,
	996285797245251241LL,996326857203504121LL,996368241418935961LL,996409462788515689LL,996449578979150521LL,
	996491948015491489LL,996531694512164281LL,996573382467018841LL,996613833394641361LL,996655455181310929LL,
	996697608957858721LL,996736968195856801LL,996776883314153881LL,996817442205947209LL,996859635351387889LL,
	996900112057015609LL,996941084825135641LL,996983260617421081LL,997024398850010281LL,997064463511509409LL,
	997106094706896001LL,997146919924698481LL,997188824458856929LL,997229160052277161LL,997271002401815761LL,
	997311846973890361LL,997351617807854761LL,997393394815047409LL,997432947557491201LL,997475792918935801LL,
	997516589749095529LL,997557890797683601LL,997599404446638361LL,997641286525082809LL,997682877821148289LL,
	997723355254938841LL,997764285004221289LL,997805399390997409LL,997848376617584881LL,997888869395791129LL,
	997930010324451961LL,997969805469765769LL,998011943075997529LL,998054505159114841LL,998096844363024961LL,
	998138221362530329LL,998179507303456921LL,998221269674637121LL,998262161677274209LL,998305552396941889LL,
	998346258281347369LL,998388032134203481LL,998428695734693521LL,998469927728478241LL,998512067897643049LL,
	998552885913944761LL,998594975870212081LL,998636323220849041LL,998676696073220641LL,998719472200539961LL,
	998760090582301609LL,998799622442936161LL,998842269279215089LL,998884157449937929LL,998924695225613209LL,
	998966233306578289LL,999008603838464041LL,999051171175873729LL,999092879810117569LL,999136648424469361LL,
	999178222898806729LL,999218654684781001LL,999259811020646569LL,999302047826827369LL,999344885328967321LL,
	999385252507671241LL,999427639922460841LL,999469732314598561LL,999512121520872961LL,999555031510255081LL,
	999596806649414689LL,999638550667309081LL,999679807634891881LL,999722245289598769LL,999761768190289129LL,
	999803923612429849LL,999845387976681481LL,999885637269895489LL,999927223324159321LL,999968926241398369LL,
	1000010634028270489LL,1000053186707187649LL,1000094408228123209LL,1000135390582342249LL,1000175969740656361LL,
	1000217817859863409LL,1000259890883623969LL,1000300360550728561LL,1000343303459259769LL,1000385075063565361LL,
	1000425991357498729LL,1000467448614287809LL,1000509742942915921LL,1000549333421087641LL,1000590561164886169LL,
	1000632217893291481LL,1000674687762520369LL,1000716926449843201LL,1000756937184289609LL,1000799221625019961LL,
	1000840190405880049LL,1000882808751868249LL,1000924839733309969LL,1000966667498669089LL,1001008932357826921LL,
	1001050569779371609LL,1001092900444782601LL,1001135548184517769LL,1001175751394816209LL,1001218376884654009LL,
	1001258813903965681LL,1001298943539846121LL,1001340410874540361LL,1001382043181153089LL,1001424248760320641LL,
	1001467155742089481LL,1001507713872266329LL,1001548004616332209LL,1001588476313729929LL,1001630245884373681LL,
	1001671956275825641LL,1001713499391842689LL,1001755555818476449LL,1001797380919534369LL,1001839767408530521LL,
	1001880557293586569LL,1001921828469965209LL,1001962688092224769LL,1002003456455505529LL,1002044950387934209LL,
	1002085648349682961LL,1002126142921125049LL,1002166826514311929LL,1002208560089676241LL,1002251243600250121LL,
	1002291829618177081LL,1002330918714777961LL,1002372271251397489LL,1002414193326164161LL,1002456144311927761LL,
	1002497082912504169LL,1002538751272382041LL,1002581730185141089LL,1002623400304127281LL,1002665035241120161LL,
	1002706875318465529LL,1002748031329463329LL,1002790097450681929LL,1002832737263744689LL,1002872646065995849LL,
	1002914418369910201LL,1002955806976636969LL,1002997064239702921LL,1003037637313122889LL,1003078459588574209LL,
	1003120396427994289LL,1003160274896789881LL,1003203094854471289LL,1003244144859736081LL,1003285476164414881LL,
	1003326960573085801LL,1003368558027876769LL,1003408084822923649LL,1003451378875985209LL,1003492782567827161LL,
	1003534323353953609LL,1003576630364784961LL,1003618345197236521LL,1003659624099515881LL,1003702422653949001LL,
	1003743214372679881LL,1003784588016717049LL,1003826619767259289LL,1003869037139887801LL,1003912293042252169LL,
	1003952131137929689LL,1003992815707147561LL,1004035164445833601LL,1004077650354636001LL,1004119912701349921LL,
	1004160400254397681LL,1004201177228001769LL,1004242905038308849LL,1004284393201968649LL,1004325930326318161LL,
	1004368177854160681LL,1004408686447282561LL,1004450799413339041LL,1004492809028868769LL,1004533243963155481LL,
	1004576907069077281LL,1004619264115194841LL,1004658715304875801LL,1004699249803490641LL,1004741340794129689LL,
	1004784543313599889LL,1004827534250761321LL,1004868998401360849LL,1004910836319712921LL,1004951219518337809LL,
	1004992361412983329LL,1005033123194640409LL,1005074840215255681LL,1005117729086248801LL,1005158361070194769LL,
	1005199659599338681LL,1005240774495343369LL,1005284858041268809LL,1005328798170617881LL,1005369486559960201LL,
	1005409915070313481LL,1005449337661415089LL,1005490738430875321LL,1005532083897999529LL,1005572876679109489LL,
	1005615764141210401LL,1005658688619574609LL,1005700462746284761LL,1005740990174433769LL,1005782112128098321LL,
	1005823728352923769LL,1005864418733093929LL,1005905013653281921LL,1005946512064384801LL,1005987361394359369LL,
	1006028596709433361LL,1006069403572672321LL,1006111286533878121LL,1006153740111766801LL,1006196294894649769LL,
	1006235524252248889LL,1006277723648870401LL,1006319751387700201LL,1006361386759273801LL,1006402116102794401LL,
	1006445490750269761LL,1006487710601209321LL,1006529722659683401LL,1006572429865173889LL,1006613520654318721LL,
	1006654407604525969LL,1006696186353045049LL,1006737624825006649LL,1006779686247869689LL,1006820395959786409LL,
	1006859505029579881LL,1006902512236793041LL,1006944528937590049LL,1006986899742542161LL,1007029769179195441LL,
	1007072723824877161LL,1007114069690634361LL,1007154509176832641LL,1007195924965629169LL,1007238317117192689LL,
	1007278855446543241LL,1007320570873339321LL,1007362014164502049LL,1007401603480852441LL,1007441847996556729LL,
	1007482591168268329LL,1007523483719524249LL,1007565557540473801LL,1007605644723593161LL,1007647009557985729LL,
	1007689089973375489LL,1007731203390869281LL,1007772570802410169LL,1007814368731975561LL,1007855581238891449LL,
	1007897770418972161LL,1007940422304694321LL,1007982601212656689LL,1008022913555854249LL,1008064491775174201LL,
	1008107179317795649LL,1008150658968909481LL,1008192312117015601LL,1008235150974011689LL,1008275753539681201LL,
	1008315770499622729LL,1008356800456465849LL,1008400169004072601LL,1008441646548074209LL,1008483643129176769LL,
	1008524375225378449LL,1008564437289601921LL,1008604978193052529LL,1008645086047924081LL,1008686950275450889LL,
	1008730157190381649LL,1008772280303692969LL,1008814299839145361LL,1008857180032055929LL,1008898140647573089LL,
	1008939146290817641LL,1008979851423371881LL,1009020593539029241LL,1009062614227661569LL,1009105154134992121LL,
	1009145870652625729LL,1009186796944912609LL,1009228495602529801LL,1009269001628163721LL,1009311292715129881LL,
	1009352680489018849LL,1009393683312054769LL,1009435832333371921LL,1009478259539570209LL,1009517661335448721LL,
	1009559415056818921LL,1009600269350791561LL,1009641261125410489LL,1009683564030233689LL,1009726804342766689LL,
	1009768031816389609LL,1009809284249084929LL,1009850537524413601LL,1009892366464548121LL,1009934433440313481LL,
	1009975769669907049LL,1010019128798532241LL,1010060864748372649LL,1010102790507767401LL,1010144516125372681LL,
	1010184980224408921LL,1010226204989409409LL,1010269493104100161LL,1010311664427326881LL,1010352795281498761LL,
	1010394899990784169LL,1010436410496124921LL,1010477085506861449LL,1010518207665150409LL,1010558389731600889LL,
	1010599702537946161LL,1010640396920066641LL,1010681908446672289LL,1010722612526634121LL,1010764495717001281LL,
	1010805297977225689LL,1010845127825859481LL,1010886181059719449LL,1010928916238252881LL,1010970220530082201LL,
	1011013520560205761LL,1011054609389724769LL,1011095992669701481LL,1011136777486926841LL,1011177900999349561LL,
	1011219415518471721LL,1011260540711311081LL,1011302724668643289LL,1011344008437808081LL,1011386161954319089LL,
	1011427942229712121LL,1011468311339760481LL,1011509972623267441LL,1011552045114556969LL,1011591933927057289LL,
	1011635134619352049LL,1011677185573792609LL,1011717849339943321LL,1011758992713709969LL,1011800647912554361LL,
	1011842798873568841LL,1011884624792907121LL,1011925135800340609LL,1011966480557909809LL,1012008248674246849LL,
	1012051409966660281LL,1012093803573355441LL,1012136121608157121LL,1012178710154639329LL,1012220233139782969LL,
	1012262960287163209LL,1012304344141689769LL,1012346811464054089LL,1012387532957138209LL,1012430517196699969LL,
	1012471984973455561LL,1012512882056734081LL,1012554673522671049LL,1012596417549693001LL,1012637292994818481LL,
	1012679964539040121LL,1012722290800963681LL,1012762746114821881LL,1012805790650905729LL,1012847624391762721LL,
	1012890312444381361LL,1012932828287900881LL,1012973706496470601LL,1013015620198006441LL,1013057768276428681LL
};

struct node
{
	LL x;int y;
	bool operator < (const node& B) const {return x<B.x;}
};

struct Heap
{
	node S[30];int n;

	void Up(int x)
	{
		while (x!=1&&S[x]<S[x>>1]) swap(S[x],S[x>>1]),x>>=1;
	}
	void Down(int x)
	{
		for (;;)
		{
			int t=x;
			if (x<<1<=n&&S[x<<1]<S[t]) t=x<<1;
			if ((x<<1|1)<=n&&S[x<<1|1]<S[t]) t=x<<1|1;
			if (x==t) return;swap(S[x],S[t]),x=t;
		}
	}
	node top() {return S[1];}
	void pop() {S[1]=S[n--];Down(1);}
	void push(node x) {S[++n]=x;Up(n);}
} Q;

int Sqrt(LL x)
{
	int L=1,R=int(sqrt(x)+3),res;
	while (L<=R)
		if (1LL*Mid*Mid<=x) res=Mid,L=Mid+1;else R=Mid-1;
	return res;
}
int Sqrt3(LL x)
{
	int L=1,R=int(pow(x,1.0/3))+3,res;
	while (L<=R)
		if (1LL*Mid*Mid*Mid<=x) res=Mid,L=Mid+1;else R=Mid-1;
	return res;
}
LL Pow(LL a,int b)
{
	LL res=1;
	for (;b;b>>=1,a=a*a) if (b&1) res=res*a;
	return res;
}
int Pow(int a,int b,int P)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
bool Work(int a,int n,int x)
{
	int tmp=Pow(a,x,n),res;
	while (x!=n-1)
	{
		res=1LL*tmp*tmp%n;
		if (res==1&&tmp!=1&&tmp!=n-1) return 0;
		x<<=1,tmp=res;
	}
	return res==1;
}
bool Miller_Rabin(int n)
{
	int x;
	for (x=n-1;!(x&1);x>>=1);
	if (n!=2&&!Work(2,n,x)) return 0;
	if (n!=7&&!Work(7,n,x)) return 0;
	if (n!=61&&!Work(61,n,x)) return 0;
	return 1;
}
LL Work(LL &n,int &k)
{
	while (Q.n) Q.pop();
	For(i,3,63)
		if (f[i]==i)
		{
			Top[i]=floor(pow(1ull<<63,1.0/i));
//			fprintf(stderr,"%.10lf\n",pow(n,1.0/i)+1e-9);
			t[i]=lower_bound(p+1,p+*p+1,(i==3?Sqrt3(n):floor(pow(n,1.0/i)))+1)-p;
			if (p[t[i]]>Top[i]) continue;
			Q.push((node){Pow(p[t[i]],i),i});
		}
	if (n<4) if (--k==0) return 4;
	cur=Sqrt(n)+1;cur+=!(cur&1);
	for (;!Miller_Rabin(cur);cur+=2);
	while (k-->1)
		if (1LL*cur*cur<Q.top().x)
			for (cur+=2;!Miller_Rabin(cur);cur+=2);
		else
		{
			int e=Q.top().y;Q.pop();
			if (p[++t[e]]<=Top[e]) Q.push((node){Pow(p[t[e]],e),e});
		}
	return min(1LL*cur*cur,Q.top().x);
}

int main()
{

	scanf("%lld%d",&n,&k);
	For(i,2,top+1)
	{
		if (!f[i]) f[i]=i,p[++*p]=i;
		for (int j=1;j<=*p&&p[j]<=f[i]&&p[j]*i<=top;j++) f[p[j]*i]=p[j];
	}

	if (n>List[1]&&k>1000)
	{
		LL Fir=upper_bound(List,List+800,n)-List;
		For(i,3,63)
			if (f[i]==i)
			{
				Top[i]=floor(pow(1ull<<63,1.0/i));
				t[i]=lower_bound(p+1,p+*p+1,floor(pow(n,1.0/i))+1)-p;
				if (p[t[i]]>Top[i]) continue;
				Q.push((node){Pow(p[t[i]],i),i});
			}
		cur=Sqrt(n)+1;cur+=!(cur&1);
		for (;!Miller_Rabin(cur);cur+=2);
		while (k--)
		{
			if (min(1LL*cur*cur,Q.top().x)==List[Fir]) break;
			if (1LL*cur*cur<Q.top().x)
				for (cur+=2;!Miller_Rabin(cur);cur+=2);
			else
			{
				int e=Q.top().y;Q.pop();
				if (p[++t[e]]<=Top[e]) Q.push((node){Pow(p[t[e]],e),e});
			}
		}
		if (k==0) return printf("%lld\n",min(1LL*cur*cur,Q.top().x)),0;
		while (Fir+1<800&&k>1000) k-=1000,Fir++;
		n=List[Fir];
	}

	printf("%lld\n",Work(n,k));
}
Problem3070
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x,_=y;i<_;i++)
#define Mid (L+R>>1)
using namespace std;

const int top=1e6+10000,N=top+19;
typedef long long LL;
int f[N],p[N],Top[N],t[70],k,cur,x,tmp;
LL n;

LL List[]=
{
	980020225443364681LL,980041252300368241LL,980061760632991969LL,980081572226620249LL,
980102971982253001LL,980123330478839089LL,980143811949604129LL,980164036225940281LL,
980184086463446089LL,980204604210903241LL,980225312265244369LL,980244915616336969LL,
980264281543523089LL,980284400132638129LL,980305176356897161LL,980326004287254769LL,
980346868083356929LL,980367054849107689LL,980388394351883449LL,980408011215491401LL,
980428329312624481LL,980448148571617489LL,980468625514428649LL,980490037416786961LL,
980510296951425601LL,980531622169613089LL,980551969273954081LL,980572883005917601LL,
980593024566558841LL,980613506983231969LL,980633803443132721LL,980655375593885209LL,
980675181302945209LL,980694804996730321LL,980714563569053569LL,980735340389963929LL,
980757052303940521LL,980776696623673849LL,980798298075927769LL,980818945055863369LL,
980839358524995649LL,980860077244742809LL,980881608306776929LL,980901970926932209LL,
980921826665910529LL,980941785610052809LL,980963365109786809LL,980983914782435041LL,
981003886243698409LL,981023295323372401LL,981044328976358761LL,981064931002353961LL,
981085430232919489LL,981106004956250209LL,981127606072586449LL,981148545752948329LL,
981167980036542169LL,981187462058963041LL,981208921431369409LL,981229533110074249LL,
981250141042942681LL,981270170687090761LL,981291389257137841LL,981311993877101041LL,
981332380776483961LL,981353001676921129LL,981373797147193129LL,981393055343982649LL,
981413153811762169LL,981435019847004529LL,981456097540684921LL,981476684075892601LL,
981495982910353681LL,981515313637415209LL,981535060659087169LL,981554415548586961LL,
981575359783012201LL,981595999088241289LL,981616369122209209LL,981637956040626481LL,
981657870748093081LL,981679525497061561LL,981699737868449161LL,981719851366137361LL,
981740278171517929LL,981761323472657809LL,981782844607096249LL,981802847979841801LL,
981822998205092761LL,981843120892480729LL,981863782830379201LL,981883331213469169LL,
981903716119481401LL,981924109164463921LL,981944704571175361LL,981965906650241041LL,
981987239763952249LL,982007605929294961LL,982027885100186401LL,982048493486992801LL,
982068515421677401LL,982088545488493249LL,982109091086873929LL,982129942135744249LL,
982150060040034649LL,982169861015997889LL,982189927794271849LL,982211655803314561LL,
982231909330842769LL,982251473271204049LL,982271858033956681LL,982291798992535201LL,
982313139610391689LL,982334119689545401LL,982354172287525489LL,982374415390584841LL,
982394634914416441LL,982414850681654329LL,982434606750062449LL,982454291651552329LL,
982474682483534881LL,982495545342611689LL,982516812840859321LL,982536696811871881LL,
982556501684894161LL,982576818242516641LL,982597341192351361LL,982618570141473721LL,
982638867515156329LL,982658197598045329LL,982678368494425201LL,982699364369187481LL,
982719745848372841LL,982739980821710329LL,982759966185045049LL,982779678138297601LL,
982801329395030161LL,982821993481711681LL,982842098645012761LL,982863175580382721LL,
982883879973430009LL,982903743864430441LL,982924147291446721LL,982944424026478369LL,
982965323598689929LL,982984894841666809LL,983004077624915641LL,983023324049756929LL,
983042800687552201LL,983063185727894041LL,983082912619912129LL,983104043696057089LL,
983126924053160041LL,983146675381575961LL,983168588483113561LL,983189589594207241LL,
983210130841281841LL,983231548859748241LL,983251642346192521LL,983271934358080249LL,
983292290042455849LL,983313772419560521LL,983335663584011929LL,983355916797155521LL,
983378038494481249LL,983398196944223449LL,983418450801335761LL,983438109856239361LL,
983458951207710121LL,983479166022242761LL,983500705976713681LL,983521774105115569LL,
983542410061762489LL,983562316308892609LL,983582881284315841LL,983603343330877369LL,
983624083288167049LL,983646235771726921LL,983666393002982329LL,983686260832348921LL,
983706918350920009LL,983727905374119889LL,983748067409518009LL,983768404217298001LL,
983789510919766321LL,983810621816142961LL,983830848179655529LL,983852165833327729LL,
983872515619917361LL,983892631525331641LL,983913799075852681LL,983935046208870001LL,
983955670629487609LL,983975787384958369LL,983996646336534601LL,984017223787874929LL,
984037448307104689LL,984058744391017201LL,984079223290874929LL,984101198367525001LL,
984121423749697249LL,984142038219084889LL,984163029883307569LL,984183454312882849LL,
984203704349990569LL,984224418889207609LL,984245006658730441LL,984266003389479721LL,
984286996375736881LL,984306493464995089LL,984325701044818609LL,984346524019196881LL,
984366081227149009LL,984385944215334049LL,984406799576436289LL,984427067786046361LL,
984447927551541049LL,984468656567115721LL,984489540586378369LL,984509920776921289LL,
984530733792918841LL,984551094564921361LL,984571852449795481LL,984592900295303209LL,
984612658405909009LL,984632781876209449LL,984653889910803841LL,984673922510161129LL,
984694054545045289LL,984714933016273369LL,984736196736240001LL,984756285744370129LL,
984776577398655409LL,984797623462829401LL,984817673402318809LL,984839124800953321LL,
984859246615761001LL,984880253866836889LL,984900118072238281LL,984921352033697521LL,
984941716844405401LL,984960930621016441LL,984981482423802889LL,985001919314171641LL,
985023464027811289LL,985045378184997529LL,985066367570979409LL,985086444066374521LL,
985106326231401529LL,985128165877540441LL,985147758640117801LL,985167446882904289LL,
985188040542764881LL,985208134159239169LL,985229407173898441LL,985249953836661241LL,
985271314652338921LL,985291123243912489LL,985310987621792329LL,985331642340180529LL,
985352396539970761LL,985373047721733889LL,985394600464452721LL,985416077999100049LL,
985436948240349361LL,985457068219821409LL,985477676819072089LL,985498619188654561LL,
985518414181305601LL,985538070388775401LL,985558584530699089LL,985579349062507081LL,
985599843778558969LL,985620501524303089LL,985640528069255809LL,985661289493048081LL,
985681701664571521LL,985701712946063689LL,985722097736756689LL,985741148354130529LL,
985761942608991601LL,985783884836517001LL,985804997262791161LL,985824870791605321LL,
985844756435505409LL,985864789230232081LL,985885664222569009LL,985905443243410369LL,
985926243202846969LL,985946384063892241LL,985966958060598721LL,985987730865784201LL,
986009055986532769LL,986030329702378801LL,986049939378223729LL,986069163961083409LL,
986090621041195849LL,986111836055026321LL,986132546831632489LL,986153405603297147LL,
986174266956203329LL,986193822451180561LL,986212818041445289LL,986233525906082281LL,
986254905326090929LL,986275712943994201LL,986295261499768081LL,986316089406063529LL,
986336162742243889LL,986357006970875929LL,986377851419756041LL,986398171691991601LL,
986417391723717529LL,986437334988897289LL,986458617297225361LL,986479109234603209LL,
986499740436586489LL,986521106850060721LL,986540979649822249LL,986561528065093369LL,
986581834336891081LL,986601302490807481LL,986621672742385969LL,986643604670218609LL,
986664583264067569LL,986685272031386929LL,986705635203152929LL,986726078052311689LL,
986747303874105601LL,986767548482551081LL,986787380055988729LL,986808554881229161LL,
986829102109354729LL,986849633656945249LL,986870288601383209LL,986890653682232209LL,
986911348793306161LL,986932270626733201LL,986953526482890409LL,986974114958872681LL,
986994644041033681LL,987015769428608929LL,987036692368823209LL,987056840594919649LL,
987076869804560929LL,987098349768102289LL,987118498623487129LL,987139231891123249LL,
987160815863389561LL,987181024970485921LL,987200960056376641LL,987221666369464681LL,
987241772764967281LL,987262221167268601LL,987282618113047369LL,987303297460814161LL,
987324124084138801LL,987345352362705961LL,987367590431565841LL,987387026589597001LL,
987407309557261849LL,987427771598164009LL,987447661477488121LL,987468370377653761LL,
987489393512050081LL,987509868328266721LL,987531070778668441LL,987551430751225729LL,
987571616030771641LL,987592572687347929LL,987612555654798529LL,987633775108308409LL,
987655479768296329LL,987675189078243121LL,987695868561605449LL,987717347308410601LL,
987738007356108649LL,987758138886168841LL,987780155000462209LL,987800294911082041LL,
987820526465042449LL,987841358542955569LL,987863232461174281LL,987883234069461409LL,
987902548078571161LL,987922331417438041LL,987942051341413081LL,987962208805820161LL,
987982748161543369LL,988003808578213249LL,988024109807772361LL,988047071203013761LL,
988067734698817369LL,988087901397575449LL,988108446035946481LL,988129153911578449LL,
988149778503387361LL,988170176663035081LL,988190535270108361LL,988211128691671921LL,
988231535437312609LL,988252709845654009LL,988272910243820569LL,988293011435508529LL,
988314540416290201LL,988336006005904609LL,988356676499431849LL,988375895718979681LL,
988397214835985761LL,988417834271586601LL,988438438015022569LL,988458334093831561LL,
988477864499062081LL,988499900563622329LL,988520890928966641LL,988540931010157849LL,
988560867891024289LL,988580582255566609LL,988600491696320281LL,988621149046724209LL,
988641361164500521LL,988661939396706481LL,988683205916203009LL,988703359008195769LL,
988723711174748641LL,988743319772544361LL,988764272947515289LL,988784760976211761LL,
988805806073896801LL,988826926969768441LL,988847586685769281LL,988868194907827441LL,
988889336358580801LL,988909543262154721LL,988930844266900441LL,988951461312189769LL,
988971728518712929LL,988992119248527241LL,989012764778281681LL,989032754152585081LL,
989053463755212241LL,989074145728040761LL,989094060138190561LL,989113982705157409LL,
989133841821430561LL,989154882677150281LL,989174953053417001LL,989195409531479089LL,
989216176534201729LL,989237122783624009LL,989258797312780201LL,989279015947753969LL,
989299143282902761LL,989319656745213049LL,989340333543756769LL,989362076840911489LL,
989382300509982289LL,989402719344439009LL,989423142368385169LL,989443541730126289LL,
989464912147183081LL,989486107722680569LL,989506853902847281LL,989527337686512769LL,
989547296448886561LL,989567613529757161LL,989587958673047449LL,989609338607956609LL,
989630237289782449LL,989650797956187481LL,989671056410227129LL,989691907991755609LL,
989712302165179609LL,989732776136978449LL,989752641464218129LL,989774055013984321LL,
989794473910990801LL,989814733835514889LL,989835598869422761LL,989856671065637281LL,
989878105639244761LL,989897924667971881LL,989918504034069289LL,989938502559380089LL,
989960005676740921LL,989980518029656609LL,990000755978425489LL,990021853812499561LL,
990043214553777409LL,990064328760576169LL,990084376520246569LL,990104245375712041LL,
990123644767085761LL,990144341906280961LL,990164410377422809LL,990184104901842601LL,
990203903111470609LL,990223976166600289LL,990244833572074369LL,990265086163768321LL,
990284849358263761LL,990305273523370561LL,990325451101638961LL,990346206078991609LL,
990366770200849441LL,990386741407788169LL,990407457219693241LL,990428965429662529LL,
990449976266342089LL,990471484937986921LL,990491473124453161LL,990513209162580601LL,
990533751132095641LL,990555001944092209LL,990574011621567409LL,990595310639183209LL,
990615542927417521LL,990636754804472689LL,990656784471170041LL,990677184602216329LL,
990698743516989049LL,990719128154470009LL,990739970866853089LL,990760240465621201LL,
990781087591976641LL,990802225591659121LL,990822452029621201LL,990842419867241041LL,
990863805385659241LL,990885577362575449LL,990906290427303121LL,990926577654608401LL,
990947458385706721LL,990967933183480729LL,990987703390224409LL,991008835629867289LL,
991029812796068809LL,991050774256039561LL,991069959920351089LL,991090977554883529LL,
991111477728380761LL,991131834753817849LL,991151674293924049LL,991173298105535689LL,
991193548242439369LL,991216188020937649LL,991236259386429169LL,991256920361412769LL,
991278198841943401LL,991298589439964521LL,991319247081926569LL,991339753598732521LL,
991360782059182441LL,991381870483555321LL,991402465268954209LL,991422673935814201LL,
991443627601540129LL,991462952486294929LL,991484241143922289LL,991504522337726401LL,
991525253819539321LL,991545479670030289LL,991565821236588361LL,991586119197293929LL,
991606090745228401LL,991626309453748609LL,991646205724521649LL,991667703481068769LL,
991688615919195769LL,991708879286247721LL,991729875810460609LL,991750721185178761LL,
991770726258720769LL,991791062168507329LL,991811705023168969LL,991832029402184881LL,
991852959507586201LL,991874479423676209LL,991895525505951361LL,991917017997195481LL,
991937809564798009LL,991957517733950881LL,991977967108542649LL,991998548164755121LL,
992019348554825761LL,992040408126136009LL,992060029664542609LL,992079133460446249LL,
992099866964494201LL,992120305853674321LL,992140362465380041LL,992161307776681249LL,
992182161669394921LL,992202557578135201LL,992223057291315721LL,992244274418638921LL,
992264041414989121LL,992284641376792201LL,992305213660361329LL,992325009156042769LL,
992345605766033401LL,992366067109869841LL,992387325613604881LL,992407588148226721LL,
992429978788424401LL,992450899262453401LL,992471409510759649LL,992491449746299801LL,
992513159897705209LL,992533467552348121LL,992553612026482801LL,992573218713936721LL,
992594618917004041LL,992615158546743169LL,992635809975832201LL,992656130841047401LL,
992677460201992009LL,992697223541970241LL,992717608802326801LL,992738257311675169LL,
992758057126257601LL,992779319828168161LL,992799785642905321LL,992819251279566649LL,
992839689606308569LL,992861232181153729LL,992883524308997281LL,992904254259447721LL,
992925195675029761LL,992944096548434809LL,992964643779588769LL,992984585359682161LL,
993006563979139609LL,993027119828666521LL,993047460643122889LL,993067124027066089LL,
993087740295667129LL,993108619867012609LL,993128303787616441LL,993149219661850729LL,
993170598169143601LL,993191406857032321LL,993211896850828561LL,993233240154709129LL,
993253391728854169LL,993273507628704241LL,993294245636439289LL,993314888182081921LL,
993335965486982569LL,993356771920468201LL,993376916774263849LL,993397651874702881LL,
993418666268617801LL,993438716065453681LL,993457769340849289LL,993478401624773689LL,
993499046083873729LL,993519810368020321LL,993540463231470001LL,993560621909062321LL,
993582256033837369LL,993602797905135289LL,993622745892150529LL,993643120716819049LL,
993664053973422049LL,993684508968586009LL,993704098910832241LL,993724279185554401LL,
993746939872633489LL,993768145373915209LL,993788713092051361LL,993810002778638809LL,
993831440236080601LL,993852319648659241LL,993872501428360849LL,993893066238608449LL,
993913866542339521LL,993934112752528249LL,993954841703719921LL,993975363498563161LL,
993995303261183161LL,994015534348738729LL,994035299039949721LL,994057169641560649LL,
994077776243629081LL,994098534610099801LL,994119077829371209LL,994139417859552409LL,
994158872694875281LL,994180457495076289LL,994202983789203841LL,994222909881067441LL,
994242624783762649LL,994264633275445249LL,994285569089193481LL,994305934754103409LL,
994325814013994641LL,994346295762677881LL,994367092831025761LL,994388109498671449LL,
994409469425467489LL,994428863081512681LL,994450103779458481LL,994470403317614161LL,
994491688337845681LL,994511892564213241LL,994532507867925049LL,994554136614769201LL,
994575482368106809LL,994596644848283569LL,994616758388734009LL,994636888089595921LL,
994656180241389121LL,994677199963832401LL,994697649426780601LL,994719196191346609LL,
994740088916696929LL,994760961913915681LL,994781404258769521LL,994802736492468289LL,
994823354810405761LL,994843761889265401LL,994863570720253441LL,994883299953380161LL,
994904421820387849LL,994925918956431289LL,994946881680598081LL,994967166338807281LL,
994987423274056969LL,995008378666138489LL,995029577671726249LL,995049795341417929LL,
995069354845520161LL,995089261686308881LL,995110066522849369LL,995130548366663809LL,
995150515673880721LL,995171189469824929LL,995192813189307121LL,995213196124290529LL,
995234098027325209LL,995255267513284969LL,995275439589215929LL,995295923134845721LL,
995316634356713761LL,995337585233912761LL,995358237028663561LL,995378565787172449LL,
995398810946743009LL,995420081955152569LL,995440926167543881LL,995461255770434209LL,
995481733246179481LL,995502693842908969LL,995523674615492929LL,995543801518364569LL,
995563832837861401LL,995584151722274689LL,995604554629220449LL,995624299190682001LL,
995645512738985161LL,995666459094589129LL,995687421635987161LL,995707889463579769LL,
995727227922200929LL,995747125376462209LL,995767941080502529LL,995788489567032529LL,
995809477342646521LL,995829235910928721LL,995850575384843161LL,995869975104988201LL,
995889798141785089LL,995910862829435569LL,995931229165258681LL,995952501869691601LL,
995974054237090009LL,995994117828512401LL,996014321342739241LL,996035243633016409LL,
996056621243007769LL,996077915247294961LL,996098379103682089LL,996119709484404961LL,
996140553036064921LL,996161584444628809LL,996182312656027561LL,996202749637985761LL,
996223110973233361LL,996244550486419081LL,996265547060074729LL,996285797245251241LL,
996305955806310361LL,996326857203504121LL,996347902556742961LL,996368241418935961LL,
996389099548968889LL,996409462788515689LL,996429958000304689LL,996449578979150521LL,
996470597677920121LL,996491948015491489LL,996512108662029961LL,996531694512164281LL,
996552634214979241LL,996573382467018841LL,996593807487293401LL,996613833394641361LL,
996634119065240881LL,996655455181310929LL,996676092689975569LL,996697608957858721LL,
996717064847695489LL,996736968195856801LL,996756520314025249LL,996776883314153881LL,
996796447804569721LL,996817442205947209LL,996838081391648521LL,996859635351387889LL,
996880003398521089LL,996900112057015609LL,996920708166333889LL,996941084825135641LL,
996961577515814689LL,996983260617421081LL,997004304914058841LL,997024398850010281LL,
997044009704269921LL,997064463511509409LL,997084789715251561LL,997106094706896001LL,
997126065846876001LL,997146919924698481LL,997167147110639761LL,997188824458856929LL,
997209072041880721LL,997229160052277161LL,997250917964487169LL,997271002401815761LL,
997291278781167841LL,997311846973890361LL,997331848136891089LL,997351617807854761LL,
997372805807720521LL,997393394815047409LL,997413360842340649LL,997432947557491201LL,
997454647769139169LL,997475792918935801LL,997496083365024049LL,997516589749095529LL,
997537152274945489LL,997557890797683601LL,997579212828610129LL,997599404446638361LL,
997620379335489361LL,997641286525082809LL,997661874308044009LL,997682877821148289LL,
997703274253854529LL,997723355254938841LL,997744675058633401LL,997764285004221289LL,
997785189706104361LL,997805399390997409LL,997827742958184961LL,997848376617584881LL,
997869018481791481LL,997888869395791129LL,997909507682998849LL,997930010324451961LL,
997950665020687249LL,997969805469765769LL,997990884151633969LL,998011943075997529LL,
998033090135955721LL,998054505159114841LL,998076727634485801LL,998096844363024961LL,
998116785460086601LL,998138221362530329LL,998158706371787041LL,998179507303456921LL,
998200504275423409LL,998221269674637121LL,998242247103423169LL,998262161677274209LL,
998284018780172881LL,998305552396941889LL,998325563521829761LL,998346258281347369LL,
998366605539654961LL,998388032134203481LL,998408991331064041LL,998428695734693521LL,
998450059045123441LL,998469927728478241LL,998490911766819241LL,998512067897643049LL,
998532652672327249LL,998552885913944761LL,998573487097947121LL,998594975870212081LL,
998615021873467441LL,998636323220849041LL,998656109813853241LL,998676696073220641LL,
998698042049718481LL,998719472200539961LL,998739539440724041LL,998760090582301609LL,
998779186823811649LL,998799622442936161LL,998822013117753889LL,998842269279215089LL,
998863928847830809LL,998884157449937929LL,998904226344553369LL,998924695225613209LL,
998944812502119289LL,998966233306578289LL,998987294523003361LL,999008603838464041LL,
999029821425832849LL,999051171175873729LL,999070809948878209LL,999092879810117569LL,
999114853957614241LL,999136648424469361LL,999156811816552489LL,999178222898806729LL,
999197619018415441LL,999218654684781001LL,999239506642541761LL,999259811020646569LL,
999280683400636729LL,999302047826827369LL,999323028611362849LL,999344885328967321LL,
999364954852610329LL,999385252507671241LL,999407109905727121LL,999427639922460841LL,
999448178147850601LL,999469732314598561LL,999490838827779769LL,999512121520872961LL,
999533376447088921LL,999555031510255081LL,999575551048789009LL,999596806649414689LL,
999618238442428201LL,999638550667309081LL,999659614970422849LL,999679807634891881LL,
999700276461916129LL,999722245289598769LL,999741982645386289LL,999761768190289129LL,
999782505827215009LL,999803923612429849LL,999823949749104841LL,999845387976681481LL,
999864986557465081LL,999885637269895489LL,999907628133238969LL,999927223324159321LL,
999947542687960441LL,999968926241398369LL,999989506027531009LL,1000010634028270489LL,
1000031406246584209LL,1000053186707187649LL,1000073207339779609LL,1000094408228123209LL,
1000114417272640849LL,1000135390582342249LL,1000154952002065729LL,1000175969740656361LL,
1000196491651294081LL,1000217817859863409LL,1000238712244183801LL,1000259890883623969LL,
1000279537532578081LL,1000300360550728561LL,1000322291963843689LL,1000343303459259769LL,
1000364067130188289LL,1000385075063565361LL,1000405499099047441LL,1000425991357498729LL,
1000446947929455601LL,1000467448614287809LL,1000489113793453729LL,1000509742942915921LL,
1000529396046503569LL,1000549333421087641LL,1000570123236970441LL,1000590561164886169LL,
1000610599179394009LL,1000632217893291481LL,1000653088596373081LL,1000674687762520369LL,
1000696859360960161LL,1000716926449843201LL,1000737830048109409LL,1000756937184289609LL,
1000778677525683169LL,1000799221625019961LL,1000820254135261849LL,1000840190405880049LL,
1000861683544701001LL,1000882808751868249LL,1000904190297672049LL,1000924839733309969LL,
1000945849552132969LL,1000966667498669089LL,1000987969900662769LL,1001008932357826921LL,
1001029386773022721LL,1001050569779371609LL,1001071929104144041LL,1001092900444782601LL,
1001114296241202049LL,1001135548184517769LL,1001155695715337761LL,1001175751394816209LL,
1001196595746338161LL,1001218376884654009LL,1001239365769099081LL,1001258813903965681LL,
1001279615091997609LL,1001298943539846121LL,1001319060693631969LL,1001340410874540361LL,
1001361365013563401LL,1001382043181153089LL,1001402645508959929LL,1001424248760320641LL,
1001446636811425249LL,1001467155742089481LL,1001487178514215969LL,1001507713872266329LL,
1001528077309480009LL,1001548004616332209LL,1001568516579170401LL,1001588476313729929LL,
1001609913434264689LL,1001630245884373681LL,1001650742676150961LL,1001671956275825641LL,
1001692873849674241LL,1001713499391842689LL,1001734409392515241LL,1001755555818476449LL,
1001776169995311481LL,1001797380919534369LL,1001819144570087281LL,1001839767408530521LL,
1001860170254700409LL,1001880557293586569LL,1001901288866737249LL,1001921828469965209LL,
1001942080004183761LL,1001962688092224769LL,1001982715817411689LL,1002003456455505529LL,
1002024998117688169LL,1002044950387934209LL,1002064706654576041LL,1002085648349682961LL,
1002105685312139521LL,1002126142921125049LL,1002146756906276809LL,1002166826514311929LL,
1002187272734255521LL,1002208560089676241LL,1002230103956453761LL,1002251243600250121LL,
1002271706699473681LL,1002291829618177081LL,1002311520239838649LL,1002330918714777961LL,
1002351358599150121LL,1002372271251397489LL,1002392947839586081LL,1002414193326164161LL,
1002435022531666441LL,1002456144311927761LL,1002476809750294321LL,1002497082912504169LL,
1002517556531292169LL,1002538751272382041LL,1002561364049298769LL,1002581730185141089LL,
1002601712028600121LL,1002623400304127281LL,1002645072793085569LL,1002665035241120161LL,
1002686239551843961LL,1002706875318465529LL,1002727278981269521LL,1002748031329463329LL,
1002768311239473601LL,1002790097450681929LL,1002810866471375809LL,1002832737263744689LL,
1002852765671084689LL,1002872646065995849LL,1002893576172822049LL,1002914418369910201LL,
1002934475633942569LL,1002955806976636969LL,1002975716434483009LL,1002997064239702921LL,
1003017278565295009LL,1003037637313122889LL,1003058196573140761LL,1003078459588574209LL,
1003098698771518801LL,1003120396427994289LL,1003140968554978009LL,1003160274896789881LL,
1003181905111116721LL,1003203094854471289LL,1003223731932503761LL,1003244144859736081LL,
1003264566007688209LL,1003285476164414881LL,1003306246307794081LL,1003326960573085801LL,
1003347618958552921LL,1003368558027876769LL,1003388239189279969LL,1003408084822923649LL,
1003429649592209449LL,1003451378875985209LL,1003471890285582481LL,1003492782567827161LL,
1003514744942500561LL,1003534323353953609LL,1003555817351821561LL,1003576630364784961LL,
1003597295327603089LL,1003618345197236521LL,1003638669971488489LL,1003659624099515881LL,
1003680774806657809LL,1003702422653949001LL,1003723185090378769LL,1003743214372679881LL,
1003763700712086889LL,1003784588016717049LL,1003805495576685481LL,1003826619767259289LL,
1003848112887439681LL,1003869037139887801LL,1003890979584847201LL,1003912293042252169LL,
1003932352266277009LL,1003952131137929689LL,1003972559490144721LL,1003992815707147561LL,
1004014134253573249LL,1004035164445833601LL,1004055922307276281LL,1004077650354636001LL,
1004098953768959161LL,1004119912701349921LL,1004141004125499769LL,1004160400254397681LL,
1004181508137176329LL,1004201177228001769LL,1004222570138301721LL,1004242905038308849LL,
1004263460612668369LL,1004284393201968649LL,1004304897089118769LL,1004325930326318161LL,
1004347553060473561LL,1004368177854160681LL,1004388602421226201LL,1004408686447282561LL,
1004430442364349529LL,1004450799413339041LL,1004472062687530369LL,1004492809028868769LL,
1004512340852684161LL,1004533243963155481LL,1004555157584050081LL,1004576907069077281LL,
1004598492412898881LL,1004619264115194841LL,1004639001641011489LL,1004658715304875801LL,
1004678356993929601LL,1004699249803490641LL,1004720263113166609LL,1004741340794129689LL,
1004762571057700849LL,1004784543313599889LL,1004806146926437249LL,1004827534250761321LL,
1004848139914057321LL,1004868998401360849LL,1004889508255383529LL,1004910836319712921LL,
1004930925566429761LL,1004951219518337809LL,1004971585853909521LL,1004992361412983329LL,
1005012379294345249LL,1005033123194640409LL,1005054196136831569LL,1005074840215255681LL,
1005096438928290361LL,1005117729086248801LL,1005137447446477489LL,1005158361070194769LL,
1005179246839065841LL,1005199659599338681LL,1005220694183088601LL,1005240774495343369LL,
1005262379001741169LL,1005284858041268809LL,1005306334682217649LL,1005328798170617881LL,
1005349469133141889LL,1005369486559960201LL,1005389054980482649LL,1005409915070313481LL,
1005430157706228409LL,1005449337661415089LL,1005470174311061449LL,1005490738430875321LL,
1005511747982855569LL,1005532083897999529LL,1005551990832255409LL,1005572876679109489LL,
1005595439413429489LL,1005615764141210401LL,1005636967539717529LL,1005658688619574609LL,
1005679138338131401LL,1005700462746284761LL,1005720704295450529LL,1005740990174433769LL,
1005761789730837049LL,1005782112128098321LL,1005802214093341921LL,1005823728352923769LL,
1005843778582322689LL,1005864418733093929LL,1005885227589260209LL,1005905013653281921LL,
1005926232136470121LL,1005946512064384801LL,1005966736029902761LL,1005987361394359369LL,
1006008677034025921LL,1006028596709433361LL,1006049515589918809LL,1006069403572672321LL,
1006091574672392569LL,1006111286533878121LL,1006132607498654689LL,1006153740111766801LL,
1006174876959139969LL,1006196294894649769LL,1006216332787429201LL,1006235524252248889LL,
1006256156384486401LL,1006277723648870401LL,1006299046377087241LL,1006319751387700201LL,
1006340685333000889LL,1006361386759273801LL,1006381566741832681LL,1006402116102794401LL,
1006423676905649809LL,1006445490750269761LL,1006466955707823289LL,1006487710601209321LL,
1006508533929522121LL,1006529722659683401LL,1006551682124463049LL,1006572429865173889LL,
1006593085516930129LL,1006613520654318721LL,1006634273045592409LL,1006654407604525969LL,
1006675718269942249LL,1006696186353045049LL,1006717280736414361LL,1006737624825006649LL,
1006757816606421961LL,1006779686247869689LL,1006799938654735681LL,1006820395959786409LL,
1006840275505947481LL,1006859505029579881LL,1006881271418259169LL,1006902512236793041LL,
1006923480339381361LL,1006944528937590049LL,1006965766409431921LL,1006986899742542161LL,
1007007916891661281LL,1007029769179195441LL,1007051653816454689LL,1007072723824877161LL,
1007093753912090881LL,1007114069690634361LL,1007134417788035161LL,1007154509176832641LL,
1007175162771406561LL,1007195924965629169LL,1007218000085505121LL,1007238317117192689LL,
1007258200788806521LL,1007278855446543241LL,1007300437682503561LL,1007320570873339321LL,
1007341085657596561LL,1007362014164502049LL,1007382115852801441LL,1007401603480852441LL,
1007422596853486969LL,1007441847996556729LL,1007462584835063449LL,1007482591168268329LL,
1007502686029614889LL,1007523483719524249LL,1007545024410368929LL,1007565557540473801LL,
1007585998531503889LL,1007605644723593161LL,1007626411354357369LL,1007647009557985729LL,
1007668752334664809LL,1007689089973375489LL,1007710106418217801LL,1007731203390869281LL,
1007752870781840401LL,1007772570802410169LL,1007793628273341001LL,1007814368731975561LL,
1007836153470605761LL,1007855581238891449LL,1007876808237401041LL,1007897770418972161LL,
1007919062114668729LL,1007940422304694321LL,1007961863038895521LL,1007982601212656689LL,
1008001921961154121LL,1008022913555854249LL,1008043865208571129LL,1008064491775174201LL,
1008085624586216929LL,1008107179317795649LL,1008127914970167289LL,1008150658968909481LL,
1008172587912724441LL,1008192312117015601LL,1008213410120266249LL,1008235150974011689LL,
1008255004317522361LL,1008275753539681201LL,1008295177511394529LL,1008315770499622729LL,
1008336319515121081LL,1008356800456465849LL,1008378370137119809LL,1008400169004072601LL,
1008420859467769609LL,1008441646548074209LL,1008462482045294929LL,1008483643129176769LL,
1008503804208895801LL,1008524375225378449LL,1008544106887643089LL,1008564437289601921LL,
1008584912513258089LL,1008604978193052529LL,1008624815091316201LL,1008645086047924081LL,
1008665537986436929LL,1008686950275450889LL,1008709262684826481LL,1008730157190381649LL,
1008752068330983001LL,1008772280303692969LL,1008793709795847361LL,1008814299839145361LL,
1008836115470372281LL,1008857180032055929LL,1008877573854982441LL,1008898140647573089LL,
1008917928197170489LL,1008939146290817641LL,1008959332012484329LL,1008979851423371881LL,
1009000218360420841LL,1009020593539029241LL,1009040747931101209LL,1009062614227661569LL,
1009083781607014129LL,1009105154134992121LL,1009125466081721641LL,1009145870652625729LL,
1009166424106581049LL,1009186796944912609LL,1009207137841906441LL,1009228495602529801LL,
1009248302465293081LL,1009269001628163721LL,1009289271019942201LL,1009311292715129881LL,
1009332044766004969LL,1009352680489018849LL,1009373203899300241LL,1009393683312054769LL,
1009415010896211529LL,1009435832333371921LL,1009457562249828409LL,1009478259539570209LL,
1009498020625657369LL,1009517661335448721LL,1009539122857414081LL,1009559415056818921LL,
1009579526600052409LL,1009600269350791561LL,1009620835470003409LL,1009641261125410489LL,
1009661883932010241LL,1009683564030233689LL,1009705678452536641LL,1009726804342766689LL,
1009747854084479449LL,1009768031816389609LL,1009788732288707809LL,1009809284249084929LL,
1009830166026781969LL,1009850537524413601LL,1009871636792147809LL,1009892366464548121LL,
1009914049037150401LL,1009934433440313481LL,1009955489365983889LL,1009975769669907049LL,
1009997408918430529LL,1010019128798532241LL,1010039437881595489LL,1010060864748372649LL,
1010082420486073489LL,1010102790507767401LL,1010123631097766761LL,1010144516125372681LL,
1010165248598271529LL,1010184980224408921LL,1010206255861169929LL,1010226204989409409LL,
1010247927329475409LL,1010269493104100161LL,1010290906328792089LL,1010311664427326881LL,
1010332310161988641LL,1010352795281498761LL,1010374213409680729LL,1010394899990784169LL,
1010415635032982929LL,1010436410496124921LL,1010457129880811089LL,1010477085506861449LL,
1010498203381747609LL,1010518207665150409LL,1010538521765213401LL,1010558389731600889LL,
1010578643919015649LL,1010599702537946161LL,1010619800313199129LL,1010640396920066641LL,
1010661468246193201LL,1010681908446672289LL,1010701411880042089LL,1010722612526634121LL,
1010744171302899289LL,1010764495717001281LL,1010785029454070809LL,1010805297977225689LL,
1010824999659080761LL,1010845127825859481LL,1010865758902076401LL,1010886181059719449LL,
1010907741580368241LL,1010928916238252881LL,1010948510535178609LL,1010970220530082201LL,
1010991878473084561LL,1011013520560205761LL,1011034024650523129LL,1011054609389724769LL,
1011075302934894409LL,1011095992669701481LL,1011115677073465441LL,1011136777486926841LL,
1011157146070483801LL,1011177900999349561LL,1011198704409240169LL,1011219415518471721LL,
1011240444610803289LL,1011260540711311081LL,1011281642636250001LL,1011302724668643289LL,
1011323171352631201LL,1011344008437808081LL,1011364479675118969LL,1011386161954319089LL,
1011406738209716809LL,1011427942229712121LL,1011447191376021481LL,1011468311339760481LL,
1011488912568258601LL,1011509972623267441LL,1011531012782538361LL,1011552045114556969LL,
1011571898903260249LL,1011591933927057289LL,1011612431812354849LL,1011635134619352049LL,
1011656304824145289LL,1011677185573792609LL,1011697052660499529LL,1011717849339943321LL,
1011739330212746521LL,1011758992713709969LL,1011779830264674241LL,1011800647912554361LL,
1011822652729117849LL,1011842798873568841LL,1011863150425043569LL,1011884624792907121LL,
1011904920432652801LL,1011925135800340609LL,1011945407703430729LL,1011966480557909809LL,
1011987223671723049LL,1012008248674246849LL,1012030090764625969LL,1012051409966660281LL,
1012073377269104929LL,1012093803573355441LL,1012114717006609129LL,1012136121608157121LL,
1012156802072681521LL,1012178710154639329LL,1012199439346150441LL,1012220233139782969LL,
1012241614710591721LL,1012262960287163209LL,1012283605827025249LL,1012304344141689769LL,
1012325911731334561LL,1012346811464054089LL,1012366222289076769LL,1012387532957138209LL,
1012409097408205561LL,1012430517196699969LL,1012450818310234801LL,1012471984973455561LL,
1012492922438147329LL,1012512882056734081LL,1012533972893895841LL,1012554673522671049LL,
1012575354237689089LL,1012596417549693001LL,1012617114791621089LL,1012637292994818481LL,
1012658473682904889LL,1012679964539040121LL,1012701270458376409LL,1012722290800963681LL,
1012742602890383689LL,1012762746114821881LL,1012783759044439561LL,1012805790650905729LL,
1012827371632776001LL,1012847624391762721LL,1012868211482504521LL,1012890312444381361LL,
1012911125410349881LL,1012932828287900881LL,1012952900939205769LL,1012973706496470601LL,
1012994387464345729LL,1013015620198006441LL,1013035943280815689LL,1013057768276428681LL
};

struct node
{
	LL x;int y;
	bool operator < (const node& B) const {return x<B.x;}
};

struct Heap
{
	node S[30];int n;

	void Up(int x)
	{
		while (x!=1&&S[x]<S[x>>1]) swap(S[x],S[x>>1]),x>>=1;
	}
	void Down(int x)
	{
		for (;;)
		{
			int t=x;
			if (x<<1<=n&&S[x<<1]<S[t]) t=x<<1;
			if ((x<<1|1)<=n&&S[x<<1|1]<S[t]) t=x<<1|1;
			if (x==t) return;swap(S[x],S[t]),x=t;
		}
	}
	node top() {return S[1];}
	void pop() {S[1]=S[n--];Down(1);}
	void push(node x) {S[++n]=x;Up(n);}
} Q;

int Sqrt(LL x)
{
	int L=1,R=int(sqrt(x)+3),res;
	while (L<=R)
		if (1LL*Mid*Mid<=x) res=Mid,L=Mid+1;else R=Mid-1;
	return res;
}
int Sqrt3(LL x)
{
	int L=1,R=int(pow(x,1.0/3))+3,res;
	while (L<=R)
		if (1LL*Mid*Mid*Mid<=x) res=Mid,L=Mid+1;else R=Mid-1;
	return res;
}
LL Pow(LL a,int b)
{
	LL res=1;
	for (;b;b>>=1,a=a*a) if (b&1) res=res*a;
	return res;
}
int Pow(int a,int b,int P)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
bool Work(int a,int n,int x)
{
	int tmp=Pow(a,x,n),res;
	while (x!=n-1)
	{
		res=1LL*tmp*tmp%n;
		if (res==1&&tmp!=1&&tmp!=n-1) return 0;
		x<<=1,tmp=res;
	}
	return res==1;
}
bool Miller_Rabin(int n)
{
	int x;
	for (x=n-1;!(x&1);x>>=1);
	if (n!=2&&!Work(2,n,x)) return 0;
	if (n!=7&&!Work(7,n,x)) return 0;
	if (n!=61&&!Work(61,n,x)) return 0;
	return 1;
}
LL Work(LL &n,int &k)
{
	while (Q.n) Q.pop();
	For(i,3,63)
		if (f[i]==i)
		{
			Top[i]=floor(pow(1ull<<63,1.0/i));
			t[i]=lower_bound(p+1,p+*p+1,(i==3?Sqrt3(n):floor(pow(n,1.0/i)))+1)-p;
			if (p[t[i]]>Top[i]) continue;
			Q.push((node){Pow(p[t[i]],i),i});
		}
	if (n<4) if (--k==0) return 4;
	cur=Sqrt(n)+1;cur+=!(cur&1);
	for (;!Miller_Rabin(cur);cur+=2);
	while (k-->1)
		if (1LL*cur*cur<Q.top().x)
			for (cur+=2;!Miller_Rabin(cur);cur+=2);
		else
		{
			int e=Q.top().y;Q.pop();
			if (p[++t[e]]<=Top[e]) Q.push((node){Pow(p[t[e]],e),e});
		}
	return min(1LL*cur*cur,Q.top().x);
}

int main()
{

	scanf("%lld%d",&n,&k);
	For(i,2,top+1)
	{
		if (!f[i]) f[i]=i,p[++*p]=i;
		for (int j=1;j<=*p&&p[j]<=f[i]&&p[j]*i<=top;j++) f[p[j]*i]=p[j];
	}

	if (n>List[1]&&k>500)
	{
		LL Fir=upper_bound(List,List+1600,n)-List;
		For(i,3,63)
			if (f[i]==i)
			{
				Top[i]=floor(pow(1ull<<63,1.0/i));
				t[i]=lower_bound(p+1,p+*p+1,floor(pow(n,1.0/i))+1)-p;
				if (p[t[i]]>Top[i]) continue;
				Q.push((node){Pow(p[t[i]],i),i});
			}
		cur=Sqrt(n)+1;cur+=!(cur&1);
		for (;!Miller_Rabin(cur);cur+=2);
		while (k--)
		{
			if (min(1LL*cur*cur,Q.top().x)==List[Fir]) break;
			if (1LL*cur*cur<Q.top().x)
				for (cur+=2;!Miller_Rabin(cur);cur+=2);
			else
			{
				int e=Q.top().y;Q.pop();
				if (p[++t[e]]<=Top[e]) Q.push((node){Pow(p[t[e]],e),e});
			}
		}
		if (k==0) return printf("%lld\n",min(1LL*cur*cur,Q.top().x)),0;
		while (Fir+1<1600&&k>500) k-=500,Fir++;
		n=List[Fir];
	}

	printf("%lld\n",Work(n,k));
}
Problem3070
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x,_=y;i<_;i++)
#define Mid (L+R>>1)
using namespace std;

const int top=1e6+10000,N=top+19;
typedef long long LL;
int f[N],p[N],Top[N],t[70],k,cur,x,tmp;
LL n;

LL List[]=
{
990008743756732561LL,990016998226168441LL,990024767170013689LL,990033519208326961LL,990042394666405081LL,990050593555405321LL,990059504910640921LL,990067564567489321LL,990075632217346249LL,990083488953830881LL,
990091094973103369LL,990099453269732569LL,990107333981725129LL,990114956013311209LL,990122908430541601LL,990131501694069289LL,990139207403497321LL,990147255444013489LL,990154945293698209LL,990163566558197641LL,
990171423643574929LL,990179806161128521LL,990187253337303961LL,990194899558549129LL,990202800552171649LL,990211330476389641LL,990219068339565289LL,990227200293169609LL,990235256652133801LL,990243687205152769LL,
990251632178426641LL,990259987172177929LL,990268803937965049LL,990276538045190449LL,990283941799392769LL,990292233240849841LL,990299752489735249LL,990308481860008249LL,990316868938275649LL,990324722651263609LL,
990333177468832201LL,990340879982355841LL,990349000494165601LL,990357503183387329LL,990365719299782401LL,990373593109974649LL,990381534623647609LL,990390021529594921LL,990398178069625081LL,990406573489242529LL,
990414980886794401LL,990423280838414641LL,990431883366940249LL,990440052021851209LL,990448837742387521LL,990457806621896089LL,990466051020548881LL,990474112331984281LL,990481512843808129LL,990490410214419409LL,
990498543282112489LL,990507301395282889LL,990516469588869721LL,990524594801542441LL,990532855402239241LL,990541239449540689LL,990549161730069769LL,990558131063801161LL,990565344778449049LL,990573044213680321LL,
990581575732444609LL,990590174967257089LL,990597950140864129LL,990606566654267779LL,990614810389173649LL,990623425693050241LL,990631619025115369LL,990639927846899521LL,990647512115698441LL,990655789153991041LL,
990664030395302761LL,990672753408353401LL,990680501036811649LL,990689056906316881LL,990697381894379329LL,990705611364589849LL,990713526339640489LL,990722213737988209LL,990730156649278369LL,990739043192280001LL,
990747161354883241LL,990755191958460769LL,990763708335641881LL,990772308360962521LL,990780311195829361LL,990788552955071641LL,990797033641670161LL,990804901203099889LL,990813071396107969LL,990821233659601369LL,
990829762265471041LL,990837956450782969LL,990846051128725009LL,990854380758055969LL,990862845799641721LL,990872342138152681LL,990880130364203641LL,990889029524996281LL,990896590856776321LL,990905267112409009LL,
990913589027066329LL,990921799486203601LL,990930161288472001LL,990937949741747569LL,990946550523258289LL,990954769082686321LL,990962912020382401LL,990971337706537489LL,990978851569348849LL,990986827364803369LL,
990995380575025081LL,991003563499241161LL,991012164565491721LL,991019813971047961LL,991028888967826921LL,991037565802637809LL,991045936057435801LL,991053724965676969LL,991061430280786489LL,991068984306123529LL,
991077896261276209LL,991086027758443369LL,991094334503509681LL,991102565622243649LL,991110458289724249LL,991118203647344809LL,991126793264427121LL,991134733815135001LL,991142905367929609LL,991150782266982481LL,
991159646802540121LL,991168232616908329LL,991176109616601841LL,991184520279745009LL,991192556637998521LL,991201341713084401LL,991210477276700521LL,991219166853609409LL,991227143616080281LL,991235208024145681LL,
991243754341287001LL,991251818816922601LL,991260253696168369LL,991268963403757921LL,991277565621651361LL,991285805466290161LL,991293886043180329LL,991301671943147569LL,991309943748631081LL,991318271345006929LL,
991326547202361241LL,991334755389518401LL,991343051228921689LL,991352032121557129LL,991360037297398609LL,991367994713177449LL,991376908012616161LL,991384937185288801LL,991392396857488609LL,991401358059811609LL,
991409088622887841LL,991417257323783161LL,991425923910135289LL,991433881590337441LL,991442544266502241LL,991450533876320281LL,991458280562640361LL,991466341927992841LL,991475283549933361LL,991483106008607809LL,
991491020105889241LL,991499635236118009LL,991508118965430049LL,991515634862985961LL,991524333743416201LL,991532096650160209LL,991540508823535441LL,991548530692559401LL,991556811494074849LL,991564741817886721LL,
991573026670204801LL,991580889345713209LL,991589178248632681LL,991596766150251361LL,991605098934452209LL,991613535316647721LL,991621561464276961LL,991629105674343049LL,991637470460341849LL,991645261692749161LL,
991653435349828729LL,991661848037906809LL,991671133105805881LL,991679302886183521LL,991687325316630121LL,991695758065243729LL,991703274673942009LL,991711918609991569LL,991721092376875249LL,991728816219584041LL,
991737225243961849LL,991745463015344041LL,991753226787677929LL,991761651849502249LL,991769686563548281LL,991778107711763761LL,991786258015084921LL,991794444203890441LL,991802188250090281LL,991810713109569721LL,
991819720021934521LL,991827563757349201LL,991835188423737529LL,991843681555807081LL,991851903834629161LL,991860078343288729LL,991868910196788649LL,991877503066281841LL,991885904753526721LL,991894485745366009LL,
991903102628282329LL,991912113943935409LL,991920424150176361LL,991928009335253929LL,991936964990264329LL,991944793253848009LL,991952693258031961LL,991960828343123809LL,991968752314590961LL,991976859578083201LL,
991984783613580241LL,991993026397010089LL,992001344910125449LL,992010129584684809LL,992018177257194649LL,992026794677365561LL,992034922098231001LL,992043432021640441LL,992051475845160481LL,992059169101632241LL,
992066675135142721LL,992074683195832681LL,992082157414970521LL,992090245221127441LL,992098735460990089LL,992106743651075809LL,992115130372356169LL,992123106754890289LL,992131294333747129LL,992139386324439721LL,
992147789120748649LL,992155917037236169LL,992164415526697009LL,992172973817282401LL,992180822933742121LL,992189405201180209LL,992197437663384241LL,992205529923809881LL,992214056516535241LL,992222017359075889LL,
992230432458584881LL,992239094629536121LL,992247143230728841LL,992254375046276281LL,992263180763598241LL,992271934721311729LL,992279437575153121LL,992287390710885361LL,992295543106544329LL,992304245407485481LL,
992312110981552321LL,992320048309780129LL,992327694792044521LL,992336616389361721LL,992344406383192801LL,992352933572618641LL,992361165931374121LL,992369127364044049LL,992378236429785241LL,992386209885160561LL,
992393932332745849LL,992401993516225009LL,992410779964574569LL,992419865312614729LL,992428867020832081LL,992437649603299201LL,992445455933131489LL,992454007465979881LL,992462471367947449LL,992470572678917929LL,
992478175906896121LL,992486153748696049LL,992494828990680409LL,992503735399363489LL,992512191543381721LL,992519794930777129LL,992527505943022009LL,992536563930031849LL,992544793065368929LL,992552822980919209LL,
992560725405949561LL,992568703579520929LL,992576745547168681LL,992585070492495769LL,992593546908791881LL,992602294353306961LL,992610021626789281LL,992618270992685401LL,992626819284814921LL,992634933222256921LL,
992643138853818841LL,992651543783086009LL,992659255307099689LL,992667732040148641LL,992676412061001529LL,992684075857514329LL,992692106336458609LL,992700587195144881LL,992708836937367001LL,992716592523392881LL,
992724535454563129LL,992732593995228241LL,992741114881418809LL,992749257184289089LL,992756969087841409LL,992765689353885841LL,992773939366615561LL,992782065861943009LL,992790523191565081LL,992799024398502049LL,
992806636855667929LL,992814448622158009LL,992821873814407729LL,992830303414142209LL,992838864576174001LL,992847780499705729LL,992856106581565801LL,992864986711175449LL,992873635708619809LL,992882611574372401LL,
992890395739466449LL,992898706056922729LL,992906996480212969LL,992915231136839761LL,992924143417435681LL,992932465833641089LL,992939672245197889LL,992946954414414169LL,992954850436497601LL,992963515768949209LL,
992971551364017241LL,992979686639962921LL,992987981387279329LL,992996997629568409LL,993005439930675889LL,993013667023505521LL,993022037647117921LL,993030802923657481LL,993038794944395761LL,993046436223225409LL,
993054934539687889LL,993062555950108081LL,993070002000666529LL,993078420695306401LL,993086628159707761LL,993094963215333001LL,993103294319753761LL,993111282645996721LL,993118936162353841LL,993127251422405401LL,
993135642455971921LL,993144133181601241LL,993151970193430609LL,993160520783318449LL,993169322547858481LL,993177418770602641LL,993186407968439161LL,993194444465336569LL,993202947401471041LL,993210888291713569LL,
993218857118602921LL,993227726910988321LL,993236042626472089LL,993244194931675129LL,993252518689061401LL,993260571399418921LL,993268162627555751LL,993276652998879649LL,993284586210669769LL,993293109465473569LL,
993301313830410841LL,993310032500256409LL,993318655529605441LL,993326943719304769LL,993335235930230209LL,993343233162591481LL,993351609161808121LL,993359777888060881LL,993368409106758721LL,993375864277340041LL,
993383734097386129LL,993393071077305721LL,993400777507535329LL,993409097934208201LL,993417809103447841LL,993425906338946089LL,993433712567679601LL,993442112869529569LL,993450002886383641LL,993457051700046649LL,
993465507917305201LL,993473864497391281LL,993481164572974009LL,993490206975764521LL,993498109144525009LL,993506517692616841LL,993514471757345521LL,993523219271809801LL,993531635900246041LL,993539482414953049LL,
993547045878426601LL,993555681897752689LL,993563408894227081LL,993572104791518641LL,993581207415280969LL,993589185701934721LL,993597355404970369LL,993605692603602961LL,993613355999242969LL,993621824843367721LL,
993630369481149409LL,993637949239582201LL,993646083257644441LL,993654097690356001LL,993662829870251641LL,993671219178764569LL,993679552699944289LL,993687375874593481LL,993695390473829521LL,993702990417189529LL,
993710945268363169LL,993718872239451121LL,993727532930121889LL,993736444868069809LL,993745871229816961LL,993753957839735569LL,993763073259002281LL,993771315452308849LL,993779442041147161LL,993787764053455849LL,
993795874759258321LL,993804810929193649LL,993813057283189441LL,993821311646645161LL,993830307745565161LL,993839052662664289LL,993847135664030041LL,993855306427480561LL,993863768327228569LL,993871436705758081LL,
993879595605880201LL,993887922025282729LL,993895961359869481LL,993904917918735601LL,993912889529336401LL,993920701658984089LL,993928856773477249LL,993937295059193521LL,993945717429237169LL,993953741046010369LL,
993961876356518689LL,993970215084341401LL,993978557835081289LL,993986713186925329LL,993994370075831569LL,994002425792870209LL,994010162502339889LL,994018756665941449LL,994026545283422401LL,994034485477353961LL,
994043103674512609LL,994051885420551049LL,994060423931072521LL,994068467951411329LL,994076974628059921LL,994085469376645801LL,994093601238050329LL,994101438006971449LL,994109386476417649LL,994117853445958921LL,
994125694298707441LL,994134225149714401LL,994142584541794081LL,994150413527220889LL,994158130871095369LL,994166633943060601LL,994175320514727649LL,994183628231030329LL,994192721690489689LL,994201743400575649LL,
994209281465590969LL,994217904408867121LL,994226260164320401LL,994233937918065601LL,994241691482322721LL,994250282658274009LL,994259679548752681LL,994267158005632681LL,994275494025382321LL,994284623801939089LL,
994292341666715569LL,994300984913109241LL,994309133610357049LL,994316719945884721LL,994324820844007129LL,994333077332475169LL,994340903079274969LL,994348884415452721LL,994357727342566129LL,994366039809679681LL,
994374356300270521LL,994383007880627401LL,994391388262446001LL,994399489464730969LL,994408460258496721LL,994416733049482681LL,994424447438138929LL,994432145901322969LL,994440486601544161LL,994449210269472049LL,
994457299740590401LL,994465114009466089LL,994473809862887929LL,994482094892547361LL,994490675140190089LL,994499167667215681LL,994507416901505329LL,994514920224108721LL,994523656185608761LL,994531590386630209LL,
994540099044613969LL,994548914898357289LL,994557583194456241LL,994566427049517169LL,994574501040840721LL,994582930099357369LL,994591510781983921LL,994599489134695921LL,994607774687859049LL,994615661353814809LL,
994623368535579721LL,994632057102381889LL,994639616744866849LL,994647722947513441LL,994655198874312361LL,994663696093101841LL,994671654788688361LL,994680247822076929LL,994688210573243761LL,994696827614422321LL,
994705289106455161LL,994713427492010521LL,994722136399310929LL,994730945080932049LL,994739155381799881LL,994747561201124329LL,994756006950946249LL,994764085701260449LL,994772152515787801LL,994780710077337481LL,
994789247727870841LL,994797466248506281LL,994805868324599809LL,994814797065432841LL,994822401288281281LL,994830404504893609LL,994838750864785369LL,994846754147162401LL,994854689636896729LL,994862756818781041LL,
994870073964564121LL,994878033485761441LL,994886120711087089LL,994894594977528961LL,994903224881999449LL,994912070273689681LL,994920041932363369LL,994928707855799161LL,994936763368198561LL,994945960018308841LL,
994954059489397921LL,994962306620188729LL,994970182721850241LL,994978118703838201LL,994986453713465929LL,994995223665547729LL,995003522836868689LL,995011371171589489LL,995019750210792289LL,995028332777522761LL,
995036412633584161LL,995044839659151649LL,995052297127732561LL,995059479306875761LL,995068349333890129LL,995076297677782321LL,995084477482502521LL,995092314165973321LL,995100980839635289LL,995109180696837649LL,
995117097282024721LL,995124682708965769LL,995133317601543481LL,995140535985501481LL,995149657761878161LL,995157618401408641LL,995166221514313489LL,995174748847984849LL,995183471745591241LL,995191659971542489LL,
995199888135061249LL,995208335804866681LL,995216428362990409LL,995224776342039961LL,995233228107930289LL,995241272881604401LL,995250055928084401LL,995258308276037569LL,995266480847767489LL,995274553689601441LL,
995281780566886201LL,995290879047160921LL,995298856213862281LL,995307691392281569LL,995315744448145129LL,995323981105881001LL,995331922489359361LL,995340721898504881LL,995348344093874521LL,995357035826617489LL,
995365380404640001LL,995373345897688081LL,995381630682788449LL,995389424637818401LL,995397645637276561LL,995406780564358009LL,995414901865003489LL,995423565952487281LL,995431647413077681LL,995439828678201481LL,
995448149657947441LL,995456446727055769LL,995464560248468209LL,995472657839205121LL,995480871200467129LL,995489312080799449LL,995497321970546641LL,995506181975814721LL,995514463322693521LL,995522668874345329LL,
995530638987775489LL,995538589177773601LL,995546914561366729LL,995555235988670449LL,995563030623344401LL,995570897128906081LL,995579278523670481LL,995587141102259161LL,995595586424301769LL,995603065912390321LL,
995611786695717361LL,995619362034154729LL,995627767580397121LL,995636245004853169LL,995644291407213361LL,995652661137025369LL,995660891206079569LL,995669604259997209LL,995677543030817761LL,995686228218053089LL,
995694622072410121LL,995702812400922649LL,995710603621882009LL,995718374916185881LL,995726301907104769LL,995734432494013969LL,995741836665610609LL,995750003239362121LL,995758121948515249LL,995766404343235849LL,
995775349368222721LL,995783328476176969LL,995791383456001729LL,995799741829270921LL,995808459482316841LL,995816578429773409LL,995824230388424761LL,995832529024699921LL,995841107112681769LL,995849318002095001LL,
995857676618502721LL,995865328735053529LL,995872793269353169LL,995880465402743449LL,995888720363871049LL,995897182932069289LL,995905713396873049LL,995913557305267969LL,995921988044305921LL,995930330998274281LL,
995939376556270129LL,995947611802119001LL,995955611559723049LL,995964440782991077LL,995973299760575161LL,995981060104089049LL,995988584951644729LL,995997087863992369LL,996004820356168921LL,996013167649095649LL,
996021766475227801LL,996030173719950769LL,996038676809821129LL,996047239817285569LL,996055443572247529LL,996064126415395129LL,996072957005495209LL,996080753666633209LL,996089364761016289LL,996097301212908049LL,
996106096020220201LL,996114715208588089LL,996122679707134849LL,996130851834729601LL,996139570936990561LL,996148357946327041LL,996156146917945729LL,996164478875677609LL,996172563343295809LL,996181534146501481LL,
996189738454488601LL,996197906864762449LL,996206007437642401LL,996213996255671209LL,996222068946907009LL,996230353270879609LL,996239076801066289LL,996247461007949089LL,996256228530596881LL,996264612809652481LL,
996272613840277489LL,996280686769009321LL,996288516183656089LL,996296529288023209LL,996305105381610649LL,996313178441982769LL,996321431203678441LL,996330031360362241LL,996338312140545529LL,996346708743052489LL,
996354754023058369LL,996363306410920009LL,996371719089692521LL,996380127811226929LL,996387945638290921LL,996396438276807649LL,996404300088681961LL,996412848696364969LL,996420794422516849LL,996429019679945569LL,
996437372743107409LL,996444352289271649LL,996452525736247969LL,996460910841258769LL,996469459691782561LL,996478024550776681LL,996487264258115569LL,996494810982581689LL,996502725091528561LL,996510715099191889LL,
996519619543273849LL,996526842953371921LL,996535108579134601LL,996543110695863481LL,996551540106066961LL,996560121290259241LL,996568710497660161LL,996576329407169809LL,996584583258670561LL,996593000864732209LL,
996601350621994441LL,996609341025039361LL,996616508855126041LL,996625014447388561LL,996633340379193001LL,996641171179403929LL,996650028286784881LL,996658390262873209LL,996666237134802529LL,996675146267043721LL,
996683472408248881LL,996692397591039241LL,996700124794992601LL,996708538895585569LL,996716262168681961LL,996724149202854361LL,996732535450634761LL,996739815541004929LL,996747686694405361LL,996755358203602321LL,
996763205457244681LL,996771504011495809LL,996779762664747889LL,996787729821560329LL,996795613144903441LL,996804031642143169LL,996812625894211681LL,996820217780598649LL,996828101232409681LL,996836979138714169LL,
996845905008793849LL,996854363655439249LL,996862858281458809LL,996870913632561361LL,996879176691380161LL,996886904619333121LL,996894956073805441LL,996903187281854449LL,996911674128257449LL,996919809553286089LL,
996927980956170481LL,996936811380807361LL,996944275935798961LL,996952311646350049LL,996960555072932641LL,996969697168722601LL,996977808866793121LL,996986631524168041LL,996994228067136289LL,997003022839149769LL,
997011050798421649LL,997018863112205761LL,997026998974586449LL,997035274662472369LL,997042967248711321LL,997050875545873801LL,997059323079759241LL,997068010297319041LL,997075539249816601LL,997083627413481001LL,
997091955260716561LL,997100446904787241LL,997109353983284161LL,997117286509105609LL,997125011365683841LL,997133603007087529LL,997141887125946241LL,997150331051074201LL,997158183853642561LL,997166184477275569LL,
997174836211243561LL,997183464016566121LL,997191808258236889LL,997200304321887241LL,997208077432981969LL,997216381833342841LL,997224462579345289LL,997233002721184849LL,997241139457226689LL,997249947301696729LL,
997257836447112529LL,997265805514289089LL,997274118144104641LL,997282247058759601LL,997290344049928009LL,997298852517111169LL,997306941586468969LL,997315118570415649LL,997323131807527561LL,997330945343905561LL,
997339134410279761LL,997346708327935729LL,997354853517255601LL,997363486096042129LL,997372002864708769LL,997379544949121569LL,997388013849081409LL,997396334977787761LL,997404172769745049LL,997412318193713041LL,
997420471640616409LL,997428557208329401LL,997436243321855401LL,997444812334684921LL,997453341435287881LL,997461878562197689LL,997470663411789961LL,997478789132482801LL,997486683177987601LL,997495252407479281LL,
997503018678031441LL,997511312321324161LL,997519222475663281LL,997527436285280209LL,997536101571478681LL,997544942679128089LL,997552701152911201LL,997560431691039841LL,997569824235293929LL,997578026267781841LL,
997586140440260281LL,997594350530195401LL,997603036083038401LL,997611342127771849LL,997619280645362761LL,997628086164328921LL,997635996781655401LL,997644063246467569LL,997652505302266969LL,997660915431231529LL,
997669401507028441LL,997677552009286201LL,997685814415164169LL,997694116809110449LL,997702519122658801LL,997710469989267241LL,997718424882990721LL,997727094994135801LL,997735425528119041LL,997743780069790009LL,
997751727105303361LL,997759422454920889LL,997767221718042169LL,997775804139122089LL,997784174832109729LL,997792453661810689LL,997799865481052929LL,997808735726790289LL,997817797802339809LL,997826548258258489LL,
997834915168430641LL,997843521854750041LL,997851393369164161LL,997860147968109001LL,997868179377457441LL,997876650351693121LL,997883758805459761LL,997892233841604721LL,997901096506300009LL,997908660570011089LL,
997916580291316009LL,997925035487596441LL,997932787447607881LL,997941118840260841LL,997949370349757281LL,997957318203990769LL,997965433918875601LL,997972862364330889LL,997981457657667961LL,997989849193147561LL,
997998144860042041LL,998007079923259849LL,998015383653825601LL,998023919189583841LL,998032135076829889LL,998040742613651881LL,998049538004149849LL,998057981775333361LL,998066553458430481LL,998075700623787769LL,
998083597030912921LL,998091345610577089LL,998099581756336921LL,998107598144329201LL,998115894300595009LL,998124526176083329LL,998132978256998809LL,998141490317917969LL,998149343026023049LL,998157703296794329LL,
998165887764045529LL,998174459910496969LL,998182684410083041LL,998191380516468961LL,998199529154210881LL,998207877645910369LL,998215990383114409LL,998224446847725241LL,998232535673479129LL,998241156063876481LL,
998249264939814001LL,998256926239254889LL,998265518759258689LL,998274403064175241LL,998282903738412889LL,998291072732619241LL,998299929175057609LL,998308238120445121LL,998316714958948009LL,998324544376410241LL,
998332593641070601LL,998341486237819201LL,998349703432089121LL,998357568949331809LL,998365626340585441LL,998374067452010209LL,998382108922788529LL,998390973762596569LL,998399506907521489LL,998407648401099049LL,
998415889848632161LL,998424339166235881LL,998431821278653609LL,998439854988262129LL,998449043833056841LL,998457169540954369LL,998465131407817441LL,998473728820784329LL,998482330267729129LL,998490036428241289LL,
998498637945427369LL,998506959708746401LL,998515169589921481LL,998523371510756569LL,998531901224393761LL,998539095950256961LL,998547629728149601LL,998555655909439489LL,998564301677663449LL,998572295948807449LL,
998581401462621601LL,998589519714729121LL,998597614016670721LL,998605572446266849LL,998614198444445881LL,998622628614899929LL,998630814988019929LL,998639549021728849LL,998647295761849561LL,998655038534707849LL,
998663808650285761LL,998671807317076489LL,998680117809905281LL,998688092557756561LL,998697182609927641LL,998705900944213081LL,998714327504299849LL,998722554227711329LL,998730589106898649LL,998738396162262001LL,
998747166643851769LL,998755501435288249LL,998763136694416129LL,998770456177031521LL,998778311358882961LL,998786702246289889LL,998794177721166649LL,998803432157962369LL,998812190932234561LL,998820825818037121LL,
998828789134693729LL,998837264185282369LL,998845579364200129LL,998854034497483609LL,998862845464050121LL,998870944871407969LL,998879268186033529LL,998886967882602241LL,998894831518191169LL,998903266870899289LL,
998911134568465561LL,998920153674524761LL,998927705608036681LL,998936185076138401LL,998943984939253609LL,998952248589624169LL,998960976033004609LL,998969791469166169LL,998977575471663649LL,998985731315751169LL,
998994454907404201LL,999003090581019241LL,999011722293936121LL,999020022206831881LL,999028661989009369LL,999036710093661121LL,999045449900257321LL,999053562042235561LL,999061798158962521LL,999069682473381289LL,
999078350457386761LL,999087670181400361LL,999095910436909609LL,999104718472003081LL,999113710464357049LL,999122346653399929LL,999131310737244721LL,999139671121086049LL,999147979562062201LL,999155932187827129LL,
999164296673007721LL,999172365315693409LL,999181413589528129LL,999189042479724721LL,999196683394224121LL,999205104027715729LL,999213476715568921LL,999222473195767921LL,999230330154938281LL,999238543009401601LL,
999246308066424889LL,999254113138698169LL,999263053822468681LL,999271606687533169LL,999279571800957841LL,999287464971781561LL,999296505769572481LL,999305458638823561LL,999313339916005321LL,999321709058675209LL,
999330793996646281LL,999339683040625369LL,999348224237535481LL,999356045702676841LL,999363827211150769LL,999372260545138561LL,999380410002684649LL,999388699450655809LL,999397024922150089LL,999405934254743929LL,
999414059856618169LL,999422757326327569LL,999430946978377489LL,999439152659494369LL,999446962483774249LL,999455540129319289LL,999464093818104121LL,999472347622627321LL,999480841398909769LL,999489927060194761LL,
999498260951311801LL,999506886805148569LL,999515120791215961LL,999523902680657929LL,999532180726519969LL,999540370826885281LL,999549596727201529LL,999557950862660401LL,999566153066000809LL,999574639242566209LL,
999582637556942209LL,999591507725007289LL,999600177972404761LL,999608504324718289LL,999617178645062041LL,999625301106392689LL,999633399605122489LL,999642086031334729LL,999649996630950289LL,999658647135417481LL,
999666205859281921LL,999674652467059969LL,999682823154277201LL,999691037868087049LL,999699076642123729LL,999708495246852169LL,999717114008951209LL,999725224877935609LL,999733299784622881LL,999740938780352521LL,
999748933760542681LL,999756716798479201LL,999764887821058969LL,999772966887471529LL,999781409946708601LL,999790077018071089LL,999798868114526041LL,999807303283900609LL,999815246534249161LL,999822805850137201LL,
999831565093176841LL,999840012399520009LL,999848243757926161LL,999855719204612449LL,999863938628489089LL,999872698051704409LL,999880797552517609LL,999888837089469889LL,999897476627895169LL,999906380191269721LL,
999914459829358441LL,999922547499780529LL,999930187218498649LL,999938662940587561LL,999946686710595649LL,999955462495908361LL,999963594331349209LL,999971934196925089LL,999980286097160449LL,999988674032069569LL,
999997242001901641LL,1000005814008450649LL,1000013562045981961LL,1000021942120362841LL,1000030398231009601LL,1000039138382945761LL,1000047766570397689LL,1000055718776123881LL,1000064099027138401LL,1000072147301261329LL,
1000080403616120401LL,1000088519958859081LL,1000097324367892921LL,1000105344774234241LL,1000113249206164129LL,1000121349681212929LL,1000129882217073721LL,1000137982759482121LL,1000145619300859249LL,1000154067933774961LL,
1000162452597175729LL,1000170889300164481LL,1000179594062782849LL,1000187790815519881LL,1000195131518148721LL,1000204136416855969LL,1000212765316066129LL,1000220866194122329LL,1000228835089876921LL,1000237772132216641LL,
1000246101139579849LL,1000254442183147369LL,1000262531228400049LL,1000271140376784721LL,1000278385371907489LL,1000286502517984081LL,1000295187780741889LL,1000303304994992881LL,1000312342385633281LL,1000320911741956249LL,
1000329849195637921LL,1000337594487701089LL,1000346524014523009LL,1000354993499505361LL,1000363014938983081LL,1000371620519038849LL,1000379682032771329LL,1000388015631732121LL,1000396365268574569LL,1000404518900613121LL,
1000412884609629241LL,1000421678443807489LL,1000429052011537009LL,1000436885706859561LL,1000445623634047369LL,1000454473624838521LL,1000462571480725081LL,1000470517333623361LL,1000479115374141841LL,1000487777467211881LL,
1000495847450939449LL,1000504645650748681LL,1000512767715835201LL,1000520209636925041LL,1000528611839161441LL,1000537206128233489LL,1000544696153280721LL,1000552510295831089LL,1000561384766106409LL,1000569074938543009LL,
1000576989205133209LL,1000585223596619761LL,1000593754109829889LL,1000601296362163609LL,1000609730914622761LL,1000617729367939489LL,1000626031948343089LL,1000635098805615001LL,1000643669544299089LL,1000651972232320489LL,
1000659882825432769LL,1000668813790591201LL,1000678477043750761LL,1000687059972327841LL,1000695887022581689LL,1000704025869506401LL,1000711968679758241LL,1000719991550324761LL,1000728066471977089LL,1000736841683932609LL,
1000744372471061689LL,1000751767235410969LL,1000759998344525329LL,1000769053804109209LL,1000777429040272321LL,1000786168454502049LL,1000793999546280241LL,1000802338872385921LL,1000810826293219561LL,1000819461810664609LL,
1000827429088949641LL,1000835436415652161LL,1000844032022393329LL,1000852007401883569LL,1000860831177884329LL,1000868930678165641LL,1000877494414699801LL,1000886198249886001LL,1000894321863537721LL,1000903157831481529LL,
1000911661687098529LL,1000919717372821009LL,1000927761085395529LL,1000935996920116321LL,1000944697007784169LL,1000953449158045321LL,1000961553034996921LL,1000970189202690529LL,1000978685339143729LL,1000987057450467649LL,
1000995973867566769LL,1001003949852418801LL,1001011849830605209LL,1001020406174465329LL,1001028298213476289LL,1001036122248377329LL,1001044734725217361LL,1001054075622556201LL,1001062368006667849LL,1001070892549301809LL,
1001079373104490681LL,1001087893717352401LL,1001096022151675321LL,1001104790972331049LL,1001113431760146721LL,1001121440230876969LL,1001130005047614649LL,1001138489855460889LL,1001146786591486441LL,1001154951285681481LL,
1001163031964334409LL,1001170840516392001LL,1001179173407684569LL,1001187770490376681LL,1001195731229749969LL,1001204324381124361LL,1001212553348724649LL,1001221530806715241LL,1001230011999943489LL,1001238161023594321LL,
1001246234033063929LL,1001253626648864689LL,1001262103975507609LL,1001270305162772401LL,1001278446345282361LL,1001286015193125601LL,1001293720157515801LL,1001301789388366489LL,1001309630502469201LL,1001317967973960289LL,
1001326741769248801LL,1001335219405407769LL,1001343617023725889LL,1001351770512381649LL,1001360500425840361LL,1001368762057117609LL,1001376567408674209LL,1001385185352676609LL,1001394207615253321LL,1001401516718463169LL,
1001410250851585129LL,1001418736846919689LL,1001427627166446481LL,1001436489505332169LL,1001445383906549761LL,1001454222306561409LL,1001461835850883801LL,1001470554235290049LL,1001478227886023281LL,1001486385925668889LL,
1001494283804340769LL,1001502826197779161LL,1001510956316467249LL,1001518722191819329LL,1001527224658949041LL,1001535571042435081LL,1001543080815765049LL,1001551403246710801LL,1001559769746535561LL,1001567856061871641LL,
1001575045704307369LL,1001583348252232321LL,1001591754917304721LL,1001600445844809409LL,1001608840571985409LL,1001617047182390809LL,1001625441979136881LL,1001633140242840169LL,1001641511087335561LL,1001649917996495161LL,
1001658140788440529LL,1001666655857346361LL,1001674742604154441LL,1001683245733530361LL,1001691937057963321LL,1001700067944206929LL,1001708631232310401LL,1001716754179444081LL,1001725025287103881LL,1001733256394260009LL,
1001742216168991441LL,1001750071017870409LL,1001758666547828809LL,1001766737651914441LL,1001775181118516809LL,1001783712699148681LL,1001792168248036489LL,1001800908088202401LL,1001809856154621361LL,1001817903443114521LL,
1001826038844235609LL,1001833914040072369LL,1001842373804502169LL,1001850637423361881LL,1001858997165490489LL,1001867136737195689LL,1001875404461931169LL,1001883267840498481LL,1001891171287729321LL,1001900420042158081LL,
1001908711927117801LL,1001916615474706801LL,1001924711238143449LL,1001932746976332649LL,1001941247196843409LL,1001949647355973801LL,1001957763272430409LL,1001965659005628409LL,1001973947156601169LL,1001981802913948921LL,
1001989622666296489LL,1001997970976289169LL,1002006183184702921LL,1002015156191999041LL,1002023780887481641LL,1002032169380393761LL,1002040285631062129LL,1002047252739748609LL,1002055829524047769LL,1002063925849907761LL,
1002071773951693201LL,1002080382874201801LL,1002088587411975001LL,1002096743933039329LL,1002104588159131081LL,1002112532521492681LL,1002120484923821761LL,1002128989944917041LL,1002137507014921489LL,1002145827910930921LL,
1002153892565918689LL,1002161913205819129LL,1002169557470124481LL,1002177666268474081LL,1002186251619615841LL,1002194468603936689LL,1002203013983011801LL,1002211779641667841LL,1002220249010221081LL,1002229066802171569LL,
1002237468167735881LL,1002246081806452921LL,1002254575346982409LL,1002262624421432929LL,1002270921809623489LL,1002278698639967401LL,1002286988085551281LL,1002294833056204081LL,1002302650025339569LL,1002310787394444529LL,
1002317779471251961LL,1002325972966860721LL,1002333782048096521LL,1002342512236466041LL,1002350225269382929LL,1002358887449205001LL,1002367057084443241LL,1002374962439647729LL,1002383700816881881LL,1002391726381132201LL,
1002401193704815129LL,1002409231353539881LL,1002417232991004769LL,1002426027620373841LL,1002434113427044489LL,1002442751940038161LL,1002451402504952401LL,1002459091927321681LL,1002467077744062841LL,1002475624285280209LL,
1002483838450840201LL,1002492048645072001LL,1002500358997861201LL,1002508124703238729LL,1002516379052245201LL,1002524713536156721LL,1002533388485087449LL,1002542051456307961LL,1002550670408877529LL,1002560338738981201LL,
1002569073919066369LL,1002576863921485609LL,1002584962351972609LL,1002591951379848769LL,1002600474422168449LL,1002610094929814809LL,1002618365719538929LL,1002626404238900281LL,1002635207796327169LL,1002643983355412161LL,
1002651949882059409LL,1002660188801882521LL,1002668491840889449LL,1002677011203187321LL,1002685302295746001LL,1002693605438734609LL,1002702197004934969LL,1002710011557019921LL,1002718290769717729LL,1002726221542525489LL,
1002734428723770961LL,1002742523785124329LL,1002751307824834681LL,1002759026435944969LL,1002767125602116449LL,1002775497178183369LL,1002783920861526049LL,1002793305919871041LL,1002801385196482369LL,1002809977224424009LL,
1002817844269700761LL,1002826957102575361LL,1002835729495093321LL,1002843840988069921LL,1002851904445453969LL,1002860288392549129LL,1002867791113571161LL,1002875682420102481LL,1002884218685627041LL,1002892606773577081LL,
1002900922792246921LL,1002909727554793249LL,1002917322594844801LL,1002925414388566321LL,1002933570308735521LL,1002942174920580049LL,1002950651380629121LL,1002958691231932009LL,1002966490759729609LL,1002974863167950929LL,
1002983219587269001LL,1002991748298489049LL,1003000501381762129LL,1003008261012006001LL,1003016253021874081LL,1003024285124022001LL,1003032801991654009LL,1003040794099293049LL,1003049687609884489LL,1003056974709437041LL,
1003065047035885201LL,1003073303677333729LL,1003081632463616161LL,1003089376382989009LL,1003097717254570921LL,1003105633502901769LL,1003115048110153969LL,1003123481232033529LL,1003131629944997281LL,1003139754653410609LL,
1003147895419889521LL,1003155467323873081LL,1003163291654677609LL,1003171785074421769LL,1003180991661528289LL,1003189625379292849LL,1003197734297003281LL,1003206003503754961LL,1003214441014376761LL,1003222830483194161LL,
1003230659083156729LL,1003239032593894849LL,1003247506301818969LL,1003255707603093961LL,1003263796755263761LL,1003271765743895209LL,1003280427898154641LL,1003289122142390521LL,1003297271528103841LL,1003305032306229409LL,
1003313077584418561LL,1003321840082968849LL,1003330326160560841LL,1003337994913106449LL,1003346597252953801LL,1003355267743660441LL,1003363080833456641LL,1003371370755327289LL,1003379496434552329LL,1003387409787906529LL,
1003395375260670001LL,1003402591493422201LL,1003411398457837009LL,1003420117310542801LL,1003428507639307369LL,1003437975850905169LL,1003446370261220209LL,1003454816796394561LL,1003462906751221849LL,1003471048828828441LL,
1003478874390257329LL,1003487601550052089LL,1003496084321631289LL,1003504246568849281LL,1003513166175931849LL,1003521428668533889LL,1003529675166938089LL,1003537717338686209LL,1003546705214999089LL,1003554691355541361LL,
1003562849833985281LL,1003571565337524481LL,1003579679805874081LL,1003588267153045729LL,1003596365660171761LL,1003604384055926041LL,1003612983530448769LL,1003621386687229249LL,1003629425219198761LL,1003637864510232961LL,
1003645730794936849LL,1003654614965060881LL,1003662593520322129LL,1003670736408013969LL,1003679644732925689LL,1003688212470923281LL,1003696776238102489LL,1003705680671170129LL,1003713783659439241LL,1003722355550583601LL,
1003730534747787961LL,1003738669896143281LL,1003745803206064801LL,1003754275046393641LL,1003762911230736721LL,1003770349199326801LL,1003778624773275961LL,1003788082613847001LL,1003796081737515049LL,1003804493675994481LL,
1003813454693537569LL,1003820981017351561LL,1003829601458046841LL,1003838133767038441LL,1003847211157654081LL,1003855242578538289LL,1003863887212666561LL,1003872844487571601LL,1003881212662380529LL,1003890001688130769LL,
1003898169545001721LL,1003907187089952721LL,1003915459220137489LL,1003923526984584649LL,1003931169948813649LL,1003939037382861889LL,1003947053139525889LL,1003955626026691321LL,1003963854269321089LL,1003971633656854801LL,
1003979890020744961LL,1003987982091888049LL,1003995521093901361LL,1004004458916052441LL,1004013076136511841LL,1004021376759186241LL,1004030214495112561LL,1004038447051461721LL,1004046443164550041LL,1004055020484160681LL,
1004063233101616249LL,1004072415721471321LL,1004080832825878921LL,1004089578635546209LL,1004097755320649089LL,1004107290820474681LL,1004115006632162881LL,1004122858753557481LL,1004131492515122689LL,1004140070198002609LL,
1004147309149537081LL,1004155385862140521LL,1004163458598907489LL,1004171968276618969LL,1004180457948626401LL,1004188935631413841LL,1004196719899322569LL,1004203995130642849LL,1004213254554074569LL,1004221572037924969LL,
1004229981750592081LL,1004237734109857129LL,1004246236085315161LL,1004254176906778561LL,1004262318185405449LL,1004271084828093289LL,1004279141995720369LL,1004286946656074761LL,1004295781552156921LL,1004303698517912521LL,
1004312292970745929LL,1004320402415884129LL,1004329469960785609LL,1004337575466606481LL,1004346486750366769LL,1004354712585850081LL,1004363186995449961LL,1004371905973577761LL,1004380051738142689LL,1004387696439953809LL,
1004395637820677281LL,1004403923989408849LL,1004412089927882689LL,1004420636738510161LL,1004429295833264401LL,1004437934921013121LL,1004445435523384009LL,1004454014547068089LL,1004462661758949409LL,1004471244865130641LL,
1004479150495607329LL,1004487240569549881LL,1004495827789724449LL,1004504042209759081LL,1004511430806593329LL,1004519701416833809LL,1004528148459141289LL,1004536731845108401LL,1004545491667288561LL,1004553930799835641LL,
1004562353931373561LL,1004571410541043801LL,1004580114386328481LL,1004588886425161489LL,1004597349795089521LL,1004606214120812521LL,1004613935858401969LL,1004622154770578569LL,1004630069013394321LL,1004638183750655281LL,
1004646122112296161LL,1004653928198493169LL,1004661726296391409LL,1004669520415225681LL,1004677122115803889LL,1004685898587524521LL,1004693949400227529LL,1004702080433048089LL,1004710921164352249LL,1004718988115018089LL,
1004727371844088201LL,1004735960090623489LL,1004744957340648241LL,1004753160750780169LL,1004761741088509849LL,1004769896452816321LL,1004778721444299169LL,1004787694828398121LL,1004796600089675761LL,1004804695451481961LL,
1004813320115020441LL,1004822121239401921LL,1004830425205763809LL,1004839382782066441LL,1004847045270471649LL,1004855417504703361LL,1004863825861255369LL,1004872198165393321LL,1004880803069879761LL,1004888778477905281LL,
1004896834113212329LL,1004905378976196721LL,1004913895806799969LL,1004922023719756081LL,1004929939143639721LL,1004938744788601561LL,1004946700377149401LL,1004954515650794809LL,1004962134469132009LL,1004970459063658201LL,
1004978960130259321LL,1004986803599070601LL,1004994923786911201LL,1005003240497253001LL,1005011360751497401LL,1005019861991090521LL,1005028479557921569LL,1005036283119370441LL,1005044251124216209LL,1005053249754480481LL,
1005061141634500129LL,1005069574912485889LL,1005078172641728641LL,1005087015027558961LL,1005095640902643889LL,1005103737469001641LL,1005112439609867521LL,1005120772847351689LL,1005128496562218961LL,1005136140101577961LL,
1005144413283174649LL,1005153019353093601LL,1005161489109320929LL,1005169646095783081LL,1005178292377154809LL,1005186200789524009LL,1005194105222628721LL,1005202426767469921LL,1005210636055336489LL,1005219679545112249LL,
1005227852809449361LL,1005235733343573601LL,1005244043029299649LL,1005252982396548601LL,1005261336269165089LL,1005269998986982369LL,1005279455829880009LL,1005287958203283049LL,1005296095649991601LL,1005304959047358841LL,
1005314203492123561LL,1005323211352073329LL,1005331826208692161LL,1005340344846224689LL,1005348550686562681LL,1005356255223051601LL,1005364316742602041LL,1005372775356818521LL,1005379822223807809LL,1005387935977741801LL,
1005396418755987241LL,1005404167594624249LL,1005412598300806609LL,1005421105248058321LL,1005429303396294529LL,1005436831764402361LL,1005444753226379761LL,1005452189401867321LL,1005460889040132529LL,1005469143503490649LL,
1005477566460211849LL,1005485708685244609LL,1005493505999626081LL,1005502169717730721LL,1005510484515622849LL,1005519140284827529LL,1005527130258699049LL,1005535023998998249LL,1005542961892057801LL,1005550968004919449LL,
1005559511637465409LL,1005567485727254641LL,1005577381183444969LL,1005585475678744801LL,1005594095670163609LL,1005602972414690329LL,1005610882497501289LL,1005619330115221441LL,1005627669464952769LL,1005635896534092121LL,
1005643742566045801LL,1005653044726406521LL,1005661576758664849LL,1005669639502240969LL,1005678115446131521LL,1005687257311122409LL,1005695191793663809LL,1005704056950208729LL,1005711654540801121LL,1005719789690737489LL,
1005728346074766889LL,1005735987883115449LL,1005744203360904121LL,1005752687641983961LL,1005760726681755529LL,1005768982375797649LL,1005776997411466921LL,1005785084687033641LL,1005792931300952089LL,1005801042710090929LL,
1005809334674012521LL,1005818461088910121LL,1005826676903537449LL,1005834563796215521LL,1005842723513249449LL,1005850991578870441LL,1005859376017817281LL,1005867708339370969LL,1005876060754110529LL,1005884328956746801LL,
1005892332416701921LL,1005900035024771041LL,1005907761733119961LL,1005917253669873169LL,1005925116846661489LL,1005933108433335889LL,1005941120111077921LL,1005949208046457249LL,1005956983086416761LL,1005965684908257649LL,
1005973857192915361LL,1005982222084195801LL,1005990759524682649LL,1005999473528553001LL,1006007357086670761LL,1006015092231223369LL,1006023385077423241LL,1006031862511891609LL,1006039946799992329LL,1006048396219690321LL,
1006056885795824641LL,1006064179798635049LL,1006072773756667681LL,1006081476079304641LL,1006090190476063729LL,1006098744423399169LL,1006106315419317121LL,1006114191371638969LL,1006122600980843641LL,1006131427898538841LL,
1006140178621982881LL,1006148287418941489LL,1006156945932915001LL,1006165187203712449LL,1006173805667115409LL,1006182472315579729LL,1006191636534463681LL,1006199480721692401LL,1006207509509696209LL,1006215530304908401LL,
1006223230137890521LL,1006230673204029001LL,1006238493468673609LL,1006246622724165601LL,1006255285673736289LL,1006263535372280641LL,1006272246544950841LL,1006280905592278369LL,1006289572701980449LL,1006298011132147969LL,
1006306678315514689LL,1006315152930896449LL,1006322636463257569LL,1006331837434211929LL,1006339650066643489LL,1006348108770155089LL,1006356535407672289LL,1006364649089134729LL,1006372666497900529LL,1006380659862156049LL,
1006388869947043801LL,1006396518277171921LL,1006405085564999761LL,1006414198631092729LL,1006422745930050289LL,1006431630344056921LL,1006439820572556049LL,1006448604740012641LL,1006457284610561809LL,1006465884260319289LL,
1006473902072329441LL,1006482108524600761LL,1006491161744989561LL,1006499745487562881LL,1006507606927669729LL,1006515616879845361LL,1006523871658496689LL,1006532868884087689LL,1006541424713075161LL,1006550337742451329LL,
1006559006012384449LL,1006567252942732009LL,1006575279184756009LL,1006583277366765121LL,1006592246765722681LL,1006600273107394681LL,1006608387771355009LL,1006616815498520209LL,1006624994440806841LL,1006633181442809881LL,
1006641428677017961LL,1006649073953502841LL,1006657859034087649LL,1006666158542416849LL,1006674827311050769LL,1006683311503160281LL,1006691137539880081LL,1006699304743971721LL,1006707937534779769LL,1006716385745720329LL,
1006724131642483489LL,1006731885595928209LL,1006740201463242481LL,1006748754159902209LL,1006756640653352689LL,1006765249608947929LL,1006774215805094881LL,1006782937215033169LL,1006790928194898961LL,1006798879070729761LL,
1006806966440039521LL,1006814804998214689LL,1006823113180743049LL,1006831180579189729LL,1006839408556171129LL,1006847315473045489LL,1006854724723837081LL,1006862960824425769LL,1006871530097393689LL,1006879987022205409LL,
1006888809234111049LL,1006896892950835441LL,1006905245623702489LL,1006914011753004601LL,1006922517022073521LL,1006931267171203201LL,1006939495557135001LL,1006947426950225401LL,1006956229388135569LL,1006964469917773249LL,
1006972979413867489LL,1006981256137486249LL,1006990548425920969LL,1006998869375448889LL,1007006732764557001LL,1007015366873411809LL,1007024691431427601LL,1007032880058657841LL,1007041775193413521LL,1007050630226689129LL,
1007058385437402169LL,1007067509489066089LL,1007076336536588761LL,1007084862561920041LL,1007092874810709241LL,1007100883077193921LL,1007109035886457729LL,1007117052245615089LL,1007125100750475529LL,1007133370070760409LL,
1007141298213104209LL,1007149495342961161LL,1007157556020325609LL,1007165945903036929LL,1007174147147519569LL,1007181714159931489LL,1007190621995054641LL,1007199509797703401LL,1007208024301246681LL,1007216851964559721LL,
1007225587334776681LL,1007233439565701209LL,1007241918082538329LL,1007249938985006929LL,1007257305557700649LL,1007265667754335081LL,1007273925608119129LL,1007281830216444721LL,1007290634115857809LL,1007299052654837881LL,
1007307684002190481LL,1007315753341766521LL,1007323666143453409LL,1007331747590954041LL,1007340106081935649LL,1007348536871656849LL,1007356261111874881LL,1007365426659865849LL,1007373419951043721LL,1007381272758190201LL,
1007389185817210849LL,1007396886124673641LL,1007404979910226921LL,1007413382867823409LL,1007421320141847601LL,1007428984438649161LL,1007437319243956441LL,1007445184344744721LL,1007453659737847921LL,1007461753751467249LL,
1007469791588834809LL,1007477500234213369LL,1007485638507977281LL,1007493648335908561LL,1007501698345433281LL,1007510033451528049LL,1007518737972924241LL,1007526422715408649LL,1007535135337687009LL,1007543916253646641LL,
1007552384031889921LL,1007560691241993529LL,1007568488567506321LL,1007576281908066049LL,1007585046942758881LL,1007592675725927281LL,1007600332644178729LL,1007608358988774841LL,1007616774840152569LL,1007625222848447641LL,
1007633048530314361LL,1007641376149215889LL,1007650201696102969LL,1007658926899421281LL,1007667876997664689LL,1007676212791131361LL,1007684223376588081LL,1007692133610012601LL,1007700614057183929LL,1007709094540039609LL,
1007717711582370721LL,1007726501324737489LL,1007734198905841801LL,1007742486788160841LL,1007751344901612481LL,1007759339723741929LL,1007767820453701609LL,1007775618580638961LL,1007784316218159769LL,1007792576197680529LL,
1007800326233552569LL,1007808807135969721LL,1007817492869892769LL,1007826455719171201LL,1007835125466586561LL,1007843100542759881LL,1007850894945279529LL,1007858813864228089LL,1007867716661674801LL,1007875908715713361LL,
1007883891984718849LL,1007892590089454521LL,1007901071380074169LL,1007910122948347441LL,1007918098321245049LL,1007926623893229121LL,1007935193675499049LL,1007943699240504049LL,1007952923682776569LL,1007960561890256881LL,
1007969537423413321LL,1007977264044142681LL,1007985440479617961LL,1007993468357910841LL,1008001046479457809LL,1008009552322310521LL,1008018022057014049LL,1008025853280078649LL,1008034359227594449LL,1008042692520703849LL,
1008051033880397809LL,1008059391338948881LL,1008068274941717089LL,1008076849342271809LL,1008084572358154201LL,1008093142811865889LL,1008102022547179921LL,1008110681431216801LL,1008119127493541449LL,1008127007303988961LL,
1008136489624360009LL,1008145686834963889LL,1008154542704034049LL,1008162410604013921LL,1008171748503708721LL,1008179154593400001LL,1008187745530867729LL,1008195485036963161LL,1008204401370380041LL,1008212414054991721LL,
1008221073413107129LL,1008229809120499729LL,1008238103057023609LL,1008246063661597489LL,1008253875688060849LL,1008262093410257401LL,1008270696750609889LL,1008278757896937409LL,1008286650380839729LL,1008294261736813489LL,
1008302326993911889LL,1008310709593617049LL,1008319096244770489LL,1008326956753593409LL,1008335162723698489LL,1008344015408282281LL,1008351884047573081LL,1008360045935570329LL,1008368862579058369LL,1008377157087504649LL,
1008385664517078241LL,1008394228217085649LL,1008403157479598521LL,1008411773472132241LL,1008419887400852161LL,1008428190152794009LL,1008436685747127289LL,1008444759607531009LL,1008453528418901161LL,1008461276978862529LL,
1008469652205454609LL,1008478176092879881LL,1008486402762972169LL,1008494456737633009LL,1008502972695945169LL,1008510930329109601LL,1008519329863898161LL,1008527315680724449LL,1008535016319750481LL,1008543054420328249LL,
1008551325542766721LL,1008559251230037049LL,1008567618829256929LL,1008575966377611241LL,1008584004641374561LL,1008591934474194841LL,1008599804080745809LL,1008608143727932801LL,1008616459306422121LL,1008624128148079249LL,
1008632202758807929LL,1008640466212305481LL,1008648034713754681LL,1008656916892595161LL,1008664706406814081LL,1008672945889606321LL,1008681647398462249LL,1008690252528618529LL,1008699536629441801LL,1008708093627362881LL,
1008716706905116609LL,1008724830095349481LL,1008733547897712961LL,1008742920581630809LL,1008750987632917369LL,1008758661003467089LL,1008767194147188961LL,1008775401908465689LL,1008783215985348049LL,1008792544706995801LL,
1008800451254204569LL,1008808454254274041LL,1008817610335958641LL,1008826545490394929LL,1008834970445188441LL,1008843118217477929LL,1008851864654624761LL,1008860362033408921LL,1008868959890445481LL,1008876706028531209LL,
1008884142831198001LL,1008893186759436001LL,1008901174056288529LL,1008909081029183569LL,1008916871517028681LL,1008925489703914561LL,1008934248551610481LL,1008942203868244801LL,1008950163234102769LL,1008958138702860889LL,
1008966146346278761LL,1008974579919789289LL,1008982824686039641LL,1008990719925060601LL,1008999073242112681LL,1009006787735903401LL,1009015301839066369LL,1009023691419934369LL,1009031140818387241LL,1009039779583497841LL,
1009048771974554809LL,1009057282236775489LL,1009065651901714801LL,1009074511810486081LL,1009082523933814009LL,1009090913794139929LL,1009099592996697049LL,1009108059273301849LL,1009116425130632641LL,1009124224455373009LL,
1009133020329689161LL,1009141301907424009LL,1009148992835374561LL,1009157013290933329LL,1009165544101037761LL,1009174058873974249LL,1009181532937396729LL,1009190196456298921LL,1009198108580029729LL,1009206085028695009LL,
1009214704450723369LL,1009223348019985921LL,1009231991626262881LL,1009239385535483041LL,1009247185335380209LL,1009255174033391041LL,1009263178836953569LL,1009271898965314009LL,1009279815427831249LL,1009288109663489041LL,
1009296934381870369LL,1009305590358964441LL,1009314431228109241LL,1009323171670894441LL,1009331032073830489LL,1009339121569546681LL,1009347484365962641LL,1009355658319629721LL,1009363920717444601LL,1009372118849867161LL,
1009380594307063801LL,1009388679982657129LL,1009397690003252449LL,1009405305551572609LL,1009414195082837041LL,1009422284911809409LL,1009430471224797241LL,1009438870569139201LL,1009447591456461481LL,1009456473136186321LL,
1009464374247007849LL,1009473183660332329LL,1009481454576988849LL,1009489098573822409LL,1009497080191307761LL,1009504350483637969LL,1009512537129390121LL,1009520908682177329LL,1009529187832370209LL,1009538089966206529LL,
1009546361148756649LL,1009554411316690801LL,1009562107837763041LL,1009570411271463721LL,1009578369095728441LL,1009586748959727481LL,1009594927901292121LL,1009603307834012761LL,1009611780242593609LL,1009620031631041009LL,
1009628431763998489LL,1009636610874403009LL,1009644564940325521LL,1009653391216900609LL,1009661136346567849LL,1009669621055666041LL,1009678439403139489LL,1009686699102632329LL,1009695827014215961LL,1009704625379316409LL,
1009713130368039241LL,1009721691664129921LL,1009730060064682009LL,1009738593296535001LL,1009746616094743081LL,1009755093124072681LL,1009763373234489241LL,1009771167019921849LL,1009779435137708041LL,1009787638976901409LL,
1009795895103492121LL,1009804328124502849LL,1009812660691288609LL,1009821222409323769LL,1009829169163189489LL,1009836971241789601LL,1009844628643447081LL,1009853467853427649LL,1009861881016458649LL,1009870865010895969LL,
1009879366680016849LL,1009887084538292689LL,1009895614413883129LL,1009904369432040289LL,1009912951637728009LL,1009921224355760161LL,1009929364453951561LL,1009937540763381169LL,1009945805542438801LL,1009954464301518649LL,
1009963034660427241LL,1009971166887329089LL,1009979375525244601LL,1009987901770660849LL,1009996576789967881LL,1010005243806609241LL,1010013456602982049LL,1010022067412128681LL,1010030207916713281LL,1010038328353970161LL,
1010047047810318961LL,1010055357258100609LL,1010064048647408329LL,1010072719973635081LL,1010081318975064361LL,1010089415497010209LL,1010097206520461929LL,1010106151359979129LL,1010114063053287481LL,1010122686351862801LL,
1010130710675813281LL,1010139631542306841LL,1010147800662354649LL,1010155949714131609LL,1010164420420948321LL,1010172477073010161LL,1010180111624745889LL,1010187818571162001LL,1010196200964099241LL,1010205303035910601LL,
1010213773949651569LL,1010221392575876209LL,1010229224312356801LL,1010238266226573409LL,1010246628726606049LL,1010255928028103689LL,1010264366990284561LL,1010272452184348609LL,1010280967605220921LL,1010289929340449209LL,
1010298175458538201LL,1010306887995294289LL,1010315001503544361LL,1010323545247893361LL,1010331140164376209LL,1010339390471272801LL,1010347596584793289LL,1010356836041076241LL,1010365203052516081LL,1010372999160188161LL,
1010381366238552961LL,1010390006760933241LL,1010397630072407641LL,1010406214373708881LL,1010414481070225009LL,1010422731717392449LL,1010431243750772281LL,1010439964902932041LL,1010448207612459841LL,1010456036207222929LL,
1010464090001228041LL,1010472147848218969LL,1010480290166361169LL,1010488545103131649LL,1010497021225266481LL,1010505360670447849LL,1010513233717294129LL,1010521066584939361LL,1010529124659103729LL,1010537375774324161LL,
1010545791785710489LL,1010553311137519249LL,1010560983317824129LL,1010569085783046409LL,1010577522031972801LL,1010586062865135409LL,1010594660030257129LL,1010602694270942161LL,1010610957750007441LL,1010618899568294041LL,
1010626668506299849LL,1010635354310853769LL,1010643806921305489LL,1010652159035904841LL,1010660603674101241LL,1010668803049422001LL,1010676741073694809LL,1010684610766828321LL,1010692267360222561LL,1010700627717749929LL

};

struct node
{
	LL x;int y;
	bool operator < (const node& B) const {return x<B.x;}
};

struct Heap
{
	node S[30];int n;

	void Up(int x)
	{
		while (x!=1&&S[x]<S[x>>1]) swap(S[x],S[x>>1]),x>>=1;
	}
	void Down(int x)
	{
		for (;;)
		{
			int t=x;
			if (x<<1<=n&&S[x<<1]<S[t]) t=x<<1;
			if ((x<<1|1)<=n&&S[x<<1|1]<S[t]) t=x<<1|1;
			if (x==t) return;swap(S[x],S[t]),x=t;
		}
	}
	node top() {return S[1];}
	void pop() {S[1]=S[n--];Down(1);}
	void push(node x) {S[++n]=x;Up(n);}
} Q;

int Sqrt(LL x)
{
	int L=1,R=int(sqrt(x)+3),res;
	while (L<=R)
		if (1LL*Mid*Mid<=x) res=Mid,L=Mid+1;else R=Mid-1;
	return res;
}
int Sqrt3(LL x)
{
	int L=1,R=int(pow(x,1.0/3))+3,res;
	while (L<=R)
		if (1LL*Mid*Mid*Mid<=x) res=Mid,L=Mid+1;else R=Mid-1;
	return res;
}
LL Pow(LL a,int b)
{
	LL res=1;
	for (;b;b>>=1,a=a*a) if (b&1) res=res*a;
	return res;
}
int Pow(int a,int b,int P)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
bool Work(int a,int n,int x)
{
	int tmp=Pow(a,x,n),res;
	while (x!=n-1)
	{
		res=1LL*tmp*tmp%n;
		if (res==1&&tmp!=1&&tmp!=n-1) return 0;
		x<<=1,tmp=res;
	}
	return res==1;
}
bool Miller_Rabin(int n)
{
	int x;
	for (x=n-1;!(x&1);x>>=1);
	if (n!=2&&!Work(2,n,x)) return 0;
	if (n!=7&&!Work(7,n,x)) return 0;
	if (n!=61&&!Work(61,n,x)) return 0;
	return 1;
}
LL Work(LL &n,int &k)
{
	while (Q.n) Q.pop();
	For(i,3,63)
		if (f[i]==i)
		{
			Top[i]=floor(pow(1ull<<63,1.0/i));
			t[i]=lower_bound(p+1,p+*p+1,(i==3?Sqrt3(n):floor(pow(n,1.0/i)))+1)-p;
			if (p[t[i]]>Top[i]) continue;
			Q.push((node){Pow(p[t[i]],i),i});
		}
	if (n<4) if (--k==0) return 4;
	cur=Sqrt(n)+1;cur+=!(cur&1);
	for (;!Miller_Rabin(cur);cur+=2);
	while (k-->1)
		if (1LL*cur*cur<Q.top().x)
			for (cur+=2;!Miller_Rabin(cur);cur+=2);
		else
		{
			int e=Q.top().y;Q.pop();
			if (p[++t[e]]<=Top[e]) Q.push((node){Pow(p[t[e]],e),e});
		}
	return min(1LL*cur*cur,Q.top().x);
}

int main()
{
	cin>>n>>k;
	For(i,2,top+1)
	{
		if (!f[i]) f[i]=i,p[++*p]=i;
		for (int j=1;j<=*p&&p[j]<=f[i]&&p[j]*i<=top;j++) f[p[j]*i]=p[j];
	}

	if (n>List[1]&&k>200)
	{
		LL Fir=upper_bound(List,List+2500,n)-List;
		For(i,3,63)
			if (f[i]==i)
			{
				Top[i]=floor(pow(1ull<<63,1.0/i));
				t[i]=lower_bound(p+1,p+*p+1,floor(pow(n,1.0/i))+1)-p;
				if (p[t[i]]>Top[i]) continue;
				Q.push((node){Pow(p[t[i]],i),i});
			}
		cur=Sqrt(n)+1;cur+=!(cur&1);
		for (;!Miller_Rabin(cur);cur+=2);
		while (k--)
		{
			if (min(1LL*cur*cur,Q.top().x)==List[Fir]) break;
			if (1LL*cur*cur<Q.top().x)
				for (cur+=2;!Miller_Rabin(cur);cur+=2);
			else
			{
				int e=Q.top().y;Q.pop();
				if (p[++t[e]]<=Top[e]) Q.push((node){Pow(p[t[e]],e),e});
			}
		}
		if (k==0) return printf("%lld\n",min(1LL*cur*cur,Q.top().x)),0;
		while (Fir+1<2500&&k>200) k-=200,Fir++;
		n=List[Fir];
	}

	cout<<Work(n,k)<<endl;
}
Problem3070
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x,_=y;i<_;i++)
#define Mid (L+R>>1)
using namespace std;

const int top=1e6+10000,N=top+19;
typedef long long LL;
int f[N],p[N],Top[N],t[70],k,cur,x,tmp;
LL n;

LL List[]=
{
	980041252300368241LL,980081572226620249LL,980123330478839089LL,980164036225940281LL,980204604210903241LL,
	980244915616336969LL,980284400132638129LL,980326004287254769LL,980367054849107689LL,980408011215491401LL,
	980448148571617489LL,980490037416786961LL,980531622169613089LL,980572883005917601LL,980613506983231969LL,
	980655375593885209LL,980694804996730321LL,980735340389963929LL,980776696623673849LL,980818945055863369LL,
	980860077244742809LL,980901970926932209LL,980941785610052809LL,980983914782435041LL,981023295323372401LL,
	981064931002353961LL,981106004956250209LL,981148545752948329LL,981187462058963041LL,981229533110074249LL,
	981270170687090761LL,981311993877101041LL,981353001676921129LL,981393055343982649LL,981435019847004529LL,
	981476684075892601LL,981515313637415209LL,981554415548586961LL,981595999088241289LL,981637956040626481LL,
	981679525497061561LL,981719851366137361LL,981761323472657809LL,981802847979841801LL,981843120892480729LL,
	981883331213469169LL,981924109164463921LL,981965906650241041LL,982007605929294961LL,982048493486992801LL,
	982088545488493249LL,982129942135744249LL,982169861015997889LL,982211655803314561LL,982251473271204049LL,
	982291798992535201LL,982334119689545401LL,982374415390584841LL,982414850681654329LL,982454291651552329LL,
	982495545342611689LL,982536696811871881LL,982576818242516641LL,982618570141473721LL,982658197598045329LL,
	982699364369187481LL,982739980821710329LL,982779678138297601LL,982821993481711681LL,982863175580382721LL,
	982903743864430441LL,982944424026478369LL,982984894841666809LL,983023324049756929LL,983063185727894041LL,
	983104043696057089LL,983146675381575961LL,983189589594207241LL,983231548859748241LL,983271934358080249LL,
	983313772419560521LL,983355916797155521LL,983398196944223449LL,983438109856239361LL,983479166022242761LL,
	983521774105115569LL,983562316308892609LL,983603343330877369LL,983646235771726921LL,983686260832348921LL,
	983727905374119889LL,983768404217298001LL,983810621816142961LL,983852165833327729LL,983892631525331641LL,
	983935046208870001LL,983975787384958369LL,984017223787874929LL,984058744391017201LL,984101198367525001LL,
	984142038219084889LL,984183454312882849LL,984224418889207609LL,984266003389479721LL,984306493464995089LL,
	984346524019196881LL,984385944215334049LL,984427067786046361LL,984468656567115721LL,984509920776921289LL,
	984551094564921361LL,984592900295303209LL,984632781876209449LL,984673922510161129LL,984714933016273369LL,
	984756285744370129LL,984797623462829401LL,984839124800953321LL,984880253866836889LL,984921352033697521LL,
	984960930621016441LL,985001919314171641LL,985045378184997529LL,985086444066374521LL,985128165877540441LL,
	985167446882904289LL,985208134159239169LL,985249953836661241LL,985291123243912489LL,985331642340180529LL,
	985373047721733889LL,985416077999100049LL,985457068219821409LL,985498619188654561LL,985538070388775401LL,
	985579349062507081LL,985620501524303089LL,985661289493048081LL,985701712946063689LL,985741148354130529LL,
	985783884836517001LL,985824870791605321LL,985864789230232081LL,985905443243410369LL,985946384063892241LL,
	985987730865784201LL,986030329702378801LL,986069163961083409LL,986111836055026321LL,986153405603297147LL,
	986193822451180561LL,986233525906082281LL,986275712943994201LL,986316089406063529LL,986357006970875929LL,
	986398171691991601LL,986437334988897289LL,986479109234603209LL,986521106850060721LL,986561528065093369LL,
	986601302490807481LL,986643604670218609LL,986685272031386929LL,986726078052311689LL,986767548482551081LL,
	986808554881229161LL,986849633656945249LL,986890653682232209LL,986932270626733201LL,986974114958872681LL,
	987015769428608929LL,987056840594919649LL,987098349768102289LL,987139231891123249LL,987181024970485921LL,
	987221666369464681LL,987262221167268601LL,987303297460814161LL,987345352362705961LL,987387026589597001LL,
	987427771598164009LL,987468370377653761LL,987509868328266721LL,987551430751225729LL,987592572687347929LL,
	987633775108308409LL,987675189078243121LL,987717347308410601LL,987758138886168841LL,987800294911082041LL,
	987841358542955569LL,987883234069461409LL,987922331417438041LL,987962208805820161LL,988003808578213249LL,
	988047071203013761LL,988087901397575449LL,988129153911578449LL,988170176663035081LL,988211128691671921LL,
	988252709845654009LL,988293011435508529LL,988336006005904609LL,988375895718979681LL,988417834271586601LL,
	988458334093831561LL,988499900563622329LL,988540931010157849LL,988580582255566609LL,988621149046724209LL,
	988661939396706481LL,988703359008195769LL,988743319772544361LL,988784760976211761LL,988826926969768441LL,
	988868194907827441LL,988909543262154721LL,988951461312189769LL,988992119248527241LL,989032754152585081LL,
	989074145728040761LL,989113982705157409LL,989154882677150281LL,989195409531479089LL,989237122783624009LL,
	989279015947753969LL,989319656745213049LL,989362076840911489LL,989402719344439009LL,989443541730126289LL,
	989486107722680569LL,989527337686512769LL,989567613529757161LL,989609338607956609LL,989650797956187481LL,
	989691907991755609LL,989732776136978449LL,989774055013984321LL,989814733835514889LL,989856671065637281LL,
	989897924667971881LL,989938502559380089LL,989980518029656609LL,990021853812499561LL,990064328760576169LL,
	990104245375712041LL,990144341906280961LL,990184104901842601LL,990223976166600289LL,990265086163768321LL,
	990305273523370561LL,990346206078991609LL,990386741407788169LL,990428965429662529LL,990471484937986921LL,
	990513209162580601LL,990555001944092209LL,990595310639183209LL,990636754804472689LL,990677184602216329LL,
	990719128154470009LL,990760240465621201LL,990802225591659121LL,990842419867241041LL,990885577362575449LL,
	990926577654608401LL,990967933183480729LL,991008835629867289LL,991050774256039561LL,991090977554883529LL,
	991131834753817849LL,991173298105535689LL,991216188020937649LL,991256920361412769LL,991298589439964521LL,
	991339753598732521LL,991381870483555321LL,991422673935814201LL,991462952486294929LL,991504522337726401LL,
	991545479670030289LL,991586119197293929LL,991626309453748609LL,991667703481068769LL,991708879286247721LL,
	991750721185178761LL,991791062168507329LL,991832029402184881LL,991874479423676209LL,991917017997195481LL,
	991957517733950881LL,991998548164755121LL,992040408126136009LL,992079133460446249LL,992120305853674321LL,
	992161307776681249LL,992202557578135201LL,992244274418638921LL,992284641376792201LL,992325009156042769LL,
	992366067109869841LL,992407588148226721LL,992450899262453401LL,992491449746299801LL,992533467552348121LL,
	992573218713936721LL,992615158546743169LL,992656130841047401LL,992697223541970241LL,992738257311675169LL,
	992779319828168161LL,992819251279566649LL,992861232181153729LL,992904254259447721LL,992944096548434809LL,
	992984585359682161LL,993027119828666521LL,993067124027066089LL,993108619867012609LL,993149219661850729LL,
	993191406857032321LL,993233240154709129LL,993273507628704241LL,993314888182081921LL,993356771920468201LL,
	993397651874702881LL,993438716065453681LL,993478401624773689LL,993519810368020321LL,993560621909062321LL,
	993602797905135289LL,993643120716819049LL,993684508968586009LL,993724279185554401LL,993768145373915209LL,
	993810002778638809LL,993852319648659241LL,993893066238608449LL,993934112752528249LL,993975363498563161LL,
	994015534348738729LL,994057169641560649LL,994098534610099801LL,994139417859552409LL,994180457495076289LL,
	994222909881067441LL,994264633275445249LL,994305934754103409LL,994346295762677881LL,994388109498671449LL,
	994428863081512681LL,994470403317614161LL,994511892564213241LL,994554136614769201LL,994596644848283569LL,
	994636888089595921LL,994677199963832401LL,994719196191346609LL,994760961913915681LL,994802736492468289LL,
	994843761889265401LL,994883299953380161LL,994925918956431289LL,994967166338807281LL,995008378666138489LL,
	995049795341417929LL,995089261686308881LL,995130548366663809LL,995171189469824929LL,995213196124290529LL,
	995255267513284969LL,995295923134845721LL,995337585233912761LL,995378565787172449LL,995420081955152569LL,
	995461255770434209LL,995502693842908969LL,995543801518364569LL,995584151722274689LL,995624299190682001LL,
	995666459094589129LL,995707889463579769LL,995747125376462209LL,995788489567032529LL,995829235910928721LL,
	995869975104988201LL,995910862829435569LL,995952501869691601LL,995994117828512401LL,996035243633016409LL,
	996077915247294961LL,996119709484404961LL,996161584444628809LL,996202749637985761LL,996244550486419081LL,
	996285797245251241LL,996326857203504121LL,996368241418935961LL,996409462788515689LL,996449578979150521LL,
	996491948015491489LL,996531694512164281LL,996573382467018841LL,996613833394641361LL,996655455181310929LL,
	996697608957858721LL,996736968195856801LL,996776883314153881LL,996817442205947209LL,996859635351387889LL,
	996900112057015609LL,996941084825135641LL,996983260617421081LL,997024398850010281LL,997064463511509409LL,
	997106094706896001LL,997146919924698481LL,997188824458856929LL,997229160052277161LL,997271002401815761LL,
	997311846973890361LL,997351617807854761LL,997393394815047409LL,997432947557491201LL,997475792918935801LL,
	997516589749095529LL,997557890797683601LL,997599404446638361LL,997641286525082809LL,997682877821148289LL,
	997723355254938841LL,997764285004221289LL,997805399390997409LL,997848376617584881LL,997888869395791129LL,
	997930010324451961LL,997969805469765769LL,998011943075997529LL,998054505159114841LL,998096844363024961LL,
	998138221362530329LL,998179507303456921LL,998221269674637121LL,998262161677274209LL,998305552396941889LL,
	998346258281347369LL,998388032134203481LL,998428695734693521LL,998469927728478241LL,998512067897643049LL,
	998552885913944761LL,998594975870212081LL,998636323220849041LL,998676696073220641LL,998719472200539961LL,
	998760090582301609LL,998799622442936161LL,998842269279215089LL,998884157449937929LL,998924695225613209LL,
	998966233306578289LL,999008603838464041LL,999051171175873729LL,999092879810117569LL,999136648424469361LL,
	999178222898806729LL,999218654684781001LL,999259811020646569LL,999302047826827369LL,999344885328967321LL,
	999385252507671241LL,999427639922460841LL,999469732314598561LL,999512121520872961LL,999555031510255081LL,
	999596806649414689LL,999638550667309081LL,999679807634891881LL,999722245289598769LL,999761768190289129LL,
	999803923612429849LL,999845387976681481LL,999885637269895489LL,999927223324159321LL,999968926241398369LL,
	1000010634028270489LL,1000053186707187649LL,1000094408228123209LL,1000135390582342249LL,1000175969740656361LL,
	1000217817859863409LL,1000259890883623969LL,1000300360550728561LL,1000343303459259769LL,1000385075063565361LL,
	1000425991357498729LL,1000467448614287809LL,1000509742942915921LL,1000549333421087641LL,1000590561164886169LL,
	1000632217893291481LL,1000674687762520369LL,1000716926449843201LL,1000756937184289609LL,1000799221625019961LL,
	1000840190405880049LL,1000882808751868249LL,1000924839733309969LL,1000966667498669089LL,1001008932357826921LL,
	1001050569779371609LL,1001092900444782601LL,1001135548184517769LL,1001175751394816209LL,1001218376884654009LL,
	1001258813903965681LL,1001298943539846121LL,1001340410874540361LL,1001382043181153089LL,1001424248760320641LL,
	1001467155742089481LL,1001507713872266329LL,1001548004616332209LL,1001588476313729929LL,1001630245884373681LL,
	1001671956275825641LL,1001713499391842689LL,1001755555818476449LL,1001797380919534369LL,1001839767408530521LL,
	1001880557293586569LL,1001921828469965209LL,1001962688092224769LL,1002003456455505529LL,1002044950387934209LL,
	1002085648349682961LL,1002126142921125049LL,1002166826514311929LL,1002208560089676241LL,1002251243600250121LL,
	1002291829618177081LL,1002330918714777961LL,1002372271251397489LL,1002414193326164161LL,1002456144311927761LL,
	1002497082912504169LL,1002538751272382041LL,1002581730185141089LL,1002623400304127281LL,1002665035241120161LL,
	1002706875318465529LL,1002748031329463329LL,1002790097450681929LL,1002832737263744689LL,1002872646065995849LL,
	1002914418369910201LL,1002955806976636969LL,1002997064239702921LL,1003037637313122889LL,1003078459588574209LL,
	1003120396427994289LL,1003160274896789881LL,1003203094854471289LL,1003244144859736081LL,1003285476164414881LL,
	1003326960573085801LL,1003368558027876769LL,1003408084822923649LL,1003451378875985209LL,1003492782567827161LL,
	1003534323353953609LL,1003576630364784961LL,1003618345197236521LL,1003659624099515881LL,1003702422653949001LL,
	1003743214372679881LL,1003784588016717049LL,1003826619767259289LL,1003869037139887801LL,1003912293042252169LL,
	1003952131137929689LL,1003992815707147561LL,1004035164445833601LL,1004077650354636001LL,1004119912701349921LL,
	1004160400254397681LL,1004201177228001769LL,1004242905038308849LL,1004284393201968649LL,1004325930326318161LL,
	1004368177854160681LL,1004408686447282561LL,1004450799413339041LL,1004492809028868769LL,1004533243963155481LL,
	1004576907069077281LL,1004619264115194841LL,1004658715304875801LL,1004699249803490641LL,1004741340794129689LL,
	1004784543313599889LL,1004827534250761321LL,1004868998401360849LL,1004910836319712921LL,1004951219518337809LL,
	1004992361412983329LL,1005033123194640409LL,1005074840215255681LL,1005117729086248801LL,1005158361070194769LL,
	1005199659599338681LL,1005240774495343369LL,1005284858041268809LL,1005328798170617881LL,1005369486559960201LL,
	1005409915070313481LL,1005449337661415089LL,1005490738430875321LL,1005532083897999529LL,1005572876679109489LL,
	1005615764141210401LL,1005658688619574609LL,1005700462746284761LL,1005740990174433769LL,1005782112128098321LL,
	1005823728352923769LL,1005864418733093929LL,1005905013653281921LL,1005946512064384801LL,1005987361394359369LL,
	1006028596709433361LL,1006069403572672321LL,1006111286533878121LL,1006153740111766801LL,1006196294894649769LL,
	1006235524252248889LL,1006277723648870401LL,1006319751387700201LL,1006361386759273801LL,1006402116102794401LL,
	1006445490750269761LL,1006487710601209321LL,1006529722659683401LL,1006572429865173889LL,1006613520654318721LL,
	1006654407604525969LL,1006696186353045049LL,1006737624825006649LL,1006779686247869689LL,1006820395959786409LL,
	1006859505029579881LL,1006902512236793041LL,1006944528937590049LL,1006986899742542161LL,1007029769179195441LL,
	1007072723824877161LL,1007114069690634361LL,1007154509176832641LL,1007195924965629169LL,1007238317117192689LL,
	1007278855446543241LL,1007320570873339321LL,1007362014164502049LL,1007401603480852441LL,1007441847996556729LL,
	1007482591168268329LL,1007523483719524249LL,1007565557540473801LL,1007605644723593161LL,1007647009557985729LL,
	1007689089973375489LL,1007731203390869281LL,1007772570802410169LL,1007814368731975561LL,1007855581238891449LL,
	1007897770418972161LL,1007940422304694321LL,1007982601212656689LL,1008022913555854249LL,1008064491775174201LL,
	1008107179317795649LL,1008150658968909481LL,1008192312117015601LL,1008235150974011689LL,1008275753539681201LL,
	1008315770499622729LL,1008356800456465849LL,1008400169004072601LL,1008441646548074209LL,1008483643129176769LL,
	1008524375225378449LL,1008564437289601921LL,1008604978193052529LL,1008645086047924081LL,1008686950275450889LL,
	1008730157190381649LL,1008772280303692969LL,1008814299839145361LL,1008857180032055929LL,1008898140647573089LL,
	1008939146290817641LL,1008979851423371881LL,1009020593539029241LL,1009062614227661569LL,1009105154134992121LL,
	1009145870652625729LL,1009186796944912609LL,1009228495602529801LL,1009269001628163721LL,1009311292715129881LL,
	1009352680489018849LL,1009393683312054769LL,1009435832333371921LL,1009478259539570209LL,1009517661335448721LL,
	1009559415056818921LL,1009600269350791561LL,1009641261125410489LL,1009683564030233689LL,1009726804342766689LL,
	1009768031816389609LL,1009809284249084929LL,1009850537524413601LL,1009892366464548121LL,1009934433440313481LL,
	1009975769669907049LL,1010019128798532241LL,1010060864748372649LL,1010102790507767401LL,1010144516125372681LL,
	1010184980224408921LL,1010226204989409409LL,1010269493104100161LL,1010311664427326881LL,1010352795281498761LL,
	1010394899990784169LL,1010436410496124921LL,1010477085506861449LL,1010518207665150409LL,1010558389731600889LL,
	1010599702537946161LL,1010640396920066641LL,1010681908446672289LL,1010722612526634121LL,1010764495717001281LL,
	1010805297977225689LL,1010845127825859481LL,1010886181059719449LL,1010928916238252881LL,1010970220530082201LL,
	1011013520560205761LL,1011054609389724769LL,1011095992669701481LL,1011136777486926841LL,1011177900999349561LL,
	1011219415518471721LL,1011260540711311081LL,1011302724668643289LL,1011344008437808081LL,1011386161954319089LL,
	1011427942229712121LL,1011468311339760481LL,1011509972623267441LL,1011552045114556969LL,1011591933927057289LL,
	1011635134619352049LL,1011677185573792609LL,1011717849339943321LL,1011758992713709969LL,1011800647912554361LL,
	1011842798873568841LL,1011884624792907121LL,1011925135800340609LL,1011966480557909809LL,1012008248674246849LL,
	1012051409966660281LL,1012093803573355441LL,1012136121608157121LL,1012178710154639329LL,1012220233139782969LL,
	1012262960287163209LL,1012304344141689769LL,1012346811464054089LL,1012387532957138209LL,1012430517196699969LL,
	1012471984973455561LL,1012512882056734081LL,1012554673522671049LL,1012596417549693001LL,1012637292994818481LL,
	1012679964539040121LL,1012722290800963681LL,1012762746114821881LL,1012805790650905729LL,1012847624391762721LL,
	1012890312444381361LL,1012932828287900881LL,1012973706496470601LL,1013015620198006441LL,1013057768276428681LL
};

struct node
{
	LL x;int y;
	bool operator < (const node& B) const {return x<B.x;}
};

struct Heap
{
	node S[30];int n;

	void Up(int x)
	{
		while (x!=1&&S[x]<S[x>>1]) swap(S[x],S[x>>1]),x>>=1;
	}
	void Down(int x)
	{
		for (;;)
		{
			int t=x;
			if (x<<1<=n&&S[x<<1]<S[t]) t=x<<1;
			if ((x<<1|1)<=n&&S[x<<1|1]<S[t]) t=x<<1|1;
			if (x==t) return;swap(S[x],S[t]),x=t;
		}
	}
	node top() {return S[1];}
	void pop() {S[1]=S[n--];Down(1);}
	void push(node x) {S[++n]=x;Up(n);}
} Q;

int Sqrt(LL x)
{
	int L=1,R=int(sqrt(x)+3),res;
	while (L<=R)
		if (1LL*Mid*Mid<=x) res=Mid,L=Mid+1;else R=Mid-1;
	return res;
}
int Sqrt3(LL x)
{
	int L=1,R=int(pow(x,1.0/3))+3,res;
	while (L<=R)
		if (1LL*Mid*Mid*Mid<=x) res=Mid,L=Mid+1;else R=Mid-1;
	return res;
}
LL Pow(LL a,int b)
{
	LL res=1;
	for (;b;b>>=1,a=a*a) if (b&1) res=res*a;
	return res;
}
int Pow(int a,int b,int P)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
bool Work(int a,int n,int x)
{
	int tmp=Pow(a,x,n),res;
	while (x!=n-1)
	{
		res=1LL*tmp*tmp%n;
		if (res==1&&tmp!=1&&tmp!=n-1) return 0;
		x<<=1,tmp=res;
	}
	return res==1;
}
bool Miller_Rabin(int n)
{
	int x;
	for (x=n-1;!(x&1);x>>=1);
	if (n!=2&&!Work(2,n,x)) return 0;
	if (n!=7&&!Work(7,n,x)) return 0;
	if (n!=61&&!Work(61,n,x)) return 0;
	return 1;
}
LL Work(LL &n,int &k)
{
	while (Q.n) Q.pop();
	For(i,3,63)
		if (f[i]==i)
		{
			Top[i]=floor(pow(1ull<<63,1.0/i));
			t[i]=lower_bound(p+1,p+*p+1,(i==3?Sqrt3(n):floor(pow(n,1.0/i)))+1)-p;
			if (p[t[i]]>Top[i]) continue;
			Q.push((node){Pow(p[t[i]],i),i});
		}
	if (n<4) if (--k==0) return 4;
	cur=Sqrt(n)+1;cur+=!(cur&1);
	for (;!Miller_Rabin(cur);cur+=2);
	while (k-->1)
		if (1LL*cur*cur<Q.top().x)
			for (cur+=2;!Miller_Rabin(cur);cur+=2);
		else
		{
			int e=Q.top().y;Q.pop();
			if (p[++t[e]]<=Top[e]) Q.push((node){Pow(p[t[e]],e),e});
		}
	return min(1LL*cur*cur,Q.top().x);
}

int main()
{

	scanf("%lld%d",&n,&k);
	For(i,2,top+1)
	{
		if (!f[i]) f[i]=i,p[++*p]=i;
		for (int j=1;j<=*p&&p[j]<=f[i]&&p[j]*i<=top;j++) f[p[j]*i]=p[j];
	}

	if (n>List[1]&&k>1000)
	{
		LL Fir=upper_bound(List,List+800,n)-List;
		For(i,3,63)
			if (f[i]==i)
			{
				Top[i]=floor(pow(1ull<<63,1.0/i));
				t[i]=lower_bound(p+1,p+*p+1,floor(pow(n,1.0/i))+1)-p;
				if (p[t[i]]>Top[i]) continue;
				Q.push((node){Pow(p[t[i]],i),i});
			}
		cur=Sqrt(n)+1;cur+=!(cur&1);
		for (;!Miller_Rabin(cur);cur+=2);
		while (k--)
		{
			if (min(1LL*cur*cur,Q.top().x)==List[Fir]) break;
			if (1LL*cur*cur<Q.top().x)
				for (cur+=2;!Miller_Rabin(cur);cur+=2);
			else
			{
				int e=Q.top().y;Q.pop();
				if (p[++t[e]]<=Top[e]) Q.push((node){Pow(p[t[e]],e),e});
			}
		}
		if (k==0) return printf("%lld\n",min(1LL*cur*cur,Q.top().x)),0;
		while (Fir+1<800&&k>1000) k-=1000,Fir++;
		n=List[Fir];
	}

	printf("%lld\n",Work(n,k));
}
Problem3083
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

typedef unsigned int Uint;
const int N=100000+19;
const Uint oo=2147483648U+1;
typedef int one[N];
struct Edge {int y,nxt;} E[N*2];
one Last,Sz,Top,ID,son,D,A,reID;
int Fa[N][20],n,cnt,tot,m,rt,x,y,z;

Uint IN()
{
	int c;Uint x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

//SegTree
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
Uint Min[N*4],Set[N*4],Qv;
int Ql,Qr;

void Build(int x,int L,int R)
{
	if (L==R) {Min[x]=A[reID[L]];return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	Min[x]=min(Min[Lsn],Min[Rsn]);
}
void SetS(int x,Uint v) {Set[x]=Min[x]=v;}
void Down(int x)
{
	if (Set[x]) SetS(Lsn,Set[x]),SetS(Rsn,Set[x]),Set[x]=0;
}
void Modify(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) {SetS(x,Qv);return;}
	Down(x);
	if (Ql<=Mid) Modify(Lsn,L,Mid);
	if (Qr>Mid) Modify(Rsn,Mid+1,R);
	Min[x]=min(Min[Lsn],Min[Rsn]);
}
Uint Qmin(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return Min[x];
	Uint res=oo;
	Down(x);
	if (Ql<=Mid) res=min(res,Qmin(Lsn,L,Mid));
	if (Qr>Mid) res=min(res,Qmin(Rsn,Mid+1,R));
	return res;
}
void Update(int L,int R,Uint v) {Ql=L,Qr=R,Qv=v;if (Ql<=Qr) Modify(1,1,n);}
Uint Query(int L,int R) {return Ql=L,Qr=R,Ql<=Qr?Qmin(1,1,n):oo;}

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}

void DFS(int x)
{
	Sz[x]=1;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x][0])
		{
			Fa[E[i].y][0]=x;D[E[i].y]=D[x]+1;
			DFS(E[i].y);
			Sz[x]+=Sz[E[i].y];if (Sz[E[i].y]>Sz[son[x]]) son[x]=E[i].y;
		}
}
void DFS(int x,int Anc)
{
	ID[x]=++tot;Top[x]=Anc;reID[tot]=x;
	if (son[x]) DFS(son[x],Anc);
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x][0]&&E[i].y!=son[x]) DFS(E[i].y,E[i].y);
}
int Getf(int x,int y)
{
	for (int i=19;~i;i--) if (D[Fa[x][i]]>D[y]) x=Fa[x][i];
	return x;
}
Uint Count(int x)
{
	if (x==rt) return Min[1];
	if (ID[x]<=ID[rt]&&ID[x]+Sz[x]-1>=ID[rt])
	{
		x=Getf(rt,x);
		return min(Query(1,ID[x]-1),Query(ID[x]+Sz[x],n));
	}
	return Query(ID[x],ID[x]+Sz[x]-1);
}
void Change(int x,int y,Uint z)
{
	int a=Top[x],b=Top[y];
	while (a!=b)
	{
		if (D[a]>D[b]) swap(a,b),swap(x,y);
		Update(ID[b],ID[y],z);
		y=Fa[b][0],b=Top[y];
	}
	if (ID[x]>ID[y]) swap(x,y);
	Update(ID[x],ID[y],z);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,n) Link(IN(),IN());
	DFS(1);
	DFS(1,1);
	For(i,1,20) for (x=1;x<=n;x++) Fa[x][i]=Fa[Fa[x][i-1]][i-1];
	For(i,1,n+1) A[i]=IN();
	Build(1,1,n);
	rt=IN();
	while (m--)
	{
		int o=IN();
		if (o==1) rt=IN();
		if (o==2) x=IN(),y=IN(),z=IN(),Change(x,y,z);
		if (o==3) printf("%u\n",Count(IN()));
	}
}
Problem3091
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=50000+19;
typedef long long LL;
struct Edge {int y,nxt;} E[N*2];
int A[N],Last[N],n,Q,cnt,opt,x,y,d;

struct node;node *null;
struct node
{
	node *L,*R,*Fa;
	LL Ai,Lcnt,Rcnt,Exp,Sum;
	int Add,S,rev;

	bool Top() {return Fa==null||Fa->L!=this&&Fa->R!=this;}
	void Setrev() {rev^=1,swap(L,R),swap(Lcnt,Rcnt);}
	void Setadd(int x)
	{
		if (this==null) return;
		Ai+=x,Add+=x,Sum+=1LL*S*x;
		Lcnt+=1LL*x*S*(S+1)/2LL,Rcnt+=1LL*x*S*(S+1)/2LL;
		Exp+=1LL*x*(1LL*S*S*S+3LL*S*S+2LL*S)/6LL;
	}
	void Down()
	{
		if (rev) L->Setrev(),R->Setrev(),rev=0;
		if (Add) L->Setadd(Add),R->Setadd(Add),Add=0;
	}
	void Update()
	{
		if (this==null) return;
		S=L->S+R->S+1,Sum=L->Sum+R->Sum+Ai;
		Lcnt=L->Lcnt+R->Lcnt+1LL*(Ai+R->Sum)*(L->S+1);
		Rcnt=R->Rcnt+L->Rcnt+1LL*(Ai+L->Sum)*(R->S+1);
		Exp=L->Exp+R->Exp
			+1LL*(R->S+1)*L->Lcnt+1LL*(L->S+1)*R->Rcnt
			+1LL*Ai*(L->S+1)*(R->S+1);
	}
	
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (z->L==y) z->L=this;else if (z->R==y) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (z->L==y) z->L=this;else if (z->R==y) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N];

void Splay(node *x)
{
	static node *S[N];
	node *tmp=x;int k=0;
	while (!tmp->Top()) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (!x->Top())
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top())
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}

node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa) Splay(x),x->R=y,x->Update();
	return y;
}
void Evert(node *x) {Access(x)->Setrev();}
node *Root(node *x)
{
	Access(x),Splay(x);
	while (x->L!=null) x=x->L,x->Down();
	return x;
}
void Link(node *x,node *y)
{
	if (Root(x)==Root(y)) return;
	Evert(x),Splay(x),x->Fa=y;
}
void Cut(node *x,node *y)
{
	if (x==y||Root(x)!=Root(y)) return;
	Evert(x),Access(y),Splay(y);
	if (y->L==x&&x->R==null) y->L=null,x->Fa=null,y->Update();
}

LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
void Add_Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x)
{
	for (int i=Last[x];~i;i=E[i].nxt)
		if ((Nd+E[i].y)!=Nd[x].Fa) Nd[E[i].y].Fa=Nd+x,DFS(E[i].y);
}

int main()
{
	memset(Last,-1,sizeof(Last));
	null=Nd;
	read(n),read(Q);
	For(i,1,n+1) read(A[i]);
	For(i,0,n+1) Nd[i]=(node){null,null,null,A[i],A[i],A[i],A[i],A[i],0,1,0};
	null->S=0;
	For(i,1,n) read(x),read(y),Add_Link(x,y);
	DFS(1);
	while (Q--)
	{
		read(opt),read(x),read(y);
		if (opt==3) read(d);
		if (opt==1) Cut(Nd+x,Nd+y);
		if (opt==2) Link(Nd+x,Nd+y);
		if (opt==3)
		{
			if (Root(Nd+x)!=Root(Nd+y)) continue;
			Evert(Nd+x),Access(Nd+y)->Setadd(d);
		}
		if (opt==4)
		{
			if (Root(Nd+x)!=Root(Nd+y)) {puts("-1");continue;}
			Evert(Nd+x);
			node *k=Access(Nd+y);
			LL X=k->Exp,Y=1LL*(k->S)*(k->S-1)/2LL+k->S,t=gcd(X,Y);
			printf("%lld/%lld\n",X/t,Y/t);
		}		
	}
}
Problem3097
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;

string s,t;

int main()
{
	s="a";
	for (int i=0;i<12;i++)
	{
		t=s;
		for (int j=0;j<(1<<i);j++) t[j]=(t[j]=='a'?'b':'a');
		s+=t;
	}
	int L=(1<<11);
	s+="a";for (int i=1;i<L;i++) s+="b";
	s+="b";for (int i=1;i<L;i++) s+="b";
	cout<<s.length()<<" "<<L<<endl<<s<<endl;
}
Problem3098
#include<cstdio>
#include<cstdlib>
using namespace std;

int main()
{
	printf("100000 30\n");
	for (int i=1;i<=100000;i++) putchar(rand()%26+'a');puts("");
}
Problem3107
#include<cstdio>
#include<cstring>
using namespace std;

const int oo=(1<<30)-1;
int F[33][33][33][33][2],n,A,B,C,Sa,Sb,Sc;

inline void Update(int &a,int b) {a=(a!=-1&&a<b)?a:b;}

int main()
{
	scanf("%d%d%d",&A,&B,&C);
	memset(F,255,sizeof(F));
	F[0][0][0][0][0]=0;
	while (A||B||C)
	{
		Sa+=A&1;Sb+=B&1;Sc+=C&1;
		A>>=1;B>>=1;C>>=1;n++;
	}
	for (int i=0;i<=n;i++)
		for (int sa=0;sa<=Sa;sa++)
		for (int sb=0;sb<=Sb;sb++)
		for (int sc=0;sc<=Sc;sc++)
		for (int t=0;t<2;t++)
			if (F[i][sa][sb][sc][t]!=-1)
				for (int ta=0;ta<2;ta++)
				for (int tb=0;tb<2;tb++)
				{
					int tc=(ta+tb+t)&1;
					Update(F[i+1][sa+ta][sb+tb][sc+tc][(ta+tb+t)>>1],
						F[i][sa][sb][sc][t]+(tc<<i));
				}
	printf("%d\n",F[n][Sa][Sb][Sc][0]);
	return 0;
}
Problem3109
#include<cstdio>
#include<cstdlib>
#include<algorithm>

#define ID(x,y) ((x-1)*9+y)
#define IDz(x,y) ((x-1)/3*3+(y-1)/3+1)
using namespace std;

typedef int two[10][10];
char s[20];
int A[82][82],c;
two tmp,Cx,Cy,Cz;
int Dx[2]={-1,0},Dy[2]={0,-1};

int Getc() {while ((c=getchar())!='^'&&c!='v'&&c!='<'&&c!='>');return c;}
void Add_1(int r)
{
	int x=0;
	for (int i=1;i<=9;i++)
		if (i%3!=1) 
			A[ID(r,i)][ID(r,i-1)]=-(A[ID(r,i-1)][ID(r,i)]=(Getc()=='<'?-1:1));
}
void Add_2(int r1,int r2)
{
	int x=0;
	for (int i=1;i<=9;i++)
		A[ID(r1,i)][ID(r2,i)]=-(A[ID(r2,i)][ID(r1,i)]=(Getc()=='v'?-1:1));
}

void DFS(int x,int y)
{
	if (x==10)
	{
		for (int i=1;i<=9;i++)
		{
			for (int j=1;j<9;j++) printf("%d ",tmp[i][j]);
			printf("%d\n",tmp[i][9]);
		}
		exit(0);
	}
	
	int U=9,D=1;
	for (int i=0;i<2;i++)
	{
		int tx=x+Dx[i],ty=y+Dy[i];
		if (tx>=1&&tx<=9&&ty>=1&&ty<=9&&A[ID(x,y)][ID(tx,ty)])
			if (A[ID(x,y)][ID(tx,ty)]==1)
				D=max(D,tmp[tx][ty]+1);else U=min(U,tmp[tx][ty]-1);
	}
	for (int i=D;i<=U;i++)
		if (!Cx[x][i]&&!Cy[y][i]&&!Cz[IDz(x,y)][i])
		{
			tmp[x][y]=i;
			Cx[x][i]=Cy[y][i]=Cz[IDz(x,y)][i]=1;
			if (y==9) DFS(x+1,1);else DFS(x,y+1);
			Cx[x][i]=Cy[y][i]=Cz[IDz(x,y)][i]=0;
		}
	tmp[x][y]=0;
}

int main()
{
	for (int i=1;i<=9;i++) 
	{
		if (i%3!=1) Add_2(i-1,i);
		Add_1(i);
	}
	DFS(1,1);
}
Problem3110
#include<cstdio>
using namespace std;

const int N=50000+19,M=N*16*16;
int Lsn[M],Rsn[M],Root[N<<2],Add[M],sum[M];
int n,m,a,b,c,tot,cnt,_sum,Flag;

inline void count(int x,int L,int R,int add)
{
	if (a<=L&&R<=b) {_sum+=sum[x]+add*(R-L+1);return;}
	int Mid=(L+R)>>1;
	if (a<=Mid) count(Lsn[x],L,Mid,add+Add[x]);
	if (b>=Mid+1) count(Rsn[x],Mid+1,R,add+Add[x]);
}
inline int query()
{
	int L=1,R=n,now=1;
	while (L^R)
	{
		int Mid=(L+R)>>1;_sum=0;
		count(Root[now<<1],1,n,0);
		if (_sum>=c) R=Mid,now=now<<1;else L=Mid+1,now=now<<1|1,c-=_sum;
	}
	return L;
}
inline void Update(int &x,int L,int R)
{
	if (!x) x=++tot;
	if (a<=L&&R<=b) Add[x]++;
		else
		{
			int Mid=(L+R)>>1;
			if (a<=Mid) Update(Lsn[x],L,Mid);
			if (b>=Mid+1) Update(Rsn[x],Mid+1,R);
		}
	sum[x]=sum[Lsn[x]]+sum[Rsn[x]]+Add[x]*(R-L+1);
}
inline void modify()
{
	int L=1,R=n,now=1;
	while (L^R)
	{
		int Mid=(L+R)>>1;
		Update(Root[now],1,n);
		if (c<=Mid) R=Mid,now<<=1;else L=Mid+1,now=now<<1|1;
	}
	Update(Root[now],1,n);
}

int main()
{
	scanf("%d%d",&n,&m);
	while (m--)
	{
		scanf("%d%d%d%d",&Flag,&a,&b,&c);
		if (Flag==1) c=n-c+1,modify();
			else printf("%d\n",n-query()+1);
	}
}
Problem3110
#include<cstdio>
#include<cctype>
using namespace std;

const int N=50000+19,M=N*16*16;
int Lsn[M],Rsn[M],Root[N<<2],Add[M],sum[M];
int cc,n,m,a,b,c,tot,cnt,_sum,Flag;

inline void Read(int &x)
{
	while (!isdigit(cc=getchar()));
	x=cc-'0';
	while (isdigit(cc=getchar())) x=x*10+cc-'0';
}
inline void count(int x,int L,int R,int add)
{
	if (a<=L&&R<=b) {_sum+=sum[x]+add*(R-L+1);return;}
	int Mid=(L+R)>>1;
	if (a<=Mid) count(Lsn[x],L,Mid,add+Add[x]);
	if (b>=Mid+1) count(Rsn[x],Mid+1,R,add+Add[x]);
}
inline int query()
{
	int L=1,R=n,now=1;
	while (L^R)
	{
		int Mid=(L+R)>>1;_sum=0;
		count(Root[now<<1],1,n,0);
		if (_sum>=c) R=Mid,now=now<<1;else L=Mid+1,now=now<<1|1,c-=_sum;
	}
	return L;
}
inline void Update(int &x,int L,int R)
{
	if (!x) x=++tot;
	if (a<=L&&R<=b) Add[x]++;
		else
		{
			int Mid=(L+R)>>1;
			if (a<=Mid) Update(Lsn[x],L,Mid);
			if (b>=Mid+1) Update(Rsn[x],Mid+1,R);
		}
	sum[x]=sum[Lsn[x]]+sum[Rsn[x]]+Add[x]*(R-L+1);
}
inline void modify()
{
	int L=1,R=n,now=1;
	while (L^R)
	{
		int Mid=(L+R)>>1;
		Update(Root[now],1,n);
		if (c<=Mid) R=Mid,now<<=1;else L=Mid+1,now=now<<1|1;
	}
	Update(Root[now],1,n);
}

int main()
{
	scanf("%d%d",&n,&m);
	while (m--)
	{
		Read(Flag);Read(a);Read(b);Read(c);
		if (Flag==1) c=n-c+1,modify();
			else printf("%d\n",n-query()+1);
	}
}
Problem3110
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define mp make_pair
#define pb push_back
#define fir first
#define sec second
#define Mid (L+R>>1)

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=100000+19;

struct QType
{
	int o,id,x,y,k;
} Q[N];
int res[N],id[N],__id[N],vis[N];
int n,m;

int Time;
struct __BIT
{
	struct BIT
	{
		ll C[N];
		int T[N];
		void Add(int x,int v)
		{
			for (;x<=n;x+=x&-x)
			{
				if (T[x]!=Time) T[x]=Time,C[x]=0;
				C[x]+=v;
			}
		}
		ll Query(int x)
		{
			ll res=0;
			for (;x;x-=x&-x) res+=(T[x]==Time?C[x]:0);
			return res;
		}
	} B1,B2;
	void Update(int l,int r)
	{
		B1.Add(l,1);
		B1.Add(r+1,-1);
		B2.Add(l,l);
		B2.Add(r+1,-(r+1));
	}
	ll Query(int l,int r)
	{
		ll res=0;
		res+=(r+1)*B1.Query(r)-B2.Query(r);
		res-=l*B1.Query(l-1)-B2.Query(l-1);
		return res;
	}
} B;

void Work(int l,int r,int L,int R)
{
	if (L==R)
	{
		For(i,l,r+1) if (Q[id[i]].o==2) res[id[i]]=L;
		return;
	}
	Time++;
	For(i,l,r+1)
	{
		int t=id[i];
		if (Q[t].o==1)
			if (Q[t].k<=Mid) vis[t]=1,B.Update(Q[t].x,Q[t].y);else vis[t]=0;
		if (Q[t].o==2)
		{
			ll tmp=B.Query(Q[t].x,Q[t].y);
			if (Q[t].k<=tmp) vis[t]=1;else Q[t].k-=tmp,vis[t]=0;
		}
	}
	int c=l-1,p;
	For(i,l,r+1) if (vis[id[i]]) __id[++c]=id[i];
	p=c;
	For(i,l,r+1) if (!vis[id[i]]) __id[++c]=id[i];
	memcpy(id+l,__id+l,sizeof(int)*(r-l+1));
	if (l<=p) Work(l,p,L,Mid);
	if (p+1<=r) Work(p+1,r,Mid+1,R);
}

int main()
{
	memset(res,-1,sizeof(res));
	n=IN(),m=IN();
	For(i,1,m+1) Q[i]=(QType){IN(),i,IN(),IN(),IN()},id[i]=i;
	For(i,1,m+1) if (Q[i].o==1) Q[i].k=n-Q[i].k+1;
	Work(1,m,1,n);
	For(i,1,m+1) if (~res[i]) printf("%d\n",n-res[i]+1);
}
Problem3111
#include<cstdio>
#include<cstring>
using namespace std;

const int N=100+19,K=20+19,oo=1<<29;
int F[N][K][N],G[N][K][N][2],sum[N][N];
int n,m,kk,Ans=-oo;

int max(int a,int b) {return a>b?a:b;}

int main()
{
	scanf("%d%d%d",&n,&m,&kk);
	kk=kk*2+1;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			scanf("%d",&sum[i][j]);
			sum[i][j]+=sum[i-1][j];
		}
	for (int i=1;i<=n;i++)
		for (int k=1;k<=kk;k++) F[0][k][i]=G[0][k][i][0]=G[0][k][i][1]=-oo;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			for (int k=1;k<=kk;k++)
			{
				for (int h=1;h<=i;h++)
					F[j][k][h]=max(F[j-1][k][h],G[j-1][k-1][h][k&1])+sum[i][j]-sum[h-1][j];
				G[j][k][1][0]=-oo;
				for (int h=2;h<=i;h++) G[j][k][h][0]=max(G[j][k][h-1][0],F[j][k][h-1]);
				G[j][k][i][1]=-oo;
				for (int h=i-1;h>=1;h--) G[j][k][h][1]=max(G[j][k][h+1][1],F[j][k][h+1]);
			}
			Ans=max(Ans,F[j][kk][i]);
			Ans=max(Ans,G[j][kk][i][0]);
		}
	printf("%d\n",Ans);
	return 0;
}
Problem3111
#include<cstdio>
#include<cstring>
using namespace std;

const int N=100+19,K=20+19,oo=1<<29;
int F[N][K][N],G[N][K][N][2],sum[N][N];
int n,m,kk,Ans=-oo;

int max(int a,int b) {return a>b?a:b;}

int main()
{
	scanf("%d%d%d",&n,&m,&kk);
	kk=kk*2+1;
	//共kk个矩形 
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			scanf("%d",&sum[i][j]);
			sum[i][j]+=sum[i-1][j];
		}
	for (int i=1;i<=n;i++)
		for (int k=1;k<=kk;k++) F[0][k][i]=G[0][k][i][0]=G[0][k][i][1]=-oo;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			for (int k=1;k<=kk;k++)
			{
				for (int h=1;h<=i;h++)
					F[j][k][h]=max(F[j-1][k][h],
						G[j-1][k-1][h][k&1])+sum[i][j]-sum[h-1][j];
				//这里的G[j-1][k-1][h][k&1]其实不包括h这一行,保证两个矩形的高不相同 
				//同时又避免了对前一个矩形比当前矩形高还是低的讨论 
				G[j][k][1][0]=-oo;
				for (int h=2;h<=i;h++) G[j][k][h][0]=max(G[j][k][h-1][0],F[j][k][h-1]);
				G[j][k][i][1]=-oo;
				for (int h=i-1;h>=1;h--) G[j][k][h][1]=max(G[j][k][h+1][1],F[j][k][h+1]);
				//仍然要注意G数组中不包括h这一行 
			}
			Ans=max(Ans,max(F[j][kk][i],G[j][kk][i][0]));
			//G[]不包括i这一行,刚好再把这一行的更新 
		}
	printf("%d\n",Ans);
	return 0;
}
Problem3115
#include<string>
#include<vector>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

typedef long long LL;
typedef double Db;

const int N=50000+19;
string A[114]=
{
	"H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Fl","Lv","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr"
},S;
vector<string> V[128];
char s[N];int f[N];

bool Work(int x)
{
	if (~f[x]) return f[x];
	if (x==S.length()) return f[x]=1;
	For(i,0,V[S[x]].size())
		if (V[S[x]][i].length()==1&&Work(x+1)||
			V[S[x]][i].length()==2&&x+1<S.length()&&S[x+1]==V[S[x]][i][1]&&Work(x+2)) return f[x]=1;
	return f[x]=0;
}

int main()
{
	For(i,0,114)
		For(j,0,A[i].length()) if (isupper(A[i][j])) A[i][j]=A[i][j]+'a'-'A';
	For(i,0,114) V[A[i][0]].Pb(A[i]);
	for (int T=IN();T--;)
	{
		memset(f,-1,sizeof(f));
		scanf("%s",s);
		S=string(s);
		For(i,0,S.length()) if (isupper(S[i])) S[i]=S[i]+'a'-'A';
		puts(Work(0)?"YES":"NO");
	}
}
Problem3122
#include<cstdio>
#include<cmath>
#include<cstring>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int Mo=100007;
struct Hash
{
	int A[2*Mo],key[2*Mo],Last[Mo],nxt[2*Mo],cnt;
	void Clear()
	{
		memset(A,-1,sizeof(A));
		memset(nxt,-1,sizeof(nxt));cnt=Mo;
	}
	void Ins(int x,int k)
	{
		int t=x%Mo;
		if (A[t]==-1) A[t]=x,key[t]=k,Last[t]=t;else
			A[cnt]=x,key[cnt]=k,nxt[Last[t]]=cnt,Last[t]=cnt++;
	}
	int Qry(int x)
	{
		for (int i=x%Mo;~i;i=nxt[i]) if (A[i]==x) return key[i];
		return -1;
	}
} H;
int T,Mod,a,b,c,d,X,t;

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%Mod) if (b&1) res=1LL*res*a%Mod;
	return res;
}

int BSGS(int y,int z)
{
	H.Clear();
	int S=sqrt(Mod)+1,t=1,Inv=Pow(Pow(y,S),Mod-2);
	For(i,0,S) {if (H.Qry(t)==-1) H.Ins(t,i);t=1LL*t*y%Mod;}
	For(i,0,S)
		if (~(t=H.Qry(z))) return i*S+t;else z=1LL*z*Inv%Mod;
	return -2;
}
int Calc()
{
	if (X==t) return 1;
	if (a==0) return t==b?2:-1;
	if (a==1)
	{
		t=(t-X+Mod)%Mod;
		if (gcd(b,Mod)!=1) return -1;
		return 1LL*t*Pow(b,Mod-2)%Mod+1;
	}
	c=(1LL*(a-1)*X%Mod+b)%Mod,d=(1LL*(a-1)*t%Mod+b)%Mod;
	if (gcd(c,Mod)!=1) return -1;
	d=1LL*d*Pow(c,Mod-2)%Mod;
	return BSGS(a,d)+1;
}

int main()
{
	for (scanf("%d",&T);T--;)
		scanf("%d%d%d%d%d",&Mod,&a,&b,&X,&t),
		printf("%d\n",Calc());
}
Problem3123
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

typedef long long LL;
typedef double Db;

const int N=80000+19,Len=10000000;
typedef int one[N];
struct Edge {int y,nxt;} E[N*2];
one Last,A,B,D,Pa,S,vis;
int Fa[17][N];
int n,m,Q,cnt,x,y,Ans,k;
char c,Buf[Len],*b=Buf;

int IN()
{
	int c,f,x;
	while (!isdigit(c=*b++)&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=*b++)) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

struct node *null;
struct node
{
	node *L,*R;
	int S;
} Nd[10000000],*cur=Nd,*rt[N];

node *New(node *L,node *R,int S) {return *cur=(node){L,R,S},cur++;}
node *Modify(node *x,int L,int R,int Qx)
{
	if (L==R) return New(0x0,0x0,x->S+1);
	return Qx<=Mid?New(Modify(x->L,L,Mid,Qx),x->R,x->S+1):New(x->L,Modify(x->R,Mid+1,R,Qx),x->S+1);
}

int Getf(int x) {return Pa[x]==x?x:Pa[x]=Getf(Pa[x]);}
void Union(int x,int y)
{
	x=Getf(x),y=Getf(y),Pa[x]=y,S[y]+=S[x];
}
void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x)
{
	vis[x]=1;
	rt[x]=Modify(rt[Fa[0][x]],1,*B,A[x]);
	For(i,1,17) Fa[i][x]=Fa[i-1][Fa[i-1][x]];
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[0][x]) D[E[i].y]=D[x]+1,Fa[0][E[i].y]=x,DFS(E[i].y);
}
int LCA(int x,int y)
{
	if (D[x]>D[y]) swap(x,y);
	for (int k=0,i=D[y]-D[x];i;i>>=1,k++) if (i&1) y=Fa[k][y];
	if (x==y) return x;
	for (int i=16;~i;i--) if (Fa[i][x]!=Fa[i][y]) x=Fa[i][x],y=Fa[i][y];
	return Fa[0][x];
}
int Query(int x,int y,int k)
{
	int L=1,R=*B,z=LCA(x,y),tmp;
	node *T[4]={rt[x],rt[z],rt[y],rt[Fa[0][z]]};
	while (L!=R)
	{
		tmp=0;
		For(i,0,4) i&1?tmp-=T[i]->L->S:tmp+=T[i]->L->S;
		if (k<=tmp) {For(i,0,4) T[i]=T[i]->L;R=Mid;}
			else {k-=tmp;For(i,0,4) T[i]=T[i]->R;L=Mid+1;}
	}
	return B[L];
}

int main()
{
	fread(Buf,1,Len,stdin);
	IN();
	rt[0]=New(Nd,Nd,0);
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN(),Q=IN();
	For(i,1,n+1) A[i]=B[i]=IN();
	sort(B+1,B+n+1);*B=unique(B+1,B+n+1)-B-1;
	For(i,1,n+1) A[i]=lower_bound(B+1,B+*B+1,A[i])-B;
	For(i,1,n+1) Pa[i]=i,S[i]=1;
	For(i,0,m) x=IN(),y=IN(),Link(x,y),Union(x,y);
	For(i,1,n+1) if (!vis[i]) DFS(i);
	while (Q--)
	{
		while (!isalpha(c=*b++));
		if (c=='Q') x=IN()^Ans,y=IN()^Ans,k=IN()^Ans,printf("%d\n",Ans=Query(x,y,k));else
		{
			x=IN()^Ans,y=IN()^Ans;
			if (S[Getf(x)]>S[Getf(y)]) swap(x,y);Union(x,y);
			Fa[0][x]=y,D[x]=D[y]+1,DFS(x),Link(x,y);
		}
	}
}
Problem3131
#include<queue>
#include<cstdio>
#include<algorithm>
#include<functional>

#define Mid (L+R>>1)
using namespace std;

const int N=15000+19,Mod=1e9+7;
typedef long long LL;
LL n,A[N],g[13][N],Ans[N];
int k,tot,res,p[4]={2,3,5,7},t[13],pre[N][10];
struct node
{
	int i,t;LL v;
	bool operator < (const node& B) const {return v<B.v;}
};priority_queue<node> Q;

void DFS(LL x,int t)
{
	A[++tot]=x;
	for (int i=t;i<4;i++) if (x*p[i]<=n) DFS(x*p[i],i);
}
int Find(LL x)
{
	int L=1,R=tot,res;
	while (L<=R) if (A[Mid]>=x) res=Mid,R=Mid-1;else L=Mid+1;
	return res;
}

LL calc(int x)
{
	LL res=0;int cnt=0;
	for (LL i=n+1;i;i/=10) t[cnt++]=i%10;reverse(t,t+cnt);
	for (int i=1;i<cnt;i++) res+=g[i][x];
	for (int i=0;i<cnt;i++)
	{
		for (int j=1;j<t[i];j++) if (A[x]%j==0) res+=g[cnt-i-1][pre[x][j]];
		if (!t[i]||A[x]%t[i]!=0) break;x=pre[x][t[i]];
	}
	return res;
}

int main()
{
	scanf("%lld%d",&n,&k);
	DFS(1,0);sort(A+1,A+tot+1);
	g[0][1]=1;
	for (int i=1;i<=tot;i++)
		for (int j=1;j<10;j++) if (A[i]%j==0) pre[i][j]=Find(A[i]/j);
	for (int i=1;i<13;i++)
		for (int j=1;j<=tot;j++)
			for (int k=1;k<10;k++) g[i][j]+=g[i-1][pre[j][k]];
	for (int i=1;i<=tot;i++) Ans[i]=calc(i);
	sort(Ans+1,Ans+tot+1,greater<int>());
	for (int i=1;i<=tot;i++) Q.push((node){i,1,Ans[1]*Ans[i]});
	while (k--)
	{
		node x=Q.top();Q.pop();
		(res+=x.v%Mod)%=Mod;
		Q.push((node){x.i,x.t+1,Ans[x.i]*Ans[x.t+1]});
	}
	printf("%d\n",res);
}
Problem3132
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=2048+19;
int C[4][Maxn][Maxn],n,m,a,b,c,d,v;
char s[3];

int ch,f;
void read(int &x)
{
	while (!isdigit(ch=getchar())&&ch!='-');
	if (ch=='-') f=1,x=0;else f=0,x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
	if (f) x=-x;
}

inline void Update(int t,int x,int y,int v)
{
	for (int i=x;i<=n;i+=i&-i)
		for (int j=y;j<=m;j+=j&-j) C[t][i][j]+=v;
}
inline int Query(int t,int x,int y)
{
	int Ans=0;
	for (int i=x;i;i-=i&-i)
		for (int j=y;j;j-=j&-j) Ans+=C[t][i][j];
	return Ans;
}
inline void Add(int x,int y,int v)
{
	Update(0,x,y,v),Update(1,x,y,x*v),Update(2,x,y,y*v),Update(3,x,y,x*y*v);
}
inline int Count(int x,int y)
{
	return (x*y+x+y+1)*Query(0,x,y)-(y+1)*Query(1,x,y)-(x+1)*Query(2,x,y)+Query(3,x,y);
}

int main()
{
	read(n),read(m);
	while (scanf("%s",s)!=EOF)
	{
		read(a),read(b),read(c),read(d);
		if (s[0]=='L') read(v),Add(a,b,v),Add(a,d+1,-v),Add(c+1,b,-v),Add(c+1,d+1,v);
			else printf("%d\n",Count(c,d)-Count(c,b-1)-Count(a-1,d)+Count(a-1,b-1));
	}
}
Problem3132
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=2048+19;
int C[4][Maxn][Maxn],n,m,a,b,c,d,v;
char s[3];

int ch,f;
void read(int &x)
{
	while (!isdigit(ch=getchar())&&ch!='-');
	if (ch=='-') f=1,x=0;else f=0,x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
	if (f) x=-x;
}

void Update(int t,int x,int y,int v)
{
	for (int i=x;i<=n;i+=i&-i)
		for (int j=y;j<=m;j+=j&-j) C[t][i][j]+=v;
}
int Query(int t,int x,int y)
{
	int Ans=0;
	for (int i=x;i;i-=i&-i)
		for (int j=y;j;j-=j&-j) Ans+=C[t][i][j];
	return Ans;
}
void Add(int x,int y,int v)
{
	Update(0,x,y,v),Update(1,x,y,x*v),Update(2,x,y,y*v),Update(3,x,y,x*y*v);
}
int Count(int x,int y)
{
	return (x*y+x+y+1)*Query(0,x,y)-(y+1)*Query(1,x,y)-(x+1)*Query(2,x,y)+Query(3,x,y);
}

int main()
{
	read(n),read(m);
	while (~scanf("%s",s))
	{
		read(a),read(b),read(c),read(d);
		if (s[0]=='L') read(v),Add(a,b,v),Add(a,d+1,-v),Add(c+1,b,-v),Add(c+1,d+1,v);
			else printf("%d\n",Count(c,d)-Count(c,b-1)-Count(a-1,d)+Count(a-1,b-1));
	}
}
Problem3134
#include <set>
#include <map>
#include <cmath>
#include <ctime>
#include <bitset>
#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <iomanip>
#include <iostream>
#include <algorithm>
#define PR pair
#define fi first
#define se second
#define mk make_pair
#define pb push_back
#define REP(i, x, y)   for(int i = (int)(x); i <= (int)(y); i++)
#define FOR(i, x, y)   for(int i = (int)(x); i <  (int)(y); i++)
#define PER(i ,x, y)  for(int i = (int)(x); i >= (int)(y); i--)
#define CH	         ch = getchar()
#define Exit(...)    printf(__VA_ARGS__), exit(0)
#define dln()        fprintf(stderr,"\n")
#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;
typedef double	  db;
typedef long long ll;
typedef vector<int> VI;
typedef vector<VI > VII;
typedef PR<int,int> PII;
const	int inf=2e9;
const	ll Inf=1e10;
const	int P=1e9+7;
const	int N=55;

inline ll IN(){
	ll x = 0;
	int ch = 0, f = 0;
	for (CH; ch != -1 && (ch < 48 || ch > 57); CH) f = (ch == '-');
	for (; ch >= 48 && ch <= 57; CH) x = (x << 1) + (x << 3) + ch - '0';
	return f ? (-x) : x;
}
template<typename T> inline int chkmin(T &a, const T &b){if(b < a) return a = b, 1; return 0;}
template<typename T> inline int chkmax(T &a, const T &b){if(b > a) return a = b, 1; return 0;}

void renew(int &x, const int &y){
	if((x += y) >= P) x -= P;
}

int Pow(int x, int y, int p){
	int a = 1;
	for (; y; y >>= 1, x = (ll)x * x %p) if(y & 1) a=(ll)a * x%p;
	return a;
}

ll L, R;
int stk[26], top;
ll f[25][15][15], g[25][15][15][3];

ll calc(ll v){
	if(v == 0) return 0;
	ll sv = v;
	top = 0;
	memset(stk, 0, sizeof stk);
	for(; v; v /= 10) stk[++top] = v % 10;
	ll ans = 0;
	if(top == 1) return sv;
	if(top == 2){
		REP(i, 1, sv){
			if(i <= 10){
				ans ++;
				continue;
			}else{
				if(i % 11 == 0) continue;
				ans ++;
			}
		}
		return ans;
	}
	FOR(bit, 1, top){
		if(bit == 1){
			ans += 9;
		}else
		if(bit == 2){
			ans += 81;
		}else{
			memset(f, 0, sizeof f);
			REP(i, 1, 9)
			REP(j, 0, 9) if(i != j) f[2][i][j] = 1;
			
			FOR(b, 2, bit)
			REP(p0, 0, 9)
			REP(p1, 0, 9)
			REP(p2, 0, 9)
			if(p2 != p0 && p2 != p1) f[b + 1][p1][p2] += f[b][p0][p1];
			
			REP(x, 0, 9) REP(y, 0, 9) ans += f[bit][x][y];
		}
	}
	
	reverse(stk + 1, stk + top + 1);
	memset(g, 0, sizeof g);
	int now = stk[1] * 10 + stk[2];
	REP(x, 1, 9) REP(y, 0, 9){
		if(x == y) continue;
		int gt = x * 10 + y;
		if(gt > now) continue;
		g[2][x][y][gt < now] = 1;
	}
	
	FOR(bit, 2, top)
	REP(p0, 0, 9)
	REP(p1, 0, 9)
	REP(zi, 0, 1){
		if(!g[bit][p0][p1][zi]) continue;
		int lim = (zi ? 9 : stk[bit + 1]);
		REP(p2, 0, lim){
			if(p2 == p0 || p2 == p1) continue;
			g[bit + 1][p1][p2][zi | (p2 < lim)] += g[bit][p0][p1][zi];
		}
	}
	
	REP(p0, 0, 9) REP(p1, 0, 9) REP(z, 0, 1) ans += g[top][p0][p1][z];
	return ans;
}

int main(){
	cin >> L >> R;
	cout << calc(R) - calc(L - 1) << endl;
	return 0;
}



Problem3135
#include <set>
#include <map>
#include <cmath>
#include <ctime>
#include <bitset>
#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <iomanip>
#include <iostream>
#include <algorithm>
#define PR pair
#define fi first
#define se second
#define mk make_pair
#define pb push_back
#define REP(i, x, y)   for(int i = (int)(x); i <= (int)(y); i++)
#define FOR(i, x, y)   for(int i = (int)(x); i <  (int)(y); i++)
#define PER(i ,x, y)  for(int i = (int)(x); i >= (int)(y); i--)
#define CH	         ch = getchar()
#define Exit(...)    printf(__VA_ARGS__), exit(0)
#define dln()        fprintf(stderr,"\n")
#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;
typedef double	  db;
typedef long long ll;
typedef vector<int> VI;
typedef vector<VI > VII;
typedef PR<int,int> PII;
typedef vector<PII> VPI;
const	int inf=2e9;
const	ll Inf=1e10;
const	int P=1e9+7;
const	int N=100005;

inline ll IN(){
	ll x = 0;
	int ch = 0, f = 0;
	for (CH; ch != -1 && (ch < 48 || ch > 57); CH) f = (ch == '-');
	for (; ch >= 48 && ch <= 57; CH) x = (x << 1) + (x << 3) + ch - '0';
	return f ? (-x) : x;
}
template<typename T> inline int chkmin(T &a, const T &b){if(b < a) return a = b, 1; return 0;}
template<typename T> inline int chkmax(T &a, const T &b){if(b > a) return a = b, 1; return 0;}

void renew(int &x, const int &y){
	if((x += y) >= P) x -= P;
}

int Pow(int x, int y, int p){
	int a = 1;
	for (; y; y >>= 1, x = (ll)x * x %p) if(y & 1) a=(ll)a * x%p;
	return a;
}

int done[N], ue[N], ve[N];
int n, m, f[N], fu, fv, fi, par[N], deg[N], que[N], r, c[N], ans[N];
VPI adj[N];

int get(int x){
	if(f[x] == x) return x;
	return f[x] = get(f[x]);
}

void dfs(int u, int pa = 0){
	par[u] = par[pa] ^ 1;
	FOR(i, 0, adj[u].size()){
		int v = adj[u][i].fi;
		if(v == pa) continue;
		dfs(v, u);
	}
}

int cir[N], cirtot, ind[N];
int edge(int u){
	int f1 = cir[u], f2 = cir[u == 1 ? cirtot : (u - 1)];
	FOR(i, 0, adj[f1].size()) if(adj[f1][i].fi == f2) return adj[f1][i].se;
	cerr << u << endl;
	return -1;
}

void der(int x, int pa = 0){
	if(ind[x]) return;
	cir[++cirtot] = x;
	ind[x] = cirtot;
	FOR(i, 0, adj[x].size()){
		int v = adj[x][i].fi;
		if(deg[v] == 1 || v == pa) continue;
		der(v, x);
	}
}

int main(){
	scanf("%d%d", &n, &m);
	if(m > n){
		puts("0");
		return 0;
	}
	REP(i, 1, n) scanf("%d", c + i);
	REP(i, 1, m) f[i] = i;
	REP(i, 1, m){
		int u = IN(), v = IN();
		ue[i] = u;
		ve[i] = v;
		if(get(u) != get(v)){
			f[get(u)] = get(v);
			adj[u].pb(mk(v, i));
			adj[v].pb(mk(u, i));
			deg[u] ++;
			deg[v] ++;
		}else{
			fu = u;
			fv = v;
			fi = i;
		}
	}
	dfs(1);
	if(m == n){
		if(par[fu] != par[fv]){
			puts("0");
			return 0;
		}
		adj[fu].pb(mk(fv, fi));
		adj[fv].pb(mk(fu, fi));
		deg[fu] ++;
		deg[fv] ++;
	}
	REP(i, 1, n) if(adj[i].size() == 1) que[++r] = i;
	REP(l, 1, r){
		int u = que[l];
		FOR(x, 0, adj[u].size()){
			int v = adj[u][x].fi, w = adj[u][x].se;
			if(deg[v] > 1){
				--deg[v];
				ans[w] = c[u];
				done[w] = 1;
				c[v] -= c[u];
				if(deg[v] == 1) que[++r] = v;
			}
		}
	}
	if(m < n){
		REP(i, 1, m){
			if(done[i]) continue;
			ans[i] = c[ue[i]];
		}
		REP(i, 1, m) printf("%d\n", ans[i] << 1);
		return 0;
	}else{
		REP(i, 1, n){
			if(deg[i] == 1) continue;
			der(i);
			break;
		}
		ll res = 0;
		REP(i, 1, cirtot){
			if((cirtot - i) & 1) res -= c[cir[i]]; else res += c[cir[i]];
		}
		ans[edge(1)] = res >> 1;
		REP(i, 2, cirtot) ans[edge(i)] = c[cir[i - 1]] - ans[edge(i - 1)];
		REP(i, 1, m) printf("%d\n", ans[i] << 1);
	}
	return 0;
}



Problem3136
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<vector>
#include<set>
#include<map>
#include<bitset>

#define ls (t<<1)
#define rs ((t<<1)+1)
#define mid ((l+r)>>1)
#define fi first
#define se second
#define mk make_pair
#define pb push_back

#define N 20000005
#define M 200005
#define seed 23333
#define Mo 998244353

using namespace std;
int i,j,m,n,k,p[M],Q,x;
int f[N],g[10000005]; 
inline int read()
{
	int x; char c;
	while (c=getchar(),c<'0'||c>'9');
	x=c-'0';
	while (c=getchar(),c>='0'&&c<='9') x=(x<<1)+(x<<3)+c-'0';
	return x;
}
int main()
{
//	  freopen("brunhilda.in","r",stdin);
//	  freopen("1.out","w",stdout); 
	  scanf("%d%d",&m,&Q); int inf=1;
	  for (i=1;i<=m;++i) p[i]=read(),inf=min((long long)10000001,1ll*inf*p[i]);
	  sort(p+1,p+m+1); 
	  for (i=1;i<=m;++i)
	    for (j=p[i]-1;j-p[i]<=inf;j+=p[i]) f[j]=p[i]-1; 
	  for (i=inf+p[m];i;--i) 
	    if (f[i+1]-1>=f[i]) f[i]=f[i+1]-1;
	  for (i=1;i<=inf;++i) g[i]=g[i-f[i]]+1;
	  for (;Q--;)
	  {
	  	  x=read();
		  if (x>=inf) puts("oo"); else printf("%d\n",g[x]);  
	  }
}
Problem3136
#include <set>
#include <map>
#include <cmath>
#include <ctime>
#include <bitset>
#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <iomanip>
#include <iostream>
#include <algorithm>
#define PR pair
#define fi first
#define se second
#define mk make_pair
#define pb push_back
#define REP(i, x, y)   for(int i = (int)(x); i <= (int)(y); i++)
#define FOR(i, x, y)   for(int i = (int)(x); i <  (int)(y); i++)
#define PER(i ,x, y)  for(int i = (int)(x); i >= (int)(y); i--)
#define CH	         ch = getchar()
#define Exit(...)    printf(__VA_ARGS__), exit(0)
#define dln()        fprintf(stderr,"\n")
#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;
typedef double	  db;
typedef long long ll;
typedef vector<int> VI;
typedef vector<VI > VII;
typedef PR<int,int> PII;
const	int inf=2e9;
const	ll Inf=1e10;
const	int P=1e9+7;
const	int N=100005;

inline ll IN(){
	ll x = 0;
	int ch = 0, f = 0;
	for (CH; ch != -1 && (ch < 48 || ch > 57); CH) f = (ch == '-');
	for (; ch >= 48 && ch <= 57; CH) x = (x << 1) + (x << 3) + ch - '0';
	return f ? (-x) : x;
}
template<typename T> inline int chkmin(T &a, const T &b){if(b < a) return a = b, 1; return 0;}
template<typename T> inline int chkmax(T &a, const T &b){if(b > a) return a = b, 1; return 0;}

void renew(int &x, const int &y){
	if((x += y) >= P) x -= P;
}

int Pow(int x, int y, int p){
	int a = 1;
	for (; y; y >>= 1, x = (ll)x * x %p) if(y & 1) a=(ll)a * x%p;
	return a;
}

int n, Q;
int a[N], b[N], m, f[N * 200], g[N * 100], dmax;

int main(){
	//freopen("1.in", "r", stdin);
	//freopen("1.out", "w", stdout);
	n = IN();
	Q = IN();
	ll inf = 1; 
	REP(i, 1, n){
		a[i] = IN();
		chkmax(m, a[i]);
		inf *= a[i];
		if(inf > 1e7) inf = 1e7 + 1;
	}
	REP(i, 1, Q) b[i] = IN();
	REP(i, 1, n){
		int pr = a[i];
		for(int x = pr - 1; x <= inf + pr; x += pr){
			chkmax(f[x], pr - 1);
		}
	}
	PER(i, inf + m, 1) chkmax(f[i], f[i + 1] - 1);
	g[0] = 0;
	REP(i, 1, inf) g[i] = g[i - f[i]] + 1;
	REP(i, 1, Q){
		if(b[i] >= inf) puts("oo");
		else printf("%d\n", g[b[i]]);
	}
	return 0;
}



Problem3142
#include<cstdio>

int k,m,Mod;long long n;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%Mod) if (b&1) res=1LL*res*a%Mod;
	return res;
}

int main()
{
	scanf("%lld%d%d%d",&n,&k,&m,&Mod);
	printf("%d\n",(1LL*n%Mod*Pow(m,k-1)%Mod-1LL*m*(m+1)/2LL%Mod*Pow(m,k-2)%Mod*(k-1)%Mod+Mod)%Mod);
}
Problem3144
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=40*40*40+19,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[Maxn*5*2];
int Last[Maxn],Dis[Maxn],Qu[Maxn];
int P,Q,R,D,S,T,cnt,f,w,x,Flow;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
int ID(int x,int y,int z) {return x*(Q*R)+y*R+z;}
void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	Qu[w=0,f=1]=S;
	while (f>w)
	{
		int x=Qu[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1)
				Dis[E[i].y]=Dis[x]+1,Qu[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			Flow-=tmp,res+=tmp;
			E[i].f-=tmp,E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(P),read(Q),read(R),read(D);
	S=P*Q*R,T=S+1;
	for (int i=0;i<R;i++)
		for (int j=0;j<P;j++)
			for (int k=0;k<Q;k++)
			{
				int t=ID(j,k,i);
				read(x);
				if (!i) Add_Edge(S,t,x);else Add_Edge(ID(j,k,i-1),t,x);
				if (i==R-1) Add_Edge(t,T,oo);
				if (i>=D)
				{
					if (j) Add_Edge(t,ID(j-1,k,i-D),oo);
					if (j<P-1) Add_Edge(t,ID(j+1,k,i-D),oo);
					if (k) Add_Edge(t,ID(j,k-1,i-D),oo);
					if (k<Q-1) Add_Edge(t,ID(j,k+1,i-D),oo);
				}
			}
	while (BFS()) Flow+=Dinic(S,oo);
	printf("%d\n",Flow);
}
Problem3145
//============================================================================
// Author       : sunyaofeng
//============================================================================

//#pragma 	comment(linker, "/STACK:100240000,100240000")
//#include	<cstdio>
//#include	<cstdlib>
//#include	<cstring>
//#include	<algorithm>

#include	<bits/stdc++.h>

using	namespace	std;

#define DB		double
#define	lf		else if
#define I64		long long
#define	Rd()	(rand()<<15|rand())

//#define	min(a,b)	((a)<(b)?(a):(b))
//#define	max(a,b)	((a)<(b)?(b):(a))

#define	CH	(ch=getchar())
int		IN()	{
		int x= 0, f= 0, ch;
		for	(; CH < '0' || ch > '9';)	f= (ch == '-');
		for	(; ch >= '0' && ch <= '9'; CH)	x= x*10 + ch -'0';
		return	f? -x : x;
}

#define	n	400005

int		N, M, T, Ans, S[n], Rank[n];

namespace	Pre{
		char	s1[n], s2[n];
		
		void	Main(){
			scanf("%s%s", s1+1, s2+1);
			N= strlen(s1+1);
			M= strlen(s2+1);
			
			if  (N <= 1 || M <= 1)	{
				printf("%d\n", 1);
				exit(0);
			}
			
			T= N+M+1;
			for	(int i= 1; i <= N; i ++ )	S[i]= s1[i] - 'a';
			for	(int i= 1; i <= M; i ++ )	S[N+1+i]= s2[i] - 'a';
			S[N+1]= 26;
		}
};

namespace	SAM1{
		int		L, C, D, Now[n], F[n], Max[n], st[n], ID[n], A[n][27];		
		int		Dep[n], E[n][27], fa[20][n];
		
		void	Extend(int d, int c){
			int p= L, np= ++C, q, nq;
			Max[np]= Max[p]+1;
			
			for	(; p && !A[p][c]; p= F[p])	A[p][c]= np;
			if  (! p)	F[np]= 1;
			lf	(Max[q= A[p][c]] == Max[p] + 1)	F[np]= q;
			else	{
				F[nq= ++ C]= F[q];
				Max[nq]= Max[p] + 1;
				for	(int i= 0; i <= 26; i ++ )	A[nq][i]= A[q][i];
				
				F[q]= F[np]= nq;
				for	(; p && A[p][c] == q; p= F[p])	A[p][c]= nq;
			}
			
			Now[d]= L= np;	st[np]= d;
		}
		
		int		LCA(int u, int v){
			if	(Dep[u] > Dep[v])	swap(u, v);
			for	(int i= 18; i+1; i -- )	
				if	(Dep[fa[i][v]] >= Dep[u])	v= fa[i][v];
			if	(u == v)	return	u;
		
			for	(int i= 18; i+1; i -- )	
				if	(fa[i][u] != fa[i][v])	u= fa[i][u],v= fa[i][v];
			return	fa[0][u];
		}
		
		int		Query(int u, int v){
			int w= LCA(u, v);
			return	Max[w]+1;
		}
		
		bool	Cmp(int a, int b){
			return	Max[a] < Max[b];
		}
		
		void	DFS(int u){
			Rank[u]= ++D;
			
			for	(int i= 0; i <= 26; i ++ )
				if  (E[u][i])	Dep[E[u][i]]= Dep[u]+1, DFS(E[u][i]);
		}
		
		void	Main(){
			L= C= 1;
			for	(int i= T; i; i -- )	Extend(i, S[i]);
			
			for	(int i= 1; i <= C; i ++ )	fa[0][i]= F[i];
			for	(int i= 1; i <= 18; i ++ )	
				for	(int j= 1; j <= C; j ++ )	fa[i][j]= fa[i-1][fa[i-1][j]];
			
			for	(int i= 1; i <= C; i ++ )	ID[i]= i;
			sort(ID+1, ID+C+1, Cmp);
			
			for	(int i= C; i > 1; i -- )	{
				int u= ID[i], f= F[u];
				st[f]= max(st[f], st[u]);
				E[f][S[st[u]+Max[f]]]= u;
			}
			
			Dep[1]= 1;	DFS(1);
/*			
			for	(int i= 1; i <= N; i ++ )	
				for	(int j= 1; j <= M; j ++ )	printf("%d %d %d\n", i, j, Query(Now[i], Now[N+1+j]));
*/		
		}
};

namespace	SAM2{
		int		L, C, Now[n], F[n], Max[n], A[n][27];
		int		RA[n], RB[n], ID[n], Pre[n];
		
		struct	Nod{
			int 	x, d;
			
			bool	operator <	(const Nod&b)	const{
				return	Rank[x] < Rank[b.x] || (Rank[x] == Rank[b.x] && d < b.d);
			}
		};
		
		set<Nod> G[n];
		
		void	Extend(int d, int c){
			int p= L, np= ++C, q, nq;
			Max[np]= Max[p]+1;
			
			for	(; p && !A[p][c]; p= F[p])	A[p][c]= np;
			if  (! p)	F[np]= 1;
			lf	(Max[q= A[p][c]] == Max[p] + 1)	F[np]= q;
			else	{
				F[nq= ++ C]= F[q];
				Max[nq]= Max[p] + 1;
				for	(int i= 0; i <= 26; i ++ )	A[nq][i]= A[q][i];
				
				F[q]= F[np]= nq;
				for	(; p && A[p][c] == q; p= F[p])	A[p][c]= nq;
			}
			
			Now[d]= L= np;
		}
		
		bool	Cmp(int a, int b){
			return	Max[a] < Max[b];
		}
		
		void	Merge(int u, set<Nod>&a, set<Nod>&b){
			if  (a.size() < b.size())	swap(a, b);
			
			for	(set<Nod>::iterator t= b.begin(); t != b.end(); t++){
				Nod	x= *t;
				a.insert(x);
				set<Nod>::iterator	p= a.find(x);
				
				p++;
				if  (p != a.end())	{
					Nod l= *p;
					if  (l.d != x.d)	Pre[u]= max(Pre[u], SAM1::Query(x.x, l.x) );
				}
				p--;
				
				if  (p != a.begin()){
					Nod l= *(--p);
					if  (l.d != x.d)	Pre[u]= max(Pre[u], SAM1::Query(x.x, l.x) );
				}
			}
		}
		
		void	Main(){
			L= C= 1;
			for	(int i= 1; i <= T; i ++ )	Extend(i, S[i]);
			
			for	(int i= 1; i <= N - 2; i ++ )	G[Now[i]].insert( (Nod){ SAM1::Now[i+2], 0} );
			for	(int i= 1; i <= M - 2; i ++ )	G[Now[N+1+i]].insert( (Nod){ SAM1::Now[N+1+i+2] , 1} );
			
			G[Now[N-1]].insert( (Nod){0, 0} );
			G[Now[N+1+M-1]].insert( (Nod){0, 1} );
			
			G[1].insert( (Nod){SAM1::Now[2], 0} );
			G[1].insert( (Nod){SAM1::Now[N+1+2], 1} );
			Pre[1]= SAM1::Query(SAM1::Now[2], SAM1::Now[N+1+2]);
			
			for	(int i= 1; i <= N; i ++ )	RA[Now[i]]= 1;
			for	(int i= 1; i <= M; i ++ )	RB[Now[N+1+i]]= 1;
			
			for	(int i= 1; i <= C; i ++ )	ID[i]= i;
			sort(ID+1, ID+C+1, Cmp);
			
			for	(int i= C; i; i -- )	{
				int u= ID[i], f= F[u];
				
				if  (f)	{	
					Pre[f]= max(Pre[f], Pre[u]);
					Merge(f, G[f], G[u]);
					
					RA[f]|= RA[u];
					RB[f]|= RB[u];
				}
				
				if  (RA[u] && RB[u])	Ans= max(Ans, Max[u] + Pre[u]);
			}
			
			printf("%d\n", Ans);
		}
};

int		main(int argc, char* argv[]){
//		freopen("str.in","r",stdin);
//		freopen("str.out","w",stdout);
	
		Pre::Main();
		SAM1::Main();
		SAM2::Main();
		
		return	0;
}
Problem3145
//============================================================================
// Author       : sunyaofeng
//============================================================================

//#pragma 	comment(linker, "/STACK:100240000,100240000")
//#include	<cstdio>
//#include	<cstdlib>
//#include	<cstring>
//#include	<algorithm>

#include	<bits/stdc++.h>

using	namespace	std;

#define DB		double
#define	lf		else if
#define I64		long long
#define	Rd()	(rand()<<15|rand())

#define	min(a,b)	((a)<(b)?(a):(b))
#define	max(a,b)	((a)<(b)?(b):(a))

#define	CH	(ch=getchar())
int		IN()	{
		int x= 0, f= 0, ch;
		for	(; CH < '0' || ch > '9';)	f= (ch == '-');
		for	(; ch >= '0' && ch <= '9'; CH)	x= x*10 + ch -'0';
		return	f? -x : x;
}

#define	n	400005

int		N, M, T, Ans, S[n], Rank[n];
int		Log2[n];

namespace	Pre{
		char	s1[n], s2[n];
		
		void	Main(){
			scanf("%s%s", s1+1, s2+1);
			N= strlen(s1+1);
			M= strlen(s2+1);
			
			if  (N <= 1 || M <= 1)	{
				printf("%d\n", 1);
				exit(0);
			}
			
			T= N+M+1;
			for	(int i= 1; i <= N; i ++ )	S[i]= s1[i] - 'a';
			for	(int i= 1; i <= M; i ++ )	S[N+1+i]= s2[i] - 'a';
			S[N+1]= 26;
			
			Log2[0]= -1;
			Log2[1]= 0;
			for	(int i= 2; i < n; i ++ )	Log2[i]= Log2[i>>1]+1;
		}
};

namespace	SAM1{
		int		L, C, D, Now[n], F[n], Max[n], st[n], ID[n], A[n][27];		
		int		Dep[n], E[n][27], fa[20][n];
		
		void	Extend(int d, int c){
			int p= L, np= ++C, q, nq;
			Max[np]= Max[p]+1;
			
			for	(; p && !A[p][c]; p= F[p])	A[p][c]= np;
			if  (! p)	F[np]= 1;
			lf	(Max[q= A[p][c]] == Max[p] + 1)	F[np]= q;
			else	{
				F[nq= ++ C]= F[q];
				Max[nq]= Max[p] + 1;
				for	(int i= 0; i <= 26; i ++ )	A[nq][i]= A[q][i];
				
				F[q]= F[np]= nq;
				for	(; p && A[p][c] == q; p= F[p])	A[p][c]= nq;
			}
			
			Now[d]= L= np;	st[np]= d;
		}
		
		int		LCA(int u, int v){
			if	(Dep[u] > Dep[v])	swap(u, v);
			for	(int i= Log2[Dep[v]-Dep[u]]; i+1; i -- )	
				if	(Dep[fa[i][v]] >= Dep[u])	v= fa[i][v];
			if	(u == v)	return	u;
		
			for	(int i= Log2[Dep[u]]; i+1; i -- )	
				if	(fa[i][u] != fa[i][v])	u= fa[i][u],v= fa[i][v];
			return	fa[0][u];
		}
		
		int		Query(int u, int v){
			int w= LCA(u, v);
			return	Max[w]+1;
		}
		
		bool	Cmp(int a, int b){
			return	Max[a] < Max[b];
		}
		
		void	DFS(int u){
			Rank[u]= ++D;
			
			for	(int i= 0; i <= 26; i ++ )
				if  (E[u][i])	Dep[E[u][i]]= Dep[u]+1, DFS(E[u][i]);
		}
		
		void	Main(){
			L= C= 1;
			for	(int i= T; i; i -- )	Extend(i, S[i]);
			
			for	(int i= 1; i <= C; i ++ )	fa[0][i]= F[i];
			for	(int i= 1; i <= 18; i ++ )	
				for	(int j= 1; j <= C; j ++ )	fa[i][j]= fa[i-1][fa[i-1][j]];
			
			for	(int i= 1; i <= C; i ++ )	ID[i]= i;
			sort(ID+1, ID+C+1, Cmp);
			
			for	(int i= C; i > 1; i -- )	{
				int u= ID[i], f= F[u];
				st[f]= max(st[f], st[u]);
				E[f][S[st[u]+Max[f]]]= u;
			}
			
			Dep[1]= 1;	DFS(1);	
		}
};

namespace	SAM2{
		int		L, C, Now[n], F[n], Max[n], A[n][27];
		int		RA[n], RB[n], ID[n], Pre[n];
		
		struct	Nod{
			int 	x, d;
			
			bool	operator <	(const Nod&b)	const{
				return	Rank[x] < Rank[b.x] || (Rank[x] == Rank[b.x] && d < b.d);
			}
		};
		
		set<Nod> G[n];
		
		void	Extend(int d, int c){
			int p= L, np= ++C, q, nq;
			Max[np]= Max[p]+1;
			
			for	(; p && !A[p][c]; p= F[p])	A[p][c]= np;
			if  (! p)	F[np]= 1;
			lf	(Max[q= A[p][c]] == Max[p] + 1)	F[np]= q;
			else	{
				F[nq= ++ C]= F[q];
				Max[nq]= Max[p] + 1;
				for	(int i= 0; i <= 26; i ++ )	A[nq][i]= A[q][i];
				
				F[q]= F[np]= nq;
				for	(; p && A[p][c] == q; p= F[p])	A[p][c]= nq;
			}
			
			Now[d]= L= np;
		}
		
		bool	Cmp(int a, int b){
			return	Max[a] < Max[b];
		}
		
		void	Merge(int u, set<Nod>&a, set<Nod>&b){
			if  (a.size() < b.size())	swap(a, b);
			
			for	(set<Nod>::iterator t= b.begin(); t != b.end(); t++){
				Nod	x= *t;
				a.insert(x);
				set<Nod>::iterator	p= a.find(x);
				
				p++;
				if  (p != a.end())	{
					Nod l= *p;
					if  (l.d != x.d)	Pre[u]= max(Pre[u], SAM1::Query(x.x, l.x) );
				}
				p--;
				
				if  (p != a.begin()){
					Nod l= *(--p);
					if  (l.d != x.d)	Pre[u]= max(Pre[u], SAM1::Query(x.x, l.x) );
				}
			}
		}
		
		void	Main(){
			L= C= 1;
			for	(int i= 1; i <= T; i ++ )	Extend(i, S[i]);
			
			for	(int i= 1; i <= N - 2; i ++ )	G[Now[i]].insert( (Nod){ SAM1::Now[i+2], 0} );
			for	(int i= 1; i <= M - 2; i ++ )	G[Now[N+1+i]].insert( (Nod){ SAM1::Now[N+1+i+2] , 1} );
			
			G[Now[N-1]].insert( (Nod){0, 0} );
			G[Now[N+1+M-1]].insert( (Nod){0, 1} );
			
			G[1].insert( (Nod){SAM1::Now[2], 0} );
			G[1].insert( (Nod){SAM1::Now[N+1+2], 1} );
			Pre[1]= SAM1::Query(SAM1::Now[2], SAM1::Now[N+1+2]);
			
			for	(int i= 1; i <= N; i ++ )	RA[Now[i]]= 1;
			for	(int i= 1; i <= M; i ++ )	RB[Now[N+1+i]]= 1;
			
			for	(int i= 1; i <= C; i ++ )	ID[i]= i;
			sort(ID+1, ID+C+1, Cmp);
			
			for	(int i= C; i; i -- )	{
				int u= ID[i], f= F[u];
				
				if  (f)	{	
					Pre[f]= max(Pre[f], Pre[u]);
					Merge(f, G[f], G[u]);
					
					RA[f]|= RA[u];
					RB[f]|= RB[u];
				}
				
				if  (RA[u] && RB[u])	Ans= max(Ans, Max[u] + Pre[u]);
			}
			
			printf("%d\n", Ans);
		}
};

int		main(int argc, char* argv[]){
//		freopen("str.in","r",stdin);
//		freopen("str.out","w",stdout);
	
//		int pp= clock();
	
		Pre::Main();
		SAM1::Main();
		SAM2::Main();
		
//		fprintf(stderr, "%d\n", clock() -pp);
		
		return	0;
}
Problem3145
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=400000+19;

typedef int one[N];
char A[N],B[N],s[N];
one dfn;
int n,m,l,res;

namespace Suf{
	struct Edge{
		int y,nxt;
	} E[N*2];
	one Last,id,sz,son,top,fa,dep,dis,pos;
	int num,cnt,tot;
	
	struct node{
		node *par,*go[27];
		int val;
	} Nd[N],*cur,*rt,*last;

	void Add_Edge(int x,int y){
		E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	}
	node *New(int v){
		return ++cur,cur->val=v,cur;
	}
	void Extend(int x){
		node *p=last,*np=New(p->val+1);
		last=np;
		for (;p&&!p->go[x];p=p->par) p->go[x]=np;
		if (!p) np->par=rt;else{
			node *t=p->go[x];
			if (t->val==p->val+1) np->par=t;else{
				node *nt=New(p->val+1);
				nt->par=t->par,t->par=np->par=nt;
				memcpy(nt->go,t->go,sizeof(t->go));
				for (;p&&p->go[x]==t;p=p->par) p->go[x]=nt;
			}
		}
	}
	void dfs(int x){
		sz[x]=1;
		dfn[id[x]]=++tot;
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if ((y=E[i].y)!=fa[x]){
				fa[y]=x;
				dep[y]=dep[x]+1;
				dfs(y);
				sz[x]+=sz[y];
				if (sz[y]>sz[son[x]]) son[x]=y;
			}
	}
	void dfs(int x,int Anc){
		id[x]=++num;
		top[x]=Anc;
		if (son[x]) dfs(son[x],Anc);
		for (int i=Last[x],y;~i;i=E[i].nxt)
			if ((y=E[i].y)!=fa[x]&&y!=son[x]) dfs(y,y);
	}
	int Query(int x,int y){
		if (x==n||x==l||y==n||y==l) return -1;
		if (x==n-1||x==l-1||y==n-1||y==l-1) return 0;
		x=pos[x+2],y=pos[y+2];
		int a=top[x],b=top[y];
		while (a!=b){
			if (dep[a]>dep[b]) swap(a,b),swap(x,y);
			y=fa[b],b=top[y];
		}
		if (dep[x]>dep[y]) swap(x,y);
		return dis[x];
	}
	void Main(){
		memset(Last,-1,sizeof(Last));
		cur=Nd,rt=last=New(0);
		for (int i=l;i;i--){
			Extend(s[i]-'a');
			id[last-Nd]=i;
			pos[i]=last-Nd;
		}
		For(i,1,(cur-Nd)+1){
			if (i>1) Add_Edge(Nd[i].par-Nd,i);
			dis[i]=Nd[i].val;
		}
		dfs(1);
		dfs(1,1);
		dfn[n+2]=dfn[l+2]=-1;
		dfn[n+1]=dfn[l+1]=0;
	}
}

namespace Pre{
	struct nd{
		int pos;
		bool operator < (const nd &B) const{
			if (dfn[pos+2]!=dfn[B.pos+2]) return dfn[pos+2]<dfn[B.pos+2];
			return pos<B.pos;
		}
		bool is_A() const{
			return pos<=n;
		}
	};
	
	struct node{
		node *par,*go[27];
		set<nd> R;
		int val;
	} Nd[N],*cur,*rt,*last;
	one Q,Max,cnt,Ra,Rb;
	
	node *New(int v){
		return ++cur,cur->val=v,cur;
	}
	void Extend(int x){
		node *p=last,*np=New(p->val+1);
		last=np;
		for (;p&&!p->go[x];p=p->par) p->go[x]=np;
		if (!p) np->par=rt;else{
			node *t=p->go[x];
			if (t->val==p->val+1) np->par=t;else{
				node *nt=New(p->val+1);
				nt->par=t->par,t->par=np->par=nt;
				memcpy(nt->go,t->go,sizeof(t->go));
				for (;p&&p->go[x]==t;p=p->par) p->go[x]=nt;
			}
		}
	}
	void Merge(int x,set<nd> &A,set<nd> &B){
		if (A.size()>B.size()) swap(A,B);
		for (set<nd>::iterator i=A.begin(),l,r;i!=A.end();i++){
			B.insert(*i);
			l=r=B.find(*i);
			if (l!=B.begin()){
				l--;
				if (l->is_A()!=i->is_A()){
					Max[x]=max(Max[x],Suf::Query(l->pos,i->pos));
				}
			}
			if (r!=--B.end()){
				r++;
				if (r->is_A()!=i->is_A()){
					Max[x]=max(Max[x],Suf::Query(r->pos,i->pos));
				}
			}
		}
	}
	void Main(){
		memset(Max,200,sizeof(Max));
		cur=Nd,rt=last=New(0);
		last->R.insert((nd){0});
		For(i,1,l+1){
			Extend(s[i]-'a');
			last->R.insert((nd){i});
			if (i<=n) Ra[last-Nd]=1;
			if (i>=n+2) Rb[last-Nd]=1;
		}
		For(i,1,cur-Nd+1) cnt[Nd[i].val]++;
		For(i,1,l+1) cnt[i]+=cnt[i-1];
		For(i,1,cur-Nd+1) Q[cnt[Nd[i].val]--]=i;
		for (int i=(cur-Nd);i;i--){
			int x=Q[i];
			if (i>1){
				int f=Nd[x].par-Nd;
				Merge(f,Nd[x].R,Nd[f].R);
				Ra[f]|=Ra[x];
				Rb[f]|=Rb[x];
			}
			if (Ra[x]&&Rb[x]){
				res=max(res,Max[x]+Nd[x].val+1);
			}
		}
	}
};

int main(){
	scanf("%s",A+1);n=strlen(A+1);
	scanf("%s",B+1);m=strlen(B+1);
	if (n==1||m==1) return puts("1"),0;
	For(i,1,n+1) s[++l]=A[i];
	s[++l]='a'+26;
	For(i,1,m+1) s[++l]=B[i];
	Suf::Main();
	Pre::Main();
	printf("%d\n",res);
}
Problem3145
#include <set>
#include <map>
#include <cmath>
#include <ctime>
#include <bitset>
#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <iomanip>
#include <iostream>
#include <algorithm>
#define PR pair
#define fi first
#define se second
#define mk make_pair
#define pb push_back
#define REP(i, x, y)   for(int i = (int)(x); i <= (int)(y); i++)
#define FOR(i, x, y)   for(int i = (int)(x); i <  (int)(y); i++)
#define PER(i ,x, y)  for(int i = (int)(x); i >= (int)(y); i--)
#define CH	         ch = getchar()
#define Exit(...)    printf(__VA_ARGS__), exit(0)
#define dln()        fprintf(stderr,"\n")
#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;
typedef double	  db;
typedef long long ll;
typedef vector<int> VI;
typedef vector<VI > VII;
typedef PR<int,int> PII;
const	int inf=2e9;
const	ll Inf=1e10;
const	int P=1e9+7;
const	int N=100005;
const	int V=400010;

template<typename T> inline T IN(){
	T x;
	int ch, f;
	for (CH; ch != -1 && (ch < 48 || ch > 57); CH) f = (ch == '-');
	for (; ch >= 48 && ch <= 57; CH) x = (x << 1) + (x << 3) + ch - '0';
	return f ? (-x) : x;	
}
template<typename T> inline int chkmin(T &a, const T &b){if(b < a) return a = b, 1; return 0;}
template<typename T> inline int chkmax(T &a, const T &b){if(b > a) return a = b, 1; return 0;}

void renew(int &x, const int &y){
	if((x += y) >= P) x -= P;
}

int Pow(int x, int y, int p){
	int a = 1;
	for (; y; y >>= 1, x = (ll)x * x %p) if(y & 1) a=(ll)a * x%p;
	return a;
}

int n, m, L;
char str1[N], str2[N];
int str[V >> 1];

int dfn[V], tim;
namespace Suf{
	int R[V >> 1];
	int T[V][27], F[V], S[V], rt, last, cnt;
	int hev[V], sz[V], top[V], dep[V];
	vector<int> E[V];
	void expand(int w){
		int p = ++cnt, q = last; last = p;
		S[p] = S[q] + 1;
		for(; q && !T[q][w]; q = F[q]) T[q][w] = p;
		if(!q) return void(F[p] = 1);
		int gt = T[q][w];
		if(S[gt] == S[q] + 1) return void(F[p] = gt);
		int nq = ++cnt;
		S[nq] = S[q] + 1;
		F[nq] = F[gt]; F[gt] = F[p] = nq;
		memcpy(T[nq], T[gt], sizeof T[nq]);
		for(; q && T[q][w] == gt; q = F[q]) T[q][w] = nq;
	}
	void DFS(int x){
		sz[x] = 1;
		FOR(i, 0, E[x].size()){
			int v = E[x][i];
			dep[v] = dep[x] + 1;
			DFS(v);
			sz[x] += sz[v];
			if(sz[v] > sz[hev[x]]) hev[x] = v;
		}
	}
	void Bud(int x){
		dfn[x] = ++tim;
		if(hev[x]){
			top[hev[x]] = top[x];
			Bud(hev[x]);
		}
		FOR(i, 0, E[x].size()){
			int v = E[x][i];
			if(v == hev[x]) continue;
			top[v] = v;
			Bud(v);
		}
	}
	int Lca(int u, int v){
		for(; top[u] ^ top[v]; u = F[top[u]])
			if(dep[top[u]] < dep[top[v]]) swap(u, v);
		return (dep[u] < dep[v]) ? u : v;
	}
	int Ask(int u, int v){
		return S[Lca(u, v)];
	}
	void Main(){
		rt = last = ++cnt;
		PER(i, L, 1) expand(str[i]), R[i] = last;
		PER(i, cnt, 1) if(F[i]) E[F[i]].pb(i);
		DFS(1); top[1] = 1; Bud(1);
	}
}

namespace Pre{
	int R[V >> 1];
	int HA[V], HB[V], ID[V], Res[V];
	int T[V][27], F[V], S[V], rt, last, cnt;
	struct Pair{
		int ps, c;
		int operator <(const Pair &a) const{
			if(dfn[ps] != dfn[a.ps]) return dfn[ps] < dfn[a.ps];
			return c < a.c;
		}
		Pair(int u = 0, int v = 0){
			ps = u;
			c = v;
		}
	};
	int cmp(const int &u, const int &v){
		return S[u] < S[v];
	}
	set<Pair> Rt[V];
	void expand(int w){
		int p = ++cnt, q = last; last = p;
		S[p] = S[q] + 1;
		for(; q && !T[q][w]; q = F[q]) T[q][w] = p;
		if(!q) return void(F[p] = 1);
		int gt = T[q][w];
		if(S[gt] == S[q] + 1) return void(F[p] = gt);
		int nq = ++cnt;
		S[nq] = S[q] + 1;
		F[nq] = F[gt]; F[gt] = F[p] = nq;
		memcpy(T[nq], T[gt], sizeof T[nq]);
		for(; q && T[q][w] == gt; q = F[q]) T[q][w] = nq;
	}
	typedef set<Pair> :: iterator iter;
	int Mer(set<Pair> &A, set<Pair> &B){
		int ans = 0;
		if(A.size() < B.size()) swap(A, B);
		for(iter it = B.begin(); it != B.end(); it ++){
			iter v = A.lower_bound(*it);
			if(v != A.end()){
				if(it -> c != v -> c) ans = max(ans, Suf :: Ask(it -> ps, v -> ps) + 1);
			}
			if(v != A.begin()){
				-- v;
				if(it -> c != v -> c) ans = max(ans, Suf :: Ask(it -> ps, v -> ps) + 1);
			}
			A.insert(*it);
		}
		return ans;
	}
	void Main(){
		rt = last = ++cnt;
		REP(i, 1, L) expand(str[i]), R[i] = last;
		REP(i, 1, n - 2) Rt[R[i]].insert(Pair(Suf :: R[i + 2], 0));
		REP(i, 1, m - 2) Rt[R[i + n + 1]].insert(Pair(Suf :: R[i + n + 3], 1));
		Rt[R[n - 1]].insert(Pair(1, 0));
		Rt[R[n + m]].insert(Pair(1, 1));
		if(n >= 2) Rt[1].insert(Pair(Suf :: R[2], 0));
		if(m >= 2) Rt[1].insert(Pair(Suf :: R[n + 3], 1));
		if(n >= 2 && m >= 2) Res[1] = max(Res[1], Suf :: Ask(Suf :: R[2], Suf :: R[n + 3]) + 1);
		
		REP(i, 1, n) HA[R[i]] = 1;
		REP(i, 1, m) HB[R[i + n + 1]] = 1;
		REP(i, 1, cnt) ID[i] = i;
		sort(ID + 1, ID + cnt + 1, cmp);
		int ans = 0;
		PER(i, cnt, 1){
			int u = ID[i], v = F[u];
			if(v){
				HA[v] |= HA[u];
				HB[v] |= HB[u];
				Res[v] = max(Res[v], Mer(Rt[v], Rt[u]));
			}
			if(HA[u] && HB[u]){
				ans = max(ans, Res[u] + S[u]);
			}
		}
		
		printf("%d\n", ans);
	}
}

int main(){
	scanf("%s", str1 + 1); n = strlen(str1 + 1);
	scanf("%s", str2 + 1); m = strlen(str2 + 1);
	if(min(n, m) == 1){
		puts("1");
		return 0;
	}
	L = n + m + 1;
	REP(i, 1, n) str[i] = str1[i] - 97;
	str[n + 1] = 26;
	REP(i, n + 2, L) str[i] = str2[i - n - 1] - 97;
	Suf :: Main();
	Pre :: Main();
	return 0;
}



Problem3152
#include<cstdio>
#include<cctype>
#include<queue>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=200000+19;
int A[N],T,n;

int Calc()
{
	if (n==1) return 0;
	int res=1,Ans=0;
	priority_queue<int> Q;
	For(i,1,n)
	{
		Q.push(A[i]);
		if (--res==0)
			if (Q.top()==1) return -1;
				else Ans++,res=Q.top()-1,Q.pop();
	}
	return Ans;
}

int main()
{
	for (read(T);T--;)
	{
		read(n);
		For(i,1,n+1) read(A[i]);
		printf("%d\n",Calc());
	}
}
Problem3153
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define mp make_pair
#define fir first
#define sec second
using namespace std;

typedef long long LL;
typedef double Db;

const int N=200000+19,oo=(1<<30)-1,Len=8000000;
struct Edge {int y,nxt;} E[N*2];
int Last[N],n,Qc,opt,x,y,z,cnt;
char Buf[Len],*b=Buf+Len;
struct node;

inline int ch()
{
	if (b==Buf+Len) fread(Buf,1,Len,stdin),b=Buf;
	return *b++;
}
int IN()
{
	int c,f,x;
	while (!isdigit(c=ch())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=ch())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}
void Print(int x)
{
	if (x>=10) Print(x/10);
	putchar(x%10+'0');
}

struct Treap *nul;
struct Treap
{
	Treap *L,*R;
	node *x;
	int fix,key,S;
	int Set,Add;
	int __Size,__Min,__Max,__Sum;
	int Size,Min,Max,Sum;

	void Update()
	{
		if (this==nul) return;
		S=L->S+R->S+1;
		Size=L->Size+R->Size+__Size;
		Min=min(min(L->Min,R->Min),__Min);
		Max=max(max(L->Max,R->Max),__Max);
		Sum=L->Sum+R->Sum+__Sum;
	}
	void Reset(int Sz,int Mn,int Mx,int Sm)
	{
		__Size=Sz,__Min=Mn,__Max=Mx,__Sum=Sm;
		Update();
	}
	void Cover(int v)
	{
		if (this==nul||!Size) return;
		Set=v,Add=0;
		if (__Size) __Min=__Max=v,__Sum=v*__Size;
		Min=Max=v;
		Sum=v*Size;
	}
	void Plus(int v)
	{
		if (this==nul||!Size) return;
		if (Set) Set+=v;else Add+=v;
		if (__Size) __Min+=v,__Max+=v,__Sum+=v*__Size;
		Min+=v,Max+=v;
		Sum+=v*Size;
	}
	void Down();
} Tnd[2*N],*cur=Tnd+1;
typedef pair<Treap*,Treap*> Ptt;

Treap *TNew(int pos,int v)
{
	Treap *x=cur++;
	x->L=x->R=nul;
	x->fix=~v?rand():-1;
	x->key=pos;
	x->Set=-1,x->Add=0;
	if (~v) x->__Size=1,x->__Min=x->__Max=x->__Sum=v;
		else x->__Size=0,x->__Min=oo,x->__Max=-oo,x->__Sum=0;
	return x->Update(),x;
}
Treap *Merge(Treap *A,Treap *B)
{
	if (A==nul) return B;
	if (B==nul) return A;
	A->Down(),B->Down();
	if (A->fix<B->fix) return A->R=Merge(A->R,B),A->Update(),A;
		else return B->L=Merge(A,B->L),B->Update(),B;
}
Ptt Split(Treap *A,int k)
{
	if (A==nul) return mp(nul,nul);
	Ptt Ans;A->Down();
	if (k<=A->L->S) Ans=Split(A->L,k),A->L=Ans.sec,A->Update(),Ans.sec=A;
		else Ans=Split(A->R,k-A->L->S-1),A->R=Ans.fir,A->Update(),Ans.fir=A;
	return Ans;
}
int Rank(Treap *x,int v)
{
	if (x==nul) return 0;
	x->Down();
	return v<x->key?Rank(x->L,v):Rank(x->R,v)+x->L->S+1;
}
void Ins(Treap *&x,Treap *y)
{
	Ptt A;
	A=Split(x,Rank(x,y->key));
	x=Merge(Merge(A.fir,y),A.sec);
}
void Del(Treap *&x,Treap *y)
{
	Ptt A,B;
	A=Split(x,Rank(x,y->key)-1);
	B=Split(A.sec,1);
	x=Merge(A.fir,B.sec);
}

struct node *null;
struct node
{
	node *L,*R,*Fa;
	Treap *t,*x;
	int rev,Add,Set,AddT,SetT;
	int key;
	int Size,Sum,Min,Max,SizeT,SumT,MinT,MaxT;
	
	void Reset()
	{
		x->Reset(Size+SizeT,min(Min,MinT),max(Max,MaxT),Sum+SumT);
	}
	bool Top(node *Aim)
	{
		return Aim==null?Fa==null||Fa->L!=this&&Fa->R!=this:Fa==Aim;
	}
	void Update()
	{
		if (this==null) return;
		Size=L->Size+R->Size+1;
		Sum=L->Sum+R->Sum+key;
		Min=min(min(L->Min,R->Min),key);
		Max=max(max(L->Max,R->Max),key);

		SizeT=L->SizeT+R->SizeT+t->Size;
		SumT=L->SumT+R->SumT+t->Sum;
		MinT=min(min(L->MinT,R->MinT),t->Min);
		MaxT=max(max(L->MaxT,R->MaxT),t->Max);
	}
	void Reverse() {rev^=1,swap(L,R);}
	void Cover(int v)
	{
		if (this==null) return;
		Set=v,Add=0;
		Sum=v*Size;
		Min=Max=key=v;
	}
	void Plus(int v)
	{
		if (this==null) return;
		if (Set) Set+=v;else Add+=v;
		Sum+=v*Size;
		Min+=v,Max+=v,key+=v;
	}
	void CoverTree(int v)
	{
		if (this==null||!SizeT) return;
		SetT=v,AddT=0;
		t->Cover(v);
		MinT=MaxT=v;
		SumT=SizeT*v;
	}
	void PlusTree(int v)
	{
		if (this==null||!SizeT) return;
		if (SetT) SetT+=v;else AddT+=v;
		t->Plus(v);
		MinT+=v,MaxT+=v;
		SumT+=SizeT*v;
	}
	void Down()
	{
		if (this==null) return;
		if (rev) L->Reverse(),R->Reverse(),rev=0;
		if (Set) L->Cover(Set),R->Cover(Set),Set=0;
		if (Add) L->Plus(Add),R->Plus(Add),Add=0;
		if (SetT) L->CoverTree(SetT),R->CoverTree(SetT),SetT=0;
		if (AddT) L->PlusTree(AddT),R->PlusTree(AddT),AddT=0;
	}
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y,y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y,y->Fa=this;y->Update();
	}
} Nd[N];

void Splay(node *x,node *Aim=null)
{
	static node *S[N];node *tmp=x;int k=0;
	while (!tmp->Top(Aim)) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (!x->Top(Aim))
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top(Aim))
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}
node *Left(node *x)
{
	x->Down();
	while (x->L!=null) x=x->L,x->Down();
	return x;
}
node *Right(node *x)
{
	x->Down();
	while (x->R!=null) x=x->R,x->Down();
	return x;
}
node *Father(node *x) {while (!x->Top(null)) x=x->Fa;return x;}
node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa)
	{
		Splay(x);
		if (y!=null) Del(x->t,Left(y)->x);
		node *z=Left(x->R);
		if (z!=null) Splay(z,x),z->Reset(),Ins(x->t,z->x);
		x->R=y,x->Update();
	}
	return y;
}

void Treap::Down()
{
	if (this==nul) return;
	if (Set)
	{
		L->Cover(Set),R->Cover(Set);
		node *u=Father(L->x),*v=Father(R->x);
		u->Cover(Set),u->CoverTree(Set);
		v->Cover(Set),v->CoverTree(Set);
		Set=0;
	}
	if (Add)
	{
		L->Plus(Add),R->Plus(Add);
		node *u=Father(L->x),*v=Father(R->x);
		u->Plus(Add),u->PlusTree(Add);
		v->Plus(Add),v->PlusTree(Add);
		Add=0;
	}
}

void QueryTree(node *x)
{
	int Ans;
	Access(x),Splay(x);
	if (opt==3) Ans=min(x->t->Min,x->key);
	if (opt==4) Ans=max(x->t->Max,x->key);
	if (opt==11) Ans=x->t->Sum+x->key;
	Print(Ans),puts("");
}
void ModifyTree(node *x,int v)
{
	Access(x),Splay(x);
	if (opt==0) x->t->Cover(v),x->key=v;
	if (opt==5) x->t->Plus(v),x->key+=v;
	x->Update();
}
void Evert(node *x) {Access(x)->Reverse();}
void QueryChain(node *x,node *y)
{
	node *z;int Ans;
	Access(x),z=Access(y);
	Ans=z->key,z=z->R;
	if (opt==7) Ans=min(Ans,z->Min);
	if (opt==8) Ans=max(Ans,z->Max);
	if (opt==10) Ans=Ans+z->Sum;
	z=Access(x)->R;
	if (opt==7) Ans=min(Ans,z->Min);
	if (opt==8) Ans=max(Ans,z->Max);
	if (opt==10) Ans=Ans+z->Sum;
	Print(Ans),puts("");
}
void ModifyChain(node *x,node *y,int v)
{
	node *z;
	Access(x),z=Access(y);
	if (opt==2) z->key=v,z->R->Cover(v);else z->key+=v,z->R->Plus(v);
	z->Update();
	z=Access(x);
	if (opt==2) z->R->Cover(v);else z->R->Plus(v);
	z->Update();
}
void Change(node *x,node *y)
{
	Access(y),Splay(x);
	if (Father(y)==x) return;
	Access(x),Splay(x);
	x->L->Fa=null;
	x->L=null,x->Update();
	x->Reset();
	Access(y),Splay(y),x->Fa=y,y->R=x,y->Update();
}

void New(int pos,int v)
{
	node *x=Nd+pos;
	x->L=x->R=x->Fa=null;
	x->Set=x->SetT=-1;
	x->t=TNew(0,-1);
	x->x=TNew(pos,v);
	x->t->x=x->x->x=x;
	x->key=v;
	x->Update();
}
void Init()
{
	null=Nd;nul=Tnd;
	
	null->L=null->R=null->Fa=null;
	null->t=null->x=nul;
	null->Min=null->MinT=oo;
	null->Max=null->MaxT=-oo;
	nul->L=nul->R=nul;
	nul->x=null;
	nul->Min=oo;
	nul->Max=-oo;
	
	For(i,1,n+1) New(i,IN());
}
void DFS(node *x)
{
	for (int i=Last[x-Nd],y;~i;i=E[i].nxt)
		if ((y=E[i].y)!=x->Fa-Nd)
		{
			node *d=Nd+y;
			d->Fa=x;
			DFS(d);
			Ins(x->t,d->x);
		}
	x->x->Reset(x->t->Size+1,min(x->key,x->t->Min),max(x->key,x->t->Max),x->key+x->t->Sum);
	x->Update();
}
void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),Qc=IN();
	For(i,1,n) Link(IN(),IN());
	Init();
	DFS(Nd+IN());
	while (Qc--)
	{
		opt=IN();
		if (opt==0||opt==5) x=IN(),y=IN(),ModifyTree(Nd+x,y);
		if (opt==1) Evert(Nd+IN());
		if (opt==2||opt==6) x=IN(),y=IN(),z=IN(),ModifyChain(Nd+x,Nd+y,z);
		if (opt==3||opt==4||opt==11) QueryTree(Nd+IN());
		if (opt==7||opt==8||opt==10) QueryChain(Nd+IN(),Nd+IN());
		if (opt==9) x=IN(),y=IN(),Change(Nd+x,Nd+y);
	}
}
Problem3155
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

typedef long long LL;
typedef double Db;

const int N=100000+19;
int A[N],n,Q,x,v;
char s[30];

struct BIT
{
	LL C[N];
	void Add(int x,LL v) {for (;x<=n;x+=x&-x) C[x]+=v;}
	LL Query(int x) {LL Ans=0;for (;x;x-=x&-x) Ans+=C[x];return Ans;}
} B1,B2;

int main()
{
	n=IN(),Q=IN();
	For(i,1,n+1) A[i]=IN(),B1.Add(i,A[i]),B2.Add(i,1LL*A[i]*i);
	while (Q--)
	{
		scanf("%s",s);x=IN();
		if (s[0]=='Q') printf("%lld\n",1LL*(x+1)*B1.Query(x)-B2.Query(x));
			else
			{
				v=IN();
				B1.Add(x,v-A[x]),B2.Add(x,1LL*(v-A[x])*x);
				A[x]=v;
			}
	}
}
Problem3156
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=1000000+19,oo=(1<<30)-1;
typedef long long LL;
LL F[Maxn],A[Maxn],n,L,R,Q[Maxn];
int c;

double x(LL a) {return double(a);}
double y(LL a) {return double(F[a]+a*a/2.-a/2.);}
double g(LL j,LL k) {return (y(j)-y(k))/(x(j)-x(k));}
LL Get_F(LL j,LL i) {return F[j]+(j-i)*(j-i-1)/2+A[i];}
void Read(LL &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) Read(A[i]);
	F[n]=A[n];
	Q[L=R=1]=n;
	for (LL i=n-1;i>=0;i--)
	{
		while (L<R&&Get_F(Q[L],i)>Get_F(Q[L+1],i)) L++;
		F[i]=Get_F(Q[L],i);
		while (L<R&&g(Q[R],Q[R-1])<g(i,Q[R])) R--;
		Q[++R]=i;
	}
	printf("%lld\n",F[0]);
	return 0;
}
Problem3157
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

typedef long long LL;
typedef double Db;

const int N=1000+19,P=1e9+7;
int f[N],C[N][N],tmp,n,m;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}

int main()
{
	n=IN(),m=IN();
	if (m==1) return printf("%d\n",1LL*n*(n+1)/2%P),0;
	tmp=Pow(m,n+1);
	f[0]=1LL*(tmp-m+P)*Pow(m-1,P-2)%P;
	For(i,0,m+1)
	{
		C[i][0]=1;
		For(j,1,i+1) C[i][j]=(C[i-1][j]+C[i-1][j-1])%P;
	}
	For(k,1,m+1)
	{
		f[k]=tmp=1LL*tmp*n%P;
		For(j,0,k) f[k]=(f[k]+1LL*C[k][j]*((k-j)&1?-1:1)*f[j]%P+P)%P;
		f[k]=1LL*f[k]*Pow(m-1,P-2)%P;
	}
	printf("%d\n",f[m]);
}
Problem3158
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=1000+19,oo=(1<<30)-1;
typedef long long LL;
typedef int one[Maxn];
one Last,Q,Dis,A,B;
struct Edge {int y,f,nxt;} E[1000000+19];
int n,sum,S,T,cnt,f,w;

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}
void Check(int i,int j)
{
	if ((A[i]&1)==(A[j]&1)) return;
	LL x=1LL*A[i]*A[i]+1LL*A[j]*A[j];
	if (fabs(LL(sqrt(x))-sqrt(x))>1e-8||gcd(A[i],A[j])>1) return;
	if (A[j]&1) swap(i,j);
	Add_Edge(i,j,oo);
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	f=1;w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			res+=tmp,Flow-=tmp;
			E[i].f-=tmp;E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&A[i]);
	for (int i=1;i<=n;i++) scanf("%d",&B[i]),sum+=B[i];
	S=n+1;T=n+2;
	for (int i=1;i<=n;i++)
	{
		(A[i]&1)?Add_Edge(S,i,B[i]):Add_Edge(i,T,B[i]);
		for (int j=1;j<i;j++) Check(i,j);
	}
	while (BFS()) sum-=Dinic(S,oo);
	printf("%d\n",sum);
}
Problem3159
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=100000+19,oo=(1<<30)-1;

struct Edge{
	int y,nxt;
} E[N*2];
int Last[N];
int n,Qc,cnt,x,y,z;
char s[20];

void Link(int x,int y){
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}

struct node *null;
struct node{
	node *L,*R,*Fa,*rt;
	int key,rev,add;
	int sz,Max,Min;
	ll Sum;
	bool Top(int f){
		if (f) return Fa==null||Fa->L!=this&&Fa->R!=this;
		return Fa==null;
	}
	void Update(){
		if (this==null) return;
		sz=L->sz+R->sz+1;
		Sum=L->Sum+R->Sum+key;
		Max=max(max(L->Max,R->Max),key);
		Min=min(min(L->Min,R->Min),key);
	}
	void Plus(int v){
		if (this==null) return;
		Sum+=1ll*v*sz;
		Max+=v,Min+=v,add+=v,key+=v;
	}
	void Reverse(){
		rev^=1,swap(L,R);
	}
	void Down(){
		if (this==null) return;
		if (rev) L->Reverse(),R->Reverse(),rev=0;
		if (add) L->Plus(add),R->Plus(add),add=0;
	}
	void Zig(){
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag(){
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y,y->Fa=this;y->Update();
	}
} Nd[N];

void Splay(node *x){
	static node *S[N];
	node *tmp=x;int k=0,f=(x-Nd<=n);
	while (!tmp->Top(f)) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	node *r=tmp->rt;
	r->rt=x;tmp->rt=0x0;x->rt=r;
	while (!x->Top(f)){
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top(f))
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}
int getrank(node *x){
	Splay(x);
	return x->L->sz+1;
}
node *findkth(node *x,int k){
	if (k==x->L->sz+1) return x;
	x->Down();
	return k<=x->L->sz?findkth(x->L,k):findkth(x->R,k-x->L->sz-1);
}
node *Access(node *x){
	node *y=null,*z,*a,*b;
	for (;x!=null;y=x,x=x->Fa){
		Splay(x);
		z=x->R;
		a=findkth(x->rt,x->L->sz+1);
		Splay(a);
		b=a->R;a->R=b->Fa=null;a->Update();
		if (z!=null){
			b->rt=z;z->rt=b;
		}
		x->R=y;
		a=findkth(x->rt,x->rt->sz);
		Splay(a);
		b=y->rt;a->R=b;a->Update();
		if (b!=null){
			b->Fa=a;
			b->rt=null,y->rt=null;
		}
		x->Update();
	}
	return y;
}
void Evert(node *x){
	x=Access(x);
	x->rt->Reverse();
	x->Reverse();
}
void dfs(int x,int fa){
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if ((y=E[i].y)!=fa){
			dfs(y,x);
			Nd[y].Fa=Nd+x;
		}
}

int main(){
	null=Nd;
	*null=(node){null,null,null,null,0,0,0,0,-oo,oo,0};
	For(i,1,N){
		Nd[i]=(node){null,null,null,null,0,0,0,1,0,0,0};
	}
	memset(Last,-1,sizeof(Last));
	n=IN(),Qc=IN(),IN();
	For(i,1,n) Link(IN(),IN());
	For(i,1,n+1){
		Nd[i].rt=Nd+i+n;
		Nd[i+n].rt=Nd+i;
	}
	dfs(1,-1);
	while (Qc--){
		scanf("%s",s);
		if (s[2]=='c'){
			x=IN(),y=IN(),z=IN();
			Evert(Nd+x);
			Access(Nd+y)->rt->Plus(z);
		}
		if (s[2]=='m'){
			x=IN(),y=IN();
			Evert(Nd+x);
			printf("%lld\n",Access(Nd+y)->rt->Sum);
		}
		if (s[2]=='j'){
			x=IN(),y=IN();
			Evert(Nd+x);
			printf("%d\n",Access(Nd+y)->rt->Max);
		}
		if (s[2]=='n'){
			x=IN(),y=IN();
			Evert(Nd+x);
			printf("%d\n",Access(Nd+y)->rt->Min);			
		}
		if (s[2]=='v'){
			x=IN(),y=IN();
			Evert(Nd+x);
			Access(Nd+y)->rt->Reverse();
		}
	}
}
Problem3159
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

const int len=200000;
inline char nc(){
	static char buf[len],*b=buf+len;
	if (b==buf+len) fread(buf,1,len,stdin),b=buf;
	return *b++;
}
int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=100000+19,oo=(1<<30)-1;

struct Edge{
	int y,nxt;
} E[N*2];
int Last[N];
int n,Qc,cnt,x,y,z;
char s[20];

void Link(int x,int y){
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}

struct node *null;
struct node{
	node *L,*R,*Fa,*rt;
	int key,rev,add;
	int sz,Max,Min;
	ll Sum;
	bool Top(int f){
		if (f) return Fa==null||Fa->L!=this&&Fa->R!=this;
		return Fa==null;
	}
	void Update(){
		if (this==null) return;
		sz=L->sz+R->sz+1;
		Sum=L->Sum+R->Sum+key;
		Max=max(max(L->Max,R->Max),key);
		Min=min(min(L->Min,R->Min),key);
	}
	void Plus(int v){
		if (this==null) return;
		Sum+=1ll*v*sz;
		Max+=v,Min+=v,add+=v,key+=v;
	}
	void Reverse(){
		rev^=1,swap(L,R);
	}
	void Down(){
		if (this==null) return;
		if (rev) L->Reverse(),R->Reverse(),rev=0;
		if (add) L->Plus(add),R->Plus(add),add=0;
	}
	void Zig(){
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag(){
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y,y->Fa=this;y->Update();
	}
} Nd[N];

void Splay(node *x){
	static node *S[N];
	node *tmp=x;int k=0,f=(x-Nd<=n);
	while (!tmp->Top(f)) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	node *r=tmp->rt;
	r->rt=x;tmp->rt=0x0;x->rt=r;
	while (!x->Top(f)){
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top(f))
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}
int getrank(node *x){
	Splay(x);
	return x->L->sz+1;
}
node *findkth(node *x,int k){
	if (k==x->L->sz+1) return x;
	x->Down();
	return k<=x->L->sz?findkth(x->L,k):findkth(x->R,k-x->L->sz-1);
}
node *Access(node *x){
	node *y=null,*z,*a,*b;
	for (;x!=null;y=x,x=x->Fa){
		Splay(x);
		z=x->R;
		a=findkth(x->rt,x->L->sz+1);
		Splay(a);
		b=a->R;a->R=b->Fa=null;a->Update();
		if (z!=null){
			b->rt=z;z->rt=b;
		}
		x->R=y;
		a=findkth(x->rt,x->rt->sz);
		Splay(a);
		b=y->rt;a->R=b;a->Update();
		if (b!=null){
			b->Fa=a;
			b->rt=null,y->rt=null;
		}
		x->Update();
	}
	return y;
}
void Evert(node *x){
	x=Access(x);
	x->rt->Reverse();
	x->Reverse();
}
void dfs(int x,int fa){
	for (int i=Last[x],y;~i;i=E[i].nxt)
		if ((y=E[i].y)!=fa){
			dfs(y,x);
			Nd[y].Fa=Nd+x;
		}
}

int main(){
	null=Nd;
	*null=(node){null,null,null,null,0,0,0,0,-oo,oo,0};
	For(i,1,N){
		Nd[i]=(node){null,null,null,null,0,0,0,1,0,0,0};
	}
	memset(Last,-1,sizeof(Last));
	n=IN(),Qc=IN(),IN();
	For(i,1,n) Link(IN(),IN());
	For(i,1,n+1){
		Nd[i].rt=Nd+i+n;
		Nd[i+n].rt=Nd+i;
	}
	dfs(1,-1);
	while (Qc--){
		scanf("%s",s);
		if (s[2]=='c'){
			x=IN(),y=IN(),z=IN();
			Evert(Nd+x);
			Access(Nd+y)->rt->Plus(z);
		}
		if (s[2]=='m'){
			x=IN(),y=IN();
			Evert(Nd+x);
			printf("%lld\n",Access(Nd+y)->rt->Sum);
		}
		if (s[2]=='j'){
			x=IN(),y=IN();
			Evert(Nd+x);
			printf("%d\n",Access(Nd+y)->rt->Max);
		}
		if (s[2]=='n'){
			x=IN(),y=IN();
			Evert(Nd+x);
			printf("%d\n",Access(Nd+y)->rt->Min);			
		}
		if (s[2]=='v'){
			x=IN(),y=IN();
			Evert(Nd+x);
			Access(Nd+y)->rt->Reverse();
		}
	}
}
Problem3160
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int P=1e9+7,Len=100000+19;
int C[Len],p[Len*2],Ans,L,Max,ID;
char s[Len],t[2*Len];

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}

//FFT
const int N=100000*4+19;
typedef double Db;
const Db Pi=acos(-1.0);
struct Comp
{
	Db re,im;
	Comp() {}
	Comp(Db r,Db i) {re=r,im=i;}
} W[2][N],A[N],B[N];
int n,c,rev[N];

Comp operator + (Comp A,Comp B) {return Comp(A.re+B.re,A.im+B.im);}
Comp operator - (Comp A,Comp B) {return Comp(A.re-B.re,A.im-B.im);}
Comp operator * (Comp A,Comp B) {return Comp(A.re*B.re-A.im*B.im,A.re*B.im+A.im*B.re);}

void FFT(Comp *A,int f)
{
	Comp x,y;
	For(i,0,n) if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=0,l=0;k<i;k++,l+=t)
				x=A[j+k],y=W[f][l]*A[j+k+i],A[j+k]=x+y,A[j+k+i]=x-y;
	if (f) For(i,0,n) A[i].re/=n;
}

int main()
{
	scanf("%s",s);n=strlen(s);
	t[0]='?';t[++L]='#';
	For(i,0,n) t[++L]=s[i],t[++L]='#';
	For(i,0,n) A[i].re=(s[i]=='a'),B[i].re=(s[i]=='b');
	for (c=1;c<n;c<<=1);n=c<<1;
	For(i,0,n)
	{
		W[0][i]=W[1][i]=Comp(cos(2*Pi*i/n),sin(2*Pi*i/n));
		W[1][i].im*=-1;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|x&1;
	}
	FFT(A,0),FFT(B,0);
	For(i,0,n) A[i]=A[i]*A[i],B[i]=B[i]*B[i];
	FFT(A,1),FFT(B,1);
	For(i,0,n)
		C[i]+=int(A[i].re+0.5)/2+(i%2==0&&i/2<Len&&s[i/2]=='a'),
		C[i]+=int(B[i].re+0.5)/2+(i%2==0&&i/2<Len&&s[i/2]=='b');
	For(i,0,n) (Ans+=(Pow(2,C[i])-1+P)%P)%=P;
	For(i,1,L+1)
	{
		if (Max>i) p[i]=min(Max-i,p[2*ID-i]);else p[i]=1;
		while (t[i+p[i]]==t[i-p[i]]) p[i]++;
		if (i+p[i]>Max) Max=i+p[i],ID=i;
		Ans=(Ans-p[i]/2+P)%P;
	}
	printf("%d\n",Ans);
}
Problem3163
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define mp make_pair
#define pb push_back
#define fir first
#define sec second
#define Mid (L+R>>1)

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=1000+19,M=1000;

typedef int one[N];
vector<pii> V[N];
one A,B,C,F;
int n,Qc,d,e;
int Ans[int(3e5+19)];

void Calc(int L,int R,int *F)
{
	For(i,L,R+1)
	{
		int t=C[i];
		for (int j=0;(1<<j)<=t;j++)
		{
			for (int k=M;k>=(1<<j)*A[i];k--) F[k]=max(F[k],F[k-(1<<j)*A[i]]+(1<<j)*B[i]);
			t-=1<<j;
		}
		if (t)
		{
			for (int k=M;k>=t*A[i];k--) F[k]=max(F[k],F[k-t*A[i]]+t*B[i]);
		}
	}
}
void Work(int L,int R,int *F)
{
	if (L==R)
	{
		For(i,0,V[L].size()) Ans[V[L][i].fir]=F[V[L][i].sec];
		return;
	}
	int f[N];
	memcpy(f,F,sizeof(int)*N);
	Calc(Mid+1,R,F);
	Work(L,Mid,F);
	memcpy(F,f,sizeof(int)*N);
	Calc(L,Mid,F);
	Work(Mid+1,R,F);
}

int main()
{
	n=IN();
	For(i,1,n+1) A[i]=IN(),B[i]=IN(),C[i]=IN();
	Qc=IN();
	For(i,1,Qc+1) d=IN(),e=IN(),V[d+1].pb(mp(i,e));
	Work(1,n,F);
	For(i,1,Qc+1) printf("%d\n",Ans[i]);
}
Problem3166
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=50000+19,Tot=10000000;
int A[N],Q[N],L[N],R[N];
int rt[Tot],S[Tot],son[Tot][2];
int n,tot,f,w,Ans;

void Insert(int y,int &x,int t,int a)
{
	S[x=++tot]=S[y]+1;
	if (a==-1) return;
	son[x][0]=son[y][0];son[x][1]=son[y][1];
	Insert(son[y][t>>a&1],son[x][t>>a&1],t,a-1);
}
int Query(int L,int R,int t)
{
	int res=0;
	for (int i=30;i>=0;i--)
	{
		int v=(t>>i&1)^1;
		if (S[son[R][v]]-S[son[L][v]]) res|=1<<i;else v^=1;
		L=son[L][v],R=son[R][v];
	}
	return res;
}

int Sl(int x,int v) {return x<1||A[x]>v?x:Sl(L[x],v);}
int Sr(int x,int v) {return x>n||A[x]>v?x:Sr(R[x],v);}

int main()
{
	read(n);
	For(i,1,n+1) read(A[i]),Insert(rt[i-1],rt[i],A[i],30);

	f=0,w=1;
	For(i,1,n+1)
	{
		while (f>=w&&A[Q[f]]<A[i]) f--;Q[++f]=i;
		L[i]=(f>w?Q[f-1]:0);
	}
	f=0,w=1;
	for (int i=n+1;i;i--)
	{
		while (f>=w&&A[Q[f]]<A[i]) f--;Q[++f]=i;
		R[i]=(f>w?Q[f-1]:n+1);
	}

	For(i,1,n+1)
	{
		if (L[i]>=1) Ans=max(Ans,Query(rt[Sl(L[i]-1,A[i])],rt[R[i]-1],A[i]));
		if (R[i]<=n) Ans=max(Ans,Query(rt[L[i]],rt[Sr(R[i]+1,A[i])-1],A[i]));
	}
	printf("%d\n",Ans);
}
Problem3169
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

typedef long long LL;
typedef double Db;

const int N=100000+19,M=1000000+19;
struct Edge {int y,nxt;} E[M];
int Last[N],In[N],pin[N],c[N];
int n,m,cnt,Ans=(1<<30)-1;
queue<int> Q[3];

void Add_Edge(int y,int x)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;In[y]++;
}

int Work(int col)
{
	For(i,1,n+1) if (In[i]==0) Q[c[i]].push(i);
	int res=0;
	while (!Q[1].empty()||!Q[2].empty())
	{
		if (Q[col].empty()) {res++;col^=3;continue;}
		while (!Q[col].empty())
		{
			int x=Q[col].front();Q[col].pop();
			for (int i=Last[x];~i;i=E[i].nxt)
				if (--In[E[i].y]==0) Q[c[E[i].y]].push(E[i].y);
		}
	}
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN();
	For(i,1,n+1) c[i]=IN();
	For(i,0,m) Add_Edge(IN(),IN());
	memcpy(pin,In,sizeof(In));	Ans=min(Ans,Work(1));
	memcpy(In,pin,sizeof(pin));	Ans=min(Ans,Work(2));
	printf("%d\n",Ans);
}
Problem3170
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Rep(i,x,y) for (int i=x;i>y;i--)
#define CH isdigit(c=getchar())
using namespace std;

int IN()
{
	int c,f,x;
	while (!CH&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (CH) x=x*10+c-'0';return !f?x:-x;
}

const int N=1e5+19;
struct node {double x,y;int ID;} A[N];
double Px[N],Sx[N],Py[N],Sy[N],Ans=1e60;
int n,a,b,t;

bool cmpx(const node& A,const node& B) {return A.x<B.x;}
bool cmpy(const node& A,const node& B) {return A.y<B.y;}

int main()
{
	n=IN();
	For(i,1,n+1) a=IN(),b=IN(),A[i]=(node){a+b,a-b,i};
	sort(A+1,A+n+1,cmpx);
	For(i,1,n+1) Px[A[i].ID]=Px[A[i-1].ID]+(A[i].x-A[i-1].x)*(i-1);
	Rep(i,n,0) Sx[A[i].ID]=Sx[A[i+1].ID]+(A[i+1].x-A[i].x)*(n-i);
	sort(A+1,A+n+1,cmpy);
	For(i,1,n+1) Py[A[i].ID]=Py[A[i-1].ID]+(A[i].y-A[i-1].y)*(i-1);
	Rep(i,n,0) Sy[A[i].ID]=Sy[A[i+1].ID]+(A[i+1].y-A[i].y)*(n-i);
	For(i,1,n+1) Ans=min(Ans,Px[i]+Sx[i]+Py[i]+Sy[i]);
	printf("%.0lf\n",Ans/2.0);
}
Problem3171
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int K=20,N=K*K*2+19,oo=(1<<30)-1;
struct Edge {int y,f,c,nxt;} E[K*K*12];
typedef int one[N];
one Last,vis,Q,Dis,pre;
int ID[K][K],n,m,tot,cnt,Cost,S,T,f,w;
char s[K][K];

void Add_Edge(int x,int y,int f,int c)
{
	E[cnt]=(Edge){y,f,c,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,-c,Last[y]};Last[y]=cnt++;
}
bool SPFA()
{
	memset(Dis,64,sizeof(Dis));Dis[S]=0;
	Q[w=0,f=1]=S,pre[S]=-1;
	while (f>w)
	{
		int x=Q[++w];vis[x]=0;
		for (int i=Last[x];~i;i=E[i].nxt)
			if (E[i].f&&Dis[x]+E[i].c<Dis[E[i].y])
			{
				Dis[E[i].y]=Dis[x]+E[i].c,pre[E[i].y]=i;
				if (!vis[E[i].y]) vis[E[i].y]=1,Q[++f]=E[i].y;
			}
	}
	return Dis[T]<oo;
}
void Update()
{
	int Min=oo;
	for (int i=pre[T];~i;i=pre[E[i^1].y]) Min=min(Min,E[i].f);
	for (int i=pre[T];~i;i=pre[E[i^1].y]) E[i].f-=Min,E[i^1].f+=Min;
	Cost+=Min*Dis[T];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	S=n*m*2+1,T=S+1;
	For(i,0,n) For(j,0,m)
		ID[i][j]=++tot,Add_Edge(S,tot,1,0),Add_Edge(tot+n*m,T,1,0);
	For(i,0,n) scanf("%s",s[i]);
	For(i,0,n) For(j,0,m)
	{
		int x=ID[i][j],c=s[i][j];
		Add_Edge(x,ID[i][(j+m-1)%m]+n*m,1,c!='L');
		Add_Edge(x,ID[i][(j+1)%m]+n*m,1,c!='R');
		Add_Edge(x,ID[(i+n-1)%n][j]+n*m,1,c!='U');
		Add_Edge(x,ID[(i+1)%n][j]+n*m,1,c!='D');
	}
	while (SPFA()) Update();
	printf("%d\n",Cost);
}
Problem3172
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;

const int Maxn=2000000+19;
typedef int one[Maxn];
struct Edge {int y,nxt;} E[Maxn];
one d,Q,Last,Ans,Fail;
int t[Maxn][26],ID[200+19],n,tot,f,w,x,cnt,c;

void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
void DFS(int x)
{
	for (int i=Last[x];~i;i=E[i].nxt) DFS(E[i].y),d[x]+=d[E[i].y];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);
	for (int T=1;T<=n;T++)
	{
		x=0;while (!isalpha(c=getchar()));
		for (;isalpha(c);c=getchar())
			{int &u=t[x][c-'a'];if (!u) u=++tot;x=u;d[x]++;}
		ID[T]=x;
	}
	for (Q[w=0,f=1]=0;f>w;)
	{
		int x=Q[++w];if (x) Add_Edge(Fail[x],x);
		for (int i=0;i<26;i++)
		{
			int& u=t[x][i];
			if (u) {Q[++f]=u;if (x) Fail[u]=t[Fail[x]][i];}
				else u=t[Fail[x]][i];
		}
	}
	DFS(0);
	for (int i=1;i<=n;i++) printf("%d\n",d[ID[i]]);
}
Problem3173
#include<cstdio>
#include<cctype>
#include<algorithm>

#define Fir first
#define Sec second
#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=100000+19;
//Treap
struct node *null,*Rt;typedef node* rt;
struct node
{
	rt L,R;
	int key,fix,S;
	void Update() {if (this!=null) S=L->S+R->S+1;}
} Nd[N];
typedef pair<rt,rt> Drt;
int A[N],f[N],tot,n;

rt Merge(rt A,rt B)
{
	if (A==null) return B; if (B==null) return A;
	if (A->fix<B->fix) return A->R=Merge(A->R,B),A->Update(),A;
		else return B->L=Merge(A,B->L),B->Update(),B;
}
Drt Split(rt A,int k)
{
	if (A==null) return Drt(null,null);
	Drt x;
	if (A->L->S>=k) x=Split(A->L,k),A->L=x.Sec,x.Sec=A,A->Update();
		else x=Split(A->R,k-A->L->S-1),A->R=x.Fir,x.Fir=A,A->Update();
	return x;
}
void Insert(rt A,int k) {Drt x=Split(Rt,k);Rt=Merge(Merge(x.Fir,A),x.Sec);}
void DFS(rt x)
{
	if (x->L!=null) DFS(x->L);
	A[++tot]=x->key;
	if (x->R!=null) DFS(x->R);
}

int C[N];
void Update(int x,int v) {for (;x<=n;x+=x&-x) C[x]=max(C[x],v);}
int Query(int x) {int Ans=0;for (;x;x-=x&-x) Ans=max(Ans,C[x]);return Ans;}

int main()
{
	Rt=null=Nd,null->S=0;null->L=null->R=null;
	n=IN();
	For(i,1,n+1)
		*(Nd+i)=(node){null,null,i,rand(),1},Insert(Nd+i,IN());
	DFS(Rt);
	For(i,1,n+1) f[A[i]]=Query(A[i]-1)+1,Update(A[i],f[A[i]]);
	for (int i=1,_=0;i<=n;i++) _=max(_,f[i]),printf("%d\n",_);
}
Problem3174
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=2000+19;
struct node
{
	int a,b;
	bool operator < (const node& B) const {return a+b<B.a+B.b;}
} A[N];
int f[100000+1],n,H,Ans;

int main()
{
	memset(f,-1,sizeof(f));f[0]=0;
	n=IN();
	For(i,1,n+1) A[i]=(node){IN(),IN()},f[0]+=A[i].a;
	sort(A+1,A+n+1);
	H=IN();
	For(i,1,n+1)
		for (int j=Ans;~j;j--)
		{
			if (f[j]+A[i].b>=H) f[j+1]=max(f[j+1],f[j]-A[i].a);
			if (f[Ans+1]>=0) Ans++;
		}
	printf("%d\n",Ans);
}
Problem3190
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=10000+19;
struct Line {int k,b,Dis;} A[Maxn],S[Maxn];
int n,top,Max=0;

int cmp_k(Line A,Line B) {return A.k<B.k||A.k==B.k&&A.b>B.b;}
int cmp_Dis(Line A,Line B) {return A.Dis<B.Dis;}
double Cross(Line A,Line B) {return double(A.b-B.b)/double(B.k-A.k);}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",&A[i].b),Max=max(Max,A[i].b);
	for (int i=0;i<n;i++) scanf("%d",&A[i].k),A[i].Dis=i+1;
	A[n]=(Line){0,Max,n+1};n++;
	sort(A,A+n,cmp_k);
	for (int i=0;i<n;i++)
	{
		if (top&&A[i].k==S[top].k) 
		{
			if (A[i].b==S[top].b) S[++top]=A[i];
			continue;
		}
		while (top>1&&Cross(A[i],S[top])<Cross(S[top],S[top-1])) top--;
		S[++top]=A[i];
	}
	sort(S+1,S+top+1,cmp_Dis);
	printf("%d\n",top-1);
	for (int i=1;i<top-1;i++) printf("%d ",S[i].Dis);
	printf("%d\n",S[top-1].Dis);
	return 0;
}
Problem3190
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

const int Maxn=10000+19;
struct Line {int k,b,Dis;} A[Maxn],S[Maxn];
int n,top,Max=0,c;

int cmp_k(Line A,Line B) {return A.k<B.k||A.k==B.k&&A.b>B.b;}
int cmp_Dis(Line A,Line B) {return A.Dis<B.Dis;}
double Cross(Line A,Line B) {return double(A.b-B.b)/double(B.k-A.k);}
void Read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) Read(A[i].b),Max=max(Max,A[i].b);
	for (int i=0;i<n;i++) Read(A[i].k),A[i].Dis=i+1;
	A[n]=(Line){0,Max,n+1};n++;
	sort(A,A+n,cmp_k);
	for (int i=0;i<n;i++)
	{
		if (top&&A[i].k==S[top].k) 
		{
			if (A[i].b==S[top].b) S[++top]=A[i];
			continue;
		}
		while (top>1&&Cross(A[i],S[top])<Cross(S[top],S[top-1])) top--;
		S[++top]=A[i];
	}
	sort(S+1,S+top+1,cmp_Dis);
	printf("%d\n",top-1);
	for (int i=1;i<top-1;i++) printf("%d ",S[i].Dis);
	printf("%d\n",S[top-1].Dis);
	return 0;
}
Problem3192
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=100000+19;
int A[Maxn],D[Maxn],C[Maxn],Pos[Maxn];
int n,m,pos;
long long Ans;

int Query(int x) {int Ans=0;while (x) Ans+=C[x],x-=x&-x;return Ans;}
void Del(int x) {while (x<=n+m) C[x]--,x+=x&-x;}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=n;i;i--) scanf("%d",&A[i]),D[i]=A[i];
	for (int i=n+1;i<=n+m;i++) scanf("%d",&A[i]),D[i]=A[i];
	sort(D+1,D+n+m+1);
	for (int i=1;i<=n+m;i++) Pos[A[i]=lower_bound(D+1,D+n+m+1,A[i])-D]=i;
	pos=n;
	for (int i=1;i<=n+m;i++) C[i]=i&-i;
	for (int i=n+m;i;i--) 
	{
		int x=Pos[i];
		if (x<=pos) Ans+=Query(pos)-Query(x);else Ans+=Query(x-1)-Query(pos);
		Del(x);pos=x;
	}
	printf("%lld\n",Ans);
}
Problem3196
#include<cstdio>
#include<cctype>
#include<algorithm>
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
#define Fir first
#define Sec second
using namespace std;

const int Maxn=50000+19;
typedef int one[Maxn];
one A,opt,Ql,Qr,Qk;
int D[Maxn*2];
int n,Q,cnt,Qx,t,_Ql,_Qr,Tl,Tr;

int f,c;
void read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=-1,x=0;else f=1,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';x=x*f;
}
int ID(int x) {return lower_bound(D,D+cnt,x)-D+1;}

struct Treap;typedef Treap* rt;
struct Treap
{
	rt L,R;
	int key,fix,size;
	Treap():fix(rand()),key(0),size(1),L(0),R(0) {}
	int sz() {return this?size:0;}
	void Update() {size=L->sz()+R->sz()+1;}
} treap[6000000];rt RT[Maxn*2*4];int tcnt;
typedef pair<rt,rt> Drt;

rt Merge(rt A,rt B)
{
	if (!A) return B;if (!B) return A;
	if (A->fix<B->fix) return A->R=Merge(A->R,B),A->Update(),A;
		else return B->L=Merge(A,B->L),B->Update(),B;
}
Drt Split(rt A,int k)
{
	if (!A) return Drt();
	Drt x;
	if (A->L->sz()>=k) x=Split(A->L,k),A->L=x.Sec,A->Update(),x.Sec=A;
		else x=Split(A->R,k-A->L->sz()-1),A->R=x.Fir,A->Update(),x.Fir=A;
	return x;
}
int Getr(rt A,int v)
{
	if (!A) return 0;
	return v<A->key?Getr(A->L,v):Getr(A->R,v)+A->L->sz()+1;
}
int Gets(rt A) {return Getr(A,Tr)-Getr(A,Tl-1);}
void Del(int t,int v)
{
	int k=Getr(RT[t],v);
	Drt x=Split(RT[t],k-1),y=Split(x.Sec,1);
	RT[t]=Merge(x.Fir,y.Sec);
}
void Ins(int t,int v)
{
	int k=Getr(RT[t],v);
	Drt x=Split(RT[t],k);
	rt y=&treap[++tcnt];y->key=v;
	RT[t]=Merge(Merge(x.Fir,y),x.Sec);
}

int Findkth(int k)
{
	int x=1,L=1,R=cnt,tmp;
	while (L!=R) (tmp=Gets(RT[Lsn]))>=k?(R=Mid,x=Lsn):(L=Mid+1,x=Rsn,k-=tmp);
	return D[L-1];
}
int Getsum(int x,int L,int R)
{
	if (_Ql<=L&&R<=_Qr) return Gets(RT[x]);
	int tmp=0;
	if (_Ql<=Mid) tmp+=Getsum(Lsn,L,Mid);
	if (_Qr>Mid) tmp+=Getsum(Rsn,Mid+1,R);
	return tmp;
}
int Getrank(int v) {_Ql=1,_Qr=v-1;return Getsum(1,1,cnt)+1;}
void Delete()
{
	int x=1,L=1,R=cnt;
    for (;;) {Del(x,Qx);if (L==R) break;t<=Mid?(R=Mid,x=Lsn):(L=Mid+1,x=Rsn);}
}
void Insert()
{
    int x=1,L=1,R=cnt;
    for (;;) {Ins(x,Qx);if (L==R) break;t<=Mid?(R=Mid,x=Lsn):(L=Mid+1,x=Rsn);}
}


int main()
{
	read(n),read(Q);
	for (int i=1;i<=n;i++) read(A[i]),D[cnt++]=A[i];
	for (int i=0;i<Q;i++)
	{
		read(opt[i]),read(Ql[i]),read(Qr[i]);
		if (opt[i]!=3) read(Qk[i]),D[cnt++]=Qk[i];else D[cnt++]=Qr[i];
	}
	sort(D,D+cnt);
	int _=cnt;cnt=0;
	for (int i=0;i<_;i++) if (D[i]!=D[i+1]) D[cnt++]=D[i];
	for (int i=1;i<=n;i++) Qx=i,t=ID(A[i]),Insert();
	for (int i=0;i<Q;i++)
	{
		if (opt[i]!=3) Tl=Ql[i],Tr=Qr[i];
		if (opt[i]==1) printf("%d\n",Getrank(ID(Qk[i])));
		if (opt[i]==2) printf("%d\n",Findkth(Qk[i]));
		if (opt[i]==3) Qx=Ql[i],t=ID(A[Qx]),Delete(),t=ID(Qr[i]),Insert(),A[Qx]=Qr[i];
		if (opt[i]==4) printf("%d\n",Findkth(Getrank(ID(Qk[i]))-1));
		if (opt[i]==5) printf("%d\n",Findkth(Getrank(ID(Qk[i])+1)));
	}
}
Problem3207
#include<cstdio>
#include<vector>
using namespace std;

const int Maxn=100000+19;
int A[30],C[Maxn];
vector<int> H[Maxn];
int n,x,y,m,k;

int Find(int St)
{
	for (int i=0;i<k;i++) if (C[i+St]!=A[i]) return 0;
	return 1;
}

int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for (int i=0;i<n;i++)
	{
		scanf("%d",&x);
		H[C[i]=x].push_back(i);
	}
	for (int i=0;i<m;i++)
	{
		scanf("%d%d",&x,&y);x--;y--;
		for (int i=0;i<k;i++) scanf("%d",&A[i]);
		int Ans=0;
		for (int i=0;i<H[A[0]].size();i++)
		if (H[A[0]][i]>=x&&H[A[0]][i]+k-1<=y)
		if (Find(H[A[0]][i])) {Ans=1; break;}
		printf("%s\n",Ans?"No": "Yes");
	}
}
Problem3207
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;

const int Maxn=100000+19;
struct node {int pos,nxt;} E[Maxn];
int A[30],C[Maxn],Last[Maxn];
int n,x,y,m,k,cnt;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
int Find(int St)
{
	for (int i=0;i<k;i++) if (C[i+St]!=A[i]) return 0;
	return 1;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n),read(m),read(k);
	for (int i=0;i<n;i++)
	{
		read(C[i]);
		E[cnt]=(node){i,Last[C[i]]};Last[C[i]]=cnt++;
	}
	for (int i=0;i<m;i++)
	{
		read(x),read(y),x--;y--;
		for (int i=0;i<k;i++) read(A[i]);
		int Ans=0;
		for (int i=Last[A[0]];i!=-1;i=E[i].nxt)
			if (E[i].pos+k-1<=y)
				if (E[i].pos>=x)
				{
					if (Find(E[i].pos)) {Ans=1;break;}
				} else break;
		puts(Ans?"No":"Yes");
	}
}
Problem3208
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=700+19;
typedef int two[Maxn][Maxn];
two A,can,F;int n,Q,a,b,c,d;
int Dx[4]={1,0,-1,0},Dy[4]={0,1,0,-1};
char s[3];

int ch;
void read(int &x)
{
	while (!isdigit(ch=getchar()));x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
}

int DFS(int x,int y)
{
	if (F[x][y]!=-1) return F[x][y];
	int& t=F[x][y];t=1;
	if (!can[x][y]) return t=0;
	for (int i=0;i<4;i++)
	{
		int nx=x+Dx[i],ny=y+Dy[i];
		if (nx>=1&&nx<=n&&ny>=1&&ny<=n&&A[nx][ny]<A[x][y]) t=max(t,DFS(nx,ny)+1);
	}
	return t;
}

int main()
{
	read(n);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++) read(A[i][j]),can[i][j]=1;
	read(Q);
	while (Q--)
	{
		scanf("%s",s);
		if (s[0]=='Q')
		{
			memset(F,-1,sizeof(F));
			int Ans=0;
			for (int i=1;i<=n;i++)
				for (int j=1;j<=n;j++) Ans=max(Ans,DFS(i,j));
			printf("%d\n",Ans);
		} else if (s[0]=='C') read(a),read(b),read(c),A[a][b]=c;else
		{
			read(a),read(b),read(c),read(d);
			for (int i=a;i<=c;i++)
				for (int j=b;j<=d;j++) can[i][j]=(s[0]=='B');
		}
	}
}
Problem3208
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=700+19;
typedef int two[Maxn][Maxn];
two A,F;int n,Q,a,b,c,d;
bool can[Maxn][Maxn];
int Dx[4]={1,0,-1,0},Dy[4]={0,1,0,-1};

int ch,s;
void read(int &x)
{
	while (!isdigit(ch=getchar()));x=ch-'0';
	while (isdigit(ch=getchar())) x=x*10+ch-'0';
}

int DFS(int x,int y)
{
	if (F[x][y]!=-1) return F[x][y];
	int& t=F[x][y];t=1;
	if (!can[x][y]) return t=0;
	for (int i=0;i<4;i++)
	{
		int nx=x+Dx[i],ny=y+Dy[i];
		if (nx>=1&&nx<=n&&ny>=1&&ny<=n&&A[nx][ny]<A[x][y]) t=max(t,DFS(nx,ny)+1);
	}
	return t;
}

int main()
{
	read(n);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++) read(A[i][j]),can[i][j]=1;
	read(Q);
	while (Q--)
	{
		while ((s=getchar())!='Q'&&s!='S'&&s!='B'&&s!='C');
		if (s=='Q')
		{
			memset(F,-1,sizeof(F));
			int Ans=0;
			for (int i=n;i;i--)
				for (int j=n;j;j--)
					if (can[i][j]) Ans=max(Ans,DFS(i,j));
			printf("%d\n",Ans);
		} else if (s=='C') read(a),read(b),read(c),A[a][b]=c;else
		{
			read(a),read(b),read(c),read(d);
			for (int i=a;i<=c;i++)
				for (int j=b;j<=d;j++) can[i][j]=(s=='B');
		}
	}
}
Problem3209
#include<cstdio>
using namespace std;

const int Phi=9988440,Mod=10000007;
int g[60][60],f[60],Ans=1;
long long n;

void Digital_DP()
{
	int pre=0;
	for (int i=60;~i;i--)
		if (n>>i&1)
		{
			for (int j=0;j<=i;j++) (f[j+pre]+=g[i][j])%=Phi;
			pre++;
		}
}
int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%Mod) if (b&1) res=1LL*res*a%Mod;
	return res;
}

int main()
{
	scanf("%lld",&n);
	for (int i=0;i<60;i++)
	{
		g[i][0]=1;
		for (int j=1;j<=i;j++) g[i][j]=(g[i-1][j-1]+g[i-1][j])%Phi;
	}
	n++;Digital_DP();
	for (int i=1;i<60;i++) Ans=1LL*Ans*Pow(i,f[i])%Mod;
	printf("%d\n",Ans);
}
Problem3211
#include<cstdio>
#include<cmath>
using namespace std;

const int Maxn=100000+19;
typedef long long LL;
int n,m,tmp,L,R,k;LL x;
LL C[Maxn],A[Maxn];
int Fa[Maxn];

inline int lowbit(int x) {return x&-x;}
LL Sum(int x)
{
	LL Ans=0;
	while (x>0) {Ans+=C[x];x-=lowbit(x);}
	return Ans;
}
void Add(int x,LL d)
{
	while (x<=n) {C[x]+=d;x+=lowbit(x);}
}
inline int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) 
	{
		scanf("%lld",&A[i]);
		Add(i,A[i]);Fa[i]=(A[i]<=1?i+1:i);
	}
	scanf("%d",&m);
	Fa[n+1]=n+1;
	for (int i=0;i<m;i++)
	{
		scanf("%d%d%d",&tmp,&L,&R);
		if (tmp==1) printf("%lld\n",Sum(R)-Sum(L-1));
		if (tmp==2) 
			for (L=Getf(L);L<=R;L=Getf(L+1))
			{
				int t=(int)sqrt(A[L]);
				Add(L,t-A[L]);
				if ((A[L]=t)<=1) Fa[L]=L+1;
			}
	}
	return 0;
}
Problem3211
#include<cmath>
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=100000+19;
typedef long long LL;
int n,m,tmp,L,R,k,c;LL x;
LL C[Maxn];
int Fa[Maxn],A[Maxn];

inline void Read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
inline int lowbit(int x) {return x&-x;}
inline LL Sum(int x)
{
	LL Ans=0;
	while (x>0) {Ans+=C[x];x-=lowbit(x);}
	return Ans;
}
inline void Add(int x,LL d)
{
	while (x<=n) {C[x]+=d;x+=lowbit(x);}
}
inline int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) 
	{
		Read(A[i]);
		Add(i,A[i]);Fa[i]=(A[i]<=1?i+1:i);
	}
	scanf("%d",&m);
	Fa[n+1]=n+1;
	for (int i=0;i<m;i++)
	{
		Read(tmp);Read(L);Read(R);
		if (tmp==1) printf("%lld\n",Sum(R)-Sum(L-1));
		if (tmp==2) 
			for (L=Getf(L);L<=R;L=Getf(L+1))
			{
				int t=(int)sqrt(A[L]);
				Add(L,t-A[L]);
				if ((A[L]=t)<=1) Fa[L]=L+1;
			}
	}
	return 0;
}
Problem3212
#include<cstdio>
#include<iostream>
using namespace std;

const int Maxn=500000+19;
typedef long long LL;
LL A[Maxn],C1[Maxn],C2[Maxn],n,Q,a,b,c;
char ch[5];

inline void Add_1(int x,LL v) {while (x<=n) {C1[x]+=v;x+=x&-x;}}
inline void Add_2(int x,LL v) {while (x<=n) {C2[x]+=v;x+=x&-x;}}
inline LL Sum_1(int x) 
{
	LL Ans=0;while (x) Ans+=C1[x],x-=x&-x;return Ans;
}
inline LL Sum_2(int x)
{
	LL Ans=0;while (x) Ans+=C2[x],x-=x&-x;return Ans;
}
inline LL Query(int x) {return 1LL*(x+1)*Sum_1(x)-1LL*Sum_2(x);}

int main()
{
	scanf("%d%d",&n,&Q);
	for (int i=1;i<=n;i++) scanf("%lld",&A[i]);
	for (int i=n;i;i--) A[i]-=A[i-1];
	for (int i=1;i<=n;i++) Add_1(i,1LL*A[i]),Add_2(i,1LL*A[i]*i);
	while (Q--)
	{
		scanf("%s",ch);
		scanf("%d%d",&a,&b);
		if (ch[0]=='Q') printf("%lld\n",Query(b)-Query(a-1));
		if (ch[0]=='C') 
		{
			scanf("%lld",&c);
			Add_1(a,c);Add_1(b+1,-c);
			Add_2(a,1LL*c*a);Add_2(b+1,1LL*(-c)*(b+1));
		}
	}
}
Problem3212
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=500000+19;
typedef long long LL;
LL A[Maxn],C1[Maxn],C2[Maxn],n,Q,a,b,c,cc,f;
char ch[5];

inline void Read(LL &x)
{
	while (!isdigit(cc=getchar())&&cc^'-');
	if (cc^'-') x=cc-'0',f=0;else f=1,x=0;
	while (isdigit(cc=getchar())) x=x*10+cc-'0';
	if (f) x=-x;
}
inline void Add_1(int x,LL v) {while (x<=n) {C1[x]+=v;x+=x&-x;}}
inline void Add_2(int x,LL v) {while (x<=n) {C2[x]+=v;x+=x&-x;}}
inline LL Sum_1(int x) 
{
	LL Ans=0;while (x) Ans+=C1[x],x-=x&-x;return Ans;
}
inline LL Sum_2(int x)
{
	LL Ans=0;while (x) Ans+=C2[x],x-=x&-x;return Ans;
}
inline LL Query(int x) {return 1LL*(x+1)*Sum_1(x)-1LL*Sum_2(x);}

int main()
{
	scanf("%d%d",&n,&Q);
	for (int i=1;i<=n;i++) Read(A[i]);
	for (int i=n;i;i--) A[i]-=A[i-1];
	for (int i=1;i<=n;i++) Add_1(i,1LL*A[i]),Add_2(i,1LL*A[i]*i);
	while (Q--)
	{
		scanf("%s",ch);
		Read(a);Read(b);
		if (ch[0]=='Q') printf("%lld\n",Query(b)-Query(a-1));
		if (ch[0]=='C') 
		{
			scanf("%lld",&c);
			Add_1(a,c);Add_1(b+1,-c);
			Add_2(a,1LL*c*a);Add_2(b+1,1LL*(-c)*(b+1));
		}
	}
}
Problem3212
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=500000+19;
typedef long long LL;
LL A[Maxn],C1[Maxn],C2[Maxn],n,Q,a,b,c,cc,f;
char ch[5];

inline void Read(LL &x)
{
	while (!isdigit(cc=getchar())&&cc^'-');
	if (cc^'-') x=cc-'0',f=0;else f=1,x=0;
	while (isdigit(cc=getchar())) x=x*10+cc-'0';
	if (f) x=-x;
}
inline void Write(LL x)
{
	char c[20];int t=0;
	if (x==0) {puts("0");return;}
	if (x<0) putchar('-'),x=-x;
	for (;x;c[++t]=x%10+48,x/=10);
	for (;t;t--) putchar(c[t]);puts("");
}
inline void Add_1(int x,LL v) {while (x<=n) {C1[x]+=v;x+=x&-x;}}
inline void Add_2(int x,LL v) {while (x<=n) {C2[x]+=v;x+=x&-x;}}
inline LL Sum_1(int x) {LL Ans=0;while (x) Ans+=C1[x],x-=x&-x;return Ans;}
inline LL Sum_2(int x) {LL Ans=0;while (x) Ans+=C2[x],x-=x&-x;return Ans;}
inline LL Query(int x) {return (x+1)*Sum_1(x)-Sum_2(x);}

int main()
{
	scanf("%d%d",&n,&Q);
	for (int i=1;i<=n;i++) Read(A[i]);
	for (int i=n;i;i--) A[i]-=A[i-1];
	for (int i=1;i<=n;i++) Add_1(i,A[i]),Add_2(i,A[i]*i);
	while (Q--)
	{
		scanf("%s",ch);
		Read(a);Read(b);
		if (ch[0]=='Q') Write(Query(b)-Query(a-1));
		if (ch[0]=='C') 
		{
			Read(c);
			Add_1(a,c);Add_1(b+1,-c);
			Add_2(a,c*a);Add_2(b+1,(-c)*(b+1));
		}
	}
}
Problem3223
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=100000+19;
typedef int one[Maxn];

int rt,cnt;
one key,Lsn,Rsn,Fa,Rev,s,tmp;
struct Splay_Tree
{
	inline void Push(int x)
	{
		if (!Rev[x]) return;
		Rev[Lsn[x]]^=1;
		Rev[Rsn[x]]^=1;
		Rev[x]=0;
		swap(Lsn[x],Rsn[x]);
	}
	inline void Update(int x) {s[x]=s[Lsn[x]]+s[Rsn[x]]+1;}
	inline void Zig(int x)
	{
		int y=Fa[x],z=Fa[y],t=Rsn[x];
		if (z) if (Lsn[z]==y) Lsn[z]=x;else Rsn[z]=x;
		Fa[y]=x;Lsn[y]=t;Fa[x]=z;Rsn[x]=y;
		if (t) Fa[t]=y;
		Update(y);
	}
	inline void Zag(int x)
	{
		int y=Fa[x],z=Fa[y],t=Lsn[x];
		if (z) if (Lsn[z]==y) Lsn[z]=x;else Rsn[z]=x;
		Fa[y]=x;Rsn[y]=t;Fa[x]=z;Lsn[x]=y;
		if (t) Fa[t]=y;
		Update(y);
	}
	inline void Splay(int x,int aim)
	{
		tmp[tmp[0]=1]=x;
		for (int i=Fa[x];i;i=Fa[i]) tmp[++tmp[0]]=i;
		for (int i=1;i<=tmp[0];i++) Push(tmp[i]);
		while (Fa[x]^aim)
		{
			int y=Fa[x],z=Fa[y];
			if (z==aim) 
				if (x==Lsn[y]) Zig(x);else Zag(x);
			else
				if (x==Lsn[y])
					if (y==Lsn[z]) Zig(y),Zig(x);else Zig(x),Zag(x);
				else
					if (y==Lsn[z]) Zag(x),Zig(x);else Zag(y),Zag(x);
		}
		Update(x);
		if (aim==0) rt=x;
	}
	inline int Select(int k)
	{
		int x=rt;
		while (1)
		{
			Push(x);
			if (s[Lsn[x]]+1==k) return x;
			if (s[Lsn[x]]+1>k) x=Lsn[x];else k-=s[Lsn[x]]+1,x=Rsn[x];
		}
	}
	
} Splay;

int n,m,L,R;

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n+2;i++) Fa[i]=i-1,Rsn[i]=i+1,key[i]=i-1,s[i]=n+3-i;
	Splay.Splay(n/2+1,0);
	while (m--)
	{
		scanf("%d%d",&L,&R);L++;R++;
		Splay.Splay(Splay.Select(L-1),0);
		Splay.Splay(Splay.Select(R+1),rt);
		Rev[Lsn[Rsn[rt]]]^=1;
	}
	for (int i=1;i<=n;i++) printf("%d ",key[Splay.Select(i+1)]);
	printf("\n");
}
Problem3224
#include<cstdio>
using namespace std;

namespace SBT
{
	const int Maxn=200000+19;
	int key[Maxn],s[Maxn],Lsn[Maxn],Rsn[Maxn];
	int Tree_Size=0,Root=0;
	
	void Right_Rotate(int &t)
	{
		int k=Lsn[t];Lsn[t]=Rsn[k];Rsn[k]=t;
		s[k]=s[t];s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
		t=k;
	}
	void Left_Rotate(int &t)
	{
		int k=Rsn[t];Rsn[t]=Lsn[k];Lsn[k]=t;
		s[k]=s[t];s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
		t=k;
	}
	void Maintain(int &t,int Flag)
	{
		if (!Flag)
		{
			if (s[Lsn[Lsn[t]]]>s[Rsn[t]]) Right_Rotate(t);
				else
			if (s[Rsn[Lsn[t]]]>s[Rsn[t]]) Left_Rotate(Lsn[t]),Right_Rotate(t);
				else return;
		}	else
		{
			if (s[Rsn[Rsn[t]]]>s[Lsn[t]]) Left_Rotate(t);
				else
			if (s[Lsn[Rsn[t]]]>s[Lsn[t]]) Right_Rotate(Rsn[t]),Left_Rotate(t);
				else return;
		}
		Maintain(Lsn[t],0);Maintain(Rsn[t],1);
		Maintain(t,1);Maintain(t,0);
	}
	void Insert(int &t,int v)
	{
		if (!t) 
		{
			t=++Tree_Size;
			s[t]=1;Lsn[t]=Rsn[t]=0;key[t]=v;
		}	else
		{
			s[t]++;
			Insert(v<key[t]?Lsn[t]:Rsn[t],v);	//
			Maintain(t,v>=key[t]);
		}
	}
	int Find(int &t,int v)
	{
		if (!t) return 0;
		if (key[t]==v) return 1;
		return Find(v<key[t]?Lsn[t]:Rsn[t],v);
	}
	int Delete(int &t,int v)
	{
		s[t]--;
		if (key[t]==v || v<key[t]&&!Lsn[t] || v>key[t]&&!Rsn[t])
		{
			int Del=key[t];
			if (!Lsn[t]||!Rsn[t]) t=Lsn[t]+Rsn[t];
				else key[t]=Delete(Lsn[t],key[t]+1);
			return Del;
		}
		return Delete(v<key[t]?Lsn[t]:Rsn[t],v);
	}
	int Select(int &t,int kth)
	{
		if (kth==s[Lsn[t]]+1) return key[t];
		if (kth<s[Lsn[t]]+1) return Select(Lsn[t],kth);
		return Select(Rsn[t],kth-s[Lsn[t]]-1);
	}
	int Rank(int &t,int v)
	{
		if (!t) return 1;
		if (v<=key[t]) return Rank(Lsn[t],v);
			else return s[Lsn[t]]+1+Rank(Rsn[t],v);
	}
	int Pred(int &t,int v)
	{
		if (!t) return v;
		if (v<=key[t]) return Pred(Lsn[t],v);
			else {int tmp=Pred(Rsn[t],v);return tmp==v?key[t]:tmp;}
	}
	int Succ(int &t,int v)
	{
		if (!t) return v;
		if (v>=key[t]) return Succ(Rsn[t],v);
			else {int tmp=Succ(Lsn[t],v);return tmp==v?key[t]:tmp;}
	}
}
int n,x,y;

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		if (x==1) SBT::Insert(SBT::Root,y);
		if (x==2&&SBT::Find(SBT::Root,y)) SBT::Delete(SBT::Root,y);
		if (x==3) printf("%d\n",SBT::Rank(SBT::Root,y));
		if (x==4) printf("%d\n",SBT::Select(SBT::Root,y));
		if (x==5) printf("%d\n",SBT::Pred(SBT::Root,y));
		if (x==6) printf("%d\n",SBT::Succ(SBT::Root,y));
	}
	return 0;
}
Problem3224
#include<cstdio>
#include<cctype>
using namespace std;

void Read(int &x)
{
	int c,tmp=0;x=0;
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') tmp=1;else x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (tmp) x=-x;
}

namespace SBT
{
	const int Maxn=200000+19;
	int key[Maxn],s[Maxn],Lsn[Maxn],Rsn[Maxn];
	int Tree_Size=0,Root=0;
	
	void Right_Rotate(int &t)
	{
		int k=Lsn[t];Lsn[t]=Rsn[k];Rsn[k]=t;
		s[k]=s[t];s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
		t=k;
	}
	void Left_Rotate(int &t)
	{
		int k=Rsn[t];Rsn[t]=Lsn[k];Lsn[k]=t;
		s[k]=s[t];s[t]=s[Lsn[t]]+s[Rsn[t]]+1;
		t=k;
	}
	void Maintain(int &t,int Flag)
	{
		if (!Flag)
		{
			if (s[Lsn[Lsn[t]]]>s[Rsn[t]]) Right_Rotate(t);
				else
			if (s[Rsn[Lsn[t]]]>s[Rsn[t]]) Left_Rotate(Lsn[t]),Right_Rotate(t);
				else return;
		}	else
		{
			if (s[Rsn[Rsn[t]]]>s[Lsn[t]]) Left_Rotate(t);
				else
			if (s[Lsn[Rsn[t]]]>s[Lsn[t]]) Right_Rotate(Rsn[t]),Left_Rotate(t);
				else return;
		}
		Maintain(Lsn[t],0);Maintain(Rsn[t],1);
		Maintain(t,1);Maintain(t,0);
	}
	void Insert(int &t,int v)
	{
		if (!t) 
		{
			t=++Tree_Size;
			s[t]=1;Lsn[t]=Rsn[t]=0;key[t]=v;
		}	else
		{
			s[t]++;
			Insert(v<key[t]?Lsn[t]:Rsn[t],v);	//
			Maintain(t,v>=key[t]);
		}
	}
	int Find(int &t,int v)
	{
		if (!t) return 0;
		if (key[t]==v) return 1;
		return Find(v<key[t]?Lsn[t]:Rsn[t],v);
	}
	int Delete(int &t,int v)
	{
		s[t]--;
		if (key[t]==v || v<key[t]&&!Lsn[t] || v>key[t]&&!Rsn[t])
		{
			int Del=key[t];
			if (!Lsn[t]||!Rsn[t]) t=Lsn[t]+Rsn[t];
				else key[t]=Delete(Lsn[t],key[t]+1);
			return Del;
		}
		return Delete(v<key[t]?Lsn[t]:Rsn[t],v);
	}
	int Select(int &t,int kth)
	{
		if (kth==s[Lsn[t]]+1) return key[t];
		if (kth<s[Lsn[t]]+1) return Select(Lsn[t],kth);
		return Select(Rsn[t],kth-s[Lsn[t]]-1);
	}
	int Rank(int &t,int v)
	{
		if (!t) return 1;
		if (v<=key[t]) return Rank(Lsn[t],v);
			else return s[Lsn[t]]+1+Rank(Rsn[t],v);
	}
	int Pred(int &t,int v)
	{
		if (!t) return v;
		if (v<=key[t]) return Pred(Lsn[t],v);
			else {int tmp=Pred(Rsn[t],v);return tmp==v?key[t]:tmp;}
	}
	int Succ(int &t,int v)
	{
		if (!t) return v;
		if (v>=key[t]) return Succ(Rsn[t],v);
			else {int tmp=Succ(Lsn[t],v);return tmp==v?key[t]:tmp;}
	}
}
int n,x,y;

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++)
	{
		Read(x);Read(y);
		if (x==1) SBT::Insert(SBT::Root,y);
		if (x==2&&SBT::Find(SBT::Root,y)) SBT::Delete(SBT::Root,y);
		if (x==3) printf("%d\n",SBT::Rank(SBT::Root,y));
		if (x==4) printf("%d\n",SBT::Select(SBT::Root,y));
		if (x==5) printf("%d\n",SBT::Pred(SBT::Root,y));
		if (x==6) printf("%d\n",SBT::Succ(SBT::Root,y));
	}
	return 0;
}
Problem3224
#include<cstdio>
#include<cctype>
using namespace std;

const int Maxn=100000+19;
typedef int one[Maxn];

int c,f;
inline void Read(int &x)
{
	while (!isdigit(c=getchar())&&c!='-');
	if (c=='-') f=1,x=0;else f=0,x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	if (f) x=-x;
}

int Rt,cnt;
struct Splay_Tree
{
	one Lsn,Rsn,s,key,Fa;
	
	inline void Update(int x) {s[x]=s[Lsn[x]]+s[Rsn[x]]+1;}
	inline void Zig(int x)
	{
		int y=Fa[x],z=Fa[y],t=Rsn[x];
		if (z) if (y==Lsn[z]) Lsn[z]=x;else Rsn[z]=x;
		Fa[y]=x;Lsn[y]=t;Fa[x]=z;Rsn[x]=y;
		if (t) Fa[t]=y;
		Update(y);
	}
	inline void Zag(int x)
	{
		int y=Fa[x],z=Fa[y],t=Lsn[x];
		if (z) if (y==Lsn[z]) Lsn[z]=x;else Rsn[z]=x;
		Fa[y]=x;Rsn[y]=t;Fa[x]=z;Lsn[x]=y;
		if (t) Fa[t]=y;
		Update(y);
	}
	inline void Splay(int x)
	{
		while (Fa[x])
		{
			int y=Fa[x],z=Fa[y];
			if (z)
				if (x==Lsn[y])
					if (y==Lsn[z]) Zig(y),Zig(x);else Zig(x),Zag(x);
				else 
					if (y==Rsn[z]) Zag(y),Zag(x);else Zag(x),Zig(x);
			else if (x==Lsn[y]) Zig(x);else Zag(x);
		}
		Update(x);Rt=x;
	}
	inline void Insert(int &x,int v,int F)
	{
		if (!x) {x=++cnt;s[x]=1;key[x]=v;Fa[x]=F;return;}
		s[x]++;
		Insert(v<key[x]?Lsn[x]:Rsn[x],v,x);
	}
	inline int Find(int v)
	{
		int x=Rt;
		while (x)
		{
			if (key[x]==v) return x;
			x=(v<key[x]?Lsn[x]:Rsn[x]);
		}
		return -1;
	}
	inline int Rank(int v)
	{
		int x=Find(v);Splay(x);return s[Lsn[x]]+1;
	}
	inline int Select(int k)	//返回指针 
	{
		int x=Rt;
		while (1)
		{
			if (s[Lsn[x]]+1==k) return x;
			if (s[Lsn[x]]+1>k) x=Lsn[x];else k-=s[Lsn[x]]+1,x=Rsn[x];
		}
	}
	inline int Pred(int x)	//返回指针 
	{
		Splay(x);x=Lsn[x];while (Rsn[x]) x=Rsn[x];return x;
	}
	inline int Succ(int x)	//返回指针 
	{
		Splay(x);x=Rsn[x];while (Lsn[x]) x=Lsn[x];return x;
	}
	inline int Join(int x,int y)	//返回指针 
	{
		if (!x||!y) return x+y;
		while (Rsn[x]) x=Rsn[x];
		Splay(x);
		Rsn[x]=y;Fa[y]=x;return x;
	}
	inline void Delete(int x)
	{
		Splay(x);
		Fa[Lsn[x]]=Fa[Rsn[x]]=0;
		Rt=Join(Lsn[x],Rsn[x]);
	}
	
} Splay;

int n,opt,v;

int main()
{
	scanf("%d",&n);
	while (n--)
	{
		Read(opt);Read(v);
		if (opt==1) Splay.Insert(Rt,v,0),Splay.Splay(cnt);
		if (opt==2) Splay.Delete(Splay.Find(v));
		if (opt==3) 
		{
			int k=Splay.Rank(v);
			while (k>1&&Splay.key[Splay.Select(k-1)]==v) k--;
			printf("%d\n",k);
		}
		if (opt==4) printf("%d\n",Splay.key[Splay.Select(v)]);
		if (opt==5||opt==6) 
		{
			Splay.Insert(Rt,v,0);
			int x=Splay.Find(v);
			while (Splay.key[x]==v) x=(opt==5?Splay.Pred(x):Splay.Succ(x));
			printf("%d\n",Splay.key[x]);
			Splay.Delete(Splay.Find(v));
		}
	}
}
Problem3224
#include<cstdio>
#include<cctype>
#include<algorithm>
#define Fir first
#define Sec second
using namespace std;

const int Maxn=100000+19;

int c,f;
inline void read(int &x)
{
    while (!isdigit(c=getchar())&&c!='-');
    if (c=='-') f=1,x=0;else f=0,x=c-'0';
    while (isdigit(c=getchar())) x=x*10+c-'0';
    if (f) x=-x;
}

struct Treap;typedef Treap* rt;
struct Treap
{
	rt L,R;
	int fix,key,size;
	Treap():key(0),fix(rand()),L(0),R(0),size(1) {}
	int sz() {return this?size:0;}
	void Update() {size=L->sz()+R->sz()+1;}
} treap[Maxn];rt RT;int tcnt;
typedef pair<rt,rt> Drt;

rt Merge(rt A,rt B)
{
	if (!A) return B;if (!B) return A;
	if (A->fix<B->fix) return A->R=Merge(A->R,B),A->Update(),A;
		else return B->L=Merge(A,B->L),B->Update(),B;
}
Drt Split(rt A,int k)
{
	if (!A) return Drt();
	Drt x;
	if (A->L->sz()>=k) x=Split(A->L,k),A->L=x.Sec,A->Update(),x.Sec=A;
		else x=Split(A->R,k-A->L->sz()-1),A->R=x.Fir,A->Update(),x.Fir=A;
	return x;
}
int Findkth(int k)
{
	Drt x=Split(RT,k-1),y=Split(x.Sec,1);
	rt Ans=y.Fir;
	RT=Merge(Merge(x.Fir,Ans),y.Sec);
	return Ans->key;
}
int Getrank(rt A,int v)
{
	if (!A) return 0;
	return v<A->key?Getrank(A->L,v):Getrank(A->R,v)+A->L->sz()+1;
}
void Insert(int v)
{
	int k=Getrank(RT,v);
	Drt x=Split(RT,k);
	rt y=&treap[++tcnt];y->key=v;
	RT=Merge(Merge(x.Fir,y),x.Sec);
}
void Delete(int v)
{
	int k=Getrank(RT,v);
	Drt x=Split(RT,k-1),y=Split(x.Sec,1);
	RT=Merge(x.Fir,y.Sec);
}

int Q,opt,x;

int main()
{
	read(Q);
	while (Q--)
	{
		read(opt),read(x);
		if (opt==1) Insert(x);
		if (opt==2) Delete(x);
		if (opt==3) printf("%d\n",Getrank(RT,x-1)+1);
		if (opt==4) printf("%d\n",Findkth(x));
		if (opt==5) printf("%d\n",Findkth(Getrank(RT,x-1)));
		if (opt==6) printf("%d\n",Findkth(Getrank(RT,x)+1));
	}
}
Problem3224
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Rep(i,x,y) for (int i=x;i>y;i--)
#define Mid (L+R>>1)
#define CH isdigit(c=getchar())
using namespace std;

int IN()
{
	int c,f,x;
	while (!CH&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (CH) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const double Alpha=0.75;
int n,v;

const int N=100000+19;
struct SGT *null;
struct SGT
{
	SGT *L,*R;
	int key,S,Sr,Del;

	void Update() {if (this!=null) S=L->S+R->S+1,Sr=L->Sr+R->Sr+!Del;}
	bool Balance() {return L->S<=S*Alpha&&R->S<=S*Alpha;}
} Nd[N],*S[N],*tmp[N],*RT;
int Tcnt,k,kt,f,Q,opt,x;

void Find(SGT *x)
{
	if (x==null) return;
	Find(x->L);if (!x->Del) tmp[++kt]=x;Find(x->R);
}
SGT *Build(int L,int R)
{
	if (L>R) return null;
	tmp[Mid]->L=Build(L,Mid-1),tmp[Mid]->R=Build(Mid+1,R);
	return tmp[Mid]->Update(),tmp[Mid];
}
void Ins(SGT *&x,int v)
{
	if (x==null) {x=Nd+(++Tcnt),*x=(SGT){null,null,v,1,1,0};return;}
	S[++k]=x,v<x->key?Ins(x->L,v):Ins(x->R,v);
}
void Insert(int v)
{
	k=0,Ins(RT,v);Rep(i,k,0) S[i]->Update();
	For(i,1,k+1)
		if (!S[i]->Balance())
		{
			f=(i>1&&S[i-1]->L==S[i]),kt=0,Find(S[i]);
			SGT *T=Build(1,kt);
			if (i==1) RT=T;else f?S[i-1]->L=T:S[i-1]->R=T;
			return;
		}
}
bool Del(SGT *x,int v)
{
	if (x==null) return 0;
	if (x->key==v&&!x->Del) {x->Del=1,x->Update();return 1;}
	return S[++k]=x,v==x->key?Del(x->L,v)||Del(x->R,v):Del(v<x->key?x->L:x->R,v);
}
void Delete(int v) {k=0,Del(RT,v);Rep(i,k,0) S[i]->Update();}
int Rank(SGT *x,int v)
{
	if (x==null) return 0;
	return v<x->key?Rank(x->L,v):Rank(x->R,v)+x->L->Sr+!x->Del;
}
int Findkth(SGT *x,int k)
{
	if (x->L->Sr+1==k&&!x->Del) return x->key;
	return k<=x->L->Sr+!x->Del?Findkth(x->L,k):Findkth(x->R,k-x->L->Sr-!x->Del);
}

int main()
{
	RT=null=Nd;
	Q=IN();
	while (Q--)
	{
		opt=IN(),x=IN();
		if (opt==1) Insert(x);
		if (opt==2) Delete(x);
		if (opt==3) printf("%d\n",Rank(RT,x-1)+1);
		if (opt==4) printf("%d\n",Findkth(RT,x));
		if (opt==5) printf("%d\n",Findkth(RT,Rank(RT,x-1)));
		if (opt==6) printf("%d\n",Findkth(RT,Rank(RT,x)+1));
	}
}
Problem3231
#include<cstdio>
using namespace std;

typedef long long LL;
struct Matrix {int n,m;LL s[16][16];} A,F;
int k;LL m,n,p,Ans,C[16],B[16];

Matrix operator * (Matrix A,Matrix B)
{
	Matrix C;C.n=A.n,C.m=B.m;
	for (int i=0;i<C.n;i++)
		for (int j=0;j<C.m;j++) C.s[i][j]=0;
	for (int i=0;i<C.n;i++)
		for (int k=0;k<A.m;k++)
			for (int j=0;j<C.m;j++) (C.s[i][j]+=A.s[i][k]*B.s[k][j]%p)%=p;
	return C;
}
Matrix Pow(Matrix A,LL b)
{
	Matrix res=A;
	for (--b;b;b>>=1,A=A*A) if (b&1) res=res*A;
	return res;
}

int main()
{
	scanf("%d",&k);
	for (int i=1;i<=k;i++) scanf("%lld",&B[i]);
	for (int i=1;i<=k;i++) scanf("%lld",&C[i]);
	scanf("%lld%lld%lld",&m,&n,&p);m--;
	for (int i=1;i<=k;i++) B[i]%=p,C[i]%=p;
	
	A.n=1,A.m=k+1;
	for (int i=1;i<=k;i++) A.s[0][i]=B[k-i+1],(A.s[0][0]+=B[i])%=p;
	F.n=k+1,F.m=k+1;
	F.s[0][0]=1;
	for (int i=1;i<=k;i++) F.s[i][0]=F.s[i][1]=C[i];
	for (int i=2;i<=k;i++) F.s[i-1][i]=1;

	if (n<=k) for (int i=1;i<=n;i++) (Ans+=B[i])%=p;else (Ans+=(A*Pow(F,n-k)).s[0][0])%=p;
	if (m<=k) for (int i=1;i<=m;i++) (Ans-=B[i])%=p;else (Ans-=(A*Pow(F,m-k)).s[0][0])%=p;
	printf("%lld\n",(Ans+p)%p);
}
Problem3236
#include<cstdio>
#include<cctype>
#include<cmath>
#include<algorithm>
using namespace std;

const int Maxn=100000+19;
typedef int one[Maxn];
struct Ques {int L,R,a,b,Ans1,Ans2,ID;} A[Maxn*10];
one C1,C2,col,tot;
int n,Q,S,cnt,L,R;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int cmp1(Ques A,Ques B) 
{
	if (A.L/S!=B.L/S) return A.L/S<B.L/S;
	return ((A.L/S)&1)?A.R<B.R:A.R>B.R;
}
int cmp2(Ques A,Ques B) {return A.ID<B.ID;}

void Update1(int x,int v) {for (;x<=n;x+=x&-x) C1[x]+=v;}
void Update2(int x,int v) {for (;x<=n;x+=x&-x) C2[x]+=v;}
int Query1(int x) {int Ans=0;for (;x;x-=x&-x) Ans+=C1[x];return Ans;}
int Query2(int x) {int Ans=0;for (;x;x-=x&-x) Ans+=C2[x];return Ans;}

void Update(int x,int v)
{
	if (!x) return;
	if (v==1) {Update1(col[x],1);tot[col[x]]++;if (tot[col[x]]==1) Update2(col[x],1);}
	if (v==-1) {Update1(col[x],-1);tot[col[x]]--;if (tot[col[x]]==0) Update2(col[x],-1);}
}

int main()
{
	read(n),read(Q);
	for (int i=1;i<=n;i++) read(col[i]);
	for (int i=0;i<Q;i++) 
		read(A[i].L),read(A[i].R),read(A[i].a),read(A[i].b),A[i].ID=i;
	S=sqrt(n)+1;cnt=n/S+(n%S!=0);
	sort(A,A+Q,cmp1);
	for (int i=0;i<Q;i++)
	{
		while (L<A[i].L) Update(L++,-1);
		while (L>A[i].L) Update(--L,1);
		while (R<A[i].R) Update(++R,1);
		while (R>A[i].R) Update(R--,-1);
		A[i].Ans1=Query1(A[i].b)-Query1(A[i].a-1);
		A[i].Ans2=Query2(A[i].b)-Query2(A[i].a-1);
	}
	sort(A,A+Q,cmp2);
	for (int i=0;i<Q;i++) printf("%d %d\n",A[i].Ans1,A[i].Ans2);
}
Problem3237
#include<set>
#include<map>
#include<cmath>
#include<string>
#include<cstdio>
#include<vector>
#include<cctype>
#include<cstdlib>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define Mid (L+R>>1)

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

const int len=200000;
inline int nc()
{
	static char buf[len],*b=buf+len;
	if (b==buf+len) fread(buf,1,len,stdin),b=buf;
	return *b++;
}
int IN()
{
	int c,f,x;
	while (!isdigit(c=nc())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=nc())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;

const int N=100000+19,M=200000+19;

int vis[M],id[N];
int Time,n,m,Qc;

struct QType
{
	int c,s[4];
} Q[M];

struct USet
{
	int fa[N];
	void Reset(int n) {For(i,1,n+1) fa[i]=i;}
	int getf(int x) {return fa[x]==x?x:fa[x]=getf(fa[x]);}
} U[20],tmp;

struct Graph
{
	struct Edge {int x,y,id;} E[M];
} G[20];

void Solve(int L,int R,int d,int n,int m)
{
	Graph &g=G[d];
	USet &u=U[d];
	For(i,0,m) g.E[i]=G[d-1].E[i];
	
	int __n=0,__m=0;
	u.Reset(n);
	tmp.Reset(n);
	Time++;
	For(i,L,R+1) For(j,0,Q[i].c) vis[Q[i].s[j]]=Time;
	For(i,0,m)
		if (vis[g.E[i].id]==Time) g.E[__m++]=g.E[i];else
		{
			int x=g.E[i].x,y=g.E[i].y;
			int fx=u.getf(x),fy=u.getf(y);
			if (fx!=fy)
			{
				u.fa[fx]=fy;
				tmp.fa[tmp.getf(x)]=y;
			}
		}
	For(i,1,n+1) if (tmp.getf(i)==i) id[i]=++__n;
	if (__n==1)
	{
		For(i,L,R+1) puts("Connected");
		return;
	}
	if (L==R)
	{
		puts("Disconnected");
		return;
	}
	m=__m,__m=0;
	For(i,0,m)
	{
		int x=tmp.getf(g.E[i].x),y=tmp.getf(g.E[i].y);
		if (x!=y) g.E[__m++]=(Graph::Edge){id[x],id[y],g.E[i].id};
	}
	Solve(L,Mid,d+1,__n,__m);
	Solve(Mid+1,R,d+1,__n,__m);
}

int main()
{
	n=IN(),m=IN();
	For(i,0,m) G[0].E[i]=(Graph::Edge){IN(),IN(),i};
	Qc=IN();
	For(i,1,Qc+1)
	{
		Q[i].c=IN();
		For(j,0,Q[i].c) Q[i].s[j]=IN()-1;
	}
	Solve(1,Qc,1,n,m);
}
Problem3238
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Rep(i,x,y) for (int i=x;i<=y;i++)
#define Dep(i,x,y) for (int i=x;i>=y;i--)
using namespace std;

const int N=500000+19;
typedef long long LL;
int SA[N],rk[2*N],h[N],trk[N],tmp[N],cnt[N],pre[N],suc[N],Q[N],t,p,n;
char s[N];LL Ans;

void Build_SA()
{
	Rep(i,1,n) p=s[i]>p?s[i]:p,cnt[s[i]]++;
	Rep(i,1,p) cnt[i]+=cnt[i-1];
	Dep(i,n,1) SA[cnt[s[i]]--]=i;
	rk[SA[1]]=p=1;
	Rep(i,2,n) rk[SA[i]]=(s[SA[i]]==s[SA[i-1]])?p:++p;
	for (int k=1;k<=n;k<<=1)
	{
		memset(cnt,0,sizeof(cnt));
		Rep(i,1,n) cnt[rk[i+k]]++;
		Rep(i,1,p) cnt[i]+=cnt[i-1];
		Dep(i,n,1) tmp[cnt[rk[i+k]]--]=i;
		memset(cnt,0,sizeof(cnt));
		Rep(i,1,n) cnt[rk[i]]++;
		Rep(i,1,p) cnt[i]+=cnt[i-1];
		Dep(i,n,1) SA[cnt[rk[tmp[i]]]--]=tmp[i];
		trk[SA[1]]=p=1;
		Rep(i,2,n) trk[SA[i]]=(rk[SA[i]]==rk[SA[i-1]]&&rk[SA[i]+k]==rk[SA[i-1]+k])?p:++p;
		Rep(i,1,n) rk[i]=trk[i];
	}
	for (int i=1,j=0;i<=n;i++)
	{
		if (rk[i]==1) continue;
		while (s[i+j]==s[SA[rk[i]-1]+j]) j++;
		h[rk[i]]=j;if (j) j--;
	}
}

LL Query()
{
	h[1]=h[n+1]=-1;
	Q[t=1]=1;  Rep(i,2,n) {while (h[Q[t]]>=h[i]) t--;pre[i]=Q[t];Q[++t]=i;}
	Q[t=1]=n+1;Dep(i,n,2) {while (h[Q[t]]> h[i]) t--;suc[i]=Q[t];Q[++t]=i;}
	LL res=0;
	Rep(i,2,n) res+=1LL*(i-pre[i])*(suc[i]-i)*h[i];
	return res;
}

int main()
{
	scanf("%s",s+1),n=strlen(s+1);
	Build_SA();
	For(i,1,n+1) Ans+=1LL*i*(i-1)+1LL*i*(n-i);
	printf("%lld\n",Ans-2*Query());
}
Problem3238
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=1e6+19;
struct Edge {int y,nxt;} E[N];
struct node
{
	node *Par,*go[26];
	int val;
} Nd[N],*cur=Nd,*pre,*rt;
char s[N];
int Last[N],S[N],Len,cnt;
long long Sum;

node *New(int v) {return cur->val=v,cur++;}
void Extend(int x)
{
	node *p=pre,*np=New(p->val+1);
	S[np-Nd]=1;
	for (;p&&!p->go[x];p=p->Par) p->go[x]=np;
	if (!p) np->Par=rt;else
	{
		node *t=p->go[x];
		if (t->val==p->val+1) np->Par=t;else
		{
			node *nt=New(p->val+1);
			nt->Par=t->Par,t->Par=np->Par=nt;
			memcpy(nt->go,t->go,sizeof(t->go));
			for (;p&&p->go[x]==t;p=p->Par) p->go[x]=nt;
		}
	}
	pre=np;
}

void Add_Edge(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
void DP(int x)
{
	int tmp=S[x];
	for (int i=Last[x];~i;i=E[i].nxt) DP(E[i].y),S[x]+=S[E[i].y];
	for (int i=Last[x];~i;i=E[i].nxt)
		Sum+=1LL*tmp*S[E[i].y]*(Nd+x)->val,tmp+=S[E[i].y];
}

int main()
{
	memset(Last,-1,sizeof(Last));
	rt=pre=New(0);
	scanf("%s",s),Len=strlen(s);
	for (int i=Len-1;~i;i--) Extend(s[i]-'a');
	for (node *i=Nd+1;i<cur;i++) Add_Edge(i->Par-Nd,i-Nd);
	DP(0);
	printf("%lld\n",1LL*(Len-1)*Len*(Len+1)/2LL-2LL*Sum);
}
Problem3239
#include<cmath>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar())&&~c);if (c==-1) return c;x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int Mo=1000007;
struct Hash
{
	int A[2*Mo],key[2*Mo],Last[Mo],nxt[2*Mo],cnt;
	void Clear()
	{
		memset(A,-1,sizeof(A));
		memset(nxt,-1,sizeof(nxt));cnt=Mo;
	}
	void Ins(int x,int k)
	{
		int t=x%Mo;
		if (A[t]==-1) A[t]=x,key[t]=k,Last[t]=t;else
			nxt[Last[t]]=cnt,A[cnt]=x,key[cnt]=k,Last[t]=cnt++;
	}
	int Qry(int x)
	{
		for (int i=x%Mo;~i;i=nxt[i]) if (A[i]==x) return key[i];
		return -1;
	}
} H;
int y,z,P;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
void BSGS(int y,int z)
{
	H.Clear();
	int S=sqrt(P)+1,Inv=Pow(Pow(y,S),P-2),t=1;
	For(i,0,S) {if (H.Qry(t)==-1) H.Ins(t,i);t=1LL*t*y%P;}
	For(i,0,S)
		if (~(t=H.Qry(z))) {printf("%d\n",i*S+t);return;}
			else z=1LL*z*Inv%P;
	puts("no solution");
}

int main()
{
	while (P=IN(),y=IN(),z=IN(),~P) BSGS(y,z);
}
Problem3240
#include<cstdio>

const int Mod=1e9+7;
typedef long long LL;
struct M {LL x,y;} A,B,Ans;
LL n,m,a,b,c,d;
char s[1000000+19],t[1000000+19];

void Getit(char* s,LL &x,int P) {for (int i=0;s[i];i++) x=(x*10+s[i]-'0')%P;}
M operator * (M a,M b) {return (M){a.x*b.x%Mod,(a.y*b.x+b.y)%Mod};}
M Pow(M A,LL b)
{
	M res=(M){1,0};
	for (;b;b>>=1,A=A*A) if (b&1) res=res*A;
	return res;
}

int main()
{
	scanf("%s%s%lld%lld%lld%lld",s,t,&a,&b,&c,&d);
	Getit(s,n,c==1?Mod:Mod-1);
	Getit(t,m,a==1?Mod:Mod-1);
	A=(M){a,b};B=(M){c,d};
	Ans=Pow(Pow(A,m-1)*B,n-1)*Pow(A,m-1);
	printf("%lld\n",(Ans.x+Ans.y)%Mod);
}
Problem3245
#include<cstdio>
#include<cstring>
using namespace std;

const int M=50000+19,N=150+19,V=500+19;
struct Edge {int y,nxt,v,L;} E[M];
int Last[N],Qx[N*V*10],Qv[N*V*10];
int px[N][V],pv[N][V],vis[N][V];
int n,m,D,cnt,x,y,v,L,Ans,f,w;
double Dis[N][V],Min=1e60;

void Add_Edge(int x,int y,int v,int L)
{
	E[cnt]=(Edge){y,Last[x],v,L};Last[x]=cnt++;
}
void print(int x,int v)
{
	if (x==-1) return;
	print(px[x][v],pv[x][v]);
	printf("%d%c",x," \n"[x==D]);
}

void SPFA()
{
	for (int i=0;i<n;i++) for (int j=0;j<=500;j++) Dis[i][j]=1e60;
	f=1;w=0;Qx[1]=0,Qv[1]=70;Dis[0][70]=0;vis[0][70]=1;
	while (f>w)
	{
		w++;int x=Qx[w],v=Qv[w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
		{
			int vv=(E[i].v?E[i].v:v);
			if (Dis[x][v]+(1.0*E[i].L/vv)<Dis[E[i].y][vv])
			{
				Dis[E[i].y][vv]=Dis[x][v]+(1.0*E[i].L/vv);
				px[E[i].y][vv]=x;pv[E[i].y][vv]=v;
				if (!vis[E[i].y][vv]) vis[E[i].y][vv]=1,f++,Qx[f]=E[i].y,Qv[f]=vv;
			}
		}
		vis[x][v]=0;
	}
}

int main()
{
	memset(Last,-1,sizeof(Last));
	memset(px,-1,sizeof(px));
	memset(pv,-1,sizeof(pv));
	scanf("%d%d%d",&n,&m,&D);
	for (int i=0;i<m;i++) scanf("%d%d%d%d",&x,&y,&v,&L),Add_Edge(x,y,v,L);
	SPFA();
	for (int i=0;i<=500;i++) if (Dis[D][i]<Min) Min=Dis[D][i],Ans=i;
	print(D,Ans);
}
Problem3246
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=500000+19,oo=(1<<30)-1;
struct Edge {int y,z,nxt;} E[N*2];
int vis[N],b[N],Ans[N],Dis[N],Q[N],Last[N],res[N];
int n,m,L,cnt,pre,rt,rt2,Max,Time,tot,t,Min,f,w,x,y,z;

void Link(int x,int y,int z)
{
	E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}

void Get_Dis(int S)
{
	f=1,w=0;Q[1]=S,Dis[S]=0,Time++;b[S]=Time;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];~i;i=E[i].nxt)
			if (b[E[i].y]!=Time) b[E[i].y]=Time,Dis[E[i].y]=Dis[x]+E[i].z,Q[++f]=E[i].y;
	}
}
void Calc(int x)
{
	Get_Dis(x);
	Max=-oo;For(i,1,f+1) if (Dis[Q[i]]>Max) Max=Dis[Q[i]],rt=Q[i];
	Get_Dis(rt);
	Max=-oo;
	For(i,1,f+1)
	{
		t=Q[i],res[t]=Dis[t];
		if (Dis[t]>Max) Max=Dis[t],rt2=t;
	}
	pre=max(pre,Max);
	Get_Dis(rt2);
	For(i,1,f+1) t=Q[i],res[t]=max(res[t],Dis[t]),vis[t]=1;
	Min=oo;For(i,1,f+1) Min=min(Min,res[Q[i]]);
	Ans[tot++]=Min;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),m=IN(),L=IN();
	For(i,0,m) x=IN(),y=IN(),z=IN(),Link(x,y,z);
	For(i,0,n) if (!vis[i]) Calc(i);
	sort(Ans,Ans+tot);
	if (tot==1) printf("%d\n",max(Ans[0],pre));else
		if (tot==2) printf("%d\n",max(Ans[0]+Ans[1]+L,pre));else
			printf("%d\n",max(max(Ans[tot-1]+Ans[tot-2]+L,Ans[tot-2]+Ans[tot-3]+2*L),pre));
}
Problem3261
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=16000000+19;
int rt[600000+19],S[N],son[N][2];
int n,m,x,B,tot,Ql,Qr;
char s[3];

void Insert(int y,int &x,int a)
{
	S[x=++tot]=S[y]+1;
	if (a==-1) return;
	son[x][0]=son[y][0],son[x][1]=son[y][1];
	Insert(son[y][B>>a&1],son[x][B>>a&1],a-1);
}
int Query(int t)
{
	Ql++,Qr++;
	int L=rt[Ql-2],R=rt[Qr-1],res=0;
	for (int i=24;i>=0;i--)
	{
		int v=(t>>i&1)^1;
		if (S[son[R][v]]-S[son[L][v]]) res|=1<<i;else v^=1;
		L=son[L][v],R=son[R][v];
	}
	return res;
}

int main()
{
	read(n),read(m);n++;
	Insert(rt[0],rt[1],24);
	For(i,2,n+1) read(x),B^=x,Insert(rt[i-1],rt[i],24);
	while (m--)
	{
		scanf("%s",s);
		if (s[0]=='A') read(x),n++,B^=x,Insert(rt[n-1],rt[n],24);
			else read(Ql),read(Qr),read(x),printf("%d\n",Query(B^x));
	}
}
Problem3262
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=100000+19,K=200000+19;
struct Event
{
	int S,C,M,cnt,res;
	bool operator < (const Event& B) const {return C<B.C||C==B.C&&S<B.S;}
} E[N],tmp[N];
int C[K],T[K],Ans[N],Time,m,n,k;

bool cmp(Event A,Event B)
{
	return A.S<B.S||A.S==B.S&&A.C<B.C||A.S==B.S&&A.C==B.C&&A.M<B.M;
}

void Update(int x,int v)
{
	for (int i=x;i<=k;i+=i&-i) {if (T[i]!=Time) T[i]=Time,C[i]=0;C[i]+=v;}
}
int Query(int x)
{
	int Ans=0;
	for (int i=x;i;i-=i&-i) Ans+=(T[i]==Time?C[i]:0);
	return Ans;
}

void CDQ(int L,int R)
{
	if (L==R) return;
	CDQ(L,Mid),CDQ(Mid+1,R);
	
	sort(E+L,E+Mid+1);
	sort(E+Mid+1,E+R+1);
	int cur=L;Time++;
	For(i,Mid+1,R+1)
	{
		while (cur<=Mid&&E[cur].C<=E[i].C) Update(E[cur].M,E[cur].cnt),cur++;
		E[i].res+=Query(E[i].M);
	}
}

int main()
{
	read(m),read(k);
	For(i,1,m+1) read(E[i].S),read(E[i].C),read(E[i].M),E[i].cnt=1;
	sort(E+1,E+m+1,cmp);
	For(i,1,m+1)
		if (i==1||E[i].S!=E[n].S||E[i].C!=E[n].C||E[i].M!=E[n].M) E[++n]=E[i];
			else E[n].cnt++;
	For(i,1,n+1) E[i].res=E[i].cnt-1;
	CDQ(1,n);
	For(i,1,n+1) Ans[E[i].res]+=E[i].cnt;
	For(i,0,m) printf("%d\n",Ans[i]);
}
Problem3265
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=1000+19,M=10000+19;
const db eps=1e-10;

db A[M][N],b[M],c[N],z;
int m,n;

void pivot(int x,int y){
	b[x]/=A[x][y];
	For(i,1,n+1) if (i!=y) A[x][i]/=A[x][y];
	A[x][y]=1/A[x][y];
	For(i,1,m+1) if (i!=x){
		b[i]=b[i]-A[i][y]*b[x];
		For(j,1,n+1) if (j!=y) A[i][j]=A[i][j]-A[i][y]*A[x][j];
		A[i][y]=-A[i][y]*A[x][y];
	}
	z+=c[y]*b[x];
	For(i,1,n+1) if (i!=y) c[i]=c[i]-c[y]*A[x][i];
	c[y]=-c[y]*A[x][y];
}
db simplex(){
	for (;;){
		db Min=1e50;
		int x=0,y=0;
		For(i,1,n+1) if (c[i]>eps) {y=i;break;}
		if (!y) return z;
		For(i,1,m+1) if (A[i][y]>eps&&b[i]/A[i][y]<Min) {Min=b[i]/A[i][y];x=i;}
		pivot(x,y);
	}
}

int main(){
	n=IN(),m=IN();
	For(i,1,n+1) c[i]=IN();
	For(i,1,m+1){
		for (int k=IN(),s,t;k--;){
			s=IN(),t=IN();
			For(j,s,t+1) A[i][j]++;
		}
		b[i]=IN();
	}
	printf("%d\n",ll(simplex()+0.5));
}
Problem3265
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=1000+19,M=10000+19;
const db eps=1e-7;

db A[M][N],b[M],c[N],z;
int m,n;

void pivot(int x,int y){
	b[x]/=A[x][y];
	For(i,1,n+1) if (i!=y) A[x][i]/=A[x][y];
	A[x][y]=1/A[x][y];
	For(i,1,m+1) if (i!=x){
		b[i]=b[i]-A[i][y]*b[x];
		For(j,1,n+1) if (j!=y) A[i][j]=A[i][j]-A[i][y]*A[x][j];
		A[i][y]=-A[i][y]*A[x][y];
	}
	z+=c[y]*b[x];
	For(i,1,n+1) if (i!=y) c[i]=c[i]-c[y]*A[x][i];
	c[y]=-c[y]*A[x][y];
}
db simplex(){
	for (;;){
		db Min=1e30;
		int x=0,y=0;
		For(i,1,n+1) if (c[i]>eps) {y=i;break;}
		if (!y) return z;
		For(i,1,m+1) if (A[i][y]>eps&&b[i]/A[i][y]<Min) {Min=b[i]/A[i][y];x=i;}
		pivot(x,y);
	}
}

int main(){
	n=IN(),m=IN();
	For(i,1,n+1) c[i]=IN();
	For(i,1,m+1){
		for (int k=IN(),s,t;k--;){
			s=IN(),t=IN();
			For(j,s,t+1) A[i][j]++;
		}
		b[i]=IN();
	}
	printf("%d\n",ll(simplex()+0.5));
}
Problem3265
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=1000+19,M=10000+19;
const db eps=1e-7;

db A[M][N],b[M],c[N],z;
int m,n;

void pivot(int x,int y){
	b[x]/=A[x][y];
	For(i,1,n+1) if (i!=y) A[x][i]/=A[x][y];
	A[x][y]=1/A[x][y];
	For(i,1,m+1) if (i!=x&&fabs(A[i][y])>eps){
		b[i]=b[i]-A[i][y]*b[x];
		For(j,1,n+1) if (j!=y) A[i][j]=A[i][j]-A[i][y]*A[x][j];
		A[i][y]=-A[i][y]*A[x][y];
	}
	z+=c[y]*b[x];
	For(i,1,n+1) if (i!=y) c[i]=c[i]-c[y]*A[x][i];
	c[y]=-c[y]*A[x][y];
}
db simplex(){
	for (;;){
		db Min=1e30;
		int x=0,y=0;
		For(i,1,n+1) if (c[i]>eps) {y=i;break;}
		if (!y) return z;
		For(i,1,m+1) if (A[i][y]>eps&&b[i]/A[i][y]<Min) {Min=b[i]/A[i][y];x=i;}
		pivot(x,y);
	}
}

int main(){
	n=IN(),m=IN();
	For(i,1,n+1) c[i]=IN();
	For(i,1,m+1){
		for (int k=IN(),s,t;k--;){
			s=IN(),t=IN();
			For(j,s,t+1) A[i][j]++;
		}
		b[i]=IN();
	}
	printf("%d\n",ll(simplex()+0.5));
}
Problem3275
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=5000+19,oo=(1<<30)-1;
typedef int one[Maxn];
one Last,Q,Dis,A;
struct Edge {int y,f,nxt;} E[1000000+19];
int n,sum,S,T,cnt,f,w;

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}
void Check(int i,int j)
{
	if ((A[i]&1)==(A[j]&1)) return;
	int x=A[i]*A[i]+A[j]*A[j];
	if (fabs(int(sqrt(x))-sqrt(x))>1e-8||gcd(A[i],A[j])>1) return;
	if (A[j]&1) swap(i,j);
	Add_Edge(i,j,oo);
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	f=1;w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			res+=tmp,Flow-=tmp;
			E[i].f-=tmp;E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&A[i]),sum+=A[i];
	S=n+1;T=n+2;
	for (int i=1;i<=n;i++)
	{
		(A[i]&1)?Add_Edge(S,i,A[i]):Add_Edge(i,T,A[i]);
		for (int j=1;j<i;j++) Check(i,j);
	}
	while (BFS()) sum-=Dinic(S,oo);
	printf("%d\n",sum);
}
Problem3275
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=3000+19,oo=(1<<30)-1;
typedef int one[Maxn];
one Last,Q,Dis,A;
struct Edge {int y,f,nxt;} E[1000000+19];
int n,sum,S,T,cnt,f,w;

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}
void Check(int i,int j)
{
	if ((A[i]&1)==(A[j]&1)) return;
	int x=A[i]*A[i]+A[j]*A[j];
	if (fabs(int(sqrt(x))-sqrt(x))>1e-8||gcd(A[i],A[j])>1) return;
	if (A[j]&1) swap(i,j);
	Add_Edge(i,j,oo);
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis));Dis[S]=1;
	f=1;w=0;Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&Dis[E[i].y]==Dis[x]+1)
		{
			int tmp=Dinic(E[i].y,min(Flow,E[i].f));
			res+=tmp,Flow-=tmp;
			E[i].f-=tmp;E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&A[i]),sum+=A[i];
	S=n+1;T=n+2;
	for (int i=1;i<=n;i++)
	{
		(A[i]&1)?Add_Edge(S,i,A[i]):Add_Edge(i,T,A[i]);
		for (int j=1;j<i;j++) Check(i,j);
	}
	while (BFS()) sum-=Dinic(S,oo);
	printf("%d\n",sum);
}
Problem3276
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x,f;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=250000+19,oo=(1<<30)-1;
typedef long long LL;
struct node {int p;LL r;} Q[N];
struct Iron
{
	LL D;int m,p;LL r;
	bool operator < (const Iron& B) const {return D<B.D;}
} A[N];
int ID[N*4],x0,y0,f,w,n,x,y,m,p,r,Qr,Qx;
LL D[N];

void Update(int x)
{
	ID[x]=A[ID[Lsn]].m<A[ID[Rsn]].m?ID[Lsn]:ID[Rsn];
}
void Build(int x,int L,int R)
{
	if (L==R) {ID[x]=L;return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	Update(x);
}
int Query(int x,int L,int R)
{
	if (R<=Qr) return ID[x];
	int res=0,t;
	if (A[t=Query(Lsn,L,Mid)].m<A[res].m) res=t;
	if (Qr>Mid&&A[t=Query(Rsn,Mid+1,R)].m<A[res].m) res=t;
	return res;
}
void Modify(int x,int L,int R)
{
	if (L==R) {A[L].m=oo;return;}
	Qx<=Mid?Modify(Lsn,L,Mid):Modify(Rsn,Mid+1,R);
	Update(x);
}

int main()
{
	x0=IN(),y0=IN(),Q[f=1]=(node){IN(),IN()};n=IN();
	Q[1].r*=Q[1].r;
	For(i,1,n+1)
	{
		x=IN(),y=IN(),m=IN(),p=IN(),r=IN();
		A[i]=(Iron){1LL*(x-x0)*(x-x0)+1LL*(y-y0)*(y-y0),m,p,1LL*r*r};
	}
	sort(A+1,A+n+1);A[0].m=oo+1;
	For(i,1,n+1) D[i]=A[i].D;
	Build(1,1,n);
	while (f>w)
	{
		w++;int t;
		Qr=upper_bound(D+1,D+n+1,Q[w].r)-D-1;
		if (Qr>=1)
			while (~(t=Query(1,1,n))&&A[t].m<=Q[w].p)
			{
				Q[++f]=(node){A[t].p,A[t].r},Qx=t,Modify(1,1,n);
			}
	}
	printf("%d\n",f-1);
}
Problem3276
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x,f;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

const int N=250000+19,oo=(1<<30)-1;
typedef long long LL;
struct Iron
{
	LL D;int m,p;LL r;
	bool operator < (const Iron& B) const {return D<B.D;}
} A[N];
int ID[N*4],Q[N],x0,y0,f,w,n,x,y,m,p,r,Qr,Qx;
LL D[N];

void Update(int x)
{
	ID[x]=A[ID[Lsn]].m<A[ID[Rsn]].m?ID[Lsn]:ID[Rsn];
}
void Build(int x,int L,int R)
{
	if (L==R) {ID[x]=L;return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	Update(x);
}
int Query(int x,int L,int R)
{
	if (R<=Qr) return ID[x];
	int res=0,t;
	if (A[t=Query(Lsn,L,Mid)].m<A[res].m) res=t;
	if (Qr>Mid&&A[t=Query(Rsn,Mid+1,R)].m<A[res].m) res=t;
	return res;
}
void Modify(int x,int L,int R)
{
	if (L==R) {A[L].m=oo;return;}
	Qx<=Mid?Modify(Lsn,L,Mid):Modify(Rsn,Mid+1,R);
	Update(x);
}

int main()
{
	x0=IN(),y0=IN(),A[0].p=IN(),A[0].r=IN(),n=IN();
	A[0].r*=A[0].r;Q[f=1]=0;
	For(i,1,n+1)
	{
		x=IN(),y=IN(),m=IN(),p=IN(),r=IN();
		A[i]=(Iron){1LL*(x-x0)*(x-x0)+1LL*(y-y0)*(y-y0),m,p,1LL*r*r};
	}
	sort(A+1,A+n+1);A[0].m=oo+1;
	For(i,1,n+1) D[i]=A[i].D;
	Build(1,1,n);
	while (f>w)
	{
		w++;int t;
		Qr=upper_bound(D+1,D+n+1,A[Q[w]].r)-D-1;
		if (Qr>=1)
			while (~(t=Query(1,1,n))&&A[t].m<=A[Q[w]].p)
			{
				Q[++f]=Qx=t,Modify(1,1,n);
			}
	}
	printf("%d\n",f-1);
}
Problem3276
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int N=250000+19,oo=(1<<30)-1,Len=20000000;
typedef long long LL;
struct Iron
{
	LL D;int m,p;LL r;
	bool operator < (const Iron& B) const {return D<B.D;}
} A[N];
int ID[N*4],Q[N],x0,y0,f,w,n,x,y,m,p,r,Qr,Qx;
LL D[N];
char Buf[Len],*B=Buf;

int IN()
{
	int c,x,f;
	while (!isdigit(c=*B++)&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=*B++)) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

void Update(int x)
{
	ID[x]=A[ID[Lsn]].m<A[ID[Rsn]].m?ID[Lsn]:ID[Rsn];
}
void Build(int x,int L,int R)
{
	if (L==R) {ID[x]=L;return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	Update(x);
}
int Query(int x,int L,int R)
{
	if (R<=Qr) return ID[x];
	int res=0,t;
	if (A[t=Query(Lsn,L,Mid)].m<A[res].m) res=t;
	if (Qr>Mid&&A[t=Query(Rsn,Mid+1,R)].m<A[res].m) res=t;
	return res;
}
void Modify(int x,int L,int R)
{
	if (L==R) {A[L].m=oo;return;}
	Qx<=Mid?Modify(Lsn,L,Mid):Modify(Rsn,Mid+1,R);
	Update(x);
}

int main()
{
	fread(Buf,1,Len,stdin);
	x0=IN(),y0=IN(),A[0].p=IN(),A[0].r=IN(),n=IN();
	A[0].r*=A[0].r;Q[f=1]=0;
	For(i,1,n+1)
	{
		x=IN(),y=IN(),m=IN(),p=IN(),r=IN();
		A[i]=(Iron){1LL*(x-x0)*(x-x0)+1LL*(y-y0)*(y-y0),m,p,1LL*r*r};
	}
	sort(A+1,A+n+1);A[0].m=oo+1;
	For(i,1,n+1) D[i]=A[i].D;
	Build(1,1,n);
	while (f>w)
	{
		w++;int t,x=Q[w];
		Qr=upper_bound(D+1,D+n+1,A[x].r)-D-1;
		if (Qr>=1)
			while (~(t=Query(1,1,n))&&A[t].m<=A[x].p) Q[++f]=Qx=t,Modify(1,1,n);
	}
	printf("%d\n",f-1);
}
Problem3276
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int N=250000+19,oo=(1<<30)-1,Len=20000000;
typedef long long LL;
struct Iron
{
	LL D;int m,p;LL r;
	bool operator < (const Iron& B) const {return D<B.D;}
} A[N];
int ID[N*4],Q[N],x0,y0,f,w,n,x,y,m,p,r,Qr,Qx;
LL D[N];
char Buf[Len],*B=Buf;

int IN()
{
	int c,x,f;
	while (!isdigit(c=*B++)&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=*B++)) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

void Update(int x)
{
	ID[x]=A[ID[Lsn]].m<A[ID[Rsn]].m?ID[Lsn]:ID[Rsn];
}
void Build(int x,int L,int R)
{
	if (L==R) {ID[x]=L;return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	Update(x);
}
int Query(int x,int L,int R)
{
	if (R<=Qr) return ID[x];
	int res=0,t;
	if (A[t=Query(Lsn,L,Mid)].m<A[res].m) res=t;
	if (Qr>Mid&&A[t=Query(Rsn,Mid+1,R)].m<A[res].m) res=t;
	return res;
}
void Modify(int x,int L,int R)
{
	if (L==R) {A[L].m=oo;return;}
	Qx<=Mid?Modify(Lsn,L,Mid):Modify(Rsn,Mid+1,R);
	Update(x);
}
int Find(LL x)
{
	int L=1,R=n,res=0;
	while (L<=R) if (D[Mid]<=x) res=Mid,L=Mid+1;else R=Mid-1;
	return res;
}

int main()
{
	fread(Buf,1,Len,stdin);
	x0=IN(),y0=IN(),A[0].p=IN(),A[0].r=IN(),n=IN();
	A[0].r*=A[0].r;Q[f=1]=0;
	For(i,1,n+1)
	{
		x=IN(),y=IN(),m=IN(),p=IN(),r=IN();
		A[i]=(Iron){1LL*(x-x0)*(x-x0)+1LL*(y-y0)*(y-y0),m,p,1LL*r*r};
	}
	sort(A+1,A+n+1);A[0].m=oo+1;
	For(i,1,n+1) D[i]=A[i].D;
	Build(1,1,n);
	while (f>w)
	{
		w++;int t,x=Q[w];
		Qr=Find(A[x].r);
//		Qr=upper_bound(D+1,D+n+1,A[x].r)-D-1;
		if (Qr>=1)
			while (~(t=Query(1,1,n))&&A[t].m<=A[x].p) Q[++f]=Qx=t,Modify(1,1,n);
	}
	printf("%d\n",f-1);
}
Problem3276
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

const int N=250000+19,oo=(1<<30)-1,Len=20000000;
typedef long long LL;
struct Iron
{
	LL D;int m,p;LL r;
	bool operator < (const Iron& B) const {return D<B.D;}
} A[N];
int ID[N*4],Q[N],x0,y0,f,w,n,x,y,m,p,r,Qr,Qx;
LL D[N];
char Buf[Len],*B=Buf;

int IN()
{
	int c,x,f;
	while (!isdigit(c=*B++)&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=*B++)) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

void Update(int x)
{
	ID[x]=A[ID[Lsn]].m<A[ID[Rsn]].m?ID[Lsn]:ID[Rsn];
}
void Build(int x,int L,int R)
{
	if (L==R) {ID[x]=L;return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	Update(x);
}
int Query(int x,int L,int R)
{
	if (R<=Qr) return ID[x];
	int res,t;
	res=Query(Lsn,L,Mid);
	if (Qr>Mid&&A[t=Query(Rsn,Mid+1,R)].m<A[res].m) res=t;
	return res;
}
void Modify(int x,int L,int R)
{
	if (L==R) {A[L].m=oo;return;}
	Qx<=Mid?Modify(Lsn,L,Mid):Modify(Rsn,Mid+1,R);
	Update(x);
}
int Find(LL x)
{
	int L=1,R=n,res=0;
	while (L<=R) if (D[Mid]<=x) res=Mid,L=Mid+1;else R=Mid-1;
	return res;
}

int main()
{
	fread(Buf,1,Len,stdin);
	x0=IN(),y0=IN(),A[0].p=IN(),A[0].r=IN(),n=IN();
	A[0].r*=A[0].r;Q[f=1]=0;
	For(i,1,n+1)
	{
		x=IN(),y=IN(),m=IN(),p=IN(),r=IN();
		A[i]=(Iron){1LL*(x-x0)*(x-x0)+1LL*(y-y0)*(y-y0),m,p,1LL*r*r};
	}
	sort(A+1,A+n+1);A[0].m=oo+1;
	For(i,1,n+1) D[i]=A[i].D;
	Build(1,1,n);
	while (f>w)
	{
		w++;int t,x=Q[w];
		if ((Qr=upper_bound(D+1,D+n+1,A[x].r)-D-1)>=1)
			while (~(t=Query(1,1,n))&&A[t].m<=A[x].p) Q[++f]=Qx=t,Modify(1,1,n);
	}
	printf("%d\n",f-1);
}
Problem3282
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=300000+19;
int n,Q,opt,x,y;

struct node;node *null;
struct node
{
	node *L,*R,*Fa;
	int Xor,key,rev;
	
	bool Top() {return Fa==null||Fa->L!=this&&Fa->R!=this;}
	void Setrev() {rev^=1,swap(L,R);}
	void Down()
	{
		if (rev) L->Setrev(),R->Setrev(),rev=0;
	}
	void Update() {Xor=L->Xor^R->Xor^key;}
	
	void Zig()
	{
		node *y=Fa,*z=y->Fa;
		if (z->L==y) z->L=this;else if (z->R==y) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag()
	{
		node *y=Fa,*z=y->Fa;
		if (z->L==y) z->L=this;else if (z->R==y) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y;y->Fa=this;y->Update();
	}
} Nd[N];

void Splay(node *x)
{
	static node *S[N];
	node *tmp=x;int k=0;
	while (!tmp->Top()) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (!x->Top())
	{
		node *y=x->Fa,*z=y->Fa;
		if (!y->Top())
			if (x==y->L) if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
				else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	x->Update();
}
node *Access(node *x)
{
	node *y;
	for (y=null;x!=null;y=x,x=x->Fa) Splay(x),x->R=y,x->Update();
	return y;
}
node *Root(node *x)
{
	Splay(x);
	while (x->L!=null) x=x->L,x->Down();
	return x;
}
void Evert(node *x) {Access(x)->Setrev();}
void Link(node *x,node *y) {if (Root(x)!=Root(y)) Evert(x),Splay(x),x->Fa=y;}
void Cut(node *x,node *y)
{
	Evert(x),Access(y),Splay(y);
	if (y->L==x&&x->R==null) y->L=x->Fa=null,y->Update();
}

int main()
{
	null=Nd;
	read(n),read(Q);
	For(i,0,n+1) Nd[i]=(node){null,null,null,0,0,0};
	For(i,1,n+1) read(Nd[i].key),Nd[i].Xor=Nd[i].key;
	while (Q--)
	{
		read(opt),read(x),read(y);
		if (opt==0) Evert(Nd+x),printf("%d\n",Access(Nd+y)->Xor);
		if (opt==1) Link(Nd+x,Nd+y);
		if (opt==2) Cut(Nd+x,Nd+y);
		if (opt==3) Splay(Nd+x),(Nd+x)->key=y,(Nd+x)->Update();
	}
}
Problem3283
#include<cmath>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int Mo=100007;
struct Hash
{
	int A[2*Mo],key[2*Mo],Last[Mo],nxt[2*Mo],cnt;
	void Clear()
	{
		memset(A,-1,sizeof(A));
		memset(nxt,-1,sizeof(nxt));cnt=Mo;
	}
	void Ins(int x,int k)
	{
		int t=x%Mo;
		if (A[t]==-1) A[t]=x,key[t]=k,Last[t]=t;else
			nxt[Last[t]]=cnt,A[cnt]=x,key[cnt]=k,Last[t]=cnt++;
	}
	int Qry(int x)
	{
		for (int i=x%Mo;~i;i=nxt[i]) if (A[i]==x) return key[i];
		return -1;
	}
} H;

int T,y,z,P,res,opt;

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}
int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
void Exgcd(int a,int b,int &x,int &y)
{
	if (!b) {x=1;y=0;return;}
	Exgcd(b,a%b,x,y);
	int t=x;x=y;y=t-a/b*y;
}
int Inv(int a) {int x,y;Exgcd(a,P,x,y);return (x+P)%P;}

int ExBSGS()
{
	int t=1,w=1,k=0;
	For(i,0,50) {if (t==z) return i;t=1LL*t*y%P;}
	for (t=gcd(y,P);t!=1;t=gcd(y,P))
	{
		if (z%t) return -1;
		z/=t,P/=t,w=1LL*w*(y/t)%P,k++;
	}
	int S=sqrt(P)+1,I=Inv(Pow(y,S));t=w;H.Clear();
	For(i,0,S) {if (H.Qry(t)==-1) H.Ins(t,i);t=1LL*t*y%P;}
	For(i,0,S)
		if (~(t=H.Qry(z))) return i*S+t+k;else z=1LL*z*I%P;
	return -1;
}

int Pri[100],A[100],Per[100],cnt,p;
int Calc(int n,int &t)
{
	if (!n) return 1;
	int Ans=Calc(n/p,t),Oth=1;t+=n/p;
	For(i,1,P) if (i%p) Oth=1LL*Oth*i%P;
	For(i,1,n%P+1) if (i%p) Ans=1LL*Ans*i%P;
	return 1LL*Ans*Pow(Oth,n/P)%P;
}
int CRT(int n,int m)
{
	if (n<m) return 0;
	int x=P,tP=P,Ans=0,Di;cnt=0;
	for (int i=2;i*i<=x;i++)
		if (x%i==0) {Pri[cnt]=i,Per[cnt]=1;while (x%i==0) Per[cnt]*=i,x/=i;cnt++;}
	if (x>1) Pri[cnt]=x,Per[cnt++]=x;
	For(i,0,cnt)
	{
		int b1=0,b2=0;
		p=Pri[i],P=Per[i];
		A[i]=Calc(n,b1);
		A[i]=1LL*A[i]*Inv(Calc(m,b2))%P;
		A[i]=1LL*A[i]*Inv(Calc(n-m,b2))%P;
		A[i]=1LL*A[i]*Pow(p,b1-b2)%P;
	}
	For(i,0,cnt) Di=tP/Per[i],P=Per[i],(Ans+=1LL*Di*Inv(Di)%tP*A[i]%tP)%=tP;
	return Ans;
}

int main()
{
	for (T=IN();T--;)
	{
		opt=IN(),y=IN(),z=IN(),P=IN();
		if (opt==1) printf("%d\n",Pow(y,z));
		if (opt==2) ~(res=ExBSGS())?printf("%d\n",res):puts("Math Error");
		if (opt==3) printf("%d\n",CRT(z,y));
	}
}
Problem3285
#include<cstdio>
#include<cmath>
#include<cstring>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int L=1000000+19,Mo=1000007;
typedef long long LL;
int a,b,c,g,P;
char s1[L],s2[L],s3[L],s4[L];

void Get(char *s,int &a,int P)
{
	int Len=strlen(s);
	For(i,0,Len) a=(10LL*a+s[i]-'0')%P;
}
int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}

struct Hash
{
	int A[Mo*2],key[Mo*2],Last[Mo],nxt[Mo*2],cnt;
	Hash()
	{
		memset(A,-1,sizeof(A));
		memset(nxt,-1,sizeof(nxt));cnt=Mo;
	}
	void Ins(int x,int k)
	{
		int t=x%Mo;
		if (A[t]==-1) A[t]=x,key[t]=k,Last[t]=t;
			else nxt[Last[t]]=cnt,A[cnt]=x,key[cnt]=k,Last[t]=cnt++;
	}
	int Qry(int x)
	{
		for (int i=x%Mo;~i;i=nxt[i]) if (A[i]==x) return key[i];
		return -1;
	}
} H;

void BSGS(int x,int z)
{
	if (x==0) {puts("no solution");return;}	//
	int S=sqrt(P)+1,Inv=Pow(x,P-1-S),t=1;
	For(i,0,S) {if (H.Qry(t)==-1) H.Ins(t,i);t=1LL*t*x%P;}
	For(i,0,S)
		if (~(t=H.Qry(z))) {printf("%d\n",i*S+t);return;}
			else z=1LL*z*Inv%P;
	puts("no solution");
}

int main()
{
	scanf("%s%s%s%s%d",s1,s2,s3,s4,&P);
	Get(s1,a,P-1),Get(s2,b,P-1),Get(s3,c,P),Get(s4,g,P);
	BSGS(Pow(g,a),1LL*c*Pow(g,P-1-b)%P);
}
Problem3289
#include<cstdio>
#include<cctype>
#include<cmath>
#include<algorithm>
using namespace std;

const int Maxn=50000+19;
struct node {int ID,num;} A[Maxn];
struct Ques {int L,R,Ans,ID;} Q[Maxn];
int C[Maxn];
int n,t,size,L,R,Ans;

int f,c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int ncmp1(node A,node B) {return A.num<B.num;}
int ncmp2(node A,node B) {return A.ID<B.ID;}
int cmp1(Ques A,Ques B) {return A.L/size!=B.L/size?A.L<B.L:A.R<B.R;}
int cmp2(Ques A,Ques B) {return A.ID<B.ID;}

void Add(int x,int v) {while (x<=n) C[x]+=v,x+=x&-x;}
int Query(int x) {int Ans=0;while (x) Ans+=C[x],x-=x&-x;return Ans;}
int Count(int L,int R) {return Query(R)-Query(L-1);}
void Update(int x,int v,int Bigger)
{
	if (!x) return;
	Add(A[x].num,v);
	Ans+=v*(Bigger?Count(A[x].num+1,n):Count(1,A[x].num-1));
}

int main()
{
	read(n);
	for (int i=1;i<=n;i++) read(A[i].num),A[i].ID=i;
	sort(A+1,A+n+1,ncmp1);
	for (int i=1;i<=n;i++) A[i].num=i;sort(A+1,A+n+1,ncmp2);
	read(t);
	size=sqrt(n)+1;
	for (int i=1;i<=t;i++) read(Q[i].L),read(Q[i].R),Q[i].ID=i;
	sort(Q+1,Q+t+1,cmp1);
	for (int i=1;i<=t;i++)
	{
		while (L<Q[i].L) Update(L++,-1,0);
		while (L>Q[i].L) Update(--L,1,0);
		while (R>Q[i].R) Update(R--,-1,1);
		while (R<Q[i].R) Update(++R,1,1);
		Q[i].Ans=Ans;
	}
	sort(Q+1,Q+t+1,cmp2);
	for (int i=1;i<=t;i++) printf("%d\n",Q[i].Ans);
}
Problem3289
#include<cstdio>
#include<cctype>
#include<cmath>
#include<algorithm>
using namespace std;
 
const int Maxn=50000+19;
struct Ques {int L,R,ID;} Q[Maxn];
int C[Maxn],Out[Maxn],A[Maxn],B[Maxn];
int n,t,size,L,R,Ans;
 
int f,c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int cmp(int a,int b) {return A[a]<A[b];}
int Qcmp(Ques A,Ques B) 
{
	if (A.L/size!=B.L/size) return A.L/size<B.L/size;
	return ((A.L/size)&1)?A.R<B.R:A.R>B.R;
}
 
void Add(int x,int v) {while (x<=n) C[x]+=v,x+=x&-x;}
int Query(int x) {int Ans=0;while (x) Ans+=C[x],x-=x&-x;return Ans;}
int Count(int L,int R) {return Query(R)-Query(L-1);}
void Update(int x,int v,int Bigger)
{
	if (!x) return;
	Add(A[x],v);
	Ans+=v*(Bigger?Count(A[x]+1,n):Count(1,A[x]-1));
}
 
int main()
{
	read(n);
	for (int i=1;i<=n;i++) read(A[i]),B[i]=i;
	sort(B+1,B+n+1,cmp);
	for (int i=1;i<=n;i++) A[B[i]]=i;
	read(t);
	size=sqrt(n)+1;
	for (int i=1;i<=t;i++) read(Q[i].L),read(Q[i].R),Q[i].ID=i;
	sort(Q+1,Q+t+1,Qcmp);
	for (int i=1;i<=t;i++)
	{
		while (L<Q[i].L) Update(L++,-1,0);
		while (L>Q[i].L) Update(--L,1,0);
		while (R>Q[i].R) Update(R--,-1,1);
		while (R<Q[i].R) Update(++R,1,1);
		Out[Q[i].ID]=Ans;
	}
	for (int i=1;i<=t;i++) printf("%d\n",Out[i]);
}
Problem3293
#include<cstdio>
#include<algorithm>
using namespace std;

const int Maxn=100000+19;
long long A[Maxn],C[Maxn],Mid,tot=0LL,Ans=0LL;
int n;

inline long long Abs(long long x) { return x>0?x:-x;}

int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%lld",&A[i]),tot+=A[i];
	tot/=n;
	for (int i=0;i<n;i++) A[i]-=tot;
	for (int i=0;i<n;i++) C[i]=(i?C[i-1]:0LL)+A[i];
	sort(C,C+n);
	Mid=C[(n-1)/2];
	for (int i=0;i<n;i++) Ans+=Abs(Mid-C[i]);
	printf("%lld\n",Ans);
}
Problem3295
#include<cstdio>
#include<cctype>
#include<cstring>

#define Mid (L+R>>1)
#define For(x) for (;x<=n;x+=x&-x)
#define Rep(x) for (;x;x-=x&-x)
using namespace std;

const int Maxn=100000+19;
typedef int one[Maxn];
typedef int Seg[5000000+19];
one rt,T,vis,pos,C,pre,nxt,A;
Seg Lsn,Rsn,sum;
int n,Q,x,tcnt,Qt=1;
long long Ans;

int read()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
	return x;
}

int Query(int x) {int tmp=0;Rep(x) tmp+=C[x];return tmp;}
void Insert(int x) {For(x) C[x]++;}

void Segins(int &x,int L,int R,int t)
{
	if (!x) x=++tcnt;
	sum[x]++;
	if (L==R) return;
	if (t<=Mid) Segins(Lsn[x],L,Mid,t);else Segins(Rsn[x],Mid+1,R,t);
}
void Init(int x) {Rep(x) if (vis[x]!=Qt) vis[x]=Qt,T[x]=rt[x];else vis[x]=-1;}
int Bitqry(int x,int f)
{
	int tmp=0;
	Rep(x) if (vis[x]==Qt) tmp+=sum[f?Rsn[T[x]]:Lsn[T[x]]];
	return tmp;
}
void Turn(int x,int f) {Rep(x) if (vis[x]==Qt) T[x]=(f?Rsn[T[x]]:Lsn[T[x]]);}
int More(int r,int t)
{
	Qt++;Init(r);
	int tmp=0,L=1,R=n;
	while (L<=R)
	{
		(t<=Mid+1)?
			(tmp+=Bitqry(r,1),Turn(r,0),R=Mid):
			(Turn(r,1),L=Mid+1);
		if (L==R) break;
	}
	return tmp;
}
int Less(int l,int t)
{
	Qt++;Init(n);Init(l-1);
	int tmp=0,L=1,R=n;
	while (L<=R)
	{
		
		(t>=Mid)?
			(tmp+=Bitqry(n,0)-Bitqry(l-1,0),Turn(n,1),Turn(l-1,1),L=Mid+1):
			(Turn(n,0),Turn(l-1,0),R=Mid);
		if (L==R) break;
	}
	return tmp;
}

int main()
{
	n=read(),Q=read();
	for (int i=1;i<=n;i++) x=read(),Ans+=(pre[x]=i-1-Query(x)),Insert(x),pos[A[i]=x]=i;
	memset(C,0,sizeof(C));
	for (int i=n;i;i--) nxt[A[i]]=Query(A[i]-1),Insert(A[i]);
	while (Q--)
	{
		x=read();
		printf("%lld\n",Ans);
		Ans-=pre[x]+nxt[x]-More(pos[x]-1,x+1)-Less(pos[x]+1,x-1);
		for (int i=pos[x];i<=n;i+=i&-i) Segins(rt[i],1,n,x);
	}
}
Problem3295
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=100000+19;
typedef int one[N];
struct QType
{
	int Time,ID,opt,x,y;
	bool operator < (const QType& B) const {return x<B.x;}
} Q[2*N],tmp[2*N];
one A,v,Del,T,C,Pos;
LL f[N];
int n,Qt,Time,Qc;

void Add(int x)
{
	for (;x<=n;x+=x&-x)
	{
		if (T[x]!=Time) T[x]=Time,C[x]=0;
		C[x]++;
	}
}
int Query(int x)
{
	int res=0;
	for (;x;x-=x&-x) res+=T[x]==Time?C[x]:0;
	return res;
}

void Work(int L,int R)
{
	if (L==R) return;
	Time++;
	for (int i=R;i>=L;i--)
	{
		if (Q[i].Time<=Mid&&Q[i].opt==1) Add(Q[i].y);
		if (Q[i].Time>Mid&&Q[i].opt==2) f[Q[i].ID]+=Query(Q[i].y);
	}
	int Tl=L,Tr=Mid+1;
	For(i,L,R+1) if (Q[i].Time<=Mid) tmp[Tl++]=Q[i];else tmp[Tr++]=Q[i];
	For(i,L,R+1) Q[i]=tmp[i];
	Work(L,Mid),Work(Mid+1,R);
}

int main()
{
	n=IN(),Qc=IN();
	For(i,1,n+1) Pos[A[i]=IN()]=i;
	For(i,1,Qc+1) Del[v[i]=IN()]=1;
	for (int i=n;i;i--) if (!Del[A[i]])
		Add(A[i]),f[Qc+1]+=Query(A[i]-1);
	For(i,1,n+1) if (!Del[i]) Qt++,Q[Qt]=(QType){Qt,0,1,Pos[i],i};
	for (int i=Qc;i;i--)
	{
		Qt++,Q[Qt]=(QType){Qt,i,2,Pos[v[i]],v[i]};
		Qt++,Q[Qt]=(QType){Qt,0,1,Pos[v[i]],v[i]};
	}
	sort(Q+1,Q+Qt+1),Work(1,Qt);
	For(i,1,Qt+1) Q[i].x=n-Q[i].x+1,Q[i].y=n-Q[i].y+1;
	sort(Q+1,Q+Qt+1),Work(1,Qt);
	for (int i=Qc;i;i--) f[i]+=f[i+1];
	For(i,1,Qc+1) printf("%lld\n",f[i]);
}
Problem3306
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=1e5+19,oo=(1<<30)-1;
typedef int one[N];
struct Edge {int y,nxt;} E[N*2];
int Fa[N][17],Min[N*4];
one A,Last,In,Out,ID,Deep;
int n,x,y,Q,cnt,rt,tot,Qx,Qv,Ql,Qr,tmp;
char s[3];

void Link(int x,int y)
{
	E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,Last[y]};Last[y]=cnt++;
}
void DFS(int x)
{
	ID[In[x]=++tot]=x;
	for (int i=Last[x];~i;i=E[i].nxt)
		if (E[i].y!=Fa[x][0])
			Deep[E[i].y]=Deep[x]+1,Fa[E[i].y][0]=x,DFS(E[i].y);
	Out[x]=tot;
}

void Build(int x,int L,int R)
{
	if (L==R) {Min[x]=A[ID[L]];return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	Min[x]=min(Min[Lsn],Min[Rsn]);
}
void Update(int x,int L,int R)
{
	if (L==R) {Min[x]=Qv;return;}
	Qx<=Mid?Update(Lsn,L,Mid):Update(Rsn,Mid+1,R);
	Min[x]=min(Min[Lsn],Min[Rsn]);
}
int Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return Min[x];
	int tmp=oo;
	if (Ql<=Mid) tmp=min(tmp,Query(Lsn,L,Mid));
	if (Qr>Mid) tmp=min(tmp,Query(Rsn,Mid+1,R));
	return tmp;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	n=IN(),Q=IN();
	For(i,1,n+1) {x=IN(),A[i]=IN();if (x) Link(x,i);}
	DFS(rt=1);
	For(x,1,17) For(i,1,n+1) Fa[i][x]=Fa[Fa[i][x-1]][x-1];
	Build(1,1,n);
	while (Q--)
	{
		scanf("%s",s);
		if (s[0]=='V') Qx=In[IN()],Qv=IN(),Update(1,1,n);
		if (s[0]=='E') rt=IN();
		if (s[0]=='Q')
		{
			x=IN();
			if (rt==x) printf("%d\n",Min[1]);else
			if (!(In[x]<=In[rt]&&Out[rt]<=Out[x])) Ql=In[x],Qr=Out[x],printf("%d\n",Query(1,1,n));else
			{
				int Ans=oo;tmp=rt;
				for (int i=Deep[rt]-Deep[x]-1,k=0;i;i>>=1,k++) if (i&1) tmp=Fa[tmp][k];
				Ql=1,Qr=In[tmp]-1;if (Ql<=Qr) Ans=min(Ans,Query(1,1,n));
				Ql=Out[tmp]+1,Qr=n;if (Ql<=Qr) Ans=min(Ans,Query(1,1,n));
				printf("%d\n",Ans);
			}
		}
	}
}
Problem3309
#include<cstdio>
#include<cmath>
#include<cctype>
#include<algorithm>
using namespace std;

const int top=10000000,Maxn=top+19;
int mu[Maxn],vis[Maxn],p[Maxn],g[Maxn];
int n,T,a,b,cnt;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	read(T);
	for (int i=2;i<=top;i++)
	{
		if (!vis[i]) mu[i]=-1,p[cnt++]=i;
		for (int j=0;j<cnt&&1LL*p[j]*i<=top;j++)
		{
			vis[p[j]*i]=1;
			if (i%p[j]==0) {mu[p[j]*i]=0;break;}
				else mu[p[j]*i]=-mu[i];
		}
	}
	for (int i=2,_=sqrt(top);i<=_;i++)
		if (mu[i]) for (long long j=i*i;j<=top;j*=i) mu[j]=mu[i];
	for (int i=2;i<=top;i++) g[i]=g[i-1]-mu[i];
	while (T--)
	{
		long long Ans=0;
		read(a),read(b);if (a>b) swap(a,b);
		for (int L=1,R;L<=a;L=R+1)
		{
			R=min(a/(a/L),b/(b/L));
			Ans+=1LL*(g[R]-g[L-1])*(a/L)*(b/L);
		}
		printf("%lld\n",Ans);
	}
}
Problem3316
#include<cstdio>
#include<cmath>
#include<cctype>
using namespace std;

const int Maxn=100000*2+19;
const double Eps=1e-10;
typedef long long Ll;
typedef double Db;
Ll C[Maxn],X,Y;
int c,nL,nR,n,Q[2][Maxn],f[2],w[2];
double L=0.,R=0.,Mid,Best=1e9;

Ll Gcd(Ll a,Ll b) {return !b?a:Gcd(b,a%b);}
inline Db Calc(int a,int b) {return Db(C[b]-C[a])-(b-a)*Mid;}
void Read(Ll &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

int main()
{
	scanf("%d%d%d",&n,&nL,&nR);
	if (nL&1) nL++;
	for (int i=1;i<=n;i++) 
	{
		Read(C[i]);C[i+n]=C[i];
		if (C[i]>R) R=C[i];
	}
	for (int i=1;i<=n<<1;i++) C[i]+=C[i-1];
	while(R-L>Eps)
	{
		Mid=(L+R)/2.;
		int flag=0;
		//check--------------------	
		f[0]=f[1]=-1;w[0]=w[1]=0;
		for (int i=1;i<=n<<1;i++)
		{
			int v=i&1;
			while (f[v]>=w[v]&&i-Q[v][w[v]]>nR) w[v]++;
			if (i<nL) continue;  //否则队列中肯定有和i距离为L..R的数 
			while (f[v]>=w[v]&&Calc(i-nL,i)>Calc(Q[v][f[v]],i)) f[v]--;
			Q[v][++f[v]]=i-nL;
			if (f[v]>=w[v]&&Calc(Q[v][w[v]],i)>0) {flag=1;break;}
		}
		//-------------------------
		if (flag) L=Mid;else R=Mid;
	}
	for (int i=nL;i<=nR;i+=2)
	{
		Ll tmp=(Ll)(i*Mid+0.5);
		double now=Db(tmp)/Db(i);
		if (abs(now-Mid)<Best) {Best=abs(now-Mid);X=tmp;Y=i;}
	}
	Ll tmp=Gcd(X,Y);
	X/=tmp;Y/=tmp;
	if (Y==1) printf("%lld\n",X);else printf("%lld/%lld\n",X,Y);
	return 0;
}
Problem3323
#include<set>
#include<map>
#include<cmath>
#include<queue>
#include<bitset>
#include<string>
#include<cstdio>
#include<cctype>
#include<cassert>
#include<cstdlib>
#include<cstring>
#include<sstream>
#include<iostream>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define pb push_back
#define mp make_pair
#define fir first
#define sec second
#define Mid (L+R>>1)

#define dprintf(...) fprintf(stderr,__VA_ARGS__)
using namespace std;

int IN(){
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> Vi;

const int N=100000+19,p=20130426,top=100000+4;

struct node *null;
struct node{
	node *L,*R,*Fa;
	int mul,add,key;
	int sz;
	void Update(){
		if (this==null) return;
		sz=L->sz+R->sz+1;
	}
	void Mult(int v){
		key=1ll*key*v%p;
		add=1ll*add*v%p;
		mul=1ll*mul*v%p;
	}
	void Plus(int x){
		key=(key+x)%p;
		add=(add+x)%p;
	}
	void Down(){
		if (this==null) return;
		if (mul!=1){
			L->Mult(mul);
			R->Mult(mul);
			mul=1;
		}
		if (add!=0){
			L->Plus(add);
			R->Plus(add);
			add=0;
		}
	}
	void Zig(){
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->L=R;if (R!=null) R->Fa=y;
		R=y;y->Fa=this;y->Update();
	}
	void Zag(){
		node *y=Fa,*z=y->Fa;
		if (y==z->L) z->L=this;else if (y==z->R) z->R=this;Fa=z;
		y->R=L;if (L!=null) L->Fa=y;
		L=y,y->Fa=this;y->Update();
	}
} Nd[N],*rt;

void Splay(node *x,node *Aim=null){
	static node *S[N];
	node *tmp=x;int k=0;
	while (tmp->Fa!=Aim) S[++k]=tmp,tmp=tmp->Fa;S[++k]=tmp;
	while (k) S[k--]->Down();
	while (x->Fa!=Aim){
		node *y=x->Fa,*z=y->Fa;
		if (y->Fa!=Aim)
			if (x==y->L)
				if (y==z->L) y->Zig(),x->Zig();else x->Zig(),x->Zag();
			else if (y==z->L) x->Zag(),x->Zig();else y->Zag(),x->Zag();
		else if (x==y->L) x->Zig();else x->Zag();
	}
	if (Aim==null) rt=x;
	x->Update();
}
node *Build(int L,int R,node *fa){
	if (L>R) return null;
	node *x=Nd+Mid;
	x->mul=1;
	x->Fa=fa;
	x->L=Build(L,Mid-1,x);
	x->R=Build(Mid+1,R,x);
	return x->Update(),x;
}

int Pow[N];
int n,res,Ql,Qr,X;
char opt[10];

void DFS(node *x,int k){
	if (x==null) return;
	x->Down();
	DFS(x->L,k);
	k+=x->L->sz+1;
	if (k>1&&k<top) (res+=1ll*x->key*Pow[k-2]%p)%=p;
	DFS(x->R,k);
}
node *Find(int k){
	node *x=rt;
	for (;;){
		if (x->L->sz+1==k) return x;
		x->Down();
		if (k<=x->L->sz) x=x->L;else k-=x->L->sz+1,x=x->R;
	}
}
node *getseq(int L,int R){
	Splay(Find(L-1));
	Splay(Find(R+1),rt);
	return rt->R->L;
}

int main(){
	null=Nd;
	*null=(node){null,null,null,0,0,0,0};
	rt=Build(1,top,null);
	for (int Qc=IN();Qc--;){
		scanf("%s",opt);
		if (opt[0]=='m'&&opt[3]=='\0'){
			Ql=IN()+2,Qr=IN()+2;
			getseq(Ql,Qr)->Mult(IN());
		}
		if (opt[0]=='a'){
			Ql=IN()+2,Qr=IN()+2;
			getseq(Ql,Qr)->Plus(IN());
		}
		if (opt[0]=='m'&&opt[3]=='x'){
			Ql=IN()+2,Qr=IN()+2;
			node *x=getseq(Ql,Qr),*y;
			for (y=x;y->R!=null;) y=y->R,y->Down();
			Splay(y,x->Fa);
			y->Fa->key+=y->key;
			y->key=0;
			y->R=y->L;
			y->L=null;
		}
		if (opt[0]=='q'){
			X=IN();
			Pow[0]=1;
			For(i,1,top+1) Pow[i]=1ll*Pow[i-1]*X%p;
			res=0;
			DFS(rt,0);
			printf("%d\n",res);
		}
	}
}
Problem3329
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int Mod=1e9+7;
typedef long long LL;
LL f[64],g[64],n;
struct Matrix {int s[2][2];} A,F,res;
int T;

void Task_1(LL n)
{
	LL res=0;
	for (int i=63;i;i--)
		if (n>>i&1)
		{
			res+=f[i-1]+g[i-1];
			if (i<63&&(n>>(i+1)&1)) break;
		}
	printf("%lld\n",res-1);
}

Matrix operator * (Matrix A,Matrix B)
{
	Matrix C;
	For(i,0,2) For(j,0,2) C.s[i][j]=0;
	For(i,0,2) For(k,0,2) For(j,0,2) (C.s[i][j]+=1LL*A.s[i][k]*B.s[k][j]%Mod)%=Mod;
	return C;
}
void Task_2(LL b)
{
	F.s[0][0]=F.s[0][1]=1,F.s[1][0]=F.s[1][1]=0;
	A.s[1][1]=0,A.s[0][0]=A.s[0][1]=A.s[1][0]=1;
	res.s[0][0]=res.s[1][1]=1,res.s[0][1]=res.s[1][0]=0;
	for (;b;b>>=1,A=A*A) if (b&1) res=res*A;
	F=F*res;
	printf("%d\n",(F.s[0][0]+F.s[0][1])%Mod);
}

int main()
{
	f[0]=g[0]=1;
	For(i,0,63) g[i+1]=f[i],f[i+1]=f[i]+g[i];
	for (scanf("%d",&T);T--;) scanf("%lld",&n),Task_1(n+1),Task_2(n-1);
}
Problem3330
#include<cmath>
#include<string>
#include<cstdio>
#include<sstream>
#include<algorithm>
#include<functional>
using namespace std;

int n,p,A[22];
double B[22],C,eps;

double calc2(double x,double y)
{
	double tmp=0;
	for (int i=1;i<=n;i++) 
	{
		C=100.0/(1.0+exp(x-y*A[i]));
		tmp+=B[i]*log(100.0/C)+(100-B[i])*log(100.0/(100.0-C));
	}
	return tmp;
}
double calc(double x)
{
	double L=0.0,R=1.0;
	while (R-L>eps)
	{
		double c1=L+(R-L)/3.0,c2=R-(R-L)/3.0;
		calc2(x,c1)>calc2(x,c2)?L=c1:R=c2;
	}
	return calc2(x,L);
}

void Print(double x)
{
	stringstream ss;string t;
	ss<<x;ss>>t;int pre=t.find('.');
	if (p>pre) 
	{
		printf("%d.",(int)x);p-=pre;
		while (p--) x-=(int)x,x*=10,printf("%d",(int)x);
	} else
	{
		ss<<(int)x;ss>>t;
		for (int i=0;i<p;i++) putchar(t[i]);
		for (int i=p;i<pre;i++) putchar('0');
	}
}

int main()
{
	scanf("%d%d",&n,&p);
	for (int i=1;i<=n;i++) scanf("%d",&A[i]);
	sort(A+1,A+n+1,greater<int>());
	B[1]=100.0;for (int i=2;i<=n;i++) B[i]=B[i-1]-100.0/(n-1);
	eps=0.1;for (int i=0;i<p;i++) eps/=10.0;
	double L=0.0,R=10.0;
	while (R-L>eps)
	{
		double c1=L+(R-L)/3.0,c2=R-(R-L)/3.0;
		calc(c1)>calc(c2)?L=c1:R=c2;
	}
	Print(calc(L));puts("");
}
Problem3333
#include<cstdio>
#include<cctype>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=500000+19,oo=(1<<30)-1;
long long Ans;
int A[N],B[N],F[N],C[N],pos[N*4];
int n,m,tot,x,t,tmp,Ql,Qr,Qx;

int Find(int x)
{
	int L=1,R=tot,res;
	while (L<=R) if (B[Mid]>=x) res=Mid,R=Mid-1;else L=Mid+1;
	return res;
}

int Query(int x) {int Ans=0;for (int i=x;i;i-=i&-i) Ans+=C[i];return Ans;}
void Update(int x,int v) {for (int i=x;i<=tot;i+=i&-i) C[i]+=v;}
void Build(int x,int L,int R)
{
	if (L==R) {pos[x]=L;return;}
	Build(Lsn,L,Mid),Build(Rsn,Mid+1,R);
	pos[x]=(A[pos[Lsn]]<A[pos[Rsn]])?pos[Lsn]:pos[Rsn];
}
int Query(int x,int L,int R)
{
	if (Ql<=L&&R<=Qr) return pos[x];
	int res=0,tmp;
	if (Ql<=Mid) if (A[tmp=Query(Lsn,L,Mid)]<A[res]||!res) res=tmp;
	if (Qr>Mid) if (A[tmp=Query(Rsn,Mid+1,R)]<A[res]||!res) res=tmp;
	return res;
}
void Modify(int x,int L,int R)
{
	if (L==R) {pos[x]=L;return;}
	Qx<=Mid?Modify(Lsn,L,Mid):Modify(Rsn,Mid+1,R);
	pos[x]=(A[pos[Lsn]]<A[pos[Rsn]])?pos[Lsn]:pos[Rsn];
}

int main()
{
	n=IN(),m=IN();
	For(i,1,n+1) A[i]=B[i]=IN();
	sort(B+1,B+n+1);tot=unique(B+1,B+n+1)-B;
	For(i,1,n+1) A[i]=Find(A[i]);
	for (int i=n;i>=1;i--) Ans+=(F[i]=Query(A[i]-1)),Update(A[i],1);
	Build(1,1,n);
	printf("%lld\n",Ans);
	while (m--)
	{
		x=IN(),t=A[x];
		if (t!=oo)
			while ((Ql=x,Qr=n,A[tmp=Query(1,1,n)])<=t)
				Ans-=F[tmp],A[tmp]=oo,Qx=tmp,Modify(1,1,n);
		printf("%lld\n",Ans);
	}
}
Problem3339
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;

const int Maxn=200000+19;
typedef int one[Maxn];
one L,nxt,pre,Last,Ans,A,C,f;
int n,Q,x,y;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Update(int x,int v) {for (;x<=n;x+=x&-x) if (C[x]>v) C[x]=v;}
int Query(int x) 
{
	int Ans=1<<30;
	for (;x;x-=x&-x) if (Ans>C[x]) Ans=C[x];
	return Ans;
}

int main()
{
	read(n),read(Q);
	for (int i=1;i<=n;i++) read(A[i]),pre[i]=Last[A[i]],Last[A[i]]=i;
	memset(Last,0,sizeof(Last));
	memset(C,60,sizeof(C));
	for (int i=n;i;i--) {f[A[i]]=1;while (f[x]) x++;Update(i,x);}
	for (int i=1;i<=Q;i++) read(x),read(y),L[i]=x,nxt[i]=Last[y],Last[y]=i;
	for (int R=n;R;R--)
	{
		for (int i=Last[R];i;i=nxt[i]) Ans[i]=Query(L[i]);
		Update(pre[R]+1,A[R]);
	}
	for (int i=1;i<=Q;i++) printf("%d\n",Ans[i]);
}
Problem3343
#include<cstdio>
#include<cctype>
#include<cmath>
#include<algorithm>
 
#define ID(x) (((x)-1)/Sz)
#define L(x) ((x)*Sz+1)
#define R(x) (((x)+1)*Sz)
using namespace std;
 
const int Cnt=1000+19,Maxn=1001000+19;
int Add[Cnt],A[Maxn],B[Maxn];
int n,Q,Ql,Qr,Sz,cnt,x,v,Bl,Br,Ans;
char s[3];
 
int c;
void read(int &x)
{
    while (!isdigit(c=getchar()));x=c-'0';
    while (isdigit(c=getchar())) x=x*10+c-'0';
}
void reset(int x)
{
    for (int i=L(x);i<=R(x);i++) B[i]=A[i];
    sort(B+L(x),B+min(n+1,L(x+1)));
}
 
int main()
{
    read(n),read(Q);
    Sz=sqrt(1.0*n)+1;cnt=n/Sz+(n%Sz!=0);
    for (int i=1;i<=n;i++) read(A[i]),B[i]=A[i];
    for (int i=0;i<cnt;i++) reset(i);
    while (Q--)
    {
        scanf("%s",s);
        read(Ql),read(Qr),read(v);
        Bl=ID(Ql)+(Ql%Sz!=1);
        Br=ID(Qr)-(Qr%Sz!=0);
        if (s[0]=='M') 
        {
            if (Bl<=Br)
            {
                for (int i=Bl;i<=Br;i++) Add[i]+=v;
                for (int i=Ql;i<L(Bl);i++) A[i]+=v;
                for (int i=R(Br)+1;i<=Qr;i++) A[i]+=v;
            } else for (int i=Ql;i<=Qr;i++) A[i]+=v;
            reset(ID(Ql));reset(ID(Qr));
        } else
        {
            Ans=0;
            if (Bl<=Br)
            {
                for (int i=Bl;i<=Br;i++) 
                    Ans+=min(n,R(i))-(lower_bound(B+L(i),B+min(n+1,L(i+1)),v-Add[i])-B)+1;
                for (int i=Ql;i<L(Bl);i++) Ans+=(A[i]+Add[ID(i)]>=v);
                for (int i=R(Br)+1;i<=Qr;i++) Ans+=(A[i]+Add[ID(i)]>=v);
            } else for (int i=Ql;i<=Qr;i++) Ans+=(A[i]+Add[ID(i)]>=v);
            printf("%d\n",Ans);
        }
    }
}
Problem3352
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Lsn (x<<1)
#define Rsn (x<<1|1)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,f,x;
	while (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

typedef long long LL;
typedef double Db;

const int N=500000+19,oo=(1<<30)-1;
struct node
{
	int T,P,V;
	bool operator < (const node& B) const {return T<B.T||T==B.T&&P<B.P;}
} A[N];
int f[N],g[N],h[N],n,D,U,S;

struct SegTree
{
	int Max[N*4],Ql,Qr,Qx,Qv;
	SegTree() {memset(Max,200,sizeof(Max));}
	void Update(int x,int L,int R)
	{
		Max[x]=max(Max[x],Qv);
		if (L==R) return;
		Qx<=Mid?Update(Lsn,L,Mid):Update(Rsn,Mid+1,R);
	}
	int Query(int x,int L,int R)
	{
		if (Ql<=L&&R<=Qr) return Max[x];
		int res=-oo;
		if (Ql<=Mid) res=max(res,Query(Lsn,L,Mid));
		if (Qr>Mid) res=max(res,Query(Rsn,Mid+1,R));
		return res;
	}
	void Update(int x,int v) {Qx=x,Qv=v,Update(1,1,500001);}
	int Query(int L,int R) {return L<=R?(Ql=L,Qr=R,Query(1,1,500001)):-oo;}
} S1,S2;

void Modify(int x)
{
	S1.Update(A[x].P,f[x]+D*A[x].P);
	S2.Update(A[x].P,f[x]-U*A[x].P);
}

int main()
{
	n=IN(),D=IN(),U=IN(),S=IN();
	For(i,1,n+1) A[i]=(node){IN(),IN(),IN()};
	A[++n]=(node){0,S,0};
	A[++n]=(node){5e5+1,S,0};
	sort(A+1,A+n+1);
	f[1]=0;Modify(1);
	for (int i=2,L,R;i<=n;i=R+1)
	{
		L=R=i;
		while (R+1<=n&&A[R+1].T==A[R].T) R++;
		for (i=L;i<=R;i++) f[i]=h[i]=g[i]=-oo;
		for (i=L;i<=R;i++)
		{
			f[i]=max(f[i],S1.Query(1,A[i].P)-D*A[i].P+A[i].V);
			f[i]=max(f[i],S2.Query(A[i].P+1,500001)+U*A[i].P+A[i].V);
			g[i]=h[i]=f[i];
		}
		for (i=L+1;i<=R;i++) g[i]=max(g[i],g[i-1]-D*(A[i].P-A[i-1].P)+A[i].V);
		for (i=R-1;i>=L;i--) h[i]=max(h[i],h[i+1]-U*(A[i+1].P-A[i].P)+A[i].V);
		for (i=L;i<=R;i++) f[i]=max(f[i],max(g[i],h[i])),Modify(i);
	}
	printf("%d\n",f[n]);
}
Problem3364
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
 
const int Maxn=40000+19;
struct Edge {int y,z,nxt;} E[Maxn*2];
int Deep[Maxn],Fa[Maxn][16],Dis[Maxn][16],Last[Maxn];
int n,Q,x,y,z,cnt,m;
 
void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void Link(int x,int y,int z)
{
    E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;
    E[cnt]=(Edge){x,z,Last[y]};Last[y]=cnt++;
}
 
void DFS(int x)
{
    for (int i=Last[x];~i;i=E[i].nxt)
        if (E[i].y!=Fa[x][0])
            Deep[E[i].y]=Deep[x]+1,Dis[E[i].y][0]=E[i].z,
            Fa[E[i].y][0]=x,DFS(E[i].y);
}
int Query(int x,int y)
{
    if (Deep[x]>Deep[y]) swap(x,y);
    int Ans=0;
    for (int k=Deep[y]-Deep[x],i=0;k;k>>=1,i++)
        if (k&1) Ans+=Dis[y][i],y=Fa[y][i];
    if (x==y) return Ans;
    for (int i=15;i>=0;i--)
        if (Fa[x][i]!=Fa[y][i])
            Ans+=Dis[x][i]+Dis[y][i],x=Fa[x][i],y=Fa[y][i];
    return Ans+Dis[x][0]+Dis[y][0];
}
 
int main()
{
    memset(Last,-1,sizeof(Last));
    read(n),read(m);
    for (int i=1;i<n;i++) read(x),read(y),read(z),Link(x,y,z);
    DFS(1);
    for (int x=1;x<=15;x++)
        for (int i=1;i<=n;i++)
            Dis[i][x]=Dis[i][x-1]+Dis[Fa[i][x-1]][x-1],
            Fa[i][x]=Fa[Fa[i][x-1]][x-1];
    read(Q);
    while (Q--)
    {
        scanf("%d%d",&x,&y);
        printf("%d\n",Query(x,y));
    }
}
Problem3373
#include<cstdio>
#include<vector>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Pb push_back
#define Mp make_pair
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

typedef long long LL;
typedef double Db;
typedef pair<int,int> Pii;

const int N=100+19,M=1000+19;

vector<Pii> V[N];
int n,Q,Ans,x,a,b;

struct Graph
{
	struct Edge {int y,nxt;} E[M];
	int Last[N],vis[N],cnt,Time,f;
	
	void Reset()
	{
		cnt=0;
		memset(Last,-1,sizeof(Last));
		memset(vis,0,sizeof(vis));
	}
	void Add(int x,int y) {E[cnt]=(Edge){y,Last[x]};Last[x]=cnt++;}
	void DFS(int x)
	{
		vis[x]=-1;
		if (!f) return;
		for (int i=Last[x];~i;i=E[i].nxt)
		{
			if (vis[E[i].y]==0) DFS(E[i].y);else 
				if (vis[E[i].y]==-1) f=0;
		}
		vis[x]=1;
	}
	bool Work()
	{
		f=1;
		For(i,1,n+1) if (!vis[i]) DFS(i);
		return f;
	}
} G;

bool Solve(int x)
{
	G.Reset();
	For(i,1,n+1) if (i!=x)
		For(j,0,V[i].size()) G.Add(V[i][j].first,V[i][j].second);
	For(i,0,V[x].size()) G.Add(V[x][i].second,V[x][i].first);
	return G.Work();
}

int main()
{
	n=IN(),Q=IN();
	while (Q--) x=IN(),a=IN(),b=IN(),V[x].Pb(Mp(a,b));
	For(i,1,n+1) if (Solve(i)) Ans++;
	printf("%d\n",Ans);
}
Problem3382
#include<cstdio>
#include<cctype>

#define For(i,x,y) for (int i=x;i<y;i++)
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
using namespace std;

const int N=50000+19,Len=3000000;
char Buf[Len],*b=Buf;
int B1,S1,B2,S2,x,y,n;

int IN()
{
	int c,f,x;
	while (!isdigit(c=*b++)&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');
	while (isdigit(c=*b++)) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;
}

int main()
{
	fread(Buf,1,Len,stdin);
	for (n=IN();n--;)
	{
		x=IN(),y=IN();
		B1=max(B1,x+y),S1=min(S1,x+y);
		B2=max(B2,x-y),S2=min(S2,x-y);
	}
	printf("%d\n",max(B1-S1,B2-S2));
}
Problem3436
#include<cstdio>
#include<cstring>
#include<cctype>
using namespace std;

const int Maxn=10000+19;
struct Edge {int y,z,nxt;} E[Maxn*2];
int n,m,opt,x,y,z;
int Last[Maxn],Dis[Maxn],vis[Maxn],cnt;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));
	x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

void Add_Edge(int x,int y,int z) {E[cnt]=(Edge){y,z,Last[x]};Last[x]=cnt++;}
int SPFA_DFS(int x)
{
	vis[x]=1;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (Dis[x]+E[i].z<Dis[E[i].y])
		{
			Dis[E[i].y]=Dis[x]+E[i].z;
			if (vis[E[i].y]||SPFA_DFS(E[i].y)) return 1;
		}
	return vis[x]=0;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	scanf("%d%d",&n,&m);
	for (int i=0;i<m;i++) 
	{
		read(opt),read(x),read(y);
		if (opt==1) read(z),Add_Edge(x,y,-z);
		if (opt==2) read(z),Add_Edge(y,x,z),Add_Edge(x,y,0);
		if (opt==3) Add_Edge(x,y,0),Add_Edge(y,x,0);
	}
	for (int i=1;i<=n;i++)
		if (!vis[i]&&SPFA_DFS(i)) {puts("No");return 0;}
	puts("Yes");
}
Problem3437
#include<cstdio>
#include<cctype>
using namespace std;

typedef long long LL;
const int Maxn=1000000+19;
const LL oo=1LL<<60;
int n,A[Maxn],B;
LL Q[Maxn],P[Maxn],F[Maxn],cur,nxt;
int Que[Maxn],L,R;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

LL y(int a) {return F[a]-Q[a]+n*P[a];}
LL x(int a) {return P[a];}
double g(int k,int j) {return (1.0*(y(j)-y(k)))/(1.0*(x(j)-x(k)));}	//k<j
LL calc(int a,int b) {return A[b]+F[a]+Q[b]-Q[a]-(n-b)*(P[b]-P[a]);}

int main()
{
	read(n);
	for (int i=1;i<=n;i++) read(A[i]);
	for (int i=1;i<=n;i++) read(B),Q[i]=Q[i-1]+1LL*B*(n-i),P[i]=P[i-1]+B;
	Que[0]=0;
	for (int i=1;i<=n;i++)
	{
		cur=calc(Que[L],i);
		while (L<R&&cur>(nxt=calc(Que[L+1],i))) L++,cur=nxt;
		F[i]=cur;
		while (L<R&&g(Que[R-1],Que[R])>g(Que[R],i)) R--;
		Que[++R]=i;
	}
	printf("%lld\n",F[n]);
}
Problem3437
#include<cstdio>
#include<cctype>
using namespace std;

typedef long long LL;
const int Maxn=1000000+19;
const LL oo=1LL<<60;
int n,A[Maxn],B;
LL Q[Maxn],P[Maxn],F[Maxn],cur,nxt;
int Que[Maxn],L,R;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

LL y(int a) {return F[a]-Q[a]+n*P[a];}
LL x(int a) {return P[a];}
double g(int k,int j) {return (1.0*(y(j)-y(k)))/(1.0*(x(j)-x(k)));}	//k<j
LL calc(int a,int b) {return A[b]+F[a]+Q[b]-Q[a]-(n-b)*(P[b]-P[a]);}

int main()
{
	read(n);
	for (int i=1;i<=n;i++) read(A[i]);
	for (int i=1;i<=n;i++) read(B),Q[i]=Q[i-1]+1LL*B*(n-i),P[i]=P[i-1]+B;
	Que[0]=0;
	for (int i=1;i<=n;i++)
	{
		while (L<R&&calc(Que[L],i)>calc(Que[L+1],i)) L++;
		F[i]=calc(Que[L],i);
		while (L<R&&g(Que[R-1],Que[R])>g(Que[R],i)) R--;
		Que[++R]=i;
	}
	printf("%lld\n",F[n]);
}
Problem3438
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;

const int Maxn=3000+19,oo=(1<<30)-1;
struct Edge {int y,f,nxt;} E[Maxn*Maxn*2];
int Last[Maxn],Dis[Maxn],Q[Maxn];
int cnt,n,m,tot,S,T,x,k,c1,c2,f,w,Ans;

int c;
void read(int &x)
{
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}
void Add_Edge(int x,int y,int f)
{
	E[cnt]=(Edge){y,f,Last[x]};Last[x]=cnt++;
	E[cnt]=(Edge){x,0,Last[y]};Last[y]=cnt++;
}

bool BFS()
{
	memset(Dis,-1,sizeof(Dis)),Dis[S]=1;
	f=1,w=0,Q[1]=S;
	while (f>w)
	{
		int x=Q[++w];
		for (int i=Last[x];i!=-1;i=E[i].nxt)
			if (E[i].f&&Dis[E[i].y]==-1) Dis[E[i].y]=Dis[x]+1,Q[++f]=E[i].y;
	}
	return Dis[T]!=-1;
}
int Dinic(int x,int Flow)
{
	if (x==T||!Flow) return Flow;
	int res=0;
	for (int i=Last[x];i!=-1;i=E[i].nxt)
		if (E[i].f&&Dis[x]+1==Dis[E[i].y])
		{
			int tmp=Dinic(E[i].y,min(E[i].f,Flow));
			Flow-=tmp,res+=tmp;
			E[i].f-=tmp,E[i^1].f+=tmp;
		}
	if (!res) Dis[x]=-1;
	return res;
}

int main()
{
	memset(Last,-1,sizeof(Last));
	read(n);tot=n;S=++tot;T=++tot;
	for (int i=1;i<=n;i++) read(x),Ans+=x,Add_Edge(S,i,x);
	for (int i=1;i<=n;i++) read(x),Ans+=x,Add_Edge(i,T,x);
	read(m);
	while (m--)
	{
		read(k),read(c1),read(c2);Ans+=c1+c2;
		int u=++tot,v=++tot;
		Add_Edge(S,u,c1),Add_Edge(v,T,c2);
		while (k--) read(x),Add_Edge(u,x,oo),Add_Edge(x,v,oo);
	}
	while (BFS()) Ans-=Dinic(S,oo);
	printf("%d\n",Ans);
}
Problem3439
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstring>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

void read(int &x)
{
	int c;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=x*10+c-'0';
}

const int N=100000+19,M=3*N,Top=15000000+19;
vector<int> V[M];
int son[M][26],Pos[N],rt[M],In[M],Out[M];
int S[Top],Lsn[Top],Rsn[Top];
int n,x,u,Time,tot,cnt,k;
char s[M];

void Build(int y,int &x,int L,int R,int t)
{
	S[x=++cnt]=S[y]+1;
	if (L==R) return;
	Lsn[x]=Lsn[y],Rsn[x]=Rsn[y];
	if (t<=Mid) Build(Lsn[y],Lsn[x],L,Mid,t);else Build(Rsn[y],Rsn[x],Mid+1,R,t);
}

void DFS(int x)
{
	In[x]=++Time;
	int p=rt[Time-1],t=0;
	for (int i=0,_=V[x].size();i<_;i++) Build(p,t,1,n,V[x][i]),p=t,t=0;
	rt[Time]=p;
	For(i,0,26) if (son[x][i]) DFS(son[x][i]);
	Out[x]=Time;
}

int main()
{
	read(n);
	For(i,1,n+1)
	{
		scanf("%s",s);
		x=0;int Len=strlen(s);
		for (int t=Len-1;t>=0;t--) {int& u=son[x][s[t]-'a'];if (!u) u=++tot;x=u;}
		Pos[i]=x;V[x].push_back(i);
	}
	DFS(0);
	For(i,1,n+1)
	{
		read(k);
		int Tr=rt[Out[Pos[i]]],Tl=rt[In[Pos[i]]-1],L=1,R=n;
		if (S[Tr]-S[Tl]<k) {puts("-1");continue;}
		while (L!=R)
			if (S[Lsn[Tr]]-S[Lsn[Tl]]>=k) R=Mid,Tr=Lsn[Tr],Tl=Lsn[Tl];
				else k-=S[Lsn[Tr]]-S[Lsn[Tl]],L=Mid+1,Tr=Rsn[Tr],Tl=Rsn[Tl];
		printf("%d\n",L);
	}
}
Problem3444
#include<cstdio>
#include<cctype>
#include<cstdlib>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=500000+19,Mod=989381;
int D[N],Fa[N],S[N],A[N],n,m,x,y,cnt,Ans=1;

int Getf(int x) {return Fa[x]==x?x:Fa[x]=Getf(Fa[x]);}
void Union(int x,int y)
{
	int fx=Getf(x),fy=Getf(y);
	if (fx!=fy) S[fy]+=S[fx],Fa[fx]=fy;else puts("0"),exit(0);
}

int main()
{
	n=IN(),m=IN();
	For(i,1,n+1) Fa[i]=i,S[i]=1;
	For(i,0,m) {x=IN(),A[x]=y=IN();if (A[y]!=x) D[x]++,D[y]++,Union(x,y);}
	For(i,1,n+1) if (D[i]>2) return puts("0"),0;
	For(i,1,n+1) if (Fa[i]==i) cnt++;
	For(i,1,n+1) if (Fa[i]==i&&S[i]>1) Ans=2*Ans%Mod;
	For(i,1,cnt+1) Ans=1LL*Ans*i%Mod;
	printf("%d\n",Ans);
}
Problem3448
const shuru='auto.in';
	  shuchu='auto.out';
	  maxlen=1000;
type  point=^node;
	  node=record
			endless,data:longint;
			next:array['a'..'z'] of point;
		   end;
	  str=array[0..maxlen] of char;
var	start,p,q:point;
	s:str;
	len,i,j,k,n,m:longint;
	ch:char;
procedure neww(var p:point);
begin
	new(p);
	p^.data:=0;
	p^.endless:=0;
	for ch:='a' to 'z' do p^.next[ch]:=nil;
end;
procedure forever(s:str;len,sign:longint);
var i:longint;
begin
	p:=start;
	for i:=1 to len do
	begin
		if p^.next[s[i]]=nil then begin
									neww(p^.next[s[i]]);
									p:=p^.next[s[i]];
								  end
							 else p:=p^.next[s[i]];
		inc(p^.data);
	end;
	p^.endless:=sign;
end;
function ever(s:str;len,k:longint):longint;
var i:longint;
begin
	p:=start;
	for i:=1 to len do
	begin
		if p^.next[s[i]]=nil then exit(-1);
		p:=p^.next[s[i]];
		if p^.data<k then exit(-1);
	end;
	while not((k=1) and (p^.endless<>0)) do
	begin
		if p^.endless<>0 then dec(k);
		for ch:='a' to 'z' do
			if p^.next[ch]<>nil then if p^.next[ch]^.data>=k then begin
																p:=p^.next[ch];
																break;
														   end
												   else k:=k-p^.next[ch]^.data;
	end;
	exit(p^.endless);
end;
procedure init;
begin
	neww(start);
	readln(n,m);
	for i:=1 to n do
	begin
		len:=0;
		while not(eoln) do
		begin
			inc(len);
			read(s[len]);
		end;
		readln;
		forever(s,len,i);
	end;
end;
procedure main;
begin
	init;
	for i:=1 to m do
	begin
		len:=0;
		read(k);
		read(s[1]);
		while not(eoln) do
		begin
			inc(len);
			read(s[len]);
		end;
		writeln(ever(s,len,k));
	end;
end;
begin
	main;
end.
		
Problem3448
#include<cstdio>
#include<cstring>
using namespace std;

struct node;typedef node* nd;
struct node
{
	nd t[26];int d,S,ID;
} RT;nd rt,x;
char s[1000+19];
int n,Q,u,tot,k;

nd New()
{
	nd x=new node();
	for (int i=0;i<26;i++) x->t[i]=rt;x->d=x->S=x->ID=0;
	return x;
}
void DFS(nd x)
{
	for (int i=0;i<26;i++)
		if (x->t[i]!=rt) DFS(x->t[i]),x->S+=x->t[i]->S;
}
int Query(nd x,int k)
{
	if (x->S<k) return -1;
	if (x->d) if (k==1) return x->ID;else k--;
	for (int i=0;i<26;i++)
		if (k<=x->t[i]->S) return Query(x->t[i],k);
			else k-=x->t[i]->S;
}

int main()
{
	rt=&RT;
	for (int i=0;i<26;i++) rt->t[i]=rt;rt->d=rt->S=rt->ID=0;
	scanf("%d%d",&n,&Q);
	
//	int cnt=0;
	for (int T=1;T<=n;T++)
	{
		scanf("%s",s);x=rt;
//		if (s[0]=='a'&&s[1]=='a'&&s[2]=='a'&&s[3]=='a'&&s[4]=='a'&&s[5]=='a') cnt++;
		for (int i=0,_=strlen(s);i<_;i++)
			{nd &u=x->t[s[i]-'a'];if (u==rt) u=New();x=u;}
		x->d=x->S=1,x->ID=T;
	}
	DFS(rt);rt->S=0;
	
//	printf("%d\n",cnt);
	
	while (Q--)
	{
		scanf("%d%s",&k,s);x=rt;
		for (int i=0,_=strlen(s);i<_;i++)
			{nd u=x->t[s[i]-'a'];x=u;if (x==rt) break;}
		if (x==rt) puts("-1");else printf("%d\n",Query(x,k));
	}
}
Problem3448
#include<cstdio>
#include<cstring>
using namespace std;

struct node;typedef node* nd;
struct node
{
	nd t[26];int d,S,ID;
} RT,ND[2300000];nd rt,x;
char s[1000+19];
int n,Q,u,tot,k,ncnt;

nd New()
{
	nd x=ND+(++ncnt);
	for (int i=0;i<26;i++) x->t[i]=rt;x->d=x->S=x->ID=0;
	return x;
}
void DFS(nd x)
{
	for (int i=0;i<26;i++)
		if (x->t[i]!=rt) DFS(x->t[i]),x->S+=x->t[i]->S;
}
int Query(nd x,int k)
{
	if (x->S<k) return -1;
	if (x->d) if (k==1) return x->ID;else k--;
	for (int i=0;i<26;i++)
		if (k<=x->t[i]->S) return Query(x->t[i],k);
			else k-=x->t[i]->S;
}

int main()
{
	rt=&RT;
	for (int i=0;i<26;i++) rt->t[i]=rt;rt->d=rt->S=rt->ID=0;
	scanf("%d%d",&n,&Q);
	for (int T=1;T<=n;T++)
	{
		scanf("%s",s);x=rt;
		for (int i=0,_=strlen(s);i<_;i++)
			{nd &u=x->t[s[i]-'a'];if (u==rt) u=New();x=u;}
		x->d=x->S=1,x->ID=T;
	}
	DFS(rt);rt->S=0;
	while (Q--)
	{
		scanf("%d%s",&k,s);x=rt;
		for (int i=0,_=strlen(s);i<_;i++)
			{nd u=x->t[s[i]-'a'];x=u;if (x==rt) break;}
		if (x==rt) puts("-1");else printf("%d\n",Query(x,k));
	}
}
Problem3448
#include<cstdio>
#include<cstring>
using namespace std;
 
const int Len=2300000+19;
char s[1000+19];
int t[Len][26],d[Len],S[Len],ID[Len];
int n,Q,x,u,tot,k;
 
void DFS(int x)
{
	for (int i=0;i<26;i++)
		if (t[x][i]) DFS(t[x][i]),S[x]+=S[t[x][i]];
}
int Query(int x,int k)
{
	if (S[x]<k) return -1;
	if (d[x]) if (k==1) return ID[x];else k--;
	for (int i=0;i<26;i++)
		if (k<=S[t[x][i]]) return Query(t[x][i],k);
			else k-=S[t[x][i]];
}
 
int main()
{
	scanf("%d%d",&n,&Q);
	for (int T=1;T<=n;T++)
	{
		scanf("%s",s);x=0;
		for (int i=0,_=strlen(s);i<_;i++)
			{int &u=t[x][s[i]-'a'];if (!u) u=++tot;x=u;}
		d[x]=S[x]=1,ID[x]=T;
	}
	DFS(0);S[0]=0;	 
	while (Q--)
	{
		scanf("%d%s",&k,s);x=0;
		for (int i=0,_=strlen(s);i<_;i++)
			{int u=t[x][s[i]-'a'];x=u;if (!x) break;}
		if (!x) puts("-1");else printf("%d\n",Query(x,k));
	}
}
Problem3450
#include<cstdio>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

double Ans,cur;
char s[10000000+19];
int n;

int main()
{
	scanf("%d",&n);
	scanf("%s",s);
	For(i,0,n)
	{
		double t=(s[i]=='?'?0.5:(s[i]=='x'?0:1));
		Ans+=t*(2*cur+1);
		cur=t*(cur+1);
	}
	printf("%.4lf\n",Ans);
}
Problem3450
#include<cstdio>

double A,c,t;char s;int n;

int main()
{
	scanf("%d\n",&n);
	for (int i=0;i<n;i++)
	{
		s=getchar();
		t=(s=='?'?0.5:(s=='x'?0:1));
		A+=t*(2*c+1),c=t*(c+1);
	}
	printf("%.4lf\n",A);
}
Problem3456
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=130000*4+19,P=1004535809;
int rev[N],Fac[N],Inv[N],Pow2[N],W[2][N];
int f[N],g[N],h[N],tmp[N];
int c,n,m;

int Pow(int a,int b,int p=P)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%p) if (b&1) res=1LL*res*a%p;
	return res;
}
void NTT(int *A,int n,int f)
{
	For(i,0,n) if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=j,l=0,x,y;k<j+i;k++,l+=t)
				x=A[k],y=1LL*W[f][l]*A[k+i]%P,A[k]=(x+y)%P,A[k+i]=(x-y+P)%P;
	if (f)
	{
		int In=Pow(n,P-2);
		For(i,0,n) A[i]=1LL*A[i]*In%P;
	}
}
void Solve(int L,int R)
{
	if (L==R)
	{
		f[L]=(Pow2[L]-1LL*Fac[L-1]*f[L]%P+P)%P;return;
	}
	Solve(L,Mid);

	for (c=1;c<R-L+1;c<<=1);n=c<<1;
	int W0=Pow(3,(P-1)/n),I0=Pow(W0,P-2),Pw=1,Pi=1;
	For(i,0,n)
	{
		W[0][i]=Pw,W[1][i]=Pi,Pw=1LL*Pw*W0%P,Pi=1LL*Pi*I0%P,rev[i]=0;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|x&1;
	}
	For(i,0,n) g[i]=h[i]=0;
	For(i,L,Mid+1) g[i-L]=1LL*f[i]*Inv[i-1]%P;
	For(i,1,R-L+1) h[i]=1LL*Pow2[i]*Inv[i]%P;
	NTT(g,n,0),NTT(h,n,0);
	For(i,0,n) tmp[i]=1LL*g[i]*h[i]%P;
	NTT(tmp,n,1);
	For(i,Mid+1,R+1) (f[i]+=tmp[i-L])%=P;

	Solve(Mid+1,R);
}

int main()
{
	scanf("%d",&m);n=m;
	Fac[0]=1;For(i,1,n+1) Fac[i]=1LL*i*Fac[i-1]%P;
	Inv[n]=Pow(Fac[n],P-2);
	for (int i=n;i;i--) Inv[i-1]=1LL*Inv[i]*i%P;
	For(i,1,n+1) Pow2[i]=Pow(2,1LL*i*(i-1)/2LL%(P-1));
	Solve(1,n);
	printf("%d\n",f[m]);
}
Problem3456
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=130000*8+19,P=1004535809;
typedef int one[N];
one rev,tmp,Fac,Inv,Pow2,g,h,w,Ig;
int W[2][N];
int n,m,c;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
void NTT(int *A,int n,int f)
{
	For(i,0,n) if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=j,l=0,x,y;k<j+i;k++,l+=t)
				x=A[k],y=1LL*A[k+i]*W[f][l]%P,A[k]=(x+y)%P,A[k+i]=(x-y+P)%P;
	if (f)
	{
		int In=Pow(n,P-2);
		For(i,0,n) A[i]=1LL*A[i]*In%P;
	}
}
void Prepare(int n)
{
	int W0=Pow(3,(P-1)/n),I0=Pow(W0,P-2),Pw=1,Pi=1;
	For(i,0,n)
	{
		W[0][i]=Pw,W[1][i]=Pi,Pw=1LL*Pw*W0%P,Pi=1LL*Pi*I0%P,rev[i]=0;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|x&1;
	}	
}
void GetInv(int *A,int *B,int n)
{
	if (n==1) {B[0]=Pow(A[0],P-2);return;}
	GetInv(A,B,n/2);n*=2;
	Prepare(n);
	For(i,0,n/2) tmp[i]=A[i];
	NTT(tmp,n,0),NTT(B,n,0);
	For(i,0,n) B[i]=(2*B[i]%P-1LL*B[i]*B[i]%P*tmp[i]%P+P)%P;
	NTT(B,n,1);
	For(i,n/2,n) B[i]=0;
}

int main()
{
	scanf("%d",&m);
	for (c=1;c<=m;c<<=1);n=c<<1;
	Fac[0]=1;For(i,1,n+1) Fac[i]=1LL*Fac[i-1]*i%P;
	Inv[n]=Pow(Fac[n],P-2);
	for (int i=n;i;i--) Inv[i-1]=1LL*Inv[i]*i%P;
	For(i,0,n+1) Pow2[i]=Pow(2,1LL*i*(i-1)/2%(P-1));
	For(i,0,n) g[i]=1LL*Pow2[i]*Inv[i]%P;
	For(i,1,n) w[i]=1LL*Pow2[i]*Inv[i-1]%P;
	GetInv(g,Ig,n);n*=2;
	Prepare(n);
	NTT(Ig,n,0),NTT(w,n,0);
	For(i,0,n) h[i]=1LL*Ig[i]*w[i]%P;
	NTT(h,n,1);
	printf("%d\n",1LL*h[m]*Fac[m-1]%P);
}
Problem3456
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=130000*8+19,P=1004535809;
typedef int one[N];
one rev,g,f,D,tmp,Inv,Fac;
int W[2][N],n,c,m;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
void NTT(int *A,int n,int f)
{
	For(i,0,n) if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=j,l=0,x,y;k<j+i;k++,l+=t)
				x=A[k],y=1LL*A[k+i]*W[f][l]%P,A[k]=(x+y)%P,A[k+i]=(x-y+P)%P;
	if (f)
	{
		int In=Pow(n,P-2);
		For(i,0,n) A[i]=1LL*A[i]*In%P;
	}
}
void Prepare(int n)
{
	int W0=Pow(3,(P-1)/n),I0=Pow(W0,P-2),Pw=1,Pi=1;
	For(i,0,n)
	{
		W[0][i]=Pw,W[1][i]=Pi,Pw=1LL*Pw*W0%P,Pi=1LL*Pi*I0%P,rev[i]=0;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|x&1;		
	}
}
void Getrev(int *A,int *B,int n)
{
	if (n==1) {B[0]=Pow(A[0],P-2);return;}
	Getrev(A,B,n/2);n*=2;
	For(i,0,n/2) tmp[i]=A[i];
	Prepare(n);
	NTT(tmp,n,0),NTT(B,n,0);
	For(i,0,n) B[i]=(2*B[i]%P-1LL*B[i]*B[i]%P*tmp[i]%P+P)%P;
	NTT(B,n,1);
	For(i,n/2,n) B[i]=0;
}
void Getln(int *A,int *B)
{
	Getrev(A,B,n);
	For(i,1,n+1) D[i-1]=1LL*A[i]*i%P;
	n<<=1,Prepare(n);
	NTT(D,n,0),NTT(B,n,0);
	For(i,0,n) B[i]=1LL*D[i]*B[i]%P;
	NTT(B,n,1);
	for (int i=n-1;~i;i--) B[i+1]=1LL*Pow(i+1,P-2)*B[i]%P;
}

int main()
{
	scanf("%d",&m);
	for (c=1;c<m;c<<=1);n=c<<1;
	Fac[0]=1;For(i,1,n+1) Fac[i]=1LL*Fac[i-1]*i%P;
	Inv[n]=Pow(Fac[n],P-2);
	for (int i=n;i;i--) Inv[i-1]=1LL*Inv[i]*i%P;
	For(i,0,n+1) g[i]=1LL*Pow(2,1LL*i*(i-1)/2%(P-1))*Inv[i]%P;
	Getln(g,f);
	For(i,0,n) f[i]=1LL*f[i]*Fac[i]%P;
	printf("%d\n",f[m]);
}
Problem3456
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=130000*8+19,P=1004535809;
typedef int one[N];
one rev,g,f,D,tmp,Inv,Fac;
int W[2][N],n,c,m;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
void NTT(int *A,int n,int f)
{
	For(i,0,n) if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=j,l=0,x,y;k<j+i;k++,l+=t)
				x=A[k],y=1LL*A[k+i]*W[f][l]%P,A[k]=(x+y)%P,A[k+i]=(x-y+P)%P;
	if (f)
	{
		int In=Pow(n,P-2);
		For(i,0,n) A[i]=1LL*A[i]*In%P;
	}
}
void Prepare(int n)
{
	int W0=Pow(3,(P-1)/n),I0=Pow(W0,P-2),Pw=1,Pi=1;
	For(i,0,n)
	{
		W[0][i]=Pw,W[1][i]=Pi,Pw=1LL*Pw*W0%P,Pi=1LL*Pi*I0%P,rev[i]=0;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|x&1;		
	}
}
void Getrev(int *A,int *B,int n)
{
	if (n==1) {B[0]=Pow(A[0],P-2);return;}
	Getrev(A,B,n/2);n*=2;
	For(i,0,n/2) tmp[i]=A[i];
	Prepare(n);
	NTT(tmp,n,0),NTT(B,n,0);
	For(i,0,n) B[i]=(2*B[i]%P-1LL*B[i]*B[i]%P*tmp[i]%P+P)%P;
	NTT(B,n,1);
	For(i,n/2,n) B[i]=0;
}
void Getln(int *A,int *B)
{
	Getrev(A,B,n);
	For(i,1,n+1) D[i-1]=1LL*A[i]*i%P;
	n<<=1,Prepare(n);
	NTT(D,n,0),NTT(B,n,0);
	For(i,0,n) B[i]=1LL*D[i]*B[i]%P;
	NTT(B,n,1);
	B[m]=1LL*Pow(m,P-2)*B[m-1]%P;
}

int main()
{
	scanf("%d",&m);
	for (c=1;c<m;c<<=1);n=c<<1;
	Fac[0]=1;For(i,1,n+1) Fac[i]=1LL*Fac[i-1]*i%P;
	Inv[n]=Pow(Fac[n],P-2);
	for (int i=n;i;i--) Inv[i-1]=1LL*Inv[i]*i%P;
	For(i,0,n+1) g[i]=1LL*Pow(2,1LL*i*(i-1)/2%(P-1))*Inv[i]%P;
	Getln(g,f);
	printf("%d\n",1LL*f[m]*Fac[m]%P);
}
Problem3456
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=130000*8+19,P=1004535809;
typedef int one[N];
one rev,g,f,D,tmp,Inv,Fac;
int W[2][N],n,c,m;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
void NTT(int *A,int n,int f)
{
	For(i,0,n) if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=j,l=0,x,y;k<j+i;k++,l+=t)
				x=A[k],y=1LL*A[k+i]*W[f][l]%P,A[k]=(x+y)%P,A[k+i]=(x-y+P)%P;
	if (f)
	{
		int In=Pow(n,P-2);
		For(i,0,n) A[i]=1LL*A[i]*In%P;
	}
}
void Prepare(int n)
{
	int W0=Pow(3,(P-1)/n),I0=Pow(W0,P-2),Pw=1,Pi=1;
	For(i,0,n)
	{
		W[0][i]=Pw,W[1][i]=Pi,Pw=1LL*Pw*W0%P,Pi=1LL*Pi*I0%P,rev[i]=0;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|x&1;		
	}
}
void Getrev(int *A,int *B,int n)
{
	if (n==1) {B[0]=Pow(A[0],P-2);return;}
	Getrev(A,B,(n+1)/2);
	for (c=1;c<n;c<<=1);c<<=1;
	For(i,0,n) tmp[i]=A[i];
	Prepare(c);
	NTT(tmp,c,0),NTT(B,c,0);
	For(i,0,c) B[i]=(2*B[i]%P-1LL*B[i]*B[i]%P*tmp[i]%P+P)%P;
	NTT(B,c,1);
	For(i,n,c) B[i]=0;
}
void Getln(int *A,int *B)
{
	Getrev(A,B,n);
	For(i,1,n+1) D[i-1]=1LL*A[i]*i%P;
	for (c=1;c<n;c<<=1);c<<=1;
	Prepare(c);
	NTT(D,c,0),NTT(B,c,0);
	For(i,0,c) B[i]=1LL*D[i]*B[i]%P;
	NTT(B,c,1);
	B[n]=1LL*Pow(n,P-2)*B[n-1]%P;
}

int main()
{
	scanf("%d",&n);
	Fac[0]=1;For(i,1,n+1) Fac[i]=1LL*Fac[i-1]*i%P;
	Inv[n]=Pow(Fac[n],P-2);
	for (int i=n;i;i--) Inv[i-1]=1LL*Inv[i]*i%P;
	For(i,0,n+1) g[i]=1LL*Pow(2,1LL*i*(i-1)/2%(P-1))*Inv[i]%P;
	Getln(g,f);
	printf("%d\n",1LL*f[n]*Fac[n]%P);
}
Problem3456
//分治FFT,O(n log^2 n)
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
#define Mid (L+R>>1)
using namespace std;

int IN()
{
	int c,x;
	while (!isdigit(c=getchar()));x=c-'0';
	while (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return x;
}

const int N=130000*4+19,P=1004535809;
int rev[N],Fac[N],Inv[N],Pow2[N],W[2][N];
int f[N],g[N],h[N],tmp[N];
int c,n,m;

int Pow(int a,int b,int p=P)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%p) if (b&1) res=1LL*res*a%p;
	return res;
}
void NTT(int *A,int n,int f)
{
	For(i,0,n) if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=j,l=0,x,y;k<j+i;k++,l+=t)
				x=A[k],y=1LL*W[f][l]*A[k+i]%P,A[k]=(x+y)%P,A[k+i]=(x-y+P)%P;
	if (f)
	{
		int In=Pow(n,P-2);
		For(i,0,n) A[i]=1LL*A[i]*In%P;
	}
}
void Solve(int L,int R)
{
	if (L==R)
	{
		f[L]=(Pow2[L]-1LL*Fac[L-1]*f[L]%P+P)%P;return;
	}
	Solve(L,Mid);

	for (c=1;c<R-L+1;c<<=1);n=c<<1;
	int W0=Pow(3,(P-1)/n),I0=Pow(W0,P-2),Pw=1,Pi=1;
	For(i,0,n)
	{
		W[0][i]=Pw,W[1][i]=Pi,Pw=1LL*Pw*W0%P,Pi=1LL*Pi*I0%P,rev[i]=0;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|x&1;
	}
	For(i,0,n) g[i]=h[i]=0;
	For(i,L,Mid+1) g[i-L]=1LL*f[i]*Inv[i-1]%P;
	For(i,1,R-L+1) h[i]=1LL*Pow2[i]*Inv[i]%P;
	NTT(g,n,0),NTT(h,n,0);
	For(i,0,n) tmp[i]=1LL*g[i]*h[i]%P;
	NTT(tmp,n,1);
	For(i,Mid+1,R+1) (f[i]+=tmp[i-L])%=P;

	Solve(Mid+1,R);
}

int main()
{
	scanf("%d",&m);n=m;
	Fac[0]=1;For(i,1,n+1) Fac[i]=1LL*i*Fac[i-1]%P;
	Inv[n]=Pow(Fac[n],P-2);
	for (int i=n;i;i--) Inv[i-1]=1LL*Inv[i]*i%P;
	For(i,1,n+1) Pow2[i]=Pow(2,1LL*i*(i-1)/2LL%(P-1));
	Solve(1,n);
	printf("%d\n",f[m]);
}
Problem3456
//多项式求逆 O(n log n) 
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=130000*4+19,P=1004535809;
typedef int one[N];
one rev,tmp,Fac,Inv,Pow2,g,h,w,Ig;
int W[2][N];
int n,m,c;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
void NTT(int *A,int n,int f)
{
	For(i,0,n) if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=j,l=0,x,y;k<j+i;k++,l+=t)
				x=A[k],y=1LL*A[k+i]*W[f][l]%P,A[k]=(x+y)%P,A[k+i]=(x-y+P)%P;
	if (f)
	{
		int In=Pow(n,P-2);
		For(i,0,n) A[i]=1LL*A[i]*In%P;
	}
}
void Prepare(int n)
{
	int W0=Pow(3,(P-1)/n),I0=Pow(W0,P-2),Pw=1,Pi=1;
	For(i,0,n)
	{
		W[0][i]=Pw,W[1][i]=Pi,Pw=1LL*Pw*W0%P,Pi=1LL*Pi*I0%P,rev[i]=0;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|x&1;
	}	
}
void GetInv(int *A,int *B,int n)
{
	if (n==1) {B[0]=Pow(A[0],P-2);return;}
	GetInv(A,B,(n+1)/2);
	for (c=1;c<n;c<<=1);c<<=1;
	Prepare(c);
	For(i,0,n) tmp[i]=A[i];
	NTT(tmp,c,0),NTT(B,c,0);
	For(i,0,c) B[i]=(2*B[i]%P-1LL*B[i]*B[i]%P*tmp[i]%P+P)%P;
	NTT(B,c,1);
	For(i,n,c) B[i]=0;
}

int main()
{
	scanf("%d",&n);
	Fac[0]=1;For(i,1,n+1) Fac[i]=1LL*Fac[i-1]*i%P;
	Inv[n]=Pow(Fac[n],P-2);
	for (int i=n;i;i--) Inv[i-1]=1LL*Inv[i]*i%P;
	For(i,0,n+1) Pow2[i]=Pow(2,1LL*i*(i-1)/2%(P-1));
	For(i,0,n+1) g[i]=1LL*Pow2[i]*Inv[i]%P;
	For(i,1,n+1) w[i]=1LL*Pow2[i]*Inv[i-1]%P;
	GetInv(g,Ig,n+1);
	for (c=1;c<n+1;c<<=1);c<<=1;
	Prepare(c);
	NTT(Ig,c,0),NTT(w,c,0);
	For(i,0,c) h[i]=1LL*Ig[i]*w[i]%P;
	NTT(h,c,1);
	printf("%d\n",1LL*h[n]*Fac[n-1]%P);
}
Problem3456
//多项式求ln O(n log n) 
#include<cstdio>
#include<cstring>
#include<algorithm>

#define For(i,x,y) for (int i=x;i<y;i++)
using namespace std;

const int N=130000*4+19,P=1004535809;
typedef int one[N];
one rev,g,f,D,tmp,Inv,Fac;
int W[2][N],n,c,m;

int Pow(int a,int b)
{
	int res=1;
	for (;b;b>>=1,a=1LL*a*a%P) if (b&1) res=1LL*res*a%P;
	return res;
}
void NTT(int *A,int n,int f)
{
	For(i,0,n) if (i<rev[i]) swap(A[i],A[rev[i]]);
	for (int i=1;i<n;i<<=1)
		for (int j=0,t=n/(i<<1);j<n;j+=i<<1)
			for (int k=j,l=0,x,y;k<j+i;k++,l+=t)
				x=A[k],y=1LL*A[k+i]*W[f][l]%P,A[k]=(x+y)%P,A[k+i]=(x-y+P)%P;
	if (f)
	{
		int In=Pow(n,P-2);
		For(i,0,n) A[i]=1LL*A[i]*In%P;
	}
}
void Prepare(int n)
{
	int W0=Pow(3,(P-1)/n),I0=Pow(W0,P-2),Pw=1,Pi=1;
	For(i,0,n)
	{
		W[0][i]=Pw,W[1][i]=Pi,Pw=1LL*Pw*W0%P,Pi=1LL*Pi*I0%P,rev[i]=0;
		for (int x=i,&y=rev[i],k=1;k<n;k<<=1,x>>=1) y=y<<1|x&1;		
	}
}
void Getrev(int *A,int *B,int n)
{
	if (n==1) {B[0]=Pow(A[0],P-2);return;}
	Getrev(A,B,(n+1)/2);
	for (c=1;c<n;c<<=1);c<<=1;
	For(i,0,n) tmp[i]=A[i];
	Prepare(c);
	NTT(tmp,c,0),NTT(B,c,0);
	For(i,0,c) B[i]=(2*B[i]%P-1LL*B[i]*B[i]%P*tmp[i]%P+P)%P;
	NTT(B,c,1);
	For(i,n,c) B[i]=0;
}
void Getln(int *A,int *B)
{
	Getrev(A,B,n);
	For(i,1,n+1) D[i-1]=1LL*A[i]*i%P;
	for (c=1;c<n;c<<=1);c<<=1;
	Prepare(c);
	NTT(D,c,0),NTT(B,c,0);
	For(i,0,c) B[i]=1LL*D[i]*B[i]%P;
	NTT(B,c,1);
	B[n]=1LL*Pow(n,P-2)*B[n-1]%P;
}

int main()
{
	scanf("%d",&n);
	Fac[0]=1;For(i,1,n+1) Fac[i]=1LL*Fac[i-1]*i%P;
	Inv[n]=Pow(Fac[n],P-2);
	for (int i=n;i;i--) Inv[i-1]=1LL*Inv[i]*i%P;
	For(i,0,n+1) g[i]=1LL*Pow(2,1LL*i*(i-1)/2%(P-1))*Inv[i]%P;
	Getln(g,f);
	printf("%d\n",1LL*f[n]*Fac[n]%P);
}
Problem3473
//============================================================================
// Author       : Sun YaoFeng
//============================================================================

//#pragma 	comment(linker, "/STACK:100240000,100240000")
//#include	<cstdio>
//#include	<cstdlib>
//#include	<cstring>
//#include	<algorithm>

#include	<bits/stdc++.h>

using	namespace	std;

#define DB		double
#define	lf		else if
#define I64		long long
#define	Rd()	(rand()<<15|rand())
#define For(i,a,b)	for(int i=a,lim=b;i<=lim;i++)
#define Rep(i,a,b)	for(int i=a,lim=b;i>=lim;i--)

#define	fi	first
#define se	second
#define MK	make_pair
#define PA	pair<int, int>

//#define	min(a,b)	((a)<(b)?(a):(b))
//#define	max(a,b)	((a)<(b)?(b):(a))

#define	CH	(ch=getchar())
int		IN()	{
		int x= 0, f= 0, ch;
		for	(; CH < '0' || ch > '9';)	f= (ch == '-');
		for	(; ch >= '0' && ch <= '9'; CH)	x= x*10 + ch -'0';
		return	f? -x : x;
}

#define n	400005
#define m	10000005

int		N, K;

string	s[n];

namespace	Seg{
	int		C, ls[m], rs[m], sum[m];
	
	void	Modify(int&u, int l, int r, int x)	{
		int v= u;
		u= ++C;
		
		if	(l == r)	{
			sum[u]= 1;	return;
		}
		
		ls[u]= ls[v];
		rs[u]= rs[v];
		
		int Mid= (l+r) >> 1;
		if	(x <= Mid)	Modify(ls[u], l, Mid, x);
			else	Modify(rs[u], Mid+1, r, x);
		
		sum[u]= sum[ls[u]] + sum[rs[u]];
	}
	
	int		Merge(int u, int v, int l, int r)	{
		if	(! u || ! v)	return	u|v;
		if	(l == r)	return	u;
		
		int Mid= (l+r) >> 1, t= ++C;
		
		ls[t]= Merge(ls[u], ls[v], l, Mid);
		rs[t]= Merge(rs[u], rs[v], Mid+1, r);
		
		sum[t]= sum[ls[t]] + sum[rs[t]];
		
		return	t;
	}
};

namespace	SAM{
	int		C= 1, L= 1, F[n], Max[n], A[n][26];
	
	int		D, st[n], Rt[n], Ans[n];
	
	struct	Lin{
		int v, next;
	}E[n];
	
	void	Extend(int c)	{
		int p= L, np= ++C, q, nq;
		Max[np]= Max[p] + 1;
		
		for (; p && ! A[p][c]; p= F[p])	A[p][c]= np;
		if	(! p)	F[np]= 1;
		lf	(Max[q= A[p][c]] == Max[p] + 1)	F[np]= q;
		else	{
			nq= ++C;
			Max[nq]= Max[p] + 1;
			F[nq]= F[q];
			
			For(i, 0, 25)	A[nq][i]= A[q][i];
			F[q]= F[np]= nq;
			
			for (; p && A[p][c] == q; p= F[p])	A[p][c]= nq;
		}
		
		L= np;
	}
	
	void	Link(int u, int v)	{
		E[++ D]= (Lin){v, st[u]};	st[u]= D;
	}
	
	void	DFS(int u)	{
		for (int i= st[u], v; i; i= E[i].next)
			DFS(v= E[i].v), Rt[u]= Seg::Merge(Rt[u], Rt[v], 1, N);
		
		if	(Seg::sum[Rt[u]] >= K)	Ans[u]= Max[u] - Max[F[u]];
	}
	
	void	DFS2(int u)	{
		Ans[u]+= Ans[F[u]];
		for (int i= st[u]; i; i= E[i].next)	DFS2(E[i].v);
	}
	
	void	Insert(string S){
		L= 1;
		
		int len= S.length();
		For(i, 1, len)	