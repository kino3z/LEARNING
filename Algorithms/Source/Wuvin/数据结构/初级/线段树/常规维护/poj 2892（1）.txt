不知是不是我脑抽了：
方法一：
	每个点记录left[],right[],记录与之相连存在的最左边和最右边的村庄，用线段树来维护。顺带可持久支持撤销。（可以做到R x(即任意恢复一个村庄)）
方法二：
	用Treap维护区间。每一个节点记录left,right,alive.区间开始，结束，区间是否被消灭。Treap排序的关键字为left，对于删除操作，找到x所在区间a，
把区间a分为三个区间[left,x-1][x,x][x+1,right],删除区间a，插入这三个区间。对于恢复操作R x,找到x所在区间[x,x],删除，如果x-1存在，合并x与x-1所在区间，
如果x+1存在，合并x所在区间与x+1.合并操作：删除原有区间，插入新增区间。（要支持删除的Treap好难写啊QAQ，不过好像可以用set(●'◡'●)）。
	以上两种方法都可以支持查询被删除的点连续有多少个，都在线。均为nlogn，第一个空间nlogn，第二个空间n。
方法三：
	用树状数组维护区间前缀和。存在的点的值为1，不存在的为0，维护前缀和来完成查询一个区间是否连续。所以要二分出最左边的连续和最右边。时间复杂度nlog^2n。空间异常优越。
方法四：
	既然可以用树状数组了，那就可以直接维护RMQ了。所以可以使用线段树或者树状数组来维护RMQ。时间复杂度nlog^2n.
方法五：
	据说可以使用splay维护区间，我并不会。
方法六：
	既然各种NB的树都来了，分块也是可以的。分块维护区间是否连续，n*sqrt(n).分块维护RMQ+二分（可能会T）n*sqrt(n)*logn.

