注意区分DFS序和欧拉序（ETT）
树：1 2
    1 3
的DFS序122331，
欧拉序12121

关于一些树上问题的研究：
支持链修改查询：树链剖分\LCT
支持子树修改查询：树链剖分（bzoj4034）\DFS序\ETT
支持换根:LCT\ETT\DFS序（分类讨论即可）
支持link-cut：ETT\DFS序\LCT
突然发现实际上树链剖分是一种特殊的DFS序，即按照子树大小优先DFS.
而动态树则和ETT较类似。

ETT和DFS序列都可以采用splay维护。
而树链剖分则使用一些数据结构维护。
如果树链剖分采用splay维护能否支持link和cut呢？
事实证明是不行的。链剖的复杂度是基于重轻剖分的，而LCT有ACCESS操作来保证logn的均摊复杂度。
所以能否动态维护重轻剖分呢，或者给链剖加上ACCESS操作呢？这要求操作后的DFS序也要一起变，意味着我们要一起维护DFS序。
所以能不能只维护DFS序呢？同时让DFS序起到重轻剖分的效果？
本来是想splay套splay完成的，突然发现这个DFS序会动，无法确定一棵子树的区间（再开一个LCT维护各点的size？）确定区间结尾这个动作会被菊花图卡爆
那么只有给每个点再开一个splay维护与改点相连的虚边和实边了。（怎么有点像top tree了）
所以解法是TopTree

最新研究可以采用纯splay完成上述操作。只需采用括号序列的形式保留DFS序，这样就解决了一棵子树的区间问题了。而查询单点到根的路径先ACCESS，然后取这个区间的一半操作就是了（是对称的）。
所以思路应该从LCT往DFS序靠。只要insert到对应区间的开头即可完成重轻切换。对于子树操作，由于有每个点对于的退出标记存在，所以某些区间加操作不能简单完成，对于每个splay中的节点定义
一下类型，入点和出点的操作相反即可。至于换根操作对于DFS序的影响如何落实和调整，先ACCESS，这时考虑影响，该重链的括号序列如下（（（（（））））），只需左侧翻转，右侧翻转即可。
对于该重链由相连的其他重链，链内DFS序不变，仅（-----------------------------------------------------------------删删删删删删删--------------------------------------------）

等等以上逻辑有bug---括号序列应该如下（（（（）***&*）**0=））**），只能用于单点到根的路径的查询，无法支持修改。可以支持子树修改，无法支持子树查询。

那么重新考虑所有动态树问题。
链修改、链查询。LCT  logn
子树修改、子树查询。splayDFS序 logn
链查询、子树修改。扩展DFS（就是上面的） logn
链修改、子树查询。扩展DFS（左括号有实值、右括号仅确定区间） logn
所以重新阐述扩展DFS序
左侧括号有实值、右侧括号为空。可以提取出一个子树对应的区间，一个来自于根的链对应的前缀。均摊复杂度logn、证明同LCT
链查询修改、子树查询修改可以同时存在。
现在这也就可以完成大部分LCT可以完成的和DFS序可以完成的动作了。
换根貌似还不行、受到‘）’的牵制。
再推广一下、这个东西可以完成一个点到祖先链的提取、即ACCESS操作也是可以扩展的。

例题sone1  正解：LCT同步ETT