主席树最大的作用是压缩空间和构造时间。
实际上应该把主席树当成一种压缩空间的方法，而不是结构。
为了空间能够压缩，两棵树应该满足结构类似，值类似，只保存不同。
对于所有要套线段树的题，可以用主席树的方法把n^2的空间改为nlogn，比如线段树套线段树，树状数组套线段树。
自然而然，线段树能够通过可持久的方式压缩空间，其他树也可以：
树状数组当然也可以，值域树状数组采用fatnode进行可持久k大查询也是可以的。（我没写过，实际可不可以不好说）
Treap由于要旋转可能要麻烦一点，因为要改不少，不过貌似也是可以的。还有一种不旋转的Treap通过分裂合并实现可持久。
splay-要可持久有点吓人。至少才会写splay版的我没有干过。
替罪羊树，这个可持久貌似很好写，毕竟直接重构，无所谓。（话说，我还没写过替罪羊树来着）
zkw线段树由于运用了下标的特殊性，只能fatnode，那常数的优势就没有了。
值域四分树的可持久好像蛮有前景。
树套树之类的，这个脑洞有点大，。。。那就分别可持久。
说白了，可持久也就两种考法，一真考可持久，二靠你各种套树利用可持久省空间。


接下来是各种树套主席树。
单点修改+区间K大。
最优做法：首先数组主席树朴素建立（不变的原数组），然后再上面建立树状数组，树状数组管理区间的delta，每个节点记录管理的区间的所有delta，也就值n条logn的链。即原数组对应区间的主席树叠上
每个节点对应记录的修改链就等于当前该区间的值域线段树。构建nlogV，修改mlogn*logV，空间（n+m）logV.V是值的范围.
脑洞做法：(1) 树状数组套值域线段树，构建nlogn*logV,修改mlogn*logV，空间n logn logV.
	(2) 树状数组套对应区间的Treap,构建nlogn*logV,修改mlogn*logV,空间nlogV
	(3) 值域树状数组+fatnode(using Treap/splay(splay更好))：构建nlogV*logt,修改mlogV*logt,空间nlogV.
	(4) 值域静态BST+pathcopy+树状数组记录delta: 构建nlogV,修改mlogn*logV,空间（n+m）logV.






另外：可持久线段树可以用于维护可持久数组。（暴力维护：直接记录修改，用两个栈。。数据随机时更快哦）
当然可持久线段树给你快速O(1) copy 一个数组的时间，但修改是logn的。
如果每个你copy的数组需要建一个线段树那就更好了。
详见clj论文

看了看可持久非旋转Treap，这也能分裂。那么区间翻转就不止splay了。
值域线段树可以合并，那能不能分裂呢，好像是可以的。让我写一写。
分裂是logn不说。由于空间有点大。所以能不能加入内存回收？
貌似不能完成区间翻转。。那分裂有什么用