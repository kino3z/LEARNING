上图中ABC分别代表三个连通分量
一下以ABC代表三个对应连通分量中的点
我们希望得到的顺是CBA，按照这个顺序可以放心地顺着乱搜
如果我们从BAC的顺序开始生产拓扑序（注意是反向沿着边走）
那么得到的会是BABC
如果是CBA，那么会是CBABC
如果是ABC 那么会是ABC
......
总之，我们得到的拓扑序的后几个的倒叙正是我们想要的。
为什么这样就可以了呢？
拿图二说吧：我们正常得到的拓扑序是14523
而看到图一中，我们从任意一个点开始深搜，一定可以访问到该点所在连通分量的所有点 和 拓扑序中在该点之后的 一些 连通分量，
我们由于连通分量内部结构不可测所以谁先进入即将生成的拓扑序不可确定，但是由于红色边的限制，只要我们访问到其他连通分量一定
是会先把其他连通分量放入即将生成的拓扑序中，然后再将自己连通分量中的部分点放在其后。
所以沿着逆向边生成的伪拓扑序中的最后一部分是确定的，而且是连通分量拓扑序的倒叙
没懂请留下评论我会补上的

好的现在来讲下最常用的tarjan算法
时间戳：用一个计数变量表示时间，一个数组记录到达该点时的时间，每访问到一个新的点 时间戳++；
tarjan算法的核心思想是：如果当前点是我们访问到的一个连通分量中的第一个点，那么之后的点一定访问不到该点之前的时间戳，而且该点之后
处于同一连通分量中的点能访问到的最小时间戳就是该点的时间戳。如上图所示，红色为该点的时间戳，蓝色为其他图中的边，绿色为
该点能到达的最小时间戳。计算方程：最小时间戳（u）=min(u的时间戳，所有u能到达的点v的 最小时间戳（v）)；
实现：用lowbit记录某点能访问到的最早时间，time记录该点的时间戳。
每到达一个点把该点压入栈
如果lowbit==time则该点就是这个连通分量中的第一个点
而其他点一定能访问到他，
所以一直pop直到该点被弹出。（弹出来的都属于这个连通分量）
