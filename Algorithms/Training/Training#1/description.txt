题组复杂了...
下周组套简单点的（瘫

T1
仔细分析.jpg
发现分析失败
f[i][j]表示处理到a[i], b[j]的时候。
假如说a[i] == b[j]，那么f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1;
if a[i] not= b[j] 
	f[i][j] = f[i - t + 1][j - t + 1] + t;
t表示a[i] -> a[i - t]都分别不与b[i] -> b[i - t]相等。
至于为什么，其实这步是一步贪心...
两只手写的不同的话，一定可以同时写，如果在步骤中出现了一次“需要写的数字相同的时候”，那么一定需要多花1ms的时间来写。
但是，这道题的难度在这里，这个算法是O(n^2)的，显然过不了。
显然，只有数字相同的时候，需要代价为O(n)的转移，我们着手于这次转移的优化。
考虑到是“写下排列”，(i, j)相同的个数只有n...
这个优化策略是第一次见，f[i]表示处理到了a[i]，两只手都遇到了a[i]的最小代价。
考虑这个优化的实现方法...
主要是装不下，我们把搜索放在一个dp(i, j)函数里。
 
T3
转化一下题意，扔掉d的倍数堆数，使得剩下数的xor值 = 0