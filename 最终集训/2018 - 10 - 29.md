# $\text{Contest 2018 10 29}$

> 解题报告

# $\text{T1}$

给出数列$A$，你需要自行选定$q$个长度为$k$的区间,每次删除区间内的最小值(当最小值有多个时任选一个),使得删除的$q$个数中最小值和最大值的差尽量小。$n \le 100000$。

毒瘤...
$\text{ARC098E}$，还带加强的。

原题数据范围是$O(n^2\log{n})$的，我的解法是这样的。
枚举删除数字的最小值，我们需要确定一个最小的最大值，从“限制”入手，枚举了最小值，代表所有比最小值小的都不能选了。确定最小的最大值有两种写法，比较类似。

可以二分最小的最大值，比最小值小的数字标记为$0$，最小值最大值之间的值标记为$1$，大于最大值的标记为$2$。所有含有$0$的区间都不能选，只能选仅含$1, 2$的区间。一个包含$1, 2$的区间中，又只有$1$才能对答案造成贡献，假如$1, 2$区间长度为$len$，我们只能从中选$len - k + 1$个$1$。贪心选择即可。

第二种写法不再介绍，相当类似，只是从区间中抽出最小的$len - k + 1$个数，放入新的数组排序，然后取第$q$个。

考虑$O(n\alpha(n))$的做法，考虑$\text{two pointers}$，对原数组排序，将$tpt$的左右指针放在排序后的数组上，我们向右移动指针的时候，顺带维护原数组的$0, 1, 2$性质。这样，每个数都会从$2 \rightarrow 1 \rightarrow 0$，当一个数从$1 \rightarrow 0$的时候，会将左右两个区间分开，我们会发现分开区间并不好处理，考虑合并区间。我们$tpt$倒过来扫，每个数字都会$0 \rightarrow 1 \rightarrow 2$，这样，就从分裂变成了合并。每当一个数字从$0 \rightarrow 1$的时候，就会合并其左右的区间，并且用并查集维护区间$1, 2$的个数。

这题的分析本来就不简单，拆分转合并的思路很妙，好题！

$AC$代码懒得写了，给$70$的吧。
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 2005;
int n, q, k;
ll a[N], b[N], c[N], cnt, tot;
int main() {
  scanf("%d%d%d", &n, &k, &q);
  for (int i = 1; i <= n; ++i)
    scanf("%lld", &a[i]);
  ll ans = 1ll << 60;
  for (int i = 1; i <= n; ++i) {
    tot = 0;
    a[n + 1] = -(1ll << 60);
    for (int j = 1; j <= n + 1; ++j)
      if (a[j] >= a[i])
        b[++cnt] = a[j];
      else {
        sort(b + 1, b + 1 + cnt);
        for (int i = 1; i <= cnt - k + 1; ++i)
          c[++tot] = b[i];
        cnt = 0;
      }
    sort(c + 1, c + 1 + tot);
    if (tot >= q)
      ans = min(ans, c[q] - a[i]);
  }
  cout << ans;
}
```

$\text{std}$:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, dk, q, vn, a[N], nmax;
struct st {
  int v, pos;
} s[N];
bool cmp1(st a, st b) { return a.v > b.v; }
int v[N], fa[N], t[N], siz[N];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
void update(int k, int f) { nmax += f * max(0, min(v[k], siz[k] - dk + 1)); }
void insert(int k) {
  v[k] = t[k] = siz[k] = 1;
  if (t[k - 1]) {
    update(find(k - 1), -1);
    siz[k] += siz[fa[k - 1]], v[k] += v[fa[k - 1]], fa[fa[k - 1]] = k;
  }
  if (t[k + 1]) {
    update(find(k + 1), -1);
    siz[k] += siz[fa[k + 1]], v[k] += v[fa[k + 1]], fa[fa[k + 1]] = k;
  }
  update(find(k), 1);
}
void erase(int k) {
  update(find(k), -1);
  v[fa[k]]--;
  update(fa[k], 1);
  t[k] = 2;
}
bool judge() {
  int l, r = 0;
  nmax = 0;
  for (int i = 1; i <= n; i++) fa[i] = i, v[i] = t[i] = 0;
  for (l = 1; l <= n; erase(s[l++].pos)) {
    while (s[l].v - s[r + 1].v <= vn && r < n) {
      insert(s[++r].pos);
    }
    if (nmax >= q) return 1;
  }
  return 0;
}
int main() {
  scanf("%d%d%d", &n, &dk, &q);
  int l = 0, r = 0;
  for (int i = 1; i <= n; i++) {
    scanf("%d", &a[i]);
    r = max(r, a[i]);
  }
  for (int i = 1; i <= n; i++) s[i] = (st){a[i], i};
  sort(s + 1, s + n + 1, cmp1);
  while (l < r) {
    vn = (l + r) >> 1;
    if (judge())
      r = vn;
    else
      l = vn + 1;
  }
  while (!judge()) {
    vn++;
  }
  while (1 && vn > 1) {
    vn--;
    if (!judge()) {
      vn++;
      break;
    }
  }
  printf("%d", vn);
  return 0;
}
```

# $\text{T2}$

$n$点$m$边无向带权图。$s$个加油站，有$q$次询问，给出起点，终点，起点终点都是加油站，给出一辆车，车有油量上限$k_i$，油量满的情况下能行驶$k_i$的距离，问能否从$s \rightarrow t$。$n, s, q \le 100000$。

$\text{BZOJ4144}$
考场想到$50pts$，结果$4k$的代码写炸了...
图上查询问题，离不了树上问题的处理。
观察到，如果能安全从$s \rightarrow t$，必定会经过一些加油站。而且，对于经过的加油站，两两之间的距离必须$\le k$。暴力的话，考虑$s$两两之间的最短路建成完全图。在完全图上跑最小生成树，就能$s \rightarrow t$全部经过$\le k$的边。如果$s \rightarrow t$的最大边权$> k$，就不能从$s$到$t$。

然后我写炸了，然后爆零了。
瓶颈出来了，$s$的完全图的最小生成树怎么处理。
考虑图中的这种路径，$s, k, t$都是加油站，并且存在$s \rightarrow k$，$k \rightarrow t$，那么$s \rightarrow t$一定没有存在的必要。怎么实现呢？考虑$s \rightarrow k$上的非关键点，将这些非关键点分为两部分，到$s$最近的，到$k$最近的。我们设$from[i]$表示离$i$最近的关键点的编号，$dis[i]$表示$i$到$from[i]$的最短路。对于原图中的$u \rightarrow v$，$dis[u] + w + dis[v]$就是某两个关键点中的唯一距离，过滤掉经过其他点的。


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQzODU4ODgyMl19
-->