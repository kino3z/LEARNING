# $CF522D$

这题能黑，怕不是在开玩笑。
首先，套路性地，对询问右端点排序。
怎么处理这个"数字相同"呢...
又是套路，维护$pre[i]$表示上一个这个数的位置。
然后顺着扫，到$i$的时候要处理完所有右端点为$i$的询问。
$nxt[i]$表示$i$到下一个为$a[i]$的最小距离。线段树中维护的就是$nxt[i]$的值。

# $BZOJ1880$

这...
之前完全做不起哎
但是现在，说不定呢？
简单来说，就是求无向图之间两点对之前的最长公共路径。
我们跑出$x1, x2, y1, y2$开始的最短路，设以上跑出的最短路的分别为$dis[1][u], dis[2][u], dis[3][u], dis[4][u]$，如果一条边$u \rightarrow v$满足$dis[1][u] + e + dis[3][v] = dis[1][n]$。并且满足这条边处于$x2 \rightarrow y2$上，那么我们把这条边赋值为$e$，其他边赋值为$0$。跑$DAG$上最长路。

# $51nod \ 1803$

给出随机的一棵树，导出编号$[l, r]$的点，求这个导出子图的树的直径。$n, q \le 10^5$。

直径这玩意儿，不能像之前某道题那样说维护就维护了啊...
这样吧。
我们考虑对所有询问的$r$排序。
然后从左到右依次加入边。
获取树的直径如何获取呢？
$f[x][2]$表示以$x$为根的子树中离$x$最远的点和次远的点。
由于的树随机，所以树的深度约为$\log{n}$。
我们现在需要快速获取$[l, r]$，抛开$[1, l - 1]$的影响，的最大$f[i][0] + f[i][1]$。

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg3MjgyODY3NSwtMTAxMjQwMzg5Nl19
-->